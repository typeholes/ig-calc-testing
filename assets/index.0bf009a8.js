function makeMap$1(str, expectsLowerCase) {
  const map3 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map3[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map3[val.toLowerCase()] : (val) => !!map3[val];
}
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
const isGloballyWhitelisted = /* @__PURE__ */ makeMap$1(GLOBALS_WHITE_LISTED);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap$1(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function normalizeStyle(value) {
  if (isArray$2(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$2(value)) {
    return value;
  } else if (isObject$2(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$2(value)) {
    res = value;
  } else if (isArray$2(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value)) {
    for (const name2 in value) {
      if (value[name2]) {
        res += name2 + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString$2(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal2 = true;
  for (let i2 = 0; equal2 && i2 < a.length; i2++) {
    equal2 = looseEqual(a[i2], b[i2]);
  }
  return equal2;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate$2(a);
  let bValidType = isDate$2(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$2(a);
  bValidType = isArray$2(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$2(a);
  bValidType = isObject$2(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString$2(val) ? val : val == null ? "" : isArray$2(val) || isObject$2(val) && (val.toString === objectToString || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer$1, 2) : String(val);
};
const replacer$1 = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer$1(_key, val.value);
  } else if (isMap$2(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries3, [key, val2]) => {
        entries3[`${key} =>`] = val2;
        return entries3;
      }, {})
    };
  } else if (isSet$1(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$2(val) && !isArray$2(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove$1 = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$3.call(val, key);
const isArray$2 = Array.isArray;
const isMap$2 = (val) => toTypeString(val) === "[object Map]";
const isSet$1 = (val) => toTypeString(val) === "[object Set]";
const isDate$2 = (val) => toTypeString(val) === "[object Date]";
const isFunction$1 = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$2(val) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap$1(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg2) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg2);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn) {
    if (this.active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i2, l;
      for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (this.parent && !fromParent) {
        const last3 = this.parent.scopes.pop();
        if (last3 && last3 !== this) {
          this.parent.scopes[this.index] = last3;
          last3.index = this.index;
        }
      }
      this.active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect2) => {
  const { deps } = effect2;
  if (deps.length) {
    let ptr = 0;
    for (let i2 = 0; i2 < deps.length; i2++) {
      const dep = deps[i2];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect2);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect2);
    }
    deps.length = 0;
  }
}
function effect(fn, options) {
  if (fn.effect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn);
  if (options) {
    extend$1(_effect, options);
    if (options.scope)
      recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop$1(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last3 = trackStack.pop();
  shouldTrack = last3 === void 0 ? true : last3;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$2(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$2(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap$2(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap$2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$2(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap$1(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l = this.length; i2 < l; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get11(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$2(target);
    if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$2(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set3(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow && !isReadonly(value)) {
      if (!isShallow(value)) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
      }
      if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys$2(target) {
  track(target, "iterate", isArray$2(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys: ownKeys$2
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$1({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ extend$1({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1$1(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has5 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has5.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has5.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1$1(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size$1(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add$2(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has5, get: get11 } = getProto(target);
  let hadKey = has5.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has5.call(target, key);
  }
  const oldValue = get11.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has5, get: get11 } = getProto(target);
  let hadKey = has5.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has5.call(target, key);
  }
  get11 ? get11.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach$1(isReadonly2, isShallow2) {
  return function forEach3(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap$2(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1$1(this, key);
    },
    get size() {
      return size$1(this);
    },
    has: has$1$1,
    add: add$2,
    set: set$1$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach$1(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, false, true);
    },
    get size() {
      return size$1(this);
    },
    has: has$1$1,
    add: add$2,
    set: set$1$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach$1(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach$1(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, true, true);
    },
    get size() {
      return size$1(this, true);
    },
    has(key) {
      return has$1$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach$1(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$2(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this.__v_isShallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this.__v_isShallow ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory2) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get11, set: set3 } = factory2(() => trackRefValue(this), () => triggerRefValue(this));
    this._get = get11;
    this._set = set3;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory2) {
  return new CustomRefImpl(factory2);
}
function toRefs(object) {
  const ret = isArray$2(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
}
function toRef(object, key, defaultValue) {
  const val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$1(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
const stack = [];
function warn(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace2 = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [
      msg + args.join(""),
      instance && instance.proxy,
      trace2.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
      trace2
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace2.length && true) {
      warnArgs.push(`
`, ...formatTrace(trace2));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last3 = normalizedStack[0];
    if (last3 && last3.vnode === currentVNode) {
      last3.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace2) {
  const logs = [];
  trace2.forEach((entry, i2) => {
    logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open2 = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close = `>` + postfix;
  return vnode.props ? [open2, ...formatProps(vnode.props), close] : [open2 + close];
}
function formatProps(props) {
  const res = [];
  const keys2 = Object.keys(props);
  keys2.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys2.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$2(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$1(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$1(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values2 = [];
  for (let i2 = 0; i2 < fn.length; i2++) {
    values2.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
  }
  return values2;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start2 = flushIndex + 1;
  let end = queue.length;
  while (start2 < end) {
    const middle = start2 + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start2 = middle + 1 : end = middle;
  }
  return start2;
}
function queueJob(job) {
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
function queueCb(cb, activeQueue, pendingQueue, index2) {
  if (!isArray$2(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index2 + 1 : index2)) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen2, parentJob = null) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      activePreFlushCbs[preFlushIndex]();
    }
    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    flushPreFlushCbs(seen2, parentJob);
  }
}
function flushPostFlushCbs(seen2) {
  flushPreFlushCbs();
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  flushPreFlushCbs(seen2);
  queue.sort((a, b) => getId(a) - getId(b));
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen2);
    }
  }
}
let devtools;
let buffer = [];
function setDevtoolsHook(hook, target) {
  var _a, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer = [];
      }
    }, 3e3);
  } else {
    buffer = [];
  }
}
function emit$1(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number2, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => a.trim());
    }
    if (number2) {
      args = rawArgs.map(toNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, null);
    return null;
  }
  if (isArray$2(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  cache.set(comp, normalized);
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn(...args);
    setCurrentRenderingInstance(prevInstance);
    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render: render2, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render2.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render3 = Component;
      if (false)
        ;
      result = normalizeVNode(render3.length > 1 ? render3(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit
      } : { attrs, slots, emit }) : render3(props, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children) {
  let singleRoot;
  for (let i2 = 0; i2 < children.length; i2++) {
    const child = children[i2];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  __isSuspense: true,
  process(n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n12 == null) {
      mountSuspense(n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n12, n22, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name2) {
  const eventListener = vnode.props && vnode.props[name2];
  if (isFunction$1(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const { p: patch, o: { createElement } } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      isSVG,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve();
  }
}
function patchSuspense(n12, n22, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n22.suspense = n12.suspense;
  suspense.vnode = n22;
  n22.el = n12.el;
  const newBranch = n22.ssContent;
  const newFallback = n22.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(
          activeBranch,
          newFallback,
          container,
          anchor,
          parentComponent,
          null,
          isSVG,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            isSVG,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        suspense.resolve(true);
      } else {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n22, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove: remove3 } } = rendererInternals;
  const timeout = toNumber(vnode.props && vnode.props.timeout);
  const suspense = {
    vnode,
    parent,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false) {
      const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container2, anchor2, 0);
            }
          };
        }
        let { anchor: anchor2 } = suspense;
        if (activeBranch) {
          anchor2 = next(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent2 = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent2) {
        if (parent2.pendingBranch) {
          parent2.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent2 = parent2.parent;
      }
      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          isSVG2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        true
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          parentNode(hydratedEl || instance.subTree.el),
          hydratedEl ? null : next(instance.subTree),
          suspense,
          isSVG,
          optimized
        );
        if (placeholder) {
          remove3(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
      }
      if (suspense.pendingBranch) {
        unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
  const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
  if (suspense.deps === 0) {
    suspense.resolve();
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (isFunction$1(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray$2(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$2(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el = vnode.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(effect2, null, { flush: "post" });
}
function watchSyncEffect(effect2, options) {
  return doWatch(effect2, null, { flush: "sync" });
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$2(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction$1(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    return NOOP;
  }
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i2) => hasChanged(v, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    scheduler = () => queuePreFlushCb(job);
  }
  const effect2 = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect2.run.bind(effect2), instance && instance.suspense);
  } else {
    effect2.run();
  }
  return () => {
    effect2.stop();
    if (instance && instance.scope) {
      remove$1(instance.scope.effects, effect2);
    }
  };
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function traverse(value, seen2) {
  if (!isObject$2(value) || value["__v_skip"]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  if (isRef(value)) {
    traverse(value.value, seen2);
  } else if (isArray$2(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], seen2);
    }
  } else if (isSet$1(value) || isMap$2(value)) {
    value.forEach((v) => {
      traverse(v, seen2);
    });
  } else if (isPlainObject$2(value)) {
    for (const key in value) {
      traverse(value[key], seen2);
    }
  }
  return value;
}
function useTransitionState() {
  const state2 = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state2.isMounted = true;
  });
  onBeforeUnmount(() => {
    state2.isUnmounting = true;
  });
  return state2;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state2 = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c of children) {
          if (c.type !== Comment) {
            child = c;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode: mode2 } = rawProps;
      if (state2.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state2, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state2, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode2 === "out-in") {
          state2.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state2.isLeaving = false;
            instance.update();
          };
          return emptyPlaceholder(child);
        } else if (mode2 === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state2, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state2, vnode) {
  const { leavingVNodes } = state2;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state2, instance) {
  const { appear, mode: mode2, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state2, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$2(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode: mode2,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state2.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state2.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove3) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(true);
      }
      if (state2.isUnmounting) {
        return remove3();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove3();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state2, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction$1(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
function defineAsyncComponent(source) {
  if (isFunction$1(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load2();
  };
  const load2 = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load2,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(err, instance, 13, !errorComponent);
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load2().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(`Async component timed out after ${timeout}ms.`);
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load2().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, { vnode: { ref: ref2, props, children, shapeFlag }, parent }) {
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys2 = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter4) {
      cache.forEach((vnode, key) => {
        const name2 = getComponentName(vnode.type);
        if (name2 && (!filter4 || !filter4(name2))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (!current || cached.type !== current.type) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys2.delete(key);
    }
    watch(
      () => [props.include, props.exclude],
      ([include, exclude]) => {
        include && pruneCache((name2) => matches(include, name2));
        exclude && pruneCache((name2) => !matches(exclude, name2));
      },
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name2 = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
      const { include, exclude, max: max3 } = props;
      if (include && (!name2 || !matches(include, name2)) || exclude && name2 && matches(exclude, name2)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys2.delete(key);
        keys2.add(key);
      } else {
        keys2.add(key);
        if (max3 && keys2.size > parseInt(max3, 10)) {
          pruneCacheEntry(keys2.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name2) {
  if (isArray$2(pattern)) {
    return pattern.some((p2) => matches(p2, name2));
  } else if (isString$2(pattern)) {
    return pattern.split(",").includes(name2);
  } else if (pattern.test) {
    return pattern.test(name2);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove$1(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  let shapeFlag = vnode.shapeFlag;
  if (shapeFlag & 256) {
    shapeFlag -= 256;
  }
  if (shapeFlag & 512) {
    shapeFlag -= 512;
  }
  vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value, arg2, modifiers = EMPTY_OBJ] = directives[i2];
    if (isFunction$1(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }
    if (dir.deep) {
      traverse(value);
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg: arg2,
      modifiers
    });
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name2) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name2];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name2, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
  if (isString$2(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name2) {
  return resolveAsset(DIRECTIVES, name2);
}
function resolveAsset(type, name2, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component, false);
      if (selfName && (selfName === name2 || selfName === camelize(name2) || selfName === capitalize(camelize(name2)))) {
        return Component;
      }
    }
    const res = resolve$1(instance[type] || Component[type], name2) || resolve$1(instance.appContext[type], name2);
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve$1(registry, name2) {
  return registry && (registry[name2] || registry[camelize(name2)] || registry[capitalize(camelize(name2))]);
}
function renderList(source, renderItem, cache, index2) {
  let ret;
  const cached = cache && cache[index2];
  if (isArray$2(source) || isString$2(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l = source.length; i2 < l; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$2(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i2) => renderItem(item, i2, void 0, cached && cached[i2]));
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i2 = 0, l = keys2.length; i2 < l; i2++) {
        const key = keys2[i2];
        ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
    const slot = dynamicSlots[i2];
    if (isArray$2(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name2, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    return createVNode("slot", name2 === "default" ? null : { name: name2 }, fallback && fallback());
  }
  let slot = slots[name2];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, { key: props.key || `_${name2}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj) {
  const ret = {};
  for (const key in obj) {
    ret[toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
  $: (i2) => i2,
  $el: (i2) => i2.vnode.el,
  $data: (i2) => i2.data,
  $props: (i2) => i2.props,
  $attrs: (i2) => i2.attrs,
  $slots: (i2) => i2.slots,
  $refs: (i2) => i2.refs,
  $parent: (i2) => getPublicInstance(i2.parent),
  $root: (i2) => getPublicInstance(i2.root),
  $emit: (i2) => i2.emit,
  $options: (i2) => resolveMergedOptions(i2),
  $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
  $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
  $watch: (i2) => instanceWatch.bind(i2)
});
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || setupState !== EMPTY_OBJ && hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend$1({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has5 = key[0] !== "_" && !isGloballyWhitelisted(key);
    return has5;
  }
});
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$2(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get11 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set3 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get11,
        set: set3
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$2(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$2(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$2(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$2(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$2(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$1(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$2(raw)) {
    if (isArray$2(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base2 = instance.type;
  const { mixins, extends: extendsOptions } = base2;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base2);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base2;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions$1(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions$1(resolved, base2, optionMergeStrategies);
  }
  cache.set(base2, resolved);
  return resolved;
}
function mergeOptions$1(to2, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to2, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions$1(to2, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to2[key] = strat ? strat(to2[key], from[key]) : from[key];
    }
  }
  return to2;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to2, from) {
  if (!from) {
    return to2;
  }
  if (!to2) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(isFunction$1(to2) ? to2.call(this, this) : to2, isFunction$1(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to2, from) {
  return mergeObjectOptions(normalizeInject(to2), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$2(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to2, from) {
  return to2 ? [...new Set([].concat(to2, from))] : from;
}
function mergeObjectOptions(to2, from) {
  return to2 ? extend$1(extend$1(/* @__PURE__ */ Object.create(null), to2), from) : from;
}
function mergeWatchOptions(to2, from) {
  if (!to2)
    return from;
  if (!from)
    return to2;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to2);
  for (const key in from) {
    merged[key] = mergeAsArray(to2[key], from[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, EMPTY_ARR);
    return EMPTY_ARR;
  }
  if (isArray$2(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$1(opt) ? { type: opt } : opt;
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  cache.set(comp, res);
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$2(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction$1(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$1(value)) {
      slots[key] = normalizeSlot$1(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$1(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid = 0;
function createAppAPI(render2, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject$2(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$2,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin2) {
        {
          if (!context.mixins.includes(mixin2)) {
            context.mixins.push(mixin2);
          }
        }
        return app2;
      },
      component(name2, component) {
        if (!component) {
          return context.components[name2];
        }
        context.components[name2] = component;
        return app2;
      },
      directive(name2, directive) {
        if (!directive) {
          return context.directives[name2];
        }
        context.directives[name2] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      }
    };
    return app2;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$2(rawRef)) {
    rawRef.forEach((r, i2) => setRef(r, oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i2] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$2(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$2(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$2(existing) && remove$1(existing, refValue);
          } else {
            if (!isArray$2(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const { mt: mountComponent, p: patch, o: { patchProp: patchProp2, createText, nextSibling, parentNode, remove: remove3, insert, createComment } } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
    const { type, ref: ref2, shapeFlag, patchFlag } = vnode;
    const domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (domType !== 1 && domType !== 3) {
          nextNode = onMismatch();
        } else {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i2 = 0; i2 < vnode.staticCount; i2++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i2 === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return nextNode;
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        }
        break;
      default:
        if (shapeFlag & 1) {
          if (domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
          if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") {
            nextNode = nextSibling(nextNode);
          }
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
        } else
          ;
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs } = vnode;
    const forcePatchValue = type === "input" && dirs || type === "option";
    if (forcePatchValue || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key in props) {
            if (forcePatchValue && key.endsWith("value") || isOn(key) && !isReservedProp(key)) {
              patchProp2(el, key, null, props[key], false, void 0, parentComponent);
            }
          }
        } else if (props.onClick) {
          patchProp2(el, "onClick", null, props.onClick, false, void 0, parentComponent);
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (shapeFlag & 16 && !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
        while (next) {
          hasMismatch = true;
          const cur = next;
          next = next.nextSibling;
          remove3(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
          el.textContent = vnode.children;
        }
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    for (let i2 = 0; i2 < l; i2++) {
      const vnode = optimized ? children[i2] : children[i2] = normalizeVNode(children[i2]);
      if (node) {
        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      hasMismatch = true;
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    hasMismatch = true;
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAsyncAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove3(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove3(node);
    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
    return next;
  };
  const locateClosingAsyncAnchor = (node) => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === "[")
          match++;
        if (node.data === "]") {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  return [hydrate2, hydrateNode];
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n12, n22, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n22.dynamicChildren) => {
    if (n12 === n22) {
      return;
    }
    if (n12 && !isSameVNodeType(n12, n22)) {
      anchor = getNextHostNode(n12);
      unmount(n12, parentComponent, parentSuspense, true);
      n12 = null;
    }
    if (n22.patchFlag === -2) {
      optimized = false;
      n22.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n22;
    switch (type) {
      case Text:
        processText(n12, n22, container, anchor);
        break;
      case Comment:
        processCommentNode(n12, n22, container, anchor);
        break;
      case Static:
        if (n12 == null) {
          mountStaticNode(n22, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n12 && n12.ref, parentSuspense, n22 || n12, !n22);
    }
  };
  const processText = (n12, n22, container, anchor) => {
    if (n12 == null) {
      hostInsert(n22.el = hostCreateText(n22.children), container, anchor);
    } else {
      const el = n22.el = n12.el;
      if (n22.children !== n12.children) {
        hostSetText(el, n22.children);
      }
    }
  };
  const processCommentNode = (n12, n22, container, anchor) => {
    if (n12 == null) {
      hostInsert(n22.el = hostCreateComment(n22.children || ""), container, anchor);
    } else {
      n22.el = n12.el;
    }
  };
  const mountStaticNode = (n22, container, anchor, isSVG) => {
    [n22.el, n22.anchor] = hostInsertStaticContent(n22.children, container, anchor, isSVG, n22.el, n22.anchor);
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n22.type === "svg";
    if (n12 == null) {
      mountElement(n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n12, n22, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
    if (vnode.el && hostCloneNode !== void 0 && patchFlag === -1) {
      el = vnode.el = hostCloneNode(vnode.el);
    } else {
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start2 = 0) => {
    for (let i2 = start2; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n12, n22, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n22.el = n12.el;
    let { patchFlag, dynamicChildren, dirs } = n22;
    patchFlag |= n12.patchFlag & 16;
    const oldProps = n12.props || EMPTY_OBJ;
    const newProps = n22.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n22, n12);
    }
    if (dirs) {
      invokeDirectiveHook(n22, n12, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n22.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n12.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n12, n22, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n22, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n22.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG, n12.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n12.children !== n22.children) {
          hostSetElementText(el, n22.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n22, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n22, n12);
        dirs && invokeDirectiveHook(n22, n12, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n22.el = n12 ? n12.el : hostCreateText("");
    const fragmentEndAnchor = n22.anchor = n12 ? n12.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n22;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n12 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n22.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n12.dynamicChildren) {
        patchBlockChildren(n12.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (n22.key != null || parentComponent && n22 === parentComponent.subTree) {
          traverseStaticChildren(n12, n22, true);
        }
      } else {
        patchChildren(n12, n22, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n22.slotScopeIds = slotScopeIds;
    if (n12 == null) {
      if (n22.shapeFlag & 512) {
        parentComponent.ctx.activate(n22, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n22, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n12, n22, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n12, n22, optimized) => {
    const instance = n22.component = n12.component;
    if (shouldUpdateComponent(n12, n22, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n22, optimized);
        return;
      } else {
        instance.next = n22;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n22.el = n12.el;
      instance.vnode = n22;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          hostParentNode(prevTree.el),
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update8),
      instance.scope
    );
    const update8 = instance.update = () => effect2.run();
    update8.id = instance.uid;
    toggleRecurse(instance, true);
    update8();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(void 0, instance.update);
    resetTracking();
  };
  const patchChildren = (n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n12 && n12.children;
    const prevShapeFlag = n12 ? n12.shapeFlag : 0;
    const c2 = n22.children;
    const { patchFlag, shapeFlag } = n22;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(c1[i2], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n12 = c1[i2];
      const n22 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n12, n22)) {
        patch(n12, n22, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n12 = c1[e1];
      const n22 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n12, n22)) {
        patch(n12, n22, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(null, c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove4 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove4();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove4, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove3(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove3 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update: update8, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update8) {
      update8.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
    for (let i2 = start2; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove3,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2)
  };
}
function toggleRecurse({ effect: effect2, update: update8 }, allowed) {
  effect2.allowRecurse = update8.allowRecurse = allowed;
}
function traverseStaticChildren(n12, n22, shallow = false) {
  const ch1 = n12.children;
  const ch2 = n22.children;
  if (isArray$2(ch1) && isArray$2(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j, u, v, c;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i2] = j;
        result.push(i2);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i2] = result[u - 1];
        }
        result[u] = i2;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$2(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n12, n22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n22.props);
    let { shapeFlag, children, dynamicChildren } = n22;
    if (n12 == null) {
      const placeholder = n22.el = createText("");
      const mainAnchor = n22.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n22.target = resolveTarget(n22.props, querySelector);
      const targetAnchor = n22.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n22.el = n12.el;
      const mainAnchor = n22.anchor = n12.anchor;
      const target = n22.target = n12.target;
      const targetAnchor = n22.targetAnchor = n12.targetAnchor;
      const wasDisabled = isTeleportDisabled(n12.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n12.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n12, n22, true);
      } else if (!optimized) {
        patchChildren(n12, n22, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n22, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n22.props && n22.props.to) !== (n12.props && n12.props.to)) {
          const nextTarget = n22.target = resolveTarget(n22.props, querySelector);
          if (nextTarget) {
            moveTeleport(n22, nextTarget, null, internals, 0);
          }
        } else if (wasDisabled) {
          moveTeleport(n22, target, targetAnchor, internals, 1);
        }
      }
    }
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
const Fragment = Symbol(void 0);
const Text = Symbol(void 0);
const Comment = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n12, n22) {
  return n12.type === n22.type && n12.key === n22.key;
}
function transformVNodeArgs(transformer) {
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString$2(ref2) || isRef(ref2) || isFunction$1(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode2 = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$2(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode2 && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode2 = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode2 && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$2(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$2(style)) {
      if (isProxy(style) && !isArray$2(style)) {
        style = extend$1({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$1(type) ? 2 : 0;
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode2, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$1({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$2(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$2(child)) {
    return createVNode(
      Fragment,
      null,
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$2(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e2) => {
          handleError(e2, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$2(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i2) => {
    if (i2.render._rc) {
      i2.withProxy = new Proxy(i2.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(extend$1({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name2 = getComponentName(Component);
  if (!name2 && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name2 = match[1];
    }
  }
  if (!name2 && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name2 = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }
  return name2 ? classify(name2) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$1(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function withDefaults(props, defaults) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function getContext() {
  const i2 = getCurrentInstance();
  return i2.setupContext || (i2.setupContext = createSetupContext(i2));
}
function mergeDefaults(raw, defaults) {
  const props = isArray$2(raw) ? raw.reduce((normalized, p2) => (normalized[p2] = {}, normalized), {}) : raw;
  for (const key in defaults) {
    const opt = props[key];
    if (opt) {
      if (isArray$2(opt) || isFunction$1(opt)) {
        props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      props[key] = { default: defaults[key] };
    } else
      ;
  }
  return props;
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e2) => {
      setCurrentInstance(ctx);
      throw e2;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$2(propsOrChildren) && !isArray$2(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol(``);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
      warn(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
    }
    return ctx;
  }
};
function initCustomFormatter() {
  {
    return;
  }
}
function withMemo(memo, render2, cache, index2) {
  const cached = cache[index2];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo.slice();
  return cache[index2] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i2 = 0; i2 < prev.length; i2++) {
    if (hasChanged(prev[i2], memo[i2])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version$2 = "3.2.37";
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag2, isSVG, is2, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag2) : doc.createElement(tag2, is2 ? { is: is2 } : void 0);
    if (tag2 === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  cloneNode(el) {
    const cloned = el.cloneNode(true);
    if (`_value` in el) {
      cloned._value = el._value;
    }
    return cloned;
  },
  insertStaticContent(content, parent, anchor, isSVG, start2, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start2 && (start2 === end || start2.nextSibling)) {
      while (true) {
        parent.insertBefore(start2.cloneNode(true), anchor);
        if (start2 === end || !(start2 = start2.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$2(next);
  if (next && !isCssString) {
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
    if (prev && !isString$2(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name2, val) {
  if (isArray$2(val)) {
    val.forEach((v) => setStyle(style, name2, v));
  } else {
    if (val == null)
      val = "";
    if (name2.startsWith("--")) {
      style.setProperty(name2, val);
    } else {
      const prefixed = autoPrefix(style, name2);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name2 = camelize(rawName);
  if (name2 !== "filter" && name2 in style) {
    return prefixCache[rawName] = name2;
  }
  name2 = capitalize(name2);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name2;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e2) {
  }
  needRemove && el.removeAttribute(key);
}
const [_getNow, skipTimestampCheck] = /* @__PURE__ */ (() => {
  let _getNow2 = Date.now;
  let skipTimestampCheck2 = false;
  if (typeof window !== "undefined") {
    if (Date.now() > document.createEvent("Event").timeStamp) {
      _getNow2 = performance.now.bind(performance);
    }
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck2 = !!(ffMatch && Number(ffMatch[1]) <= 53);
  }
  return [_getNow2, skipTimestampCheck2];
})();
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const reset = () => {
  cachedNow = 0;
};
const getNow = () => cachedNow || (p.then(reset), cachedNow = _getNow());
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name2, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name2, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name2, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name2) {
  let options;
  if (optionsModifierRE.test(name2)) {
    options = {};
    let m;
    while (m = name2.match(optionsModifierRE)) {
      name2 = name2.slice(0, name2.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  return [hyphenate(name2.slice(2)), options];
}
function createInvoker(initialValue, instance) {
  const invoker = (e2) => {
    const timeStamp = e2.timeStamp || _getNow();
    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e2, invoker.value), instance, 5, [e2]);
    }
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e2, value) {
  if (isArray$2(value)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop.call(e2);
      e2._stopped = true;
    };
    return value.map((fn) => (e3) => !e3._stopped && fn && fn(e3));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction$1(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$2(value)) {
    return false;
  }
  return key in el;
}
function defineCustomElement(options, hydrate2) {
  const Comp = defineComponent(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
const defineSSRCustomElement = (options) => {
  return defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      this.attachShadow({ mode: "open" });
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      this._resolveDef();
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        render(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  _resolveDef() {
    if (this._resolved) {
      return;
    }
    this._resolved = true;
    for (let i2 = 0; i2 < this.attributes.length; i2++) {
      this._setAttr(this.attributes[i2].name);
    }
    new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    }).observe(this, { attributes: true });
    const resolve2 = (def2) => {
      const { props, styles } = def2;
      const hasOptions = !isArray$2(props);
      const rawKeys = props ? hasOptions ? Object.keys(props) : props : [];
      let numberProps;
      if (hasOptions) {
        for (const key in this._props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            this._props[key] = toNumber(this._props[key]);
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[key] = true;
          }
        }
      }
      this._numberProps = numberProps;
      for (const key of Object.keys(this)) {
        if (key[0] !== "_") {
          this._setProp(key, this[key], true, false);
        }
      }
      for (const key of rawKeys.map(camelize)) {
        Object.defineProperty(this, key, {
          get() {
            return this._getProp(key);
          },
          set(val) {
            this._setProp(key, val);
          }
        });
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then(resolve2);
    } else {
      resolve2(this._def);
    }
  }
  _setAttr(key) {
    let value = this.getAttribute(key);
    if (this._numberProps && this._numberProps[key]) {
      value = toNumber(value);
    }
    this._setProp(camelize(key), value, false);
  }
  _getProp(key) {
    return this._props[key];
  }
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
      }
    }
  }
  _update() {
    render(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend$1({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        instance.emit = (event, ...args) => {
          this.dispatchEvent(new CustomEvent(event, {
            detail: args
          }));
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css) => {
        const s = document.createElement("style");
        s.textContent = css;
        this.shadowRoot.appendChild(s);
      });
    }
  }
}
function useCssModule(name2 = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod2 = modules[name2];
    if (!mod2) {
      return EMPTY_OBJ;
    }
    return mod2;
  }
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
    }
  }
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$1({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if (isArray$2(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name: name2 = "v", type, duration, enterFromClass = `${name2}-enter-from`, enterActiveClass = `${name2}-enter-active`, enterToClass = `${name2}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name2}-leave-from`, leaveActiveClass = `${name2}-leave-active`, leaveToClass = `${name2}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$2(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e2) => {
    if (e2.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(TRANSITION + "Delay");
  const transitionDurations = getStyleProperties(TRANSITION + "Duration");
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(ANIMATION + "Delay");
  const animationDurations = getStyleProperties(ANIMATION + "Duration");
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + "Property"]);
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i2) => toMs(d) + toMs(delays[i2])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state2 = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el._moveCb = (e2) => {
          if (e2 && e2.target !== el) {
            return;
          }
          if (!e2 || /transform$/.test(e2.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag2 = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.key != null) {
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state2, instance));
        }
      }
      if (prevChildren) {
        for (let i2 = 0; i2 < prevChildren.length; i2++) {
          const child = prevChildren[i2];
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state2, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag2, null, children);
    };
  }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone2 = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
  clone2.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone2);
  const { hasTransform } = getTransitionInfo(clone2);
  container.removeChild(clone2);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$2(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e2) {
  e2.target.composing = true;
}
function onCompositionEnd(e2) {
  const target = e2.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const vModelText = {
  created(el, { modifiers: { lazy: lazy2, trim, number: number2 } }, vnode) {
    el._assign = getModelAssigner(vnode);
    const castToNumber = number2 || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy2 ? "change" : "input", (e2) => {
      if (e2.target.composing)
        return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = toNumber(domValue);
      }
      el._assign(domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy2) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy: lazy2, trim, number: number2 } }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (el.composing)
      return;
    if (document.activeElement === el && el.type !== "range") {
      if (lazy2) {
        return;
      }
      if (trim && el.value.trim() === value) {
        return;
      }
      if ((number2 || el.type === "number") && toNumber(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelCheckbox = {
  deep: true,
  created(el, _, vnode) {
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign2 = el._assign;
      if (isArray$2(modelValue)) {
        const index2 = looseIndexOf(modelValue, elementValue);
        const found = index2 !== -1;
        if (checked && !found) {
          assign2(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index2, 1);
          assign2(filtered);
        }
      } else if (isSet$1(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el, checked));
      }
    });
  },
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el._assign = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  if (isArray$2(value)) {
    el.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet$1(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el._assign(getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  deep: true,
  created(el, { value, modifiers: { number: number2 } }, vnode) {
    const isSetModel = isSet$1(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map((o) => number2 ? toNumber(getValue(o)) : getValue(o));
      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode);
  },
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray$2(value) && !isSet$1(value)) {
    return;
  }
  for (let i2 = 0, l = el.options.length; i2 < l; i2++) {
    const option = el.options[i2];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray$2(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i2)
          el.selectedIndex = i2;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray$2(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet$1(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e2) => e2.stopPropagation(),
  prevent: (e2) => e2.preventDefault(),
  self: (e2) => e2.target !== e2.currentTarget,
  ctrl: (e2) => !e2.ctrlKey,
  shift: (e2) => !e2.shiftKey,
  alt: (e2) => !e2.altKey,
  meta: (e2) => !e2.metaKey,
  left: (e2) => "button" in e2 && e2.button !== 0,
  middle: (e2) => "button" in e2 && e2.button !== 1,
  right: (e2) => "button" in e2 && e2.button !== 2,
  exact: (e2, modifiers) => systemModifiers.some((m) => e2[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn(event);
    }
  };
};
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el._vod = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el._vod : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer$1;
let enabledHydration = false;
function ensureRenderer() {
  return renderer$1 || (renderer$1 = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer$1 = enabledHydration ? renderer$1 : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer$1;
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
const createSSRApp = (...args) => {
  const app2 = ensureHydrationRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString$2(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
var robotoFont = /* @__PURE__ */ (() => "@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 100;\n  src: url(/ig-calc-testing/assets/KFOkCnqEu92Fr1MmgVxIIzQ.34e9582c.woff) format('woff');\n}\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 300;\n  src: url(/ig-calc-testing/assets/KFOlCnqEu92Fr1MmSU5fBBc-.bf14c7d7.woff) format('woff');\n}\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 400;\n  src: url(/ig-calc-testing/assets/KFOmCnqEu92Fr1Mu4mxM.f2abf7fb.woff) format('woff');\n}\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 500;\n  src: url(/ig-calc-testing/assets/KFOlCnqEu92Fr1MmEU9fBBc-.9ce7f3ac.woff) format('woff');\n}\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 700;\n  src: url(/ig-calc-testing/assets/KFOlCnqEu92Fr1MmWUlfBBc-.e0fd57c0.woff) format('woff');\n}\n@font-face {\n  font-family: 'Roboto';\n  font-style: normal;\n  font-weight: 900;\n  src: url(/ig-calc-testing/assets/KFOlCnqEu92Fr1MmYUtfBBc-.f6537e32.woff) format('woff');\n}\n")();
var materialIcons$1 = /* @__PURE__ */ (() => "@font-face {\n  font-family: 'Material Icons';\n  font-style: normal;\n  font-weight: 400;\n  font-display: block;\n  src: url('/ig-calc-testing/assets/flUhRq6tzZclQEJ-Vdg-IuiaDsNcIhQ8tQ.115bdc62.woff2') format('woff2'), url('/ig-calc-testing/assets/flUhRq6tzZclQEJ-Vdg-IuiaDsNa.1659ac2b.woff') format('woff');\n}\n\n.material-icons {\n  font-family: 'Material Icons';\n  font-weight: normal;\n  font-style: normal;\n  display: inline-block;\n  line-height: 1;\n  text-transform: none;\n  letter-spacing: normal;\n  word-wrap: normal;\n  white-space: nowrap;\n  direction: ltr;\n\n  /* Support for all WebKit browsers. */\n  -webkit-font-smoothing: antialiased;\n  /* Support for Safari and Chrome. */\n  text-rendering: optimizeLegibility;\n\n  /* Support for Firefox. */\n  -moz-osx-font-smoothing: grayscale;\n\n  /* Support for IE. */\n  font-feature-settings: 'liga';\n}\n")();
var quasar = /* @__PURE__ */ (() => '@charset "UTF-8";\n/*!\n * * Quasar Framework v2.7.5\n * * (c) 2015-present Razvan Stoenescu\n * * Released under the MIT License.\n * */\n*, *:before, *:after {\n  box-sizing: inherit;\n  -webkit-tap-highlight-color: transparent;\n  -moz-tap-highlight-color: transparent;\n}\nhtml, body, #q-app {\n  width: 100%;\n  direction: ltr;\n}\nbody.platform-ios.within-iframe, body.platform-ios.within-iframe #q-app {\n  width: 100px;\n  min-width: 100%;\n}\nhtml, body {\n  margin: 0;\n  box-sizing: border-box;\n}\narticle,\naside,\ndetails,\nfigcaption,\nfigure,\nfooter,\nheader,\nmain,\nmenu,\nnav,\nsection,\nsummary {\n  display: block;\n}\n/* * line 1: Remove the bottom border in Firefox 39-.\n * * lines 2,3: Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n * */\nabbr[title] {\n  border-bottom: none;\n  text-decoration: underline;\n  -webkit-text-decoration: underline dotted;\n          text-decoration: underline dotted;\n}\nimg {\n  border-style: none;\n}\nsvg:not(:root) {\n  overflow: hidden;\n}\n/* * line 1: Correct the inheritance and scaling of font size in all browsers.\n * * line 2: Correct the odd `em` font sizing in all browsers.\n * */\ncode, kbd, pre, samp {\n  font-family: monospace, monospace;\n  font-size: 1em;\n}\n/* * lines 1,2: Add the correct box sizing in Firefox.\n * * line 3: Show the overflow in Edge and IE.\n * */\nhr {\n  box-sizing: content-box;\n  height: 0;\n  overflow: visible;\n}\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font: inherit;\n  font-family: inherit;\n  margin: 0;\n}\noptgroup {\n  font-weight: bold;\n}\n/* * Show the overflow in IE.\n * *  input: Show the overflow in Edge.\n * *  select: Show the overflow in Edge, Firefox, and IE.\n * * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * *  select: Remove the inheritance of text transform in Firefox.\n * */\nbutton,\ninput,\nselect {\n  overflow: visible;\n  text-transform: none;\n}\nbutton::-moz-focus-inner, input::-moz-focus-inner {\n  border: 0;\n  padding: 0;\n}\nbutton:-moz-focusring, input:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\nfieldset {\n  padding: 0.35em 0.75em 0.625em;\n}\n/**\n * * lines 1,3,4,6: Correct the text wrapping in Edge and IE.\n * * line 2: Correct the color inheritance from `fieldset` elements in IE.\n * * line 5: Remove the padding so developers are not caught out when they zero out\n * *    `fieldset` elements in all browsers.\n * */\nlegend {\n  box-sizing: border-box;\n  color: inherit;\n  display: table;\n  max-width: 100%;\n  padding: 0;\n  white-space: normal;\n}\nprogress {\n  vertical-align: baseline;\n}\ntextarea {\n  overflow: auto;\n}\ninput[type=search]::-webkit-search-cancel-button,\ninput[type=search]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n.q-icon {\n  line-height: 1;\n  width: 1em;\n  height: 1em;\n  flex-shrink: 0;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  text-align: center;\n  position: relative;\n  box-sizing: content-box;\n  fill: currentColor;\n}\n.q-icon:before, .q-icon:after {\n  width: 100%;\n  height: 100%;\n  display: flex !important;\n  align-items: center;\n  justify-content: center;\n}\n.q-icon > svg,\n.q-icon > img {\n  width: 100%;\n  height: 100%;\n}\n.q-icon,\n.material-icons,\n.material-icons-outlined,\n.material-icons-round,\n.material-icons-sharp,\n.material-symbols-outlined,\n.material-symbols-rounded,\n.material-symbols-sharp {\n  -webkit-user-select: none;\n          user-select: none;\n  cursor: inherit;\n  font-size: inherit;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  vertical-align: middle;\n}\n.q-panel {\n  height: 100%;\n  width: 100%;\n}\n.q-panel > div {\n  height: 100%;\n  width: 100%;\n}\n.q-panel-parent {\n  overflow: hidden;\n  position: relative;\n}\n.q-loading-bar {\n  position: fixed;\n  z-index: 9998;\n  transition: transform 0.5s cubic-bezier(0, 0, 0.2, 1), opacity 0.5s;\n  background: #f44336;\n}\n.q-loading-bar--top {\n  left: 0 /* rtl:ignore */;\n  right: 0 /* rtl:ignore */;\n  top: 0;\n  width: 100%;\n}\n.q-loading-bar--bottom {\n  left: 0 /* rtl:ignore */;\n  right: 0 /* rtl:ignore */;\n  bottom: 0;\n  width: 100%;\n}\n.q-loading-bar--right {\n  top: 0;\n  bottom: 0;\n  right: 0;\n  height: 100%;\n}\n.q-loading-bar--left {\n  top: 0;\n  bottom: 0;\n  left: 0;\n  height: 100%;\n}\n.q-avatar {\n  position: relative;\n  vertical-align: middle;\n  display: inline-block;\n  border-radius: 50%;\n  font-size: 48px;\n  height: 1em;\n  width: 1em;\n}\n.q-avatar__content {\n  font-size: 0.5em;\n  line-height: 0.5em;\n}\n.q-avatar__content, .q-avatar img:not(.q-icon):not(.q-img__image) {\n  border-radius: inherit;\n  height: inherit;\n  width: inherit;\n}\n.q-avatar--square {\n  border-radius: 0;\n}\n.q-badge {\n  background-color: var(--q-primary);\n  color: #fff;\n  padding: 2px 6px;\n  border-radius: 4px;\n  font-size: 12px;\n  line-height: 12px;\n  min-height: 12px;\n  font-weight: normal;\n  vertical-align: baseline;\n}\n.q-badge--single-line {\n  white-space: nowrap;\n}\n.q-badge--multi-line {\n  word-break: break-all;\n  word-wrap: break-word;\n}\n.q-badge--floating {\n  position: absolute;\n  top: -4px;\n  right: -3px;\n  cursor: inherit;\n}\n.q-badge--transparent {\n  opacity: 0.8;\n}\n.q-badge--outline {\n  background-color: transparent;\n  border: 1px solid currentColor;\n}\n.q-badge--rounded {\n  border-radius: 1em;\n}\n.q-banner {\n  min-height: 54px;\n  padding: 8px 16px;\n  background: #fff;\n}\n.q-banner--top-padding {\n  padding-top: 14px;\n}\n.q-banner__avatar {\n  min-width: 1px !important;\n}\n.q-banner__avatar > .q-avatar {\n  font-size: 46px;\n}\n.q-banner__avatar > .q-icon {\n  font-size: 40px;\n}\n.q-banner__avatar:not(:empty) + .q-banner__content {\n  padding-left: 16px;\n}\n.q-banner__actions.col-auto {\n  padding-left: 16px;\n}\n.q-banner__actions.col-all .q-btn-item {\n  margin: 4px 0 0 4px;\n}\n.q-banner--dense {\n  min-height: 32px;\n  padding: 8px;\n}\n.q-banner--dense.q-banner--top-padding {\n  padding-top: 12px;\n}\n.q-banner--dense .q-banner__avatar > .q-avatar, .q-banner--dense .q-banner__avatar > .q-icon {\n  font-size: 28px;\n}\n.q-banner--dense .q-banner__avatar:not(:empty) + .q-banner__content {\n  padding-left: 8px;\n}\n.q-banner--dense .q-banner__actions.col-auto {\n  padding-left: 8px;\n}\n.q-bar {\n  background: rgba(0, 0, 0, 0.2);\n}\n.q-bar > .q-icon {\n  margin-left: 2px;\n}\n.q-bar > div, .q-bar > div + .q-icon {\n  margin-left: 8px;\n}\n.q-bar > .q-btn {\n  margin-left: 2px;\n}\n.q-bar > .q-icon:first-child, .q-bar > .q-btn:first-child, .q-bar > div:first-child {\n  margin-left: 0;\n}\n.q-bar--standard {\n  padding: 0 12px;\n  height: 32px;\n  font-size: 18px;\n}\n.q-bar--standard > div {\n  font-size: 16px;\n}\n.q-bar--standard .q-btn {\n  font-size: 11px;\n}\n.q-bar--dense {\n  padding: 0 8px;\n  height: 24px;\n  font-size: 14px;\n}\n.q-bar--dense .q-btn {\n  font-size: 8px;\n}\n.q-bar--dark {\n  background: rgba(255, 255, 255, 0.15);\n}\n.q-breadcrumbs__el {\n  color: inherit;\n}\n.q-breadcrumbs__el-icon {\n  font-size: 125%;\n}\n.q-breadcrumbs__el-icon--with-label {\n  margin-right: 8px;\n}\n[dir=rtl] .q-breadcrumbs__separator .q-icon {\n  transform: scaleX(-1) /* rtl:ignore */;\n}\n.q-btn {\n  display: inline-flex;\n  flex-direction: column;\n  align-items: stretch;\n  position: relative;\n  outline: 0;\n  border: 0;\n  vertical-align: middle;\n  font-size: 14px;\n  line-height: 1.715em;\n  text-decoration: none;\n  color: inherit;\n  background: transparent;\n  font-weight: 500;\n  text-transform: uppercase;\n  text-align: center;\n  width: auto;\n  height: auto;\n  cursor: default;\n  padding: 4px 16px;\n  min-height: 2.572em;\n}\n.q-btn .q-icon, .q-btn .q-spinner {\n  font-size: 1.715em;\n}\n.q-btn.disabled {\n  opacity: 0.7 !important;\n}\n.q-btn:before {\n  content: "";\n  display: block;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  border-radius: inherit;\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n}\n.q-btn--actionable {\n  cursor: pointer;\n}\n.q-btn--actionable.q-btn--standard:before {\n  transition: box-shadow 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\n.q-btn--actionable.q-btn--standard:active:before, .q-btn--actionable.q-btn--standard.q-btn--active:before {\n  box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 5px 8px rgba(0, 0, 0, 0.14), 0 1px 14px rgba(0, 0, 0, 0.12);\n}\n.q-btn--no-uppercase {\n  text-transform: none;\n}\n.q-btn--rectangle {\n  border-radius: 3px;\n}\n.q-btn--outline {\n  background: transparent !important;\n}\n.q-btn--outline:before {\n  border: 1px solid currentColor;\n}\n.q-btn--push {\n  border-radius: 7px;\n}\n.q-btn--push:before {\n  border-bottom: 3px solid rgba(0, 0, 0, 0.15);\n}\n.q-btn--push.q-btn--actionable {\n  transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\n.q-btn--push.q-btn--actionable:before {\n  transition: border-width 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\n.q-btn--push.q-btn--actionable:active, .q-btn--push.q-btn--actionable.q-btn--active {\n  transform: translateY(2px);\n}\n.q-btn--push.q-btn--actionable:active:before, .q-btn--push.q-btn--actionable.q-btn--active:before {\n  border-bottom-width: 0;\n}\n.q-btn--rounded {\n  border-radius: 28px;\n}\n.q-btn--round {\n  border-radius: 50%;\n  padding: 0;\n  min-width: 3em;\n  min-height: 3em;\n}\n.q-btn--flat:before, .q-btn--outline:before, .q-btn--unelevated:before {\n  box-shadow: none;\n}\n.q-btn--dense {\n  padding: 0.285em;\n  min-height: 2em;\n}\n.q-btn--dense.q-btn--round {\n  padding: 0;\n  min-height: 2.4em;\n  min-width: 2.4em;\n}\n.q-btn--dense .on-left {\n  margin-right: 6px;\n}\n.q-btn--dense .on-right {\n  margin-left: 6px;\n}\n.q-btn--fab .q-icon, .q-btn--fab-mini .q-icon {\n  font-size: 24px;\n}\n.q-btn--fab {\n  padding: 16px;\n  min-height: 56px;\n  min-width: 56px;\n}\n.q-btn--fab .q-icon {\n  margin: auto;\n}\n.q-btn--fab-mini {\n  padding: 8px;\n  min-height: 40px;\n  min-width: 40px;\n}\n.q-btn__content {\n  transition: opacity 0.3s;\n  z-index: 0;\n}\n.q-btn__content--hidden {\n  opacity: 0;\n  pointer-events: none;\n}\n.q-btn__progress {\n  border-radius: inherit;\n  z-index: 0;\n}\n.q-btn__progress-indicator {\n  z-index: -1;\n  transform: translateX(-100%);\n  background: rgba(255, 255, 255, 0.25);\n}\n.q-btn__progress--dark .q-btn__progress-indicator {\n  background: rgba(0, 0, 0, 0.2);\n}\n.q-btn--flat .q-btn__progress-indicator, .q-btn--outline .q-btn__progress-indicator {\n  opacity: 0.2;\n  background: currentColor;\n}\n.q-btn-dropdown--split .q-btn-dropdown__arrow-container {\n  padding: 0 4px;\n}\n.q-btn-dropdown--split .q-btn-dropdown__arrow-container.q-btn--outline {\n  border-left: 1px solid currentColor;\n}\n.q-btn-dropdown--split .q-btn-dropdown__arrow-container:not(.q-btn--outline) {\n  border-left: 1px solid rgba(255, 255, 255, 0.3);\n}\n.q-btn-dropdown--simple * + .q-btn-dropdown__arrow {\n  margin-left: 8px;\n}\n.q-btn-dropdown__arrow {\n  transition: transform 0.28s;\n}\n.q-btn-dropdown--current {\n  flex-grow: 1;\n}\n.q-btn-group {\n  border-radius: 3px;\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n  vertical-align: middle;\n}\n.q-btn-group > .q-btn-item {\n  border-radius: inherit;\n  align-self: stretch;\n}\n.q-btn-group > .q-btn-item:before {\n  box-shadow: none;\n}\n.q-btn-group > .q-btn-item .q-badge--floating {\n  right: 0;\n}\n.q-btn-group > .q-btn-group {\n  box-shadow: none;\n}\n.q-btn-group > .q-btn-group:first-child > .q-btn:first-child {\n  border-top-left-radius: inherit;\n  border-bottom-left-radius: inherit;\n}\n.q-btn-group > .q-btn-group:last-child > .q-btn:last-child {\n  border-top-right-radius: inherit;\n  border-bottom-right-radius: inherit;\n}\n.q-btn-group > .q-btn-group:not(:first-child) > .q-btn:first-child:before {\n  border-left: 0;\n}\n.q-btn-group > .q-btn-group:not(:last-child) > .q-btn:last-child:before {\n  border-right: 0;\n}\n.q-btn-group > .q-btn-item:not(:last-child) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.q-btn-group > .q-btn-item:not(:first-child) {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.q-btn-group > .q-btn-item.q-btn--standard:before {\n  z-index: -1;\n}\n.q-btn-group--push {\n  border-radius: 7px;\n}\n.q-btn-group--push > .q-btn--push.q-btn--actionable {\n  transform: none;\n}\n.q-btn-group--push > .q-btn--push.q-btn--actionable .q-btn__content {\n  transition: margin-top 0.3s cubic-bezier(0.25, 0.8, 0.5, 1), margin-bottom 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\n.q-btn-group--push > .q-btn--push.q-btn--actionable:active .q-btn__content, .q-btn-group--push > .q-btn--push.q-btn--actionable.q-btn--active .q-btn__content {\n  margin-top: 2px;\n  margin-bottom: -2px;\n}\n.q-btn-group--rounded {\n  border-radius: 28px;\n}\n.q-btn-group--flat, .q-btn-group--outline, .q-btn-group--unelevated {\n  box-shadow: none;\n}\n.q-btn-group--outline > .q-separator {\n  display: none;\n}\n.q-btn-group--outline > .q-btn-item + .q-btn-item:before {\n  border-left: 0;\n}\n.q-btn-group--outline > .q-btn-item:not(:last-child):before {\n  border-right: 0;\n}\n.q-btn-group--stretch {\n  align-self: stretch;\n  border-radius: 0;\n}\n.q-btn-group--glossy > .q-btn-item {\n  background-image: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.12) 51%, rgba(0, 0, 0, 0.04)) !important;\n}\n.q-btn-group--spread > .q-btn-group {\n  display: flex !important;\n}\n.q-btn-group--spread > .q-btn-item, .q-btn-group--spread > .q-btn-group > .q-btn-item:not(.q-btn-dropdown__arrow-container) {\n  width: auto;\n  min-width: 0;\n  max-width: 100%;\n  flex: 10000 1 0%;\n}\n.q-btn-toggle {\n  position: relative;\n}\n.q-card {\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n  border-radius: 4px;\n  vertical-align: top;\n  background: #fff;\n  position: relative;\n}\n.q-card > div:first-child,\n.q-card > img:first-child {\n  border-top: 0;\n  border-top-left-radius: inherit;\n  border-top-right-radius: inherit;\n}\n.q-card > div:last-child,\n.q-card > img:last-child {\n  border-bottom: 0;\n  border-bottom-left-radius: inherit;\n  border-bottom-right-radius: inherit;\n}\n.q-card > div:not(:first-child),\n.q-card > img:not(:first-child) {\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n.q-card > div:not(:last-child),\n.q-card > img:not(:last-child) {\n  border-bottom-left-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.q-card > div {\n  border-left: 0;\n  border-right: 0;\n  box-shadow: none;\n}\n.q-card--bordered {\n  border: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-card--dark {\n  border-color: rgba(255, 255, 255, 0.28);\n}\n.q-card__section {\n  position: relative;\n}\n.q-card__section--vert {\n  padding: 16px;\n}\n.q-card__section--horiz > div:first-child,\n.q-card__section--horiz > img:first-child {\n  border-top-left-radius: inherit;\n  border-bottom-left-radius: inherit;\n}\n.q-card__section--horiz > div:last-child,\n.q-card__section--horiz > img:last-child {\n  border-top-right-radius: inherit;\n  border-bottom-right-radius: inherit;\n}\n.q-card__section--horiz > div:not(:first-child),\n.q-card__section--horiz > img:not(:first-child) {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.q-card__section--horiz > div:not(:last-child),\n.q-card__section--horiz > img:not(:last-child) {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.q-card__section--horiz > div {\n  border-top: 0;\n  border-bottom: 0;\n  box-shadow: none;\n}\n.q-card__actions {\n  padding: 8px;\n  align-items: center;\n}\n.q-card__actions .q-btn {\n  padding: 0 8px;\n}\n.q-card__actions--horiz > .q-btn-item + .q-btn-item,\n.q-card__actions--horiz > .q-btn-group + .q-btn-item,\n.q-card__actions--horiz > .q-btn-item + .q-btn-group {\n  margin-left: 8px;\n}\n.q-card__actions--vert > .q-btn-item.q-btn--round {\n  align-self: center;\n}\n.q-card__actions--vert > .q-btn-item + .q-btn-item,\n.q-card__actions--vert > .q-btn-group + .q-btn-item,\n.q-card__actions--vert > .q-btn-item + .q-btn-group {\n  margin-top: 4px;\n}\n.q-card__actions--vert > .q-btn-group > .q-btn-item {\n  flex-grow: 1;\n}\n.q-card > img {\n  display: block;\n  width: 100%;\n  max-width: 100%;\n  border: 0;\n}\n.q-carousel {\n  background-color: #fff;\n  height: 400px;\n}\n.q-carousel__slide {\n  min-height: 100%;\n  background-size: cover;\n  background-position: 50%;\n}\n.q-carousel__slide, .q-carousel .q-carousel--padding {\n  padding: 16px;\n}\n.q-carousel__slides-container {\n  height: 100%;\n}\n.q-carousel__control {\n  color: #fff;\n}\n.q-carousel__arrow {\n  pointer-events: none;\n}\n.q-carousel__arrow .q-icon {\n  font-size: 28px;\n}\n.q-carousel__arrow .q-btn {\n  pointer-events: all;\n}\n.q-carousel__prev-arrow--horizontal, .q-carousel__next-arrow--horizontal {\n  top: 16px;\n  bottom: 16px;\n}\n.q-carousel__prev-arrow--horizontal {\n  left: 16px;\n}\n.q-carousel__next-arrow--horizontal {\n  right: 16px;\n}\n.q-carousel__prev-arrow--vertical, .q-carousel__next-arrow--vertical {\n  left: 16px;\n  right: 16px;\n}\n.q-carousel__prev-arrow--vertical {\n  top: 16px;\n}\n.q-carousel__next-arrow--vertical {\n  bottom: 16px;\n}\n.q-carousel__navigation--top, .q-carousel__navigation--bottom {\n  left: 16px;\n  right: 16px;\n  overflow-x: auto;\n  overflow-y: hidden;\n}\n.q-carousel__navigation--top {\n  top: 16px;\n}\n.q-carousel__navigation--bottom {\n  bottom: 16px;\n}\n.q-carousel__navigation--left, .q-carousel__navigation--right {\n  top: 16px;\n  bottom: 16px;\n  overflow-x: hidden;\n  overflow-y: auto;\n}\n.q-carousel__navigation--left > .q-carousel__navigation-inner, .q-carousel__navigation--right > .q-carousel__navigation-inner {\n  flex-direction: column;\n}\n.q-carousel__navigation--left {\n  left: 16px;\n}\n.q-carousel__navigation--right {\n  right: 16px;\n}\n.q-carousel__navigation-inner {\n  flex: 1 1 auto;\n}\n.q-carousel__navigation .q-btn {\n  margin: 6px 4px;\n  padding: 5px;\n}\n.q-carousel__navigation-icon--inactive {\n  opacity: 0.7;\n}\n.q-carousel .q-carousel__thumbnail {\n  margin: 2px;\n  height: 50px;\n  width: auto;\n  display: inline-block;\n  cursor: pointer;\n  border: 1px solid transparent;\n  border-radius: 4px;\n  vertical-align: middle;\n  opacity: 0.7;\n  transition: opacity 0.3s;\n}\n.q-carousel .q-carousel__thumbnail:hover,\n.q-carousel .q-carousel__thumbnail--active {\n  opacity: 1;\n}\n.q-carousel .q-carousel__thumbnail--active {\n  border-color: currentColor;\n  cursor: default;\n}\n.q-carousel--navigation-top.q-carousel--with-padding .q-carousel__slide, .q-carousel--navigation-top .q-carousel--padding, .q-carousel--arrows-vertical.q-carousel--with-padding .q-carousel__slide, .q-carousel--arrows-vertical .q-carousel--padding {\n  padding-top: 60px;\n}\n.q-carousel--navigation-bottom.q-carousel--with-padding .q-carousel__slide, .q-carousel--navigation-bottom .q-carousel--padding, .q-carousel--arrows-vertical.q-carousel--with-padding .q-carousel__slide, .q-carousel--arrows-vertical .q-carousel--padding {\n  padding-bottom: 60px;\n}\n.q-carousel--navigation-left.q-carousel--with-padding .q-carousel__slide, .q-carousel--navigation-left .q-carousel--padding, .q-carousel--arrows-horizontal.q-carousel--with-padding .q-carousel__slide, .q-carousel--arrows-horizontal .q-carousel--padding {\n  padding-left: 60px;\n}\n.q-carousel--navigation-right.q-carousel--with-padding .q-carousel__slide, .q-carousel--navigation-right .q-carousel--padding, .q-carousel--arrows-horizontal.q-carousel--with-padding .q-carousel__slide, .q-carousel--arrows-horizontal .q-carousel--padding {\n  padding-right: 60px;\n}\n.q-carousel.fullscreen {\n  height: 100%;\n}\n.q-message-name, .q-message-stamp, .q-message-label {\n  font-size: small;\n}\n.q-message-label {\n  margin: 24px 0;\n  text-align: center;\n}\n.q-message-stamp {\n  color: inherit;\n  margin-top: 4px;\n  opacity: 0.6;\n  display: none;\n}\n.q-message-avatar {\n  border-radius: 50%;\n  width: 48px;\n  height: 48px;\n  min-width: 48px;\n}\n.q-message {\n  margin-bottom: 8px;\n}\n.q-message:first-child .q-message-label {\n  margin-top: 0;\n}\n.q-message-avatar--received {\n  margin-right: 8px;\n}\n.q-message-text--received {\n  color: #81c784;\n  border-radius: 4px 4px 4px 0;\n}\n.q-message-text--received:last-child:before {\n  right: 100%;\n  border-right: 0 solid transparent;\n  border-left: 8px solid transparent;\n  border-bottom: 8px solid currentColor;\n}\n.q-message-text-content--received {\n  color: #000;\n}\n.q-message-name--sent {\n  text-align: right;\n}\n.q-message-avatar--sent {\n  margin-left: 8px;\n}\n.q-message-container--sent {\n  flex-direction: row-reverse;\n}\n.q-message-text--sent {\n  color: #e0e0e0;\n  border-radius: 4px 4px 0 4px;\n}\n.q-message-text--sent:last-child:before {\n  left: 100%;\n  border-left: 0 solid transparent;\n  border-right: 8px solid transparent;\n  border-bottom: 8px solid currentColor;\n}\n.q-message-text-content--sent {\n  color: #000;\n}\n.q-message-text {\n  background: currentColor;\n  padding: 8px;\n  line-height: 1.2;\n  word-break: break-word;\n  position: relative;\n}\n.q-message-text + .q-message-text {\n  margin-top: 3px;\n}\n.q-message-text:last-child {\n  min-height: 48px;\n}\n.q-message-text:last-child .q-message-stamp {\n  display: block;\n}\n.q-message-text:last-child:before {\n  content: "";\n  position: absolute;\n  bottom: 0;\n  width: 0;\n  height: 0;\n}\n.q-checkbox {\n  vertical-align: middle;\n}\n.q-checkbox__native {\n  width: 1px;\n  height: 1px;\n}\n.q-checkbox__bg, .q-checkbox__icon-container {\n  -webkit-user-select: none;\n          user-select: none;\n}\n.q-checkbox__bg {\n  top: 25%;\n  left: 25%;\n  width: 50%;\n  height: 50%;\n  border: 2px solid currentColor;\n  border-radius: 2px;\n  transition: background 0.22s cubic-bezier(0, 0, 0.2, 1) 0ms;\n  -webkit-print-color-adjust: exact;\n}\n.q-checkbox__icon {\n  color: currentColor;\n  font-size: 0.5em;\n}\n.q-checkbox__svg {\n  color: #fff;\n}\n.q-checkbox__truthy {\n  stroke: currentColor;\n  stroke-width: 3.12px;\n  stroke-dashoffset: 29.78334;\n  stroke-dasharray: 29.78334;\n}\n.q-checkbox__indet {\n  fill: currentColor;\n  transform-origin: 50% 50%;\n  transform: rotate(-280deg) scale(0);\n}\n.q-checkbox__inner {\n  font-size: 40px;\n  width: 1em;\n  min-width: 1em;\n  height: 1em;\n  outline: 0;\n  border-radius: 50%;\n  color: rgba(0, 0, 0, 0.54);\n}\n.q-checkbox__inner--truthy, .q-checkbox__inner--indet {\n  color: var(--q-primary);\n}\n.q-checkbox__inner--truthy .q-checkbox__bg, .q-checkbox__inner--indet .q-checkbox__bg {\n  background: currentColor;\n}\n.q-checkbox__inner--truthy path {\n  stroke-dashoffset: 0;\n  transition: stroke-dashoffset 0.18s cubic-bezier(0.4, 0, 0.6, 1) 0ms;\n}\n.q-checkbox__inner--indet .q-checkbox__indet {\n  transform: rotate(0) scale(1);\n  transition: transform 0.22s cubic-bezier(0, 0, 0.2, 1) 0ms;\n}\n.q-checkbox.disabled {\n  opacity: 0.75 !important;\n}\n.q-checkbox--dark .q-checkbox__inner {\n  color: rgba(255, 255, 255, 0.7);\n}\n.q-checkbox--dark .q-checkbox__inner:before {\n  opacity: 0.32 !important;\n}\n.q-checkbox--dark .q-checkbox__inner--truthy, .q-checkbox--dark .q-checkbox__inner--indet {\n  color: var(--q-primary);\n}\n.q-checkbox--dense .q-checkbox__inner {\n  width: 0.5em;\n  min-width: 0.5em;\n  height: 0.5em;\n}\n.q-checkbox--dense .q-checkbox__bg {\n  left: 5%;\n  top: 5%;\n  width: 90%;\n  height: 90%;\n}\n.q-checkbox--dense .q-checkbox__label {\n  padding-left: 0.5em;\n}\n.q-checkbox--dense.reverse .q-checkbox__label {\n  padding-left: 0;\n  padding-right: 0.5em;\n}\nbody.desktop .q-checkbox:not(.disabled) .q-checkbox__inner:before {\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  border-radius: 50%;\n  background: currentColor;\n  opacity: 0.12;\n  transform: scale3d(0, 0, 1);\n  transition: transform 0.22s cubic-bezier(0, 0, 0.2, 1);\n}\nbody.desktop .q-checkbox:not(.disabled):focus .q-checkbox__inner:before, body.desktop .q-checkbox:not(.disabled):hover .q-checkbox__inner:before {\n  transform: scale3d(1, 1, 1);\n}\nbody.desktop .q-checkbox--dense:not(.disabled):focus .q-checkbox__inner:before, body.desktop .q-checkbox--dense:not(.disabled):hover .q-checkbox__inner:before {\n  transform: scale3d(1.4, 1.4, 1);\n}\n.q-chip {\n  vertical-align: middle;\n  border-radius: 16px;\n  outline: 0;\n  position: relative;\n  height: 2em;\n  max-width: 100%;\n  margin: 4px;\n  background: #e0e0e0;\n  color: rgba(0, 0, 0, 0.87);\n  font-size: 14px;\n  padding: 0.5em 0.9em;\n}\n.q-chip--colored .q-chip__icon, .q-chip--dark .q-chip__icon {\n  color: inherit;\n}\n.q-chip--outline {\n  background: transparent !important;\n  border: 1px solid currentColor;\n}\n.q-chip .q-avatar {\n  font-size: 2em;\n  margin-left: -0.45em;\n  margin-right: 0.2em;\n  border-radius: 16px;\n}\n.q-chip--selected .q-avatar {\n  display: none;\n}\n.q-chip__icon {\n  color: rgba(0, 0, 0, 0.54);\n  font-size: 1.5em;\n  margin: -0.2em;\n}\n.q-chip__icon--left {\n  margin-right: 0.2em;\n}\n.q-chip__icon--right {\n  margin-left: 0.2em;\n}\n.q-chip__icon--remove {\n  margin-left: 0.1em;\n  margin-right: -0.5em;\n  opacity: 0.6;\n  outline: 0;\n}\n.q-chip__icon--remove:hover, .q-chip__icon--remove:focus {\n  opacity: 1;\n}\n.q-chip__content {\n  white-space: nowrap;\n}\n.q-chip--dense {\n  border-radius: 12px;\n  padding: 0 0.4em;\n  height: 1.5em;\n}\n.q-chip--dense .q-avatar {\n  font-size: 1.5em;\n  margin-left: -0.27em;\n  margin-right: 0.1em;\n  border-radius: 12px;\n}\n.q-chip--dense .q-chip__icon {\n  font-size: 1.25em;\n}\n.q-chip--dense .q-chip__icon--left {\n  margin-right: 0.195em;\n}\n.q-chip--dense .q-chip__icon--remove {\n  margin-right: -0.25em;\n}\n.q-chip--square {\n  border-radius: 4px;\n}\n.q-chip--square .q-avatar {\n  border-radius: 3px 0 0 3px;\n}\nbody.desktop .q-chip--clickable:focus {\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2), 0 1px 1px rgba(0, 0, 0, 0.14), 0 2px 1px -1px rgba(0, 0, 0, 0.12);\n}\n.q-circular-progress {\n  display: inline-block;\n  position: relative;\n  vertical-align: middle;\n  width: 1em;\n  height: 1em;\n  line-height: 1;\n}\n.q-circular-progress.q-focusable {\n  border-radius: 50%;\n}\n.q-circular-progress__svg {\n  width: 100%;\n  height: 100%;\n}\n.q-circular-progress__text {\n  font-size: 0.25em;\n}\n.q-circular-progress--indeterminate .q-circular-progress__svg {\n  transform-origin: 50% 50%;\n  animation: q-spin 2s linear infinite /* rtl:ignore */;\n}\n.q-circular-progress--indeterminate .q-circular-progress__circle {\n  stroke-dasharray: 1 400;\n  stroke-dashoffset: 0;\n  animation: q-circular-progress-circle 1.5s ease-in-out infinite /* rtl:ignore */;\n}\n@keyframes q-circular-progress-circle {\n  0% {\n    stroke-dasharray: 1, 400;\n    stroke-dashoffset: 0;\n  }\n  50% {\n    stroke-dasharray: 400, 400;\n    stroke-dashoffset: -100;\n  }\n  100% {\n    stroke-dasharray: 400, 400;\n    stroke-dashoffset: -300;\n  }\n}\n.q-color-picker {\n  overflow: hidden;\n  background: #fff;\n  max-width: 350px;\n  vertical-align: top;\n  min-width: 180px;\n  border-radius: 4px;\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n}\n.q-color-picker .q-tab {\n  padding: 0 !important;\n}\n.q-color-picker--bordered {\n  border: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-color-picker__header-tabs {\n  height: 32px;\n}\n.q-color-picker__header-banner {\n  height: 36px;\n}\n.q-color-picker__header input {\n  line-height: 24px;\n  border: 0;\n}\n.q-color-picker__header .q-tab {\n  min-height: 32px !important;\n  height: 32px !important;\n}\n.q-color-picker__header .q-tab--inactive {\n  background: linear-gradient(to top, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.15) 25%, rgba(0, 0, 0, 0.1));\n}\n.q-color-picker__error-icon {\n  bottom: 2px;\n  right: 2px;\n  font-size: 24px;\n  opacity: 0;\n  transition: opacity 0.3s ease-in;\n}\n.q-color-picker__header-content {\n  position: relative;\n  background: #fff;\n}\n.q-color-picker__header-content--light {\n  color: #000;\n}\n.q-color-picker__header-content--dark {\n  color: #fff;\n}\n.q-color-picker__header-content--dark .q-tab--inactive:before {\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background: rgba(255, 255, 255, 0.2);\n}\n.q-color-picker__header-banner {\n  height: 36px;\n}\n.q-color-picker__header-bg {\n  background: #fff;\n  background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAH0lEQVQoU2NkYGAwZkAFZ5G5jPRRgOYEVDeB3EBjBQBOZwTVugIGyAAAAABJRU5ErkJggg==") !important;\n}\n.q-color-picker__footer {\n  height: 36px;\n}\n.q-color-picker__footer .q-tab {\n  min-height: 36px !important;\n  height: 36px !important;\n}\n.q-color-picker__footer .q-tab--inactive {\n  background: linear-gradient(to bottom, rgba(0, 0, 0, 0.3) 0%, rgba(0, 0, 0, 0.15) 25%, rgba(0, 0, 0, 0.1));\n}\n.q-color-picker__spectrum {\n  width: 100%;\n  height: 100%;\n}\n.q-color-picker__spectrum-tab {\n  padding: 0 !important;\n}\n.q-color-picker__spectrum-white {\n  background: linear-gradient(to right, #fff, rgba(255, 255, 255, 0));\n}\n.q-color-picker__spectrum-black {\n  background: linear-gradient(to top, #000, rgba(0, 0, 0, 0));\n}\n.q-color-picker__spectrum-circle {\n  width: 10px;\n  height: 10px;\n  box-shadow: 0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0, 0, 0, 0.3), 0 0 1px 2px rgba(0, 0, 0, 0.4);\n  border-radius: 50%;\n  transform: translate(-5px, -5px);\n}\n.q-color-picker__hue .q-slider__track {\n  background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%) !important;\n  opacity: 1;\n}\n.q-color-picker__alpha .q-slider__track-container {\n  padding-top: 0;\n}\n.q-color-picker__alpha .q-slider__track:before {\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  border-radius: inherit;\n  background: linear-gradient(90deg, rgba(255, 255, 255, 0), #757575);\n}\n.q-color-picker__sliders {\n  padding: 0 16px;\n}\n.q-color-picker__sliders .q-slider__thumb {\n  color: #424242;\n}\n.q-color-picker__sliders .q-slider__thumb path {\n  stroke-width: 2px;\n  fill: transparent;\n}\n.q-color-picker__sliders .q-slider--active path {\n  stroke-width: 3px;\n}\n.q-color-picker__tune-tab .q-slider {\n  margin-left: 18px;\n  margin-right: 18px;\n}\n.q-color-picker__tune-tab input {\n  font-size: 11px;\n  border: 1px solid #e0e0e0;\n  border-radius: 4px;\n  width: 3.5em;\n}\n.q-color-picker__palette-tab {\n  padding: 0 !important;\n}\n.q-color-picker__palette-rows--editable .q-color-picker__cube {\n  cursor: pointer;\n}\n.q-color-picker__cube {\n  padding-bottom: 10%;\n  width: 10% !important;\n}\n.q-color-picker input {\n  color: inherit;\n  background: transparent;\n  outline: 0;\n  text-align: center;\n}\n.q-color-picker .q-tabs {\n  overflow: hidden;\n}\n.q-color-picker .q-tab--active {\n  box-shadow: 0 0 14px 3px rgba(0, 0, 0, 0.2);\n}\n.q-color-picker .q-tab--active .q-focus-helper {\n  display: none;\n}\n.q-color-picker .q-tab__indicator {\n  display: none;\n}\n.q-color-picker .q-tab-panels {\n  background: inherit;\n}\n.q-color-picker--dark .q-color-picker__tune-tab input {\n  border: 1px solid rgba(255, 255, 255, 0.3);\n}\n.q-color-picker--dark .q-slider__thumb {\n  color: #fafafa;\n}\n.q-date {\n  display: inline-flex;\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n  border-radius: 4px;\n  background: #fff;\n  width: 290px;\n  min-width: 290px;\n  max-width: 100%;\n}\n.q-date--bordered {\n  border: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-date__header {\n  border-top-left-radius: inherit;\n  color: #fff;\n  background-color: var(--q-primary);\n  padding: 16px;\n}\n.q-date__actions {\n  padding: 0 16px 16px;\n}\n.q-date__content, .q-date__main {\n  outline: 0;\n}\n.q-date__content .q-btn {\n  font-weight: normal;\n}\n.q-date__header-link {\n  opacity: 0.64;\n  outline: 0;\n  transition: opacity 0.3s ease-out;\n}\n.q-date__header-link--active, .q-date__header-link:hover, .q-date__header-link:focus {\n  opacity: 1;\n}\n.q-date__header-subtitle {\n  font-size: 14px;\n  line-height: 1.75;\n  letter-spacing: 0.00938em;\n}\n.q-date__header-title-label {\n  font-size: 24px;\n  line-height: 1.2;\n  letter-spacing: 0.00735em;\n}\n.q-date__view {\n  height: 100%;\n  width: 100%;\n  min-height: 290px;\n  padding: 16px;\n}\n.q-date__navigation {\n  height: 12.5%;\n}\n.q-date__navigation > div:first-child {\n  width: 8%;\n  min-width: 24px;\n  justify-content: flex-end;\n}\n.q-date__navigation > div:last-child {\n  width: 8%;\n  min-width: 24px;\n  justify-content: flex-start;\n}\n.q-date__calendar-weekdays {\n  height: 12.5%;\n}\n.q-date__calendar-weekdays > div {\n  opacity: 0.38;\n  font-size: 12px;\n}\n.q-date__calendar-item {\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  vertical-align: middle;\n  width: 14.285% !important;\n  height: 12.5% !important;\n  position: relative;\n  padding: 1px;\n}\n.q-date__calendar-item:after {\n  content: "";\n  position: absolute;\n  pointer-events: none;\n  top: 1px;\n  right: 0;\n  bottom: 1px;\n  left: 0;\n  border-style: dashed;\n  border-color: transparent;\n  border-width: 1px;\n}\n.q-date__calendar-item > div, .q-date__calendar-item button {\n  width: 30px;\n  height: 30px;\n  border-radius: 50%;\n}\n.q-date__calendar-item > div {\n  line-height: 30px;\n  text-align: center;\n}\n.q-date__calendar-item > button {\n  line-height: 22px;\n}\n.q-date__calendar-item--out {\n  opacity: 0.18;\n}\n.q-date__calendar-item--fill {\n  visibility: hidden;\n}\n.q-date__range:before, .q-date__range-from:before, .q-date__range-to:before {\n  content: "";\n  background-color: currentColor;\n  position: absolute;\n  top: 1px;\n  bottom: 1px;\n  left: 0;\n  right: 0;\n  opacity: 0.3;\n}\n.q-date__range:nth-child(7n-6):before, .q-date__range-from:nth-child(7n-6):before, .q-date__range-to:nth-child(7n-6):before {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.q-date__range:nth-child(7n):before, .q-date__range-from:nth-child(7n):before, .q-date__range-to:nth-child(7n):before {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.q-date__range-from:before {\n  left: 50%;\n}\n.q-date__range-to:before {\n  right: 50%;\n}\n.q-date__edit-range:after {\n  border-color: currentColor transparent;\n}\n.q-date__edit-range:nth-child(7n-6):after {\n  border-top-left-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.q-date__edit-range:nth-child(7n):after {\n  border-top-right-radius: 0;\n  border-bottom-right-radius: 0;\n}\n.q-date__edit-range-from:after, .q-date__edit-range-from-to:after {\n  left: 4px;\n  border-left-color: currentColor;\n  border-top-color: currentColor;\n  border-bottom-color: currentColor;\n  border-top-left-radius: 28px;\n  border-bottom-left-radius: 28px;\n}\n.q-date__edit-range-to:after, .q-date__edit-range-from-to:after {\n  right: 4px;\n  border-right-color: currentColor;\n  border-top-color: currentColor;\n  border-bottom-color: currentColor;\n  border-top-right-radius: 28px;\n  border-bottom-right-radius: 28px;\n}\n.q-date__calendar-days-container {\n  height: 75%;\n  min-height: 192px;\n}\n.q-date__calendar-days > div {\n  height: 16.66% !important;\n}\n.q-date__event {\n  position: absolute;\n  bottom: 2px;\n  left: 50%;\n  height: 5px;\n  width: 8px;\n  border-radius: 5px;\n  background-color: var(--q-secondary);\n  transform: translate3d(-50%, 0, 0);\n}\n.q-date__today {\n  box-shadow: 0 0 1px 0 currentColor;\n}\n.q-date__years-content {\n  padding: 0 8px;\n}\n.q-date__years-item, .q-date__months-item {\n  flex: 0 0 33.3333%;\n}\n.q-date.disabled .q-date__header, .q-date.disabled .q-date__content, .q-date--readonly .q-date__header, .q-date--readonly .q-date__content {\n  pointer-events: none;\n}\n.q-date--readonly .q-date__navigation {\n  display: none;\n}\n.q-date--portrait {\n  flex-direction: column;\n}\n.q-date--portrait-standard .q-date__content {\n  height: calc(100% - 86px);\n}\n.q-date--portrait-standard .q-date__header {\n  border-top-right-radius: inherit;\n  height: 86px;\n}\n.q-date--portrait-standard .q-date__header-title {\n  align-items: center;\n  height: 30px;\n}\n.q-date--portrait-minimal .q-date__content {\n  height: 100%;\n}\n.q-date--landscape {\n  flex-direction: row;\n  align-items: stretch;\n  min-width: 420px;\n}\n.q-date--landscape > div {\n  display: flex;\n  flex-direction: column;\n}\n.q-date--landscape .q-date__content {\n  height: 100%;\n}\n.q-date--landscape-standard {\n  min-width: 420px;\n}\n.q-date--landscape-standard .q-date__header {\n  border-bottom-left-radius: inherit;\n  min-width: 110px;\n  width: 110px;\n}\n.q-date--landscape-standard .q-date__header-title {\n  flex-direction: column;\n}\n.q-date--landscape-standard .q-date__header-today {\n  margin-top: 12px;\n  margin-left: -8px;\n}\n.q-date--landscape-minimal {\n  width: 310px;\n}\n.q-date--dark {\n  border-color: rgba(255, 255, 255, 0.28);\n}\n.q-dialog__title {\n  font-size: 1.25rem;\n  font-weight: 500;\n  line-height: 2rem;\n  letter-spacing: 0.0125em;\n}\n.q-dialog__progress {\n  font-size: 4rem;\n}\n.q-dialog__inner {\n  outline: 0;\n}\n.q-dialog__inner > div {\n  pointer-events: all;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  will-change: scroll-position;\n  border-radius: 4px;\n  box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px rgba(0, 0, 0, 0.14), 0 1px 10px rgba(0, 0, 0, 0.12);\n}\n.q-dialog__inner--square > div {\n  border-radius: 0 !important;\n}\n.q-dialog__inner > .q-card > .q-card__actions .q-btn--rectangle {\n  min-width: 64px;\n}\n.q-dialog__inner--minimized {\n  padding: 24px;\n}\n.q-dialog__inner--minimized > div {\n  max-height: calc(100vh - 48px);\n}\n.q-dialog__inner--maximized > div {\n  height: 100%;\n  width: 100%;\n  max-height: 100vh;\n  max-width: 100vw;\n  border-radius: 0 !important;\n  top: 0 !important;\n  left: 0 !important;\n}\n.q-dialog__inner--top, .q-dialog__inner--bottom {\n  padding-top: 0 !important;\n  padding-bottom: 0 !important;\n}\n.q-dialog__inner--right, .q-dialog__inner--left {\n  padding-right: 0 !important;\n  padding-left: 0 !important;\n}\n.q-dialog__inner--left:not(.q-dialog__inner--animating) > div, .q-dialog__inner--top:not(.q-dialog__inner--animating) > div {\n  border-top-left-radius: 0;\n}\n.q-dialog__inner--right:not(.q-dialog__inner--animating) > div, .q-dialog__inner--top:not(.q-dialog__inner--animating) > div {\n  border-top-right-radius: 0;\n}\n.q-dialog__inner--left:not(.q-dialog__inner--animating) > div, .q-dialog__inner--bottom:not(.q-dialog__inner--animating) > div {\n  border-bottom-left-radius: 0;\n}\n.q-dialog__inner--right:not(.q-dialog__inner--animating) > div, .q-dialog__inner--bottom:not(.q-dialog__inner--animating) > div {\n  border-bottom-right-radius: 0;\n}\n.q-dialog__inner--fullwidth > div {\n  width: 100% !important;\n  max-width: 100% !important;\n}\n.q-dialog__inner--fullheight > div {\n  height: 100% !important;\n  max-height: 100% !important;\n}\n.q-dialog__backdrop {\n  z-index: -1;\n  pointer-events: all;\n  outline: 0;\n  background: rgba(0, 0, 0, 0.4);\n}\nbody.platform-ios .q-dialog__inner--minimized > div, body.platform-android:not(.native-mobile) .q-dialog__inner--minimized > div {\n  max-height: calc(100vh - 108px);\n}\nbody.q-ios-padding .q-dialog__inner {\n  padding-top: 20px !important;\n  padding-top: env(safe-area-inset-top) !important;\n  padding-bottom: env(safe-area-inset-bottom) !important;\n}\nbody.q-ios-padding .q-dialog__inner > div {\n  max-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom)) !important;\n}\n@media (max-width: 599.98px) {\n  .q-dialog__inner--top, .q-dialog__inner--bottom {\n    padding-left: 0;\n    padding-right: 0;\n  }\n  .q-dialog__inner--top > div, .q-dialog__inner--bottom > div {\n    width: 100% !important;\n  }\n}\n@media (min-width: 600px) {\n  .q-dialog__inner--minimized > div {\n    max-width: 560px;\n  }\n}\n.q-body--dialog {\n  overflow: hidden;\n}\n.q-bottom-sheet {\n  padding-bottom: 8px;\n}\n.q-bottom-sheet__avatar {\n  border-radius: 50%;\n}\n.q-bottom-sheet--list {\n  width: 400px;\n}\n.q-bottom-sheet--list .q-icon, .q-bottom-sheet--list img {\n  font-size: 24px;\n  width: 24px;\n  height: 24px;\n}\n.q-bottom-sheet--grid {\n  width: 700px;\n}\n.q-bottom-sheet--grid .q-bottom-sheet__item {\n  padding: 8px;\n  text-align: center;\n  min-width: 100px;\n}\n.q-bottom-sheet--grid .q-icon, .q-bottom-sheet--grid img, .q-bottom-sheet--grid .q-bottom-sheet__empty-icon {\n  font-size: 48px;\n  width: 48px;\n  height: 48px;\n  margin-bottom: 8px;\n}\n.q-bottom-sheet--grid .q-separator {\n  margin: 12px 0;\n}\n.q-bottom-sheet__item {\n  flex: 0 0 33.3333%;\n}\n@media (min-width: 600px) {\n  .q-bottom-sheet__item {\n    flex: 0 0 25%;\n  }\n}\n.q-dialog-plugin {\n  width: 400px;\n}\n.q-dialog-plugin__form {\n  max-height: 50vh;\n}\n.q-dialog-plugin .q-card__section + .q-card__section {\n  padding-top: 0;\n}\n.q-dialog-plugin--progress {\n  text-align: center;\n}\n.q-editor {\n  border: 1px solid rgba(0, 0, 0, 0.12);\n  border-radius: 4px;\n  background-color: #fff;\n}\n.q-editor.disabled {\n  border-style: dashed;\n}\n.q-editor > div:first-child, .q-editor__toolbars-container, .q-editor__toolbars-container > div:first-child {\n  border-top-left-radius: inherit;\n  border-top-right-radius: inherit;\n}\n.q-editor__content {\n  outline: 0;\n  padding: 10px;\n  min-height: 10em;\n  border-bottom-left-radius: inherit;\n  border-bottom-right-radius: inherit;\n  overflow: auto;\n  max-width: 100%;\n}\n.q-editor__content pre {\n  white-space: pre-wrap;\n}\n.q-editor__content hr {\n  border: 0;\n  outline: 0;\n  margin: 1px;\n  height: 1px;\n  background: rgba(0, 0, 0, 0.12);\n}\n.q-editor__content:empty:not(:focus):before {\n  content: attr(placeholder);\n  opacity: 0.7;\n}\n.q-editor__toolbar {\n  border-bottom: 1px solid rgba(0, 0, 0, 0.12);\n  min-height: 32px;\n}\n.q-editor__toolbars-container {\n  max-width: 100%;\n}\n.q-editor .q-btn {\n  margin: 4px;\n}\n.q-editor__toolbar-group {\n  position: relative;\n  margin: 0 4px;\n}\n.q-editor__toolbar-group + .q-editor__toolbar-group:before {\n  content: "";\n  position: absolute;\n  left: -4px;\n  top: 4px;\n  bottom: 4px;\n  width: 1px;\n  background: rgba(0, 0, 0, 0.12);\n}\n.q-editor__link-input {\n  color: inherit;\n  text-decoration: none;\n  text-transform: none;\n  border: none;\n  border-radius: 0;\n  background: none;\n  outline: 0;\n}\n.q-editor--flat, .q-editor--flat .q-editor__toolbar {\n  border: 0;\n}\n.q-editor--dense .q-editor__toolbar-group {\n  display: flex;\n  align-items: center;\n  flex-wrap: nowrap;\n}\n.q-editor--dark {\n  border-color: rgba(255, 255, 255, 0.28);\n}\n.q-editor--dark .q-editor__content hr {\n  background: rgba(255, 255, 255, 0.28);\n}\n.q-editor--dark .q-editor__toolbar {\n  border-color: rgba(255, 255, 255, 0.28);\n}\n.q-editor--dark .q-editor__toolbar-group + .q-editor__toolbar-group:before {\n  background: rgba(255, 255, 255, 0.28);\n}\n.q-expansion-item__border {\n  opacity: 0;\n}\n.q-expansion-item__toggle-icon {\n  position: relative;\n  transition: transform 0.3s;\n}\n.q-expansion-item__toggle-icon--rotated {\n  transform: rotate(180deg);\n}\n.q-expansion-item__toggle-focus {\n  width: 1em !important;\n  height: 1em !important;\n  position: relative !important;\n}\n.q-expansion-item__toggle-focus + .q-expansion-item__toggle-icon {\n  margin-top: -1em;\n}\n.q-expansion-item--standard.q-expansion-item--expanded > div > .q-expansion-item__border {\n  opacity: 1;\n}\n.q-expansion-item--popup {\n  transition: padding 0.5s;\n}\n.q-expansion-item--popup > .q-expansion-item__container {\n  border: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-expansion-item--popup > .q-expansion-item__container > .q-separator {\n  display: none;\n}\n.q-expansion-item--popup.q-expansion-item--collapsed {\n  padding: 0 15px;\n}\n.q-expansion-item--popup.q-expansion-item--expanded {\n  padding: 15px 0;\n}\n.q-expansion-item--popup.q-expansion-item--expanded + .q-expansion-item--popup.q-expansion-item--expanded {\n  padding-top: 0;\n}\n.q-expansion-item--popup.q-expansion-item--collapsed:not(:first-child) > .q-expansion-item__container {\n  border-top-width: 0;\n}\n.q-expansion-item--popup.q-expansion-item--expanded + .q-expansion-item--popup.q-expansion-item--collapsed > .q-expansion-item__container {\n  border-top-width: 1px;\n}\n.q-expansion-item__content > .q-card {\n  box-shadow: none;\n  border-radius: 0;\n}\n.q-expansion-item:first-child > div > .q-expansion-item__border--top {\n  opacity: 0;\n}\n.q-expansion-item:last-child > div > .q-expansion-item__border--bottom {\n  opacity: 0;\n}\n.q-expansion-item--expanded + .q-expansion-item--expanded > div > .q-expansion-item__border--top {\n  opacity: 0;\n}\n.q-expansion-item--expanded .q-textarea--autogrow textarea {\n  animation: q-expansion-done 0s;\n}\n@keyframes q-expansion-done {\n  0% {\n    --q-exp-done: 1;\n  }\n}\n.z-fab {\n  z-index: 990;\n}\n.q-fab {\n  position: relative;\n  vertical-align: middle;\n}\n.q-fab > .q-btn {\n  width: 100%;\n}\n.q-fab--form-rounded {\n  border-radius: 28px;\n}\n.q-fab--form-square {\n  border-radius: 4px;\n}\n.q-fab__icon, .q-fab__active-icon {\n  transition: opacity 0.4s, transform 0.4s;\n}\n.q-fab__icon {\n  opacity: 1;\n  transform: rotate(0deg);\n}\n.q-fab__active-icon {\n  opacity: 0;\n  transform: rotate(-180deg);\n}\n.q-fab__label--external {\n  position: absolute;\n  padding: 0 8px;\n  transition: opacity 0.18s cubic-bezier(0.65, 0.815, 0.735, 0.395);\n}\n.q-fab__label--external-hidden {\n  opacity: 0;\n  pointer-events: none;\n}\n.q-fab__label--external-left {\n  top: 50%;\n  left: -12px;\n  transform: translate(-100%, -50%);\n}\n.q-fab__label--external-right {\n  top: 50%;\n  right: -12px;\n  transform: translate(100%, -50%);\n}\n.q-fab__label--external-bottom {\n  bottom: -12px;\n  left: 50%;\n  transform: translate(-50%, 100%);\n}\n.q-fab__label--external-top {\n  top: -12px;\n  left: 50%;\n  transform: translate(-50%, -100%);\n}\n.q-fab__label--internal {\n  padding: 0;\n  transition: font-size 0.12s cubic-bezier(0.65, 0.815, 0.735, 0.395), max-height 0.12s cubic-bezier(0.65, 0.815, 0.735, 0.395), opacity 0.07s cubic-bezier(0.65, 0.815, 0.735, 0.395);\n  max-height: 30px;\n}\n.q-fab__label--internal-hidden {\n  font-size: 0;\n  opacity: 0;\n}\n.q-fab__label--internal-top {\n  padding-bottom: 0.12em;\n}\n.q-fab__label--internal-bottom {\n  padding-top: 0.12em;\n}\n.q-fab__label--internal-top.q-fab__label--internal-hidden, .q-fab__label--internal-bottom.q-fab__label--internal-hidden {\n  max-height: 0;\n}\n.q-fab__label--internal-left {\n  padding-left: 0.285em;\n  padding-right: 0.571em;\n}\n.q-fab__label--internal-right {\n  padding-right: 0.285em;\n  padding-left: 0.571em;\n}\n.q-fab__icon-holder {\n  min-width: 24px;\n  min-height: 24px;\n  position: relative;\n}\n.q-fab__icon-holder--opened .q-fab__icon {\n  transform: rotate(180deg);\n  opacity: 0;\n}\n.q-fab__icon-holder--opened .q-fab__active-icon {\n  transform: rotate(0deg);\n  opacity: 1;\n}\n.q-fab__actions {\n  position: absolute;\n  opacity: 0;\n  transition: transform 0.18s ease-in, opacity 0.18s ease-in;\n  pointer-events: none;\n  align-items: center;\n  justify-content: center;\n  align-self: center;\n  padding: 3px;\n}\n.q-fab__actions .q-btn {\n  margin: 5px;\n}\n.q-fab__actions--right {\n  transform-origin: 0 50%;\n  transform: scale(0.4) translateX(-62px);\n  height: 56px;\n  left: 100%;\n  margin-left: 9px;\n}\n.q-fab__actions--left {\n  transform-origin: 100% 50%;\n  transform: scale(0.4) translateX(62px);\n  height: 56px;\n  right: 100%;\n  margin-right: 9px;\n  flex-direction: row-reverse;\n}\n.q-fab__actions--up {\n  transform-origin: 50% 100%;\n  transform: scale(0.4) translateY(62px);\n  width: 56px;\n  bottom: 100%;\n  margin-bottom: 9px;\n  flex-direction: column-reverse;\n}\n.q-fab__actions--down {\n  transform-origin: 50% 0;\n  transform: scale(0.4) translateY(-62px);\n  width: 56px;\n  top: 100%;\n  margin-top: 9px;\n  flex-direction: column;\n}\n.q-fab__actions--up, .q-fab__actions--down {\n  left: 50%;\n  margin-left: -28px;\n}\n.q-fab__actions--opened {\n  opacity: 1;\n  transform: scale(1) translate(0, 0);\n  pointer-events: all;\n}\n.q-fab--align-left > .q-fab__actions--up, .q-fab--align-left > .q-fab__actions--down {\n  align-items: flex-start;\n  left: 28px;\n}\n.q-fab--align-right > .q-fab__actions--up, .q-fab--align-right > .q-fab__actions--down {\n  align-items: flex-end;\n  left: auto;\n  right: 0;\n}\n.q-field {\n  font-size: 14px;\n}\n.q-field ::-ms-clear,\n.q-field ::-ms-reveal {\n  display: none;\n}\n.q-field--with-bottom {\n  padding-bottom: 20px;\n}\n.q-field__marginal {\n  height: 56px;\n  color: rgba(0, 0, 0, 0.54);\n  font-size: 24px;\n}\n.q-field__marginal > * + * {\n  margin-left: 2px;\n}\n.q-field__marginal .q-avatar {\n  font-size: 32px;\n}\n.q-field__before, .q-field__prepend {\n  padding-right: 12px;\n}\n.q-field__after, .q-field__append {\n  padding-left: 12px;\n}\n.q-field__after:empty, .q-field__append:empty {\n  display: none;\n}\n.q-field__append + .q-field__append {\n  padding-left: 2px;\n}\n.q-field__inner {\n  text-align: left;\n}\n.q-field__bottom {\n  font-size: 12px;\n  min-height: 20px;\n  line-height: 1;\n  color: rgba(0, 0, 0, 0.54);\n  padding: 8px 12px 0;\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n}\n.q-field__bottom--animated {\n  transform: translateY(100%);\n  position: absolute;\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n.q-field__messages {\n  line-height: 1;\n}\n.q-field__messages > div {\n  word-break: break-word;\n  word-wrap: break-word;\n  overflow-wrap: break-word;\n}\n.q-field__messages > div + div {\n  margin-top: 4px;\n}\n.q-field__counter {\n  padding-left: 8px;\n  line-height: 1;\n}\n.q-field--item-aligned {\n  padding: 8px 16px;\n}\n.q-field--item-aligned .q-field__before {\n  min-width: 56px;\n}\n.q-field__control-container {\n  height: inherit;\n}\n.q-field__control {\n  color: var(--q-primary);\n  height: 56px;\n  max-width: 100%;\n  outline: none;\n}\n.q-field__control:before, .q-field__control:after {\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n}\n.q-field__control:before {\n  border-radius: inherit;\n}\n.q-field__shadow {\n  top: 8px;\n  opacity: 0;\n  overflow: hidden;\n  white-space: pre-wrap;\n  transition: opacity 0.36s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.q-field__shadow + .q-field__native::placeholder {\n  transition: opacity 0.36s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.q-field__shadow + .q-field__native:focus::placeholder {\n  opacity: 0;\n}\n.q-field__native, .q-field__prefix, .q-field__suffix, .q-field__input {\n  font-weight: 400;\n  line-height: 28px;\n  letter-spacing: 0.00937em;\n  text-decoration: inherit;\n  text-transform: inherit;\n  border: none;\n  border-radius: 0;\n  background: none;\n  color: rgba(0, 0, 0, 0.87);\n  outline: 0;\n  padding: 6px 0;\n}\n.q-field__native, .q-field__input {\n  width: 100%;\n  min-width: 0;\n  outline: 0 !important;\n  -webkit-user-select: auto;\n          user-select: auto;\n}\n.q-field__native:-webkit-autofill, .q-field__input:-webkit-autofill {\n  -webkit-animation-name: q-autofill;\n  -webkit-animation-fill-mode: both;\n}\n.q-field__native:-webkit-autofill + .q-field__label, .q-field__input:-webkit-autofill + .q-field__label {\n  transform: translateY(-40%) scale(0.75);\n}\n.q-field__native[type=number]:invalid + .q-field__label, .q-field__input[type=number]:invalid + .q-field__label {\n  transform: translateY(-40%) scale(0.75);\n}\n.q-field__native:invalid, .q-field__input:invalid {\n  box-shadow: none;\n}\n.q-field__native[type=file] {\n  line-height: 1em;\n}\n.q-field__input {\n  padding: 0;\n  height: 0;\n  min-height: 24px;\n  line-height: 24px;\n}\n.q-field__prefix, .q-field__suffix {\n  transition: opacity 0.36s cubic-bezier(0.4, 0, 0.2, 1);\n  white-space: nowrap;\n}\n.q-field__prefix {\n  padding-right: 4px;\n}\n.q-field__suffix {\n  padding-left: 4px;\n}\n.q-field--readonly .q-placeholder, .q-field--disabled .q-placeholder {\n  opacity: 1 !important;\n}\n.q-field--readonly.q-field--labeled .q-field__native, .q-field--readonly.q-field--labeled .q-field__input {\n  cursor: default;\n}\n.q-field--readonly.q-field--float .q-field__native, .q-field--readonly.q-field--float .q-field__input {\n  cursor: text;\n}\n.q-field--disabled .q-field__inner {\n  cursor: not-allowed;\n}\n.q-field--disabled .q-field__control {\n  pointer-events: none;\n}\n.q-field--disabled .q-field__control > div {\n  opacity: 0.6 !important;\n}\n.q-field--disabled .q-field__control > div, .q-field--disabled .q-field__control > div * {\n  outline: 0 !important;\n}\n.q-field__label {\n  left: 0;\n  top: 18px;\n  max-width: 100%;\n  color: rgba(0, 0, 0, 0.6);\n  font-size: 16px;\n  line-height: 20px;\n  font-weight: 400;\n  letter-spacing: 0.00937em;\n  text-decoration: inherit;\n  text-transform: inherit;\n  transform-origin: left top;\n  transition: transform 0.36s cubic-bezier(0.4, 0, 0.2, 1), max-width 0.324s cubic-bezier(0.4, 0, 0.2, 1);\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n}\n.q-field--float .q-field__label {\n  max-width: 133%;\n  transform: translateY(-40%) scale(0.75);\n  transition: transform 0.36s cubic-bezier(0.4, 0, 0.2, 1), max-width 0.396s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.q-field--highlighted .q-field__label {\n  color: currentColor;\n}\n.q-field--highlighted .q-field__shadow {\n  opacity: 0.5;\n}\n.q-field--filled .q-field__control {\n  padding: 0 12px;\n  background: rgba(0, 0, 0, 0.05);\n  border-radius: 4px 4px 0 0;\n}\n.q-field--filled .q-field__control:before {\n  background: rgba(0, 0, 0, 0.05);\n  border-bottom: 1px solid rgba(0, 0, 0, 0.42);\n  opacity: 0;\n  transition: opacity 0.36s cubic-bezier(0.4, 0, 0.2, 1), background 0.36s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.q-field--filled .q-field__control:hover:before {\n  opacity: 1;\n}\n.q-field--filled .q-field__control:after {\n  height: 2px;\n  top: auto;\n  transform-origin: center bottom;\n  transform: scale3d(0, 1, 1);\n  background: currentColor;\n  transition: transform 0.36s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.q-field--filled.q-field--rounded .q-field__control {\n  border-radius: 28px 28px 0 0;\n}\n.q-field--filled.q-field--highlighted .q-field__control:before {\n  opacity: 1;\n  background: rgba(0, 0, 0, 0.12);\n}\n.q-field--filled.q-field--highlighted .q-field__control:after {\n  transform: scale3d(1, 1, 1);\n}\n.q-field--filled.q-field--dark .q-field__control, .q-field--filled.q-field--dark .q-field__control:before {\n  background: rgba(255, 255, 255, 0.07);\n}\n.q-field--filled.q-field--dark.q-field--highlighted .q-field__control:before {\n  background: rgba(255, 255, 255, 0.1);\n}\n.q-field--filled.q-field--readonly .q-field__control:before {\n  opacity: 1;\n  background: transparent;\n  border-bottom-style: dashed;\n}\n.q-field--outlined .q-field__control {\n  border-radius: 4px;\n  padding: 0 12px;\n}\n.q-field--outlined .q-field__control:before {\n  border: 1px solid rgba(0, 0, 0, 0.24);\n  transition: border-color 0.36s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.q-field--outlined .q-field__control:hover:before {\n  border-color: #000;\n}\n.q-field--outlined .q-field__control:after {\n  height: inherit;\n  border-radius: inherit;\n  border: 2px solid transparent;\n  transition: border-color 0.36s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.q-field--outlined .q-field__native:-webkit-autofill,\n.q-field--outlined .q-field__input:-webkit-autofill {\n  margin-top: 1px;\n  margin-bottom: 1px;\n}\n.q-field--outlined.q-field--rounded .q-field__control {\n  border-radius: 28px;\n}\n.q-field--outlined.q-field--highlighted .q-field__control:hover:before {\n  border-color: transparent;\n}\n.q-field--outlined.q-field--highlighted .q-field__control:after {\n  border-color: currentColor;\n  border-width: 2px;\n  transform: scale3d(1, 1, 1);\n}\n.q-field--outlined.q-field--readonly .q-field__control:before {\n  border-style: dashed;\n}\n.q-field--standard .q-field__control:before {\n  border-bottom: 1px solid rgba(0, 0, 0, 0.24);\n  transition: border-color 0.36s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.q-field--standard .q-field__control:hover:before {\n  border-color: #000;\n}\n.q-field--standard .q-field__control:after {\n  height: 2px;\n  top: auto;\n  border-bottom-left-radius: inherit;\n  border-bottom-right-radius: inherit;\n  transform-origin: center bottom;\n  transform: scale3d(0, 1, 1);\n  background: currentColor;\n  transition: transform 0.36s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.q-field--standard.q-field--highlighted .q-field__control:after {\n  transform: scale3d(1, 1, 1);\n}\n.q-field--standard.q-field--readonly .q-field__control:before {\n  border-bottom-style: dashed;\n}\n.q-field--dark .q-field__control:before {\n  border-color: rgba(255, 255, 255, 0.6);\n}\n.q-field--dark .q-field__control:hover:before {\n  border-color: #fff;\n}\n.q-field--dark .q-field__native, .q-field--dark .q-field__prefix, .q-field--dark .q-field__suffix, .q-field--dark .q-field__input {\n  color: #fff;\n}\n.q-field--dark:not(.q-field--highlighted) .q-field__label, .q-field--dark .q-field__marginal, .q-field--dark .q-field__bottom {\n  color: rgba(255, 255, 255, 0.7);\n}\n.q-field--standout .q-field__control {\n  padding: 0 12px;\n  background: rgba(0, 0, 0, 0.05);\n  border-radius: 4px;\n  transition: box-shadow 0.36s cubic-bezier(0.4, 0, 0.2, 1), background-color 0.36s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.q-field--standout .q-field__control:before {\n  background: rgba(0, 0, 0, 0.07);\n  opacity: 0;\n  transition: opacity 0.36s cubic-bezier(0.4, 0, 0.2, 1), background 0.36s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.q-field--standout .q-field__control:hover:before {\n  opacity: 1;\n}\n.q-field--standout.q-field--rounded .q-field__control {\n  border-radius: 28px;\n}\n.q-field--standout.q-field--highlighted .q-field__control {\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n  background: #000;\n}\n.q-field--standout.q-field--highlighted .q-field__native, .q-field--standout.q-field--highlighted .q-field__prefix, .q-field--standout.q-field--highlighted .q-field__suffix, .q-field--standout.q-field--highlighted .q-field__prepend, .q-field--standout.q-field--highlighted .q-field__append, .q-field--standout.q-field--highlighted .q-field__input {\n  color: #fff;\n}\n.q-field--standout.q-field--readonly .q-field__control:before {\n  opacity: 1;\n  background: transparent;\n  border: 1px dashed rgba(0, 0, 0, 0.24);\n}\n.q-field--standout.q-field--dark .q-field__control {\n  background: rgba(255, 255, 255, 0.07);\n}\n.q-field--standout.q-field--dark .q-field__control:before {\n  background: rgba(255, 255, 255, 0.07);\n}\n.q-field--standout.q-field--dark.q-field--highlighted .q-field__control {\n  background: #fff;\n}\n.q-field--standout.q-field--dark.q-field--highlighted .q-field__native, .q-field--standout.q-field--dark.q-field--highlighted .q-field__prefix, .q-field--standout.q-field--dark.q-field--highlighted .q-field__suffix, .q-field--standout.q-field--dark.q-field--highlighted .q-field__prepend, .q-field--standout.q-field--dark.q-field--highlighted .q-field__append, .q-field--standout.q-field--dark.q-field--highlighted .q-field__input {\n  color: #000;\n}\n.q-field--standout.q-field--dark.q-field--readonly .q-field__control:before {\n  border-color: rgba(255, 255, 255, 0.24);\n}\n.q-field--labeled .q-field__native, .q-field--labeled .q-field__prefix, .q-field--labeled .q-field__suffix {\n  line-height: 24px;\n  padding-top: 24px;\n  padding-bottom: 8px;\n}\n.q-field--labeled .q-field__shadow {\n  top: 0;\n}\n.q-field--labeled:not(.q-field--float) .q-field__prefix, .q-field--labeled:not(.q-field--float) .q-field__suffix {\n  opacity: 0;\n}\n.q-field--labeled:not(.q-field--float) .q-field__native::placeholder, .q-field--labeled:not(.q-field--float) .q-field__input::placeholder {\n  color: transparent;\n}\n.q-field--labeled.q-field--dense .q-field__native, .q-field--labeled.q-field--dense .q-field__prefix, .q-field--labeled.q-field--dense .q-field__suffix {\n  padding-top: 14px;\n  padding-bottom: 2px;\n}\n.q-field--dense .q-field__shadow {\n  top: 0;\n}\n.q-field--dense .q-field__control, .q-field--dense .q-field__marginal {\n  height: 40px;\n}\n.q-field--dense .q-field__bottom {\n  font-size: 11px;\n}\n.q-field--dense .q-field__label {\n  font-size: 14px;\n  top: 10px;\n}\n.q-field--dense .q-field__before, .q-field--dense .q-field__prepend {\n  padding-right: 6px;\n}\n.q-field--dense .q-field__after, .q-field--dense .q-field__append {\n  padding-left: 6px;\n}\n.q-field--dense .q-field__append + .q-field__append {\n  padding-left: 2px;\n}\n.q-field--dense .q-field__marginal .q-avatar {\n  font-size: 24px;\n}\n.q-field--dense.q-field--float .q-field__label {\n  transform: translateY(-30%) scale(0.75);\n}\n.q-field--dense .q-field__native:-webkit-autofill + .q-field__label, .q-field--dense .q-field__input:-webkit-autofill + .q-field__label {\n  transform: translateY(-30%) scale(0.75);\n}\n.q-field--dense .q-field__native[type=number]:invalid + .q-field__label, .q-field--dense .q-field__input[type=number]:invalid + .q-field__label {\n  transform: translateY(-30%) scale(0.75);\n}\n.q-field--borderless .q-field__bottom, .q-field--borderless.q-field--dense .q-field__control, .q-field--standard .q-field__bottom, .q-field--standard.q-field--dense .q-field__control {\n  padding-left: 0;\n  padding-right: 0;\n}\n.q-field--error .q-field__label {\n  animation: q-field-label 0.36s;\n}\n.q-field--error .q-field__bottom {\n  color: var(--q-negative);\n}\n.q-field__focusable-action {\n  opacity: 0.6;\n  cursor: pointer;\n  outline: 0 !important;\n  border: 0;\n  color: inherit;\n  background: transparent;\n  padding: 0;\n}\n.q-field__focusable-action:hover, .q-field__focusable-action:focus {\n  opacity: 1;\n}\n.q-field--auto-height .q-field__control {\n  height: auto;\n}\n.q-field--auto-height .q-field__control, .q-field--auto-height .q-field__native {\n  min-height: 56px;\n}\n.q-field--auto-height .q-field__native {\n  align-items: center;\n}\n.q-field--auto-height .q-field__control-container {\n  padding-top: 0;\n}\n.q-field--auto-height .q-field__native, .q-field--auto-height .q-field__prefix, .q-field--auto-height .q-field__suffix {\n  line-height: 18px;\n}\n.q-field--auto-height.q-field--labeled .q-field__control-container {\n  padding-top: 24px;\n}\n.q-field--auto-height.q-field--labeled .q-field__shadow {\n  top: 24px;\n}\n.q-field--auto-height.q-field--labeled .q-field__native, .q-field--auto-height.q-field--labeled .q-field__prefix, .q-field--auto-height.q-field--labeled .q-field__suffix {\n  padding-top: 0;\n}\n.q-field--auto-height.q-field--labeled .q-field__native {\n  min-height: 24px;\n}\n.q-field--auto-height.q-field--dense .q-field__control, .q-field--auto-height.q-field--dense .q-field__native {\n  min-height: 40px;\n}\n.q-field--auto-height.q-field--dense.q-field--labeled .q-field__control-container {\n  padding-top: 14px;\n}\n.q-field--auto-height.q-field--dense.q-field--labeled .q-field__shadow {\n  top: 14px;\n}\n.q-field--auto-height.q-field--dense.q-field--labeled .q-field__native {\n  min-height: 24px;\n}\n.q-field--square .q-field__control {\n  border-radius: 0 !important;\n}\n.q-transition--field-message-enter-active, .q-transition--field-message-leave-active {\n  transition: transform 0.6s cubic-bezier(0.86, 0, 0.07, 1), opacity 0.6s cubic-bezier(0.86, 0, 0.07, 1);\n}\n.q-transition--field-message-enter-from, .q-transition--field-message-leave-to {\n  opacity: 0;\n  transform: translateY(-10px);\n}\n.q-transition--field-message-leave-from, .q-transition--field-message-leave-active {\n  position: absolute;\n}\n@keyframes q-field-label {\n  40% {\n    margin-left: 2px;\n  }\n  60%, 80% {\n    margin-left: -2px;\n  }\n  70%, 90% {\n    margin-left: 2px;\n  }\n}\n@keyframes q-autofill {\n  to {\n    background: transparent;\n    color: inherit;\n  }\n}\n.q-file .q-field__native {\n  word-break: break-all;\n  overflow: hidden;\n}\n.q-file .q-field__input {\n  opacity: 0 !important;\n}\n.q-file .q-field__input::-webkit-file-upload-button {\n  cursor: pointer;\n}\n.q-file__filler {\n  visibility: hidden;\n  width: 100%;\n  border: none;\n  padding: 0;\n}\n.q-file__dnd {\n  outline: 1px dashed currentColor;\n  outline-offset: -4px;\n}\n.q-form {\n  position: relative;\n}\n.q-img {\n  position: relative;\n  width: 100%;\n  display: inline-block;\n  vertical-align: middle;\n  overflow: hidden;\n}\n.q-img__loading .q-spinner {\n  font-size: 50px;\n}\n.q-img__container {\n  border-radius: inherit;\n  font-size: 0;\n}\n.q-img__image {\n  border-radius: inherit;\n  width: 100%;\n  height: 100%;\n  opacity: 0;\n}\n.q-img__image--with-transition {\n  transition: opacity 0.28s ease-in;\n}\n.q-img__image--loaded {\n  opacity: 1;\n}\n.q-img__content {\n  border-radius: inherit;\n  pointer-events: none;\n}\n.q-img__content > div {\n  pointer-events: all;\n  position: absolute;\n  padding: 16px;\n  color: #fff;\n  background: rgba(0, 0, 0, 0.47);\n}\n.q-img--no-menu .q-img__image,\n.q-img--no-menu .q-img__placeholder {\n  pointer-events: none;\n}\n.q-inner-loading {\n  background: rgba(255, 255, 255, 0.6);\n}\n.q-inner-loading--dark {\n  background: rgba(0, 0, 0, 0.4);\n}\n.q-inner-loading__label {\n  margin-top: 8px;\n}\n.q-textarea .q-field__control {\n  min-height: 56px;\n  height: auto;\n}\n.q-textarea .q-field__control-container {\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n.q-textarea .q-field__shadow {\n  top: 2px;\n  bottom: 2px;\n}\n.q-textarea .q-field__native, .q-textarea .q-field__prefix, .q-textarea .q-field__suffix {\n  line-height: 18px;\n}\n.q-textarea .q-field__native {\n  resize: vertical;\n  padding-top: 17px;\n  min-height: 52px;\n}\n.q-textarea.q-field--labeled .q-field__control-container {\n  padding-top: 26px;\n}\n.q-textarea.q-field--labeled .q-field__shadow {\n  top: 26px;\n}\n.q-textarea.q-field--labeled .q-field__native, .q-textarea.q-field--labeled .q-field__prefix, .q-textarea.q-field--labeled .q-field__suffix {\n  padding-top: 0;\n}\n.q-textarea.q-field--labeled .q-field__native {\n  min-height: 26px;\n  padding-top: 1px;\n}\n.q-textarea--autogrow .q-field__native {\n  resize: none;\n}\n.q-textarea.q-field--dense .q-field__control, .q-textarea.q-field--dense .q-field__native {\n  min-height: 36px;\n}\n.q-textarea.q-field--dense .q-field__native {\n  padding-top: 9px;\n}\n.q-textarea.q-field--dense.q-field--labeled .q-field__control-container {\n  padding-top: 14px;\n}\n.q-textarea.q-field--dense.q-field--labeled .q-field__shadow {\n  top: 14px;\n}\n.q-textarea.q-field--dense.q-field--labeled .q-field__native {\n  min-height: 24px;\n  padding-top: 3px;\n}\n.q-textarea.q-field--dense.q-field--labeled .q-field__prefix, .q-textarea.q-field--dense.q-field--labeled .q-field__suffix {\n  padding-top: 2px;\n}\nbody.mobile .q-textarea .q-field__native,\n.q-textarea.disabled .q-field__native {\n  resize: none;\n}\n.q-intersection {\n  position: relative;\n}\n.q-item {\n  min-height: 48px;\n  padding: 8px 16px;\n  color: inherit;\n  transition: color 0.3s, background-color 0.3s;\n}\n.q-item__section--side {\n  color: #757575;\n  align-items: flex-start;\n  padding-right: 16px;\n  width: auto;\n  min-width: 0;\n  max-width: 100%;\n}\n.q-item__section--side > .q-icon {\n  font-size: 24px;\n}\n.q-item__section--side > .q-avatar {\n  font-size: 40px;\n}\n.q-item__section--avatar {\n  color: inherit;\n  min-width: 56px;\n}\n.q-item__section--thumbnail img {\n  width: 100px;\n  height: 56px;\n}\n.q-item__section--nowrap {\n  white-space: nowrap;\n}\n.q-item > .q-item__section--thumbnail:first-child,\n.q-item > .q-focus-helper + .q-item__section--thumbnail {\n  margin-left: -16px;\n}\n.q-item > .q-item__section--thumbnail:last-of-type {\n  margin-right: -16px;\n}\n.q-item__label {\n  line-height: 1.2em !important;\n  max-width: 100%;\n}\n.q-item__label--overline {\n  color: rgba(0, 0, 0, 0.7);\n}\n.q-item__label--caption {\n  color: rgba(0, 0, 0, 0.54);\n}\n.q-item__label--header {\n  color: #757575;\n  padding: 16px;\n  font-size: 0.875rem;\n  line-height: 1.25rem;\n  letter-spacing: 0.01786em;\n}\n.q-separator--spaced + .q-item__label--header, .q-list--padding .q-item__label--header {\n  padding-top: 8px;\n}\n.q-item__label + .q-item__label {\n  margin-top: 4px;\n}\n.q-item__section--main {\n  width: auto;\n  min-width: 0;\n  max-width: 100%;\n  flex: 10000 1 0%;\n}\n.q-item__section--main + .q-item__section--main {\n  margin-left: 8px;\n}\n.q-item__section--main ~ .q-item__section--side {\n  align-items: flex-end;\n  padding-right: 0;\n  padding-left: 16px;\n}\n.q-item__section--main.q-item__section--thumbnail {\n  margin-left: 0;\n  margin-right: -16px;\n}\n.q-list--bordered {\n  border: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-list--separator > .q-item-type + .q-item-type,\n.q-list--separator > .q-virtual-scroll__content > .q-item-type + .q-item-type {\n  border-top: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-list--padding {\n  padding: 8px 0;\n}\n.q-list--dense > .q-item, .q-item--dense {\n  min-height: 32px;\n  padding: 2px 16px;\n}\n.q-list--dark.q-list--separator > .q-item-type + .q-item-type,\n.q-list--dark.q-list--separator > .q-virtual-scroll__content > .q-item-type + .q-item-type {\n  border-top-color: rgba(255, 255, 255, 0.28);\n}\n.q-list--dark, .q-item--dark {\n  color: #fff;\n  border-color: rgba(255, 255, 255, 0.28);\n}\n.q-list--dark .q-item__section--side:not(.q-item__section--avatar), .q-item--dark .q-item__section--side:not(.q-item__section--avatar) {\n  color: rgba(255, 255, 255, 0.7);\n}\n.q-list--dark .q-item__label--header, .q-item--dark .q-item__label--header {\n  color: rgba(255, 255, 255, 0.64);\n}\n.q-list--dark .q-item__label--overline, .q-list--dark .q-item__label--caption, .q-item--dark .q-item__label--overline, .q-item--dark .q-item__label--caption {\n  color: rgba(255, 255, 255, 0.8);\n}\n.q-item {\n  position: relative;\n}\n.q-item.q-router-link--active, .q-item--active {\n  color: var(--q-primary);\n}\n.q-knob {\n  font-size: 48px;\n}\n.q-knob--editable {\n  cursor: pointer;\n  outline: 0;\n}\n.q-knob--editable:before {\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  border-radius: 50%;\n  box-shadow: none;\n  transition: box-shadow 0.24s ease-in-out;\n}\n.q-knob--editable:focus:before {\n  box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px rgba(0, 0, 0, 0.14), 0 1px 10px rgba(0, 0, 0, 0.12);\n}\n.q-layout {\n  width: 100%;\n}\n.q-layout-container {\n  position: relative;\n  width: 100%;\n  height: 100%;\n}\n.q-layout-container .q-layout {\n  min-height: 100%;\n}\n.q-layout-container > div {\n  transform: translate3d(0, 0, 0);\n}\n.q-layout-container > div > div {\n  min-height: 0;\n  max-height: 100%;\n}\n.q-layout__shadow {\n  width: 100%;\n}\n.q-layout__shadow:after {\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  box-shadow: 0 0 10px 2px rgba(0, 0, 0, 0.2), 0 0px 10px rgba(0, 0, 0, 0.24);\n}\n.q-layout__section--marginal {\n  background-color: var(--q-primary);\n  color: #fff;\n}\n.q-header--hidden {\n  transform: translateY(-110%);\n}\n.q-header--bordered {\n  border-bottom: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-header .q-layout__shadow {\n  bottom: -10px;\n}\n.q-header .q-layout__shadow:after {\n  bottom: 10px;\n}\n.q-footer--hidden {\n  transform: translateY(110%);\n}\n.q-footer--bordered {\n  border-top: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-footer .q-layout__shadow {\n  top: -10px;\n}\n.q-footer .q-layout__shadow:after {\n  top: 10px;\n}\n.q-header, .q-footer {\n  z-index: 2000;\n}\n.q-drawer {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  background: #fff;\n  z-index: 1000;\n}\n.q-drawer--on-top {\n  z-index: 3000;\n}\n.q-drawer--left {\n  left: 0;\n  transform: translateX(-100%);\n}\n.q-drawer--left.q-drawer--bordered {\n  border-right: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-drawer--left .q-layout__shadow {\n  left: 10px;\n  right: -10px;\n}\n.q-drawer--left .q-layout__shadow:after {\n  right: 10px;\n}\n.q-drawer--right {\n  right: 0;\n  transform: translateX(100%);\n}\n.q-drawer--right.q-drawer--bordered {\n  border-left: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-drawer--right .q-layout__shadow {\n  left: -10px;\n}\n.q-drawer--right .q-layout__shadow:after {\n  left: 10px;\n}\n.q-drawer-container:not(.q-drawer--mini-animate) .q-drawer--mini {\n  padding: 0 !important;\n}\n.q-drawer-container:not(.q-drawer--mini-animate) .q-drawer--mini .q-item, .q-drawer-container:not(.q-drawer--mini-animate) .q-drawer--mini .q-item__section {\n  text-align: center;\n  justify-content: center;\n  padding-left: 0;\n  padding-right: 0;\n  min-width: 0;\n}\n.q-drawer-container:not(.q-drawer--mini-animate) .q-drawer--mini .q-item__label, .q-drawer-container:not(.q-drawer--mini-animate) .q-drawer--mini .q-item__section--main, .q-drawer-container:not(.q-drawer--mini-animate) .q-drawer--mini .q-item__section--side ~ .q-item__section--side {\n  display: none;\n}\n.q-drawer--mini .q-mini-drawer-hide, .q-drawer--mini .q-expansion-item__content {\n  display: none;\n}\n.q-drawer--mini-animate .q-drawer__content {\n  overflow-x: hidden !important;\n  white-space: nowrap;\n}\n.q-drawer--standard .q-mini-drawer-only {\n  display: none;\n}\n.q-drawer--mobile .q-mini-drawer-only, .q-drawer--mobile .q-mini-drawer-hide {\n  display: none;\n}\n.q-drawer__backdrop {\n  z-index: 2999 !important;\n  will-change: background-color;\n}\n.q-drawer__opener {\n  z-index: 2001;\n  height: 100%;\n  width: 15px;\n  -webkit-user-select: none;\n          user-select: none;\n}\n.q-layout, .q-header, .q-footer, .q-page {\n  position: relative;\n}\n.q-page-sticky--shrink {\n  pointer-events: none;\n}\n.q-page-sticky--shrink > div {\n  display: inline-block;\n  pointer-events: auto;\n}\nbody.q-ios-padding .q-layout--standard .q-header > .q-toolbar:nth-child(1),\nbody.q-ios-padding .q-layout--standard .q-header > .q-tabs:nth-child(1) .q-tabs-head,\nbody.q-ios-padding .q-layout--standard .q-drawer--top-padding .q-drawer__content {\n  padding-top: 20px;\n  min-height: 70px;\n  padding-top: env(safe-area-inset-top);\n  min-height: calc(env(safe-area-inset-top) + 50px);\n}\nbody.q-ios-padding .q-layout--standard .q-footer > .q-toolbar:last-child,\nbody.q-ios-padding .q-layout--standard .q-footer > .q-tabs:last-child .q-tabs-head,\nbody.q-ios-padding .q-layout--standard .q-drawer--top-padding .q-drawer__content {\n  padding-bottom: env(safe-area-inset-bottom);\n  min-height: calc(env(safe-area-inset-bottom) + 50px);\n}\n.q-body--layout-animate .q-drawer__backdrop {\n  transition: background-color 0.12s !important;\n}\n.q-body--layout-animate .q-drawer {\n  transition: transform 0.12s, width 0.12s, top 0.12s, bottom 0.12s !important;\n}\n.q-body--layout-animate .q-layout__section--marginal {\n  transition: transform 0.12s, left 0.12s, right 0.12s !important;\n}\n.q-body--layout-animate .q-page-container {\n  transition: padding-top 0.12s, padding-right 0.12s, padding-bottom 0.12s, padding-left 0.12s !important;\n}\n.q-body--layout-animate .q-page-sticky {\n  transition: transform 0.12s, left 0.12s, right 0.12s, top 0.12s, bottom 0.12s !important;\n}\nbody:not(.q-body--layout-animate) .q-layout--prevent-focus {\n  visibility: hidden;\n}\n.q-body--drawer-toggle {\n  overflow-x: hidden !important;\n}\n@media (max-width: 599.98px) {\n  .q-layout-padding {\n    padding: 8px;\n  }\n}\n@media (min-width: 600px) and (max-width: 1439.98px) {\n  .q-layout-padding {\n    padding: 16px;\n  }\n}\n@media (min-width: 1440px) {\n  .q-layout-padding {\n    padding: 24px;\n  }\n}\nbody.body--dark .q-header, body.body--dark .q-footer, body.body--dark .q-drawer {\n  border-color: rgba(255, 255, 255, 0.28);\n}\nbody.platform-ios .q-layout--containerized {\n  position: unset !important;\n}\n.q-linear-progress {\n  --q-linear-progress-speed: .3s;\n  position: relative;\n  width: 100%;\n  overflow: hidden;\n  font-size: 4px;\n  height: 1em;\n  color: var(--q-primary);\n  transform: scale3d(1, 1, 1);\n}\n.q-linear-progress__model, .q-linear-progress__track {\n  transform-origin: 0 0;\n}\n.q-linear-progress__model--with-transition, .q-linear-progress__track--with-transition {\n  transition: transform var(--q-linear-progress-speed);\n}\n.q-linear-progress--reverse .q-linear-progress__model, .q-linear-progress--reverse .q-linear-progress__track {\n  transform-origin: 0 100%;\n}\n.q-linear-progress__model--determinate {\n  background: currentColor;\n}\n.q-linear-progress__model--indeterminate, .q-linear-progress__model--query {\n  transition: none;\n}\n.q-linear-progress__model--indeterminate:before, .q-linear-progress__model--indeterminate:after, .q-linear-progress__model--query:before, .q-linear-progress__model--query:after {\n  background: currentColor;\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  transform-origin: 0 0;\n}\n.q-linear-progress__model--indeterminate:before, .q-linear-progress__model--query:before {\n  animation: q-linear-progress--indeterminate 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;\n}\n.q-linear-progress__model--indeterminate:after, .q-linear-progress__model--query:after {\n  transform: translate3d(-101%, 0, 0) scale3d(1, 1, 1);\n  animation: q-linear-progress--indeterminate-short 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) infinite;\n  animation-delay: 1.15s;\n}\n.q-linear-progress__track {\n  opacity: 0.4;\n}\n.q-linear-progress__track--light {\n  background: rgba(0, 0, 0, 0.26);\n}\n.q-linear-progress__track--dark {\n  background: rgba(255, 255, 255, 0.6);\n}\n.q-linear-progress__stripe {\n  transition: width var(--q-linear-progress-speed);\n  background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, rgba(255, 255, 255, 0) 25%, rgba(255, 255, 255, 0) 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, rgba(255, 255, 255, 0) 75%, rgba(255, 255, 255, 0)) !important;\n  background-size: 40px 40px !important;\n}\n@keyframes q-linear-progress--indeterminate {\n  0% {\n    transform: translate3d(-35%, 0, 0) scale3d(0.35, 1, 1);\n  }\n  60% {\n    transform: translate3d(100%, 0, 0) scale3d(0.9, 1, 1);\n  }\n  100% {\n    transform: translate3d(100%, 0, 0) scale3d(0.9, 1, 1);\n  }\n}\n@keyframes q-linear-progress--indeterminate-short {\n  0% {\n    transform: translate3d(-101%, 0, 0) scale3d(1, 1, 1);\n  }\n  60% {\n    transform: translate3d(107%, 0, 0) scale3d(0.01, 1, 1);\n  }\n  100% {\n    transform: translate3d(107%, 0, 0) scale3d(0.01, 1, 1);\n  }\n}\n.q-menu {\n  position: fixed !important;\n  display: inline-block;\n  max-width: 95vw;\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n  background: #fff;\n  border-radius: 4px;\n  overflow-y: auto;\n  overflow-x: hidden;\n  outline: 0;\n  max-height: 65vh;\n  z-index: 6000;\n}\n.q-menu--square {\n  border-radius: 0;\n}\n.q-option-group--inline > div {\n  display: inline-block;\n}\n.q-pagination input {\n  text-align: center;\n  -moz-appearance: textfield;\n}\n.q-pagination input::-webkit-outer-spin-button,\n.q-pagination input::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n.q-parallax {\n  position: relative;\n  width: 100%;\n  overflow: hidden;\n  border-radius: inherit;\n}\n.q-parallax__media > img, .q-parallax__media > video {\n  position: absolute;\n  left: 50% /* rtl:ignore */;\n  bottom: 0;\n  min-width: 100%;\n  min-height: 100%;\n  will-change: transform;\n  display: none;\n}\n.q-popup-edit {\n  padding: 8px 16px;\n}\n.q-popup-edit__buttons {\n  margin-top: 8px;\n}\n.q-popup-edit__buttons .q-btn + .q-btn {\n  margin-left: 8px;\n}\n.q-pull-to-refresh {\n  position: relative;\n}\n.q-pull-to-refresh__puller {\n  border-radius: 50%;\n  width: 40px;\n  height: 40px;\n  color: var(--q-primary);\n  background: #fff;\n  box-shadow: 0 0 4px 0 rgba(0, 0, 0, 0.3);\n}\n.q-pull-to-refresh__puller--animating {\n  transition: transform 0.3s, opacity 0.3s;\n}\n.q-radio {\n  vertical-align: middle;\n}\n.q-radio__native {\n  width: 1px;\n  height: 1px;\n}\n.q-radio__bg, .q-radio__icon-container {\n  -webkit-user-select: none;\n          user-select: none;\n}\n.q-radio__bg {\n  top: 25%;\n  left: 25%;\n  width: 50%;\n  height: 50%;\n  -webkit-print-color-adjust: exact;\n}\n.q-radio__bg path {\n  fill: currentColor;\n}\n.q-radio__icon {\n  color: currentColor;\n  font-size: 0.5em;\n}\n.q-radio__check {\n  transform-origin: 50% 50%;\n  transform: scale3d(0, 0, 1);\n  transition: transform 0.22s cubic-bezier(0, 0, 0.2, 1) 0ms;\n}\n.q-radio__inner {\n  font-size: 40px;\n  width: 1em;\n  min-width: 1em;\n  height: 1em;\n  outline: 0;\n  border-radius: 50%;\n  color: rgba(0, 0, 0, 0.54);\n}\n.q-radio__inner--truthy {\n  color: var(--q-primary);\n}\n.q-radio__inner--truthy .q-radio__check {\n  transform: scale3d(1, 1, 1);\n}\n.q-radio.disabled {\n  opacity: 0.75 !important;\n}\n.q-radio--dark .q-radio__inner {\n  color: rgba(255, 255, 255, 0.7);\n}\n.q-radio--dark .q-radio__inner:before {\n  opacity: 0.32 !important;\n}\n.q-radio--dark .q-radio__inner--truthy {\n  color: var(--q-primary);\n}\n.q-radio--dense .q-radio__inner {\n  width: 0.5em;\n  min-width: 0.5em;\n  height: 0.5em;\n}\n.q-radio--dense .q-radio__bg {\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n.q-radio--dense .q-radio__label {\n  padding-left: 0.5em;\n}\n.q-radio--dense.reverse .q-radio__label {\n  padding-left: 0;\n  padding-right: 0.5em;\n}\nbody.desktop .q-radio:not(.disabled) .q-radio__inner:before {\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  border-radius: 50%;\n  background: currentColor;\n  opacity: 0.12;\n  transform: scale3d(0, 0, 1);\n  transition: transform 0.22s cubic-bezier(0, 0, 0.2, 1) 0ms;\n}\nbody.desktop .q-radio:not(.disabled):focus .q-radio__inner:before, body.desktop .q-radio:not(.disabled):hover .q-radio__inner:before {\n  transform: scale3d(1, 1, 1);\n}\nbody.desktop .q-radio--dense:not(.disabled):focus .q-radio__inner:before, body.desktop .q-radio--dense:not(.disabled):hover .q-radio__inner:before {\n  transform: scale3d(1.5, 1.5, 1);\n}\n.q-rating {\n  color: #ffeb3b;\n  vertical-align: middle;\n}\n.q-rating__icon-container {\n  height: 1em;\n  outline: 0;\n}\n.q-rating__icon-container + .q-rating__icon-container {\n  margin-left: 2px;\n}\n.q-rating__icon {\n  color: currentColor;\n  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);\n  position: relative;\n  opacity: 0.4;\n  transition: transform 0.2s ease-in, opacity 0.2s ease-in;\n}\n.q-rating__icon--hovered {\n  transform: scale(1.3);\n}\n.q-rating__icon--active {\n  opacity: 1;\n}\n.q-rating__icon--exselected {\n  opacity: 0.7;\n}\n.q-rating--no-dimming .q-rating__icon {\n  opacity: 1;\n}\n.q-rating--editable .q-rating__icon-container {\n  cursor: pointer;\n}\n.q-responsive {\n  position: relative;\n  max-width: 100%;\n  max-height: 100%;\n}\n.q-responsive__filler {\n  width: inherit;\n  max-width: inherit;\n  height: inherit;\n  max-height: inherit;\n}\n.q-responsive__content {\n  border-radius: inherit;\n}\n.q-responsive__content > * {\n  width: 100% !important;\n  height: 100% !important;\n  max-height: 100% !important;\n  max-width: 100% !important;\n}\n.q-scrollarea {\n  position: relative;\n  contain: strict;\n}\n.q-scrollarea__bar, .q-scrollarea__thumb {\n  opacity: 0.2;\n  transition: opacity 0.3s;\n  will-change: opacity;\n  cursor: grab;\n}\n.q-scrollarea__bar--v, .q-scrollarea__thumb--v {\n  right: 0;\n  width: 10px;\n}\n.q-scrollarea__bar--h, .q-scrollarea__thumb--h {\n  bottom: 0;\n  height: 10px;\n}\n.q-scrollarea__bar--invisible, .q-scrollarea__thumb--invisible {\n  opacity: 0 !important;\n  pointer-events: none;\n}\n.q-scrollarea__thumb {\n  background: #000;\n  border-radius: 3px;\n}\n.q-scrollarea__thumb:hover {\n  opacity: 0.3;\n}\n.q-scrollarea__thumb:active {\n  opacity: 0.5;\n}\n.q-scrollarea__content {\n  min-height: 100%;\n  min-width: 100%;\n}\n.q-scrollarea--dark .q-scrollarea__thumb {\n  background: #fff;\n}\n.q-select--without-input .q-field__control {\n  cursor: pointer;\n}\n.q-select--with-input .q-field__control {\n  cursor: text;\n}\n.q-select .q-field__input {\n  min-width: 50px !important;\n  cursor: text;\n}\n.q-select .q-field__input--padding {\n  padding-left: 4px;\n}\n.q-select__focus-target, .q-select__autocomplete-input {\n  position: absolute;\n  outline: 0 !important;\n  width: 0;\n  height: 0;\n  padding: 0;\n  border: 0;\n  opacity: 0;\n}\n.q-select__dropdown-icon {\n  cursor: pointer;\n  transition: transform 0.28s;\n}\n.q-select.q-field--readonly .q-field__control, .q-select.q-field--readonly .q-select__dropdown-icon {\n  cursor: default;\n}\n.q-select__dialog {\n  width: 90vw !important;\n  max-width: 90vw !important;\n  max-height: calc(100vh - 70px) !important;\n  background: #fff;\n  display: flex;\n  flex-direction: column;\n}\n.q-select__dialog > .scroll {\n  position: relative;\n  background: inherit;\n}\nbody.mobile:not(.native-mobile) .q-select__dialog {\n  max-height: calc(100vh - 108px) !important;\n}\nbody.platform-android.native-mobile .q-dialog__inner--top .q-select__dialog {\n  max-height: calc(100vh - 24px) !important;\n}\nbody.platform-android:not(.native-mobile) .q-dialog__inner--top .q-select__dialog {\n  max-height: calc(100vh - 80px) !important;\n}\nbody.platform-ios.native-mobile .q-dialog__inner--top > div {\n  border-radius: 4px;\n}\nbody.platform-ios.native-mobile .q-dialog__inner--top .q-select__dialog--focused {\n  max-height: 47vh !important;\n}\nbody.platform-ios:not(.native-mobile) .q-dialog__inner--top .q-select__dialog--focused {\n  max-height: 50vh !important;\n}\n.q-separator {\n  border: 0;\n  background: rgba(0, 0, 0, 0.12);\n  margin: 0;\n  transition: background 0.3s, opacity 0.3s;\n  flex-shrink: 0;\n}\n.q-separator--dark {\n  background: rgba(255, 255, 255, 0.28);\n}\n.q-separator--horizontal {\n  display: block;\n  height: 1px;\n}\n.q-separator--horizontal-inset {\n  margin-left: 16px;\n  margin-right: 16px;\n}\n.q-separator--horizontal-item-inset {\n  margin-left: 72px;\n  margin-right: 0;\n}\n.q-separator--horizontal-item-thumbnail-inset {\n  margin-left: 116px;\n  margin-right: 0;\n}\n.q-separator--vertical {\n  width: 1px;\n  height: auto;\n  align-self: stretch;\n}\n.q-separator--vertical-inset {\n  margin-top: 8px;\n  margin-bottom: 8px;\n}\n.q-skeleton {\n  --q-skeleton-speed: 1500ms;\n  background: rgba(0, 0, 0, 0.12);\n  border-radius: 4px;\n  box-sizing: border-box;\n}\n.q-skeleton--anim {\n  cursor: wait;\n}\n.q-skeleton:before {\n  content: "\xA0";\n}\n.q-skeleton--type-text {\n  transform: scale(1, 0.5);\n}\n.q-skeleton--type-circle, .q-skeleton--type-QAvatar {\n  height: 48px;\n  width: 48px;\n  border-radius: 50%;\n}\n.q-skeleton--type-QBtn {\n  width: 90px;\n  height: 36px;\n}\n.q-skeleton--type-QBadge {\n  width: 70px;\n  height: 16px;\n}\n.q-skeleton--type-QChip {\n  width: 90px;\n  height: 28px;\n  border-radius: 16px;\n}\n.q-skeleton--type-QToolbar {\n  height: 50px;\n}\n.q-skeleton--type-QCheckbox, .q-skeleton--type-QRadio {\n  width: 40px;\n  height: 40px;\n  border-radius: 50%;\n}\n.q-skeleton--type-QToggle {\n  width: 56px;\n  height: 40px;\n  border-radius: 7px;\n}\n.q-skeleton--type-QSlider, .q-skeleton--type-QRange {\n  height: 40px;\n}\n.q-skeleton--type-QInput {\n  height: 56px;\n}\n.q-skeleton--bordered {\n  border: 1px solid rgba(0, 0, 0, 0.05);\n}\n.q-skeleton--square {\n  border-radius: 0;\n}\n.q-skeleton--anim-fade {\n  animation: q-skeleton--fade var(--q-skeleton-speed) linear 0.5s infinite;\n}\n.q-skeleton--anim-pulse {\n  animation: q-skeleton--pulse var(--q-skeleton-speed) ease-in-out 0.5s infinite;\n}\n.q-skeleton--anim-pulse-x {\n  animation: q-skeleton--pulse-x var(--q-skeleton-speed) ease-in-out 0.5s infinite;\n}\n.q-skeleton--anim-pulse-y {\n  animation: q-skeleton--pulse-y var(--q-skeleton-speed) ease-in-out 0.5s infinite;\n}\n.q-skeleton--anim-wave, .q-skeleton--anim-blink, .q-skeleton--anim-pop {\n  position: relative;\n  overflow: hidden;\n  z-index: 1;\n}\n.q-skeleton--anim-wave:after, .q-skeleton--anim-blink:after, .q-skeleton--anim-pop:after {\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 0;\n}\n.q-skeleton--anim-blink:after {\n  background: rgba(255, 255, 255, 0.7);\n  animation: q-skeleton--fade var(--q-skeleton-speed) linear 0.5s infinite;\n}\n.q-skeleton--anim-wave:after {\n  background: linear-gradient(90deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0));\n  animation: q-skeleton--wave var(--q-skeleton-speed) linear 0.5s infinite;\n}\n.q-skeleton--dark {\n  background: rgba(255, 255, 255, 0.05);\n}\n.q-skeleton--dark.q-skeleton--bordered {\n  border: 1px solid rgba(255, 255, 255, 0.25);\n}\n.q-skeleton--dark.q-skeleton--anim-wave:after {\n  background: linear-gradient(90deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0));\n}\n.q-skeleton--dark.q-skeleton--anim-blink:after {\n  background: rgba(255, 255, 255, 0.2);\n}\n@keyframes q-skeleton--fade {\n  0% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0.4;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n@keyframes q-skeleton--pulse {\n  0% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(0.85);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n@keyframes q-skeleton--pulse-x {\n  0% {\n    transform: scaleX(1);\n  }\n  50% {\n    transform: scaleX(0.75);\n  }\n  100% {\n    transform: scaleX(1);\n  }\n}\n@keyframes q-skeleton--pulse-y {\n  0% {\n    transform: scaleY(1);\n  }\n  50% {\n    transform: scaleY(0.75);\n  }\n  100% {\n    transform: scaleY(1);\n  }\n}\n@keyframes q-skeleton--wave {\n  0% {\n    transform: translateX(-100%);\n  }\n  100% {\n    transform: translateX(100%);\n  }\n}\n.q-slide-item {\n  position: relative;\n  background: white;\n}\n.q-slide-item__left, .q-slide-item__right, .q-slide-item__top, .q-slide-item__bottom {\n  visibility: hidden;\n  font-size: 14px;\n  color: #fff;\n}\n.q-slide-item__left .q-icon, .q-slide-item__right .q-icon, .q-slide-item__top .q-icon, .q-slide-item__bottom .q-icon {\n  font-size: 1.714em;\n}\n.q-slide-item__left {\n  background: #4caf50;\n  padding: 8px 16px;\n}\n.q-slide-item__left > div {\n  transform-origin: left center;\n}\n.q-slide-item__right {\n  background: #ff9800;\n  padding: 8px 16px;\n}\n.q-slide-item__right > div {\n  transform-origin: right center;\n}\n.q-slide-item__top {\n  background: #2196f3;\n  padding: 16px 8px;\n}\n.q-slide-item__top > div {\n  transform-origin: top center;\n}\n.q-slide-item__bottom {\n  background: #9c27b0;\n  padding: 16px 8px;\n}\n.q-slide-item__bottom > div {\n  transform-origin: bottom center;\n}\n.q-slide-item__content {\n  background: inherit;\n  transition: transform 0.2s ease-in;\n  -webkit-user-select: none;\n          user-select: none;\n  cursor: pointer;\n}\n.q-slider {\n  position: relative;\n}\n.q-slider--h {\n  width: 100%;\n}\n.q-slider--v {\n  height: 200px;\n}\n.q-slider--editable .q-slider__track-container {\n  cursor: grab;\n}\n.q-slider__track-container {\n  outline: 0;\n}\n.q-slider__track-container--h {\n  width: 100%;\n  padding: 12px 0;\n}\n.q-slider__track-container--h .q-slider__selection {\n  will-change: width, left;\n}\n.q-slider__track-container--v {\n  height: 100%;\n  padding: 0 12px;\n}\n.q-slider__track-container--v .q-slider__selection {\n  will-change: height, top;\n}\n.q-slider__track {\n  color: var(--q-primary);\n  background: rgba(0, 0, 0, 0.1);\n  border-radius: 4px;\n  width: inherit;\n  height: inherit;\n}\n.q-slider__inner {\n  background: rgba(0, 0, 0, 0.1);\n  border-radius: inherit;\n  width: 100%;\n  height: 100%;\n}\n.q-slider__selection {\n  background: currentColor;\n  border-radius: inherit;\n  width: 100%;\n  height: 100%;\n}\n.q-slider__markers {\n  color: rgba(0, 0, 0, 0.3);\n  border-radius: inherit;\n  width: 100%;\n  height: 100%;\n}\n.q-slider__markers:after {\n  content: "";\n  position: absolute;\n  background: currentColor;\n}\n.q-slider__markers--h {\n  background-image: repeating-linear-gradient(to right, currentColor, currentColor 2px, rgba(255, 255, 255, 0) 0, rgba(255, 255, 255, 0));\n}\n.q-slider__markers--h:after {\n  height: 100%;\n  width: 2px;\n  top: 0;\n  right: 0;\n}\n.q-slider__markers--v {\n  background-image: repeating-linear-gradient(to bottom, currentColor, currentColor 2px, rgba(255, 255, 255, 0) 0, rgba(255, 255, 255, 0));\n}\n.q-slider__markers--v:after {\n  width: 100%;\n  height: 2px;\n  left: 0;\n  bottom: 0;\n}\n.q-slider__marker-labels-container {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  min-height: 24px;\n  min-width: 24px;\n}\n.q-slider__marker-labels {\n  position: absolute;\n}\n.q-slider__marker-labels--h-standard {\n  top: 0;\n}\n.q-slider__marker-labels--h-switched {\n  bottom: 0;\n}\n.q-slider__marker-labels--h-ltr {\n  transform: translateX(-50%) /* rtl:ignore */;\n}\n.q-slider__marker-labels--h-rtl {\n  transform: translateX(50%) /* rtl:ignore */;\n}\n.q-slider__marker-labels--v-standard {\n  left: 4px;\n}\n.q-slider__marker-labels--v-switched {\n  right: 4px;\n}\n.q-slider__marker-labels--v-ltr {\n  transform: translateY(-50%) /* rtl:ignore */;\n}\n.q-slider__marker-labels--v-rtl {\n  transform: translateY(50%) /* rtl:ignore */;\n}\n.q-slider__thumb {\n  z-index: 1;\n  outline: 0;\n  color: var(--q-primary);\n  transition: transform 0.18s ease-out, fill 0.18s ease-out, stroke 0.18s ease-out;\n}\n.q-slider__thumb.q-slider--focus {\n  opacity: 1 !important;\n}\n.q-slider__thumb--h {\n  top: 50%;\n  will-change: left;\n}\n.q-slider__thumb--h-ltr {\n  transform: scale(1) translate(-50%, -50%) /* rtl:ignore */;\n}\n.q-slider__thumb--h-rtl {\n  transform: scale(1) translate(50%, -50%) /* rtl:ignore */;\n}\n.q-slider__thumb--v {\n  left: 50% /* rtl:ignore */;\n  will-change: top;\n}\n.q-slider__thumb--v-ltr {\n  transform: scale(1) translate(-50%, -50%) /* rtl:ignore */;\n}\n.q-slider__thumb--v-rtl {\n  transform: scale(1) translate(-50%, 50%) /* rtl:ignore */;\n}\n.q-slider__thumb-shape {\n  top: 0;\n  left: 0;\n  stroke-width: 3.5;\n  stroke: currentColor;\n  transition: transform 0.28s;\n}\n.q-slider__thumb-shape path {\n  stroke: currentColor;\n  fill: currentColor;\n}\n.q-slider__focus-ring {\n  border-radius: 50%;\n  opacity: 0;\n  transition: transform 266.67ms ease-out, opacity 266.67ms ease-out, background-color 266.67ms ease-out;\n  transition-delay: 0.14s;\n}\n.q-slider__pin {\n  opacity: 0;\n  white-space: nowrap;\n  transition: opacity 0.28s ease-out;\n  transition-delay: 0.14s;\n}\n.q-slider__pin:before {\n  content: "";\n  width: 0;\n  height: 0;\n  position: absolute;\n}\n.q-slider__pin--h:before {\n  border-left: 6px solid transparent;\n  border-right: 6px solid transparent;\n  left: 50%;\n  transform: translateX(-50%);\n}\n.q-slider__pin--h-standard {\n  bottom: 100%;\n}\n.q-slider__pin--h-standard:before {\n  bottom: 2px;\n  border-top: 6px solid currentColor;\n}\n.q-slider__pin--h-switched {\n  top: 100%;\n}\n.q-slider__pin--h-switched:before {\n  top: 2px;\n  border-bottom: 6px solid currentColor;\n}\n.q-slider__pin--v {\n  top: 0;\n}\n.q-slider__pin--v:before {\n  top: 50%;\n  transform: translateY(-50%);\n  border-top: 6px solid transparent;\n  border-bottom: 6px solid transparent;\n}\n.q-slider__pin--v-standard {\n  left: 100%;\n}\n.q-slider__pin--v-standard:before {\n  left: 2px;\n  border-right: 6px solid currentColor;\n}\n.q-slider__pin--v-switched {\n  right: 100%;\n}\n.q-slider__pin--v-switched:before {\n  right: 2px;\n  border-left: 6px solid currentColor;\n}\n.q-slider__label {\n  z-index: 1;\n  white-space: nowrap;\n  position: absolute;\n}\n.q-slider__label--h {\n  left: 50%;\n  transform: translateX(-50%);\n}\n.q-slider__label--h-standard {\n  bottom: 7px;\n}\n.q-slider__label--h-switched {\n  top: 7px;\n}\n.q-slider__label--v {\n  top: 50%;\n  transform: translateY(-50%);\n}\n.q-slider__label--v-standard {\n  left: 7px;\n}\n.q-slider__label--v-switched {\n  right: 7px;\n}\n.q-slider__text-container {\n  min-height: 25px;\n  padding: 2px 8px;\n  border-radius: 4px;\n  background: currentColor;\n  position: relative;\n  text-align: center;\n}\n.q-slider__text {\n  color: #fff;\n  font-size: 12px;\n}\n.q-slider--no-value .q-slider__thumb,\n.q-slider--no-value .q-slider__inner,\n.q-slider--no-value .q-slider__selection {\n  opacity: 0;\n}\n.q-slider--focus .q-slider__focus-ring, body.desktop .q-slider.q-slider--editable .q-slider__track-container:hover .q-slider__focus-ring {\n  background: currentColor;\n  transform: scale3d(1.55, 1.55, 1);\n  opacity: 0.25;\n}\n.q-slider--focus .q-slider__thumb,\n.q-slider--focus .q-slider__inner,\n.q-slider--focus .q-slider__selection, body.desktop .q-slider.q-slider--editable .q-slider__track-container:hover .q-slider__thumb,\nbody.desktop .q-slider.q-slider--editable .q-slider__track-container:hover .q-slider__inner,\nbody.desktop .q-slider.q-slider--editable .q-slider__track-container:hover .q-slider__selection {\n  opacity: 1;\n}\n.q-slider--inactive .q-slider__thumb--h {\n  transition: left 0.28s, right 0.28s;\n}\n.q-slider--inactive .q-slider__thumb--v {\n  transition: top 0.28s, bottom 0.28s;\n}\n.q-slider--inactive .q-slider__selection {\n  transition: width 0.28s, left 0.28s, right 0.28s, height 0.28s, top 0.28s, bottom 0.28s;\n}\n.q-slider--inactive .q-slider__text-container {\n  transition: transform 0.28s;\n}\n.q-slider--active {\n  cursor: grabbing;\n}\n.q-slider--active .q-slider__thumb-shape {\n  transform: scale(1.5);\n}\n.q-slider--active .q-slider__focus-ring, .q-slider--active.q-slider--label .q-slider__thumb-shape {\n  transform: scale(0) !important;\n}\nbody.desktop .q-slider.q-slider--enabled .q-slider__track-container:hover .q-slider__pin {\n  opacity: 1;\n}\n.q-slider--label.q-slider--active .q-slider__pin,\n.q-slider--label .q-slider--focus .q-slider__pin, .q-slider--label.q-slider--label-always .q-slider__pin {\n  opacity: 1;\n}\n.q-slider--dark .q-slider__track {\n  background: rgba(255, 255, 255, 0.1);\n}\n.q-slider--dark .q-slider__inner {\n  background: rgba(255, 255, 255, 0.1);\n}\n.q-slider--dark .q-slider__markers {\n  color: rgba(255, 255, 255, 0.3);\n}\n.q-slider--dense .q-slider__track-container--h {\n  padding: 6px 0;\n}\n.q-slider--dense .q-slider__track-container--v {\n  padding: 0 6px;\n}\n.q-space {\n  flex-grow: 1 !important;\n}\n.q-spinner {\n  vertical-align: middle;\n}\n.q-spinner-mat {\n  animation: q-spin 2s linear infinite;\n  transform-origin: center center;\n}\n.q-spinner-mat .path {\n  stroke-dasharray: 1, 200 /* rtl:ignore */;\n  stroke-dashoffset: 0 /* rtl:ignore */;\n  animation: q-mat-dash 1.5s ease-in-out infinite;\n}\n@keyframes q-spin {\n  0% {\n    transform: rotate3d(0, 0, 1, 0deg) /* rtl:ignore */;\n  }\n  25% {\n    transform: rotate3d(0, 0, 1, 90deg) /* rtl:ignore */;\n  }\n  50% {\n    transform: rotate3d(0, 0, 1, 180deg) /* rtl:ignore */;\n  }\n  75% {\n    transform: rotate3d(0, 0, 1, 270deg) /* rtl:ignore */;\n  }\n  100% {\n    transform: rotate3d(0, 0, 1, 359deg) /* rtl:ignore */;\n  }\n}\n@keyframes q-mat-dash {\n  0% {\n    stroke-dasharray: 1, 200;\n    stroke-dashoffset: 0;\n  }\n  50% {\n    stroke-dasharray: 89, 200;\n    stroke-dashoffset: -35px;\n  }\n  100% {\n    stroke-dasharray: 89, 200;\n    stroke-dashoffset: -124px;\n  }\n}\n.q-splitter__panel {\n  position: relative;\n  z-index: 0;\n}\n.q-splitter__panel > .q-splitter {\n  width: 100%;\n  height: 100%;\n}\n.q-splitter__separator {\n  background-color: rgba(0, 0, 0, 0.12);\n  -webkit-user-select: none;\n          user-select: none;\n  position: relative;\n  z-index: 1;\n}\n.q-splitter__separator-area > * {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n.q-splitter--dark .q-splitter__separator {\n  background-color: rgba(255, 255, 255, 0.28);\n}\n.q-splitter--vertical > .q-splitter__panel {\n  height: 100%;\n}\n.q-splitter--vertical.q-splitter--active {\n  cursor: col-resize;\n}\n.q-splitter--vertical > .q-splitter__separator {\n  width: 1px;\n}\n.q-splitter--vertical > .q-splitter__separator > div {\n  left: -6px;\n  right: -6px;\n}\n.q-splitter--vertical.q-splitter--workable > .q-splitter__separator {\n  cursor: col-resize;\n}\n.q-splitter--horizontal > .q-splitter__panel {\n  width: 100%;\n}\n.q-splitter--horizontal.q-splitter--active {\n  cursor: row-resize;\n}\n.q-splitter--horizontal > .q-splitter__separator {\n  height: 1px;\n}\n.q-splitter--horizontal > .q-splitter__separator > div {\n  top: -6px;\n  bottom: -6px;\n}\n.q-splitter--horizontal.q-splitter--workable > .q-splitter__separator {\n  cursor: row-resize;\n}\n.q-splitter__before, .q-splitter__after {\n  overflow: auto;\n}\n.q-stepper {\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n  border-radius: 4px;\n  background: #fff;\n}\n.q-stepper__title {\n  font-size: 14px;\n  line-height: 18px;\n  letter-spacing: 0.1px;\n}\n.q-stepper__caption {\n  font-size: 12px;\n  line-height: 14px;\n}\n.q-stepper__dot {\n  contain: layout;\n  margin-right: 8px;\n  font-size: 14px;\n  width: 24px;\n  min-width: 24px;\n  height: 24px;\n  border-radius: 50%;\n  background: currentColor;\n}\n.q-stepper__dot span {\n  color: #fff;\n}\n.q-stepper__tab {\n  padding: 8px 24px;\n  font-size: 14px;\n  color: #9e9e9e;\n  flex-direction: row;\n}\n.q-stepper--dark .q-stepper__dot span {\n  color: #000;\n}\n.q-stepper__tab--navigation {\n  -webkit-user-select: none;\n          user-select: none;\n  cursor: pointer;\n}\n.q-stepper__tab--active, .q-stepper__tab--done {\n  color: var(--q-primary);\n}\n.q-stepper__tab--active .q-stepper__dot, .q-stepper__tab--active .q-stepper__label, .q-stepper__tab--done .q-stepper__dot, .q-stepper__tab--done .q-stepper__label {\n  text-shadow: 0 0 0 currentColor;\n}\n.q-stepper__tab--disabled .q-stepper__dot {\n  background: rgba(0, 0, 0, 0.22);\n}\n.q-stepper__tab--disabled .q-stepper__label {\n  color: rgba(0, 0, 0, 0.32);\n}\n.q-stepper__tab--error {\n  color: var(--q-negative);\n}\n.q-stepper__tab--error-with-icon .q-stepper__dot {\n  background: transparent !important;\n}\n.q-stepper__tab--error-with-icon .q-stepper__dot span {\n  color: currentColor;\n  font-size: 24px;\n}\n.q-stepper__header {\n  border-top-left-radius: inherit;\n  border-top-right-radius: inherit;\n}\n.q-stepper__header--border {\n  border-bottom: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-stepper__header--standard-labels .q-stepper__tab {\n  min-height: 72px;\n  justify-content: center;\n}\n.q-stepper__header--standard-labels .q-stepper__tab:first-child {\n  justify-content: flex-start;\n}\n.q-stepper__header--standard-labels .q-stepper__tab:last-child {\n  justify-content: flex-end;\n}\n.q-stepper__header--standard-labels .q-stepper__tab:only-child {\n  justify-content: center;\n}\n.q-stepper__header--standard-labels .q-stepper__dot:after {\n  display: none;\n}\n.q-stepper__header--alternative-labels .q-stepper__tab {\n  min-height: 104px;\n  padding: 24px 32px;\n  flex-direction: column;\n  justify-content: flex-start;\n}\n.q-stepper__header--alternative-labels .q-stepper__dot {\n  margin-right: 0;\n}\n.q-stepper__header--alternative-labels .q-stepper__label {\n  margin-top: 8px;\n  text-align: center;\n}\n.q-stepper__header--alternative-labels .q-stepper__label:before, .q-stepper__header--alternative-labels .q-stepper__label:after {\n  display: none;\n}\n.q-stepper__header--contracted {\n  min-height: 72px;\n}\n.q-stepper__header--contracted.q-stepper__header--alternative-labels .q-stepper__tab {\n  min-height: 72px;\n}\n.q-stepper__header--contracted.q-stepper__header--alternative-labels .q-stepper__tab:first-child {\n  align-items: flex-start;\n}\n.q-stepper__header--contracted.q-stepper__header--alternative-labels .q-stepper__tab:last-child {\n  align-items: flex-end;\n}\n.q-stepper__header--contracted .q-stepper__tab {\n  padding: 24px 0;\n}\n.q-stepper__header--contracted .q-stepper__tab:first-child .q-stepper__dot {\n  transform: translateX(24px);\n}\n.q-stepper__header--contracted .q-stepper__tab:last-child .q-stepper__dot {\n  transform: translateX(-24px);\n}\n.q-stepper__header--contracted .q-stepper__tab:not(:last-child) .q-stepper__dot:after {\n  display: block !important;\n}\n.q-stepper__header--contracted .q-stepper__dot {\n  margin: 0;\n}\n.q-stepper__header--contracted .q-stepper__label {\n  display: none;\n}\n.q-stepper__nav {\n  padding-top: 24px;\n}\n.q-stepper--bordered {\n  border: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-stepper--horizontal .q-stepper__step-inner {\n  padding: 24px;\n}\n.q-stepper--horizontal .q-stepper__tab:first-child {\n  border-top-left-radius: inherit;\n}\n.q-stepper--horizontal .q-stepper__tab:last-child {\n  border-top-right-radius: inherit;\n}\n.q-stepper--horizontal .q-stepper__tab:first-child .q-stepper__dot:before,\n.q-stepper--horizontal .q-stepper__tab:last-child .q-stepper__label:after,\n.q-stepper--horizontal .q-stepper__tab:last-child .q-stepper__dot:after {\n  display: none;\n}\n.q-stepper--horizontal .q-stepper__tab {\n  overflow: hidden;\n}\n.q-stepper--horizontal .q-stepper__line {\n  contain: layout;\n}\n.q-stepper--horizontal .q-stepper__line:before, .q-stepper--horizontal .q-stepper__line:after {\n  position: absolute;\n  top: 50%;\n  height: 1px;\n  width: 100vw;\n  background: rgba(0, 0, 0, 0.12);\n}\n.q-stepper--horizontal .q-stepper__label:after, .q-stepper--horizontal .q-stepper__dot:after {\n  content: "";\n  left: 100%;\n  margin-left: 8px;\n}\n.q-stepper--horizontal .q-stepper__dot:before {\n  content: "";\n  right: 100%;\n  margin-right: 8px;\n}\n.q-stepper--horizontal > .q-stepper__nav {\n  padding: 0 24px 24px;\n}\n.q-stepper--vertical {\n  padding: 16px 0;\n}\n.q-stepper--vertical .q-stepper__tab {\n  padding: 12px 24px;\n}\n.q-stepper--vertical .q-stepper__title {\n  line-height: 18px;\n}\n.q-stepper--vertical .q-stepper__step-inner {\n  padding: 0 24px 32px 60px;\n}\n.q-stepper--vertical > .q-stepper__nav {\n  padding: 24px 24px 0;\n}\n.q-stepper--vertical .q-stepper__step {\n  overflow: hidden;\n}\n.q-stepper--vertical .q-stepper__dot {\n  margin-right: 12px;\n}\n.q-stepper--vertical .q-stepper__dot:before, .q-stepper--vertical .q-stepper__dot:after {\n  content: "";\n  position: absolute;\n  left: 50%;\n  width: 1px;\n  height: 99999px;\n  background: rgba(0, 0, 0, 0.12);\n}\n.q-stepper--vertical .q-stepper__dot:before {\n  bottom: 100%;\n  margin-bottom: 8px;\n}\n.q-stepper--vertical .q-stepper__dot:after {\n  top: 100%;\n  margin-top: 8px;\n}\n.q-stepper--vertical .q-stepper__step:first-child .q-stepper__dot:before,\n.q-stepper--vertical .q-stepper__step:last-child .q-stepper__dot:after {\n  display: none;\n}\n.q-stepper--vertical .q-stepper__step:last-child .q-stepper__step-inner {\n  padding-bottom: 8px;\n}\n.q-stepper--dark.q-stepper--bordered,\n.q-stepper--dark .q-stepper__header--border {\n  border-color: rgba(255, 255, 255, 0.28);\n}\n.q-stepper--dark.q-stepper--horizontal .q-stepper__line:before, .q-stepper--dark.q-stepper--horizontal .q-stepper__line:after {\n  background: rgba(255, 255, 255, 0.28);\n}\n.q-stepper--dark.q-stepper--vertical .q-stepper__dot:before, .q-stepper--dark.q-stepper--vertical .q-stepper__dot:after {\n  background: rgba(255, 255, 255, 0.28);\n}\n.q-stepper--dark .q-stepper__tab--disabled {\n  color: rgba(255, 255, 255, 0.28);\n}\n.q-stepper--dark .q-stepper__tab--disabled .q-stepper__dot {\n  background: rgba(255, 255, 255, 0.28);\n}\n.q-stepper--dark .q-stepper__tab--disabled .q-stepper__label {\n  color: rgba(255, 255, 255, 0.54);\n}\n.q-tab-panels {\n  background: #fff;\n}\n.q-tab-panel {\n  padding: 16px;\n}\n.q-markup-table {\n  overflow: auto;\n  background: #fff;\n}\n.q-table {\n  width: 100%;\n  max-width: 100%;\n  border-collapse: separate;\n  border-spacing: 0;\n}\n.q-table thead tr, .q-table tbody td {\n  height: 48px;\n}\n.q-table th {\n  font-weight: 500;\n  font-size: 12px;\n  -webkit-user-select: none;\n          user-select: none;\n}\n.q-table th.sortable {\n  cursor: pointer;\n}\n.q-table th.sortable:hover .q-table__sort-icon {\n  opacity: 0.64;\n}\n.q-table th.sorted .q-table__sort-icon {\n  opacity: 0.86 !important;\n}\n.q-table th.sort-desc .q-table__sort-icon {\n  transform: rotate(180deg);\n}\n.q-table th, .q-table td {\n  padding: 7px 16px;\n  background-color: inherit;\n}\n.q-table thead, .q-table td, .q-table th {\n  border-style: solid;\n  border-width: 0;\n}\n.q-table tbody td {\n  font-size: 13px;\n}\n.q-table__card {\n  color: #000;\n  background-color: #fff;\n  border-radius: 4px;\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n}\n.q-table__card .q-table__middle {\n  flex: 1 1 auto;\n}\n.q-table__card .q-table__top,\n.q-table__card .q-table__bottom {\n  flex: 0 0 auto;\n}\n.q-table__container {\n  position: relative;\n}\n.q-table__container > div:first-child {\n  border-top-left-radius: inherit;\n  border-top-right-radius: inherit;\n}\n.q-table__container > div:last-child {\n  border-bottom-left-radius: inherit;\n  border-bottom-right-radius: inherit;\n}\n.q-table__container > .q-inner-loading {\n  border-radius: inherit !important;\n}\n.q-table__top {\n  padding: 12px 16px;\n}\n.q-table__top .q-table__control {\n  flex-wrap: wrap;\n}\n.q-table__title {\n  font-size: 20px;\n  letter-spacing: 0.005em;\n  font-weight: 400;\n}\n.q-table__separator {\n  min-width: 8px !important;\n}\n.q-table__progress {\n  height: 0 !important;\n}\n.q-table__progress th {\n  padding: 0 !important;\n  border: 0 !important;\n}\n.q-table__progress .q-linear-progress {\n  position: absolute;\n  bottom: 0;\n}\n.q-table__middle {\n  max-width: 100%;\n}\n.q-table__bottom {\n  min-height: 50px;\n  padding: 4px 14px 4px 16px;\n  font-size: 12px;\n}\n.q-table__bottom .q-table__control {\n  min-height: 24px;\n}\n.q-table__bottom-nodata-icon {\n  font-size: 200%;\n  margin-right: 8px;\n}\n.q-table__bottom-item {\n  margin-right: 16px;\n}\n.q-table__control {\n  display: flex;\n  align-items: center;\n}\n.q-table__sort-icon {\n  transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n  opacity: 0;\n  font-size: 120%;\n}\n.q-table__sort-icon--left, .q-table__sort-icon--center {\n  margin-left: 4px;\n}\n.q-table__sort-icon--right {\n  margin-right: 4px;\n}\n.q-table--col-auto-width {\n  width: 1px;\n}\n.q-table--flat {\n  box-shadow: none;\n}\n.q-table--bordered {\n  border: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-table--square {\n  border-radius: 0;\n}\n.q-table__linear-progress {\n  height: 2px;\n}\n.q-table--no-wrap th, .q-table--no-wrap td {\n  white-space: nowrap;\n}\n.q-table--grid {\n  box-shadow: none;\n  border-radius: 4px;\n}\n.q-table--grid .q-table__top {\n  padding-bottom: 4px;\n}\n.q-table--grid .q-table__middle {\n  min-height: 2px;\n  margin-bottom: 4px;\n}\n.q-table--grid .q-table__middle thead, .q-table--grid .q-table__middle thead th {\n  border: 0 !important;\n}\n.q-table--grid .q-table__linear-progress {\n  bottom: 0;\n}\n.q-table--grid .q-table__bottom {\n  border-top: 0;\n}\n.q-table--grid .q-table__grid-content {\n  flex: 1 1 auto;\n}\n.q-table--grid.fullscreen {\n  background: inherit;\n}\n.q-table__grid-item-card {\n  vertical-align: top;\n  padding: 12px;\n}\n.q-table__grid-item-card .q-separator {\n  margin: 12px 0;\n}\n.q-table__grid-item-row + .q-table__grid-item-row {\n  margin-top: 8px;\n}\n.q-table__grid-item-title {\n  opacity: 0.54;\n  font-weight: 500;\n  font-size: 12px;\n}\n.q-table__grid-item-value {\n  font-size: 13px;\n}\n.q-table__grid-item {\n  padding: 4px;\n  transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\n.q-table__grid-item--selected {\n  transform: scale(0.95);\n}\n.q-table--horizontal-separator thead th, .q-table--horizontal-separator tbody tr:not(:last-child) > td, .q-table--cell-separator thead th, .q-table--cell-separator tbody tr:not(:last-child) > td {\n  border-bottom-width: 1px;\n}\n.q-table--vertical-separator td, .q-table--vertical-separator th, .q-table--cell-separator td, .q-table--cell-separator th {\n  border-left-width: 1px;\n}\n.q-table--vertical-separator thead tr:last-child th, .q-table--vertical-separator.q-table--loading tr:nth-last-child(2) th, .q-table--cell-separator thead tr:last-child th, .q-table--cell-separator.q-table--loading tr:nth-last-child(2) th {\n  border-bottom-width: 1px;\n}\n.q-table--vertical-separator td:first-child, .q-table--vertical-separator th:first-child, .q-table--cell-separator td:first-child, .q-table--cell-separator th:first-child {\n  border-left: 0;\n}\n.q-table--vertical-separator .q-table__top, .q-table--cell-separator .q-table__top {\n  border-bottom: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-table--dense .q-table__top {\n  padding: 6px 16px;\n}\n.q-table--dense .q-table__bottom {\n  min-height: 33px;\n}\n.q-table--dense .q-table__sort-icon {\n  font-size: 110%;\n}\n.q-table--dense .q-table th, .q-table--dense .q-table td {\n  padding: 4px 8px;\n}\n.q-table--dense .q-table thead tr, .q-table--dense .q-table tbody tr, .q-table--dense .q-table tbody td {\n  height: 28px;\n}\n.q-table--dense .q-table th:first-child, .q-table--dense .q-table td:first-child {\n  padding-left: 16px;\n}\n.q-table--dense .q-table th:last-child, .q-table--dense .q-table td:last-child {\n  padding-right: 16px;\n}\n.q-table--dense .q-table__bottom-item {\n  margin-right: 8px;\n}\n.q-table--dense .q-table__select .q-field__control, .q-table--dense .q-table__select .q-field__native {\n  min-height: 24px;\n  padding: 0;\n}\n.q-table--dense .q-table__select .q-field__marginal {\n  height: 24px;\n}\n.q-table__bottom {\n  border-top: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-table thead, .q-table tr, .q-table th, .q-table td {\n  border-color: rgba(0, 0, 0, 0.12);\n}\n.q-table tbody td {\n  position: relative;\n}\n.q-table tbody td:before, .q-table tbody td:after {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n}\n.q-table tbody td:before {\n  background: rgba(0, 0, 0, 0.03);\n}\n.q-table tbody td:after {\n  background: rgba(0, 0, 0, 0.06);\n}\n.q-table tbody tr.selected td:after {\n  content: "";\n}\nbody.desktop .q-table > tbody > tr:not(.q-tr--no-hover):hover > td:not(.q-td--no-hover):before {\n  content: "";\n}\n.q-table__card--dark, .q-table--dark {\n  border-color: rgba(255, 255, 255, 0.28);\n}\n.q-table--dark .q-table__bottom, .q-table--dark thead, .q-table--dark tr, .q-table--dark th, .q-table--dark td {\n  border-color: rgba(255, 255, 255, 0.28);\n}\n.q-table--dark tbody td:before {\n  background: rgba(255, 255, 255, 0.07);\n}\n.q-table--dark tbody td:after {\n  background: rgba(255, 255, 255, 0.1);\n}\n.q-table--dark.q-table--vertical-separator .q-table__top, .q-table--dark.q-table--cell-separator .q-table__top {\n  border-color: rgba(255, 255, 255, 0.28);\n}\n.q-tab {\n  padding: 0 16px;\n  min-height: 48px;\n  transition: color 0.3s, background-color 0.3s;\n  text-transform: uppercase;\n  white-space: nowrap;\n  color: inherit;\n  text-decoration: none;\n}\n.q-tab--full {\n  min-height: 72px;\n}\n.q-tab--no-caps {\n  text-transform: none;\n}\n.q-tab__content {\n  height: inherit;\n  padding: 4px 0;\n  min-width: 40px;\n}\n.q-tab__content--inline .q-tab__icon + .q-tab__label {\n  padding-left: 8px;\n}\n.q-tab__content .q-chip--floating {\n  top: 0;\n  right: -16px;\n}\n.q-tab__icon {\n  width: 24px;\n  height: 24px;\n  font-size: 24px;\n}\n.q-tab__label {\n  font-size: 14px;\n  line-height: 1.715em;\n  font-weight: 500;\n}\n.q-tab .q-badge {\n  top: 3px;\n  right: -12px;\n}\n.q-tab__alert, .q-tab__alert-icon {\n  position: absolute;\n}\n.q-tab__alert {\n  top: 7px;\n  right: -9px;\n  height: 10px;\n  width: 10px;\n  border-radius: 50%;\n  background: currentColor;\n}\n.q-tab__alert-icon {\n  top: 2px;\n  right: -12px;\n  font-size: 18px;\n}\n.q-tab__indicator {\n  opacity: 0;\n  height: 2px;\n  background: currentColor;\n}\n.q-tab--active .q-tab__indicator {\n  opacity: 1;\n  transform-origin: left /* rtl:ignore */;\n}\n.q-tab--inactive {\n  opacity: 0.85;\n}\n.q-tabs {\n  position: relative;\n  transition: color 0.3s, background-color 0.3s;\n}\n.q-tabs--scrollable.q-tabs__arrows--outside.q-tabs--horizontal {\n  padding-left: 36px;\n  padding-right: 36px;\n}\n.q-tabs--scrollable.q-tabs__arrows--outside.q-tabs--vertical {\n  padding-top: 36px;\n  padding-bottom: 36px;\n}\n.q-tabs--scrollable.q-tabs__arrows--outside .q-tabs__arrow--faded {\n  opacity: 0.3;\n  pointer-events: none;\n}\n.q-tabs--scrollable.q-tabs__arrows--inside .q-tabs__arrow--faded {\n  display: none;\n}\n.q-tabs--not-scrollable .q-tabs__arrow {\n  display: none;\n}\n.q-tabs--not-scrollable .q-tabs__content {\n  border-radius: inherit;\n}\n.q-tabs__arrow {\n  cursor: pointer;\n  font-size: 32px;\n  min-width: 36px;\n  text-shadow: 0 0 3px #fff, 0 0 1px #fff, 0 0 1px #000;\n  transition: opacity 0.3s;\n}\n.q-tabs__content {\n  overflow: hidden;\n  flex: 1 1 auto;\n}\n.q-tabs__content--align-center {\n  justify-content: center;\n}\n.q-tabs__content--align-right {\n  justify-content: flex-end;\n}\n.q-tabs__content--align-justify .q-tab {\n  flex: 1 1 auto;\n}\n.q-tabs__offset {\n  display: none;\n}\n.q-tabs--horizontal .q-tabs__arrow {\n  height: 100%;\n}\n.q-tabs--horizontal .q-tabs__arrow--left {\n  top: 0;\n  left: 0 /* rtl:ignore */;\n  bottom: 0;\n}\n.q-tabs--horizontal .q-tabs__arrow--right {\n  top: 0;\n  right: 0 /* rtl:ignore */;\n  bottom: 0;\n}\n.q-tabs--vertical {\n  display: block !important;\n  height: 100%;\n}\n.q-tabs--vertical .q-tabs__content {\n  display: block !important;\n  height: 100%;\n}\n.q-tabs--vertical .q-tabs__arrow {\n  width: 100%;\n  height: 36px;\n  text-align: center;\n}\n.q-tabs--vertical .q-tabs__arrow--left {\n  top: 0;\n  left: 0;\n  right: 0;\n}\n.q-tabs--vertical .q-tabs__arrow--right {\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n.q-tabs--vertical .q-tab {\n  padding: 0 8px;\n}\n.q-tabs--vertical .q-tab__indicator {\n  height: unset;\n  width: 2px;\n}\n.q-tabs--vertical.q-tabs--not-scrollable .q-tabs__content {\n  height: 100%;\n}\n.q-tabs--vertical.q-tabs--dense .q-tab__content {\n  min-width: 24px;\n}\n.q-tabs--dense .q-tab {\n  min-height: 36px;\n}\n.q-tabs--dense .q-tab--full {\n  min-height: 52px;\n}\n.q-time {\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n  border-radius: 4px;\n  background: #fff;\n  outline: 0;\n  width: 290px;\n  min-width: 290px;\n  max-width: 100%;\n}\n.q-time--bordered {\n  border: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-time__header {\n  border-top-left-radius: inherit;\n  color: #fff;\n  background-color: var(--q-primary);\n  padding: 16px;\n  font-weight: 300;\n}\n.q-time__actions {\n  padding: 0 16px 16px;\n}\n.q-time__header-label {\n  font-size: 28px;\n  line-height: 1;\n  letter-spacing: -0.00833em;\n}\n.q-time__header-label > div + div {\n  margin-left: 4px;\n}\n.q-time__link {\n  opacity: 0.56;\n  outline: 0;\n  transition: opacity 0.3s ease-out;\n}\n.q-time__link--active, .q-time__link:hover, .q-time__link:focus {\n  opacity: 1;\n}\n.q-time__header-ampm {\n  font-size: 16px;\n  letter-spacing: 0.1em;\n}\n.q-time__content {\n  padding: 16px;\n}\n.q-time__content:before {\n  content: "";\n  display: block;\n  padding-bottom: 100%;\n}\n.q-time__container-parent {\n  padding: 16px;\n}\n.q-time__container-child {\n  border-radius: 50%;\n  background: rgba(0, 0, 0, 0.12);\n}\n.q-time__clock {\n  padding: 24px;\n  width: 100%;\n  height: 100%;\n  max-width: 100%;\n  max-height: 100%;\n  font-size: 14px;\n}\n.q-time__clock-circle {\n  position: relative;\n}\n.q-time__clock-center {\n  height: 6px;\n  width: 6px;\n  margin: auto;\n  border-radius: 50%;\n  min-height: 0;\n  background: currentColor;\n}\n.q-time__clock-pointer {\n  width: 2px;\n  height: 50%;\n  transform-origin: 0 0 /* rtl:ignore */;\n  min-height: 0;\n  position: absolute;\n  left: 50%;\n  right: 0;\n  bottom: 0;\n  color: var(--q-primary);\n  background: currentColor;\n  transform: translateX(-50%);\n}\n.q-time__clock-pointer:before, .q-time__clock-pointer:after {\n  content: "";\n  position: absolute;\n  left: 50%;\n  border-radius: 50%;\n  background: currentColor;\n  transform: translateX(-50%);\n}\n.q-time__clock-pointer:before {\n  bottom: -4px;\n  width: 8px;\n  height: 8px;\n}\n.q-time__clock-pointer:after {\n  top: -3px;\n  height: 6px;\n  width: 6px;\n}\n.q-time__clock-position {\n  position: absolute;\n  min-height: 32px;\n  width: 32px;\n  height: 32px;\n  font-size: 12px;\n  line-height: 32px;\n  margin: 0;\n  padding: 0;\n  transform: translate(-50%, -50%) /* rtl:ignore */;\n  border-radius: 50%;\n}\n.q-time__clock-position--disable {\n  opacity: 0.4;\n}\n.q-time__clock-position--active {\n  background-color: var(--q-primary);\n  color: #fff;\n}\n.q-time__clock-pos-0 {\n  top: 0%;\n  left: 50% /* rtl:ignore */;\n}\n.q-time__clock-pos-1 {\n  top: 6.7%;\n  left: 75% /* rtl:ignore */;\n}\n.q-time__clock-pos-2 {\n  top: 25%;\n  left: 93.3% /* rtl:ignore */;\n}\n.q-time__clock-pos-3 {\n  top: 50%;\n  left: 100% /* rtl:ignore */;\n}\n.q-time__clock-pos-4 {\n  top: 75%;\n  left: 93.3% /* rtl:ignore */;\n}\n.q-time__clock-pos-5 {\n  top: 93.3%;\n  left: 75% /* rtl:ignore */;\n}\n.q-time__clock-pos-6 {\n  top: 100%;\n  left: 50% /* rtl:ignore */;\n}\n.q-time__clock-pos-7 {\n  top: 93.3%;\n  left: 25% /* rtl:ignore */;\n}\n.q-time__clock-pos-8 {\n  top: 75%;\n  left: 6.7% /* rtl:ignore */;\n}\n.q-time__clock-pos-9 {\n  top: 50%;\n  left: 0% /* rtl:ignore */;\n}\n.q-time__clock-pos-10 {\n  top: 25%;\n  left: 6.7% /* rtl:ignore */;\n}\n.q-time__clock-pos-11 {\n  top: 6.7%;\n  left: 25% /* rtl:ignore */;\n}\n.q-time__clock-pos-12 {\n  top: 15%;\n  left: 50% /* rtl:ignore */;\n}\n.q-time__clock-pos-13 {\n  top: 19.69%;\n  left: 67.5% /* rtl:ignore */;\n}\n.q-time__clock-pos-14 {\n  top: 32.5%;\n  left: 80.31% /* rtl:ignore */;\n}\n.q-time__clock-pos-15 {\n  top: 50%;\n  left: 85% /* rtl:ignore */;\n}\n.q-time__clock-pos-16 {\n  top: 67.5%;\n  left: 80.31% /* rtl:ignore */;\n}\n.q-time__clock-pos-17 {\n  top: 80.31%;\n  left: 67.5% /* rtl:ignore */;\n}\n.q-time__clock-pos-18 {\n  top: 85%;\n  left: 50% /* rtl:ignore */;\n}\n.q-time__clock-pos-19 {\n  top: 80.31%;\n  left: 32.5% /* rtl:ignore */;\n}\n.q-time__clock-pos-20 {\n  top: 67.5%;\n  left: 19.69% /* rtl:ignore */;\n}\n.q-time__clock-pos-21 {\n  top: 50%;\n  left: 15% /* rtl:ignore */;\n}\n.q-time__clock-pos-22 {\n  top: 32.5%;\n  left: 19.69% /* rtl:ignore */;\n}\n.q-time__clock-pos-23 {\n  top: 19.69%;\n  left: 32.5% /* rtl:ignore */;\n}\n.q-time__now-button {\n  background-color: var(--q-primary);\n  color: #fff;\n  top: 12px;\n  right: 12px;\n}\n.q-time.disabled .q-time__header-ampm, .q-time.disabled .q-time__content, .q-time--readonly .q-time__header-ampm, .q-time--readonly .q-time__content {\n  pointer-events: none;\n}\n.q-time--portrait {\n  display: inline-flex;\n  flex-direction: column;\n}\n.q-time--portrait .q-time__header {\n  border-top-right-radius: inherit;\n  min-height: 86px;\n}\n.q-time--portrait .q-time__header-ampm {\n  margin-left: 12px;\n}\n.q-time--portrait.q-time--bordered .q-time__content {\n  margin: 1px 0;\n}\n.q-time--landscape {\n  display: inline-flex;\n  align-items: stretch;\n  min-width: 420px;\n}\n.q-time--landscape > div {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n}\n.q-time--landscape .q-time__header {\n  border-bottom-left-radius: inherit;\n  min-width: 156px;\n}\n.q-time--landscape .q-time__header-ampm {\n  margin-top: 12px;\n}\n.q-time--dark {\n  border-color: rgba(255, 255, 255, 0.28);\n}\n.q-timeline {\n  padding: 0;\n  width: 100%;\n  list-style: none;\n}\n.q-timeline h6 {\n  line-height: inherit;\n}\n.q-timeline--dark {\n  color: #fff;\n}\n.q-timeline--dark .q-timeline__subtitle {\n  opacity: 0.7;\n}\n.q-timeline__content {\n  padding-bottom: 24px;\n}\n.q-timeline__title {\n  margin-top: 0;\n  margin-bottom: 16px;\n}\n.q-timeline__subtitle {\n  font-size: 12px;\n  margin-bottom: 8px;\n  opacity: 0.6;\n  text-transform: uppercase;\n  letter-spacing: 1px;\n  font-weight: 700;\n}\n.q-timeline__dot {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  width: 15px;\n}\n.q-timeline__dot:before, .q-timeline__dot:after {\n  content: "";\n  background: currentColor;\n  display: block;\n  position: absolute;\n}\n.q-timeline__dot:before {\n  border: 3px solid transparent;\n  border-radius: 100%;\n  height: 15px;\n  width: 15px;\n  top: 4px;\n  left: 0;\n  transition: background 0.3s ease-in-out, border 0.3s ease-in-out;\n}\n.q-timeline__dot:after {\n  width: 3px;\n  opacity: 0.4;\n  top: 24px;\n  bottom: 0;\n  left: 6px;\n}\n.q-timeline__dot .q-icon {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  height: 38px;\n  line-height: 38px;\n  width: 100%;\n  color: #fff;\n}\n.q-timeline__dot .q-icon > svg,\n.q-timeline__dot .q-icon > img {\n  width: 1em;\n  height: 1em;\n}\n.q-timeline__dot-img {\n  position: absolute;\n  top: 4px;\n  left: 0;\n  right: 0;\n  height: 31px;\n  width: 31px;\n  background: currentColor;\n  border-radius: 50%;\n}\n.q-timeline__heading {\n  position: relative;\n}\n.q-timeline__heading:first-child .q-timeline__heading-title {\n  padding-top: 0;\n}\n.q-timeline__heading:last-child .q-timeline__heading-title {\n  padding-bottom: 0;\n}\n.q-timeline__heading-title {\n  padding: 32px 0;\n  margin: 0;\n}\n.q-timeline__entry {\n  position: relative;\n  line-height: 22px;\n}\n.q-timeline__entry:last-child {\n  padding-bottom: 0 !important;\n}\n.q-timeline__entry:last-child .q-timeline__dot:after {\n  content: none;\n}\n.q-timeline__entry--icon .q-timeline__dot {\n  width: 31px;\n}\n.q-timeline__entry--icon .q-timeline__dot:before {\n  height: 31px;\n  width: 31px;\n}\n.q-timeline__entry--icon .q-timeline__dot:after {\n  top: 41px;\n  left: 14px;\n}\n.q-timeline__entry--icon .q-timeline__subtitle {\n  padding-top: 8px;\n}\n.q-timeline--dense--right .q-timeline__entry {\n  padding-left: 40px;\n}\n.q-timeline--dense--right .q-timeline__entry--icon .q-timeline__dot {\n  left: -8px;\n}\n.q-timeline--dense--right .q-timeline__dot {\n  left: 0;\n}\n.q-timeline--dense--left .q-timeline__heading {\n  text-align: right;\n}\n.q-timeline--dense--left .q-timeline__entry {\n  padding-right: 40px;\n}\n.q-timeline--dense--left .q-timeline__entry--icon .q-timeline__dot {\n  right: -8px;\n}\n.q-timeline--dense--left .q-timeline__content, .q-timeline--dense--left .q-timeline__title, .q-timeline--dense--left .q-timeline__subtitle {\n  text-align: right;\n}\n.q-timeline--dense--left .q-timeline__dot {\n  right: 0;\n}\n.q-timeline--comfortable {\n  display: table;\n}\n.q-timeline--comfortable .q-timeline__heading {\n  display: table-row;\n  font-size: 200%;\n}\n.q-timeline--comfortable .q-timeline__heading > div {\n  display: table-cell;\n}\n.q-timeline--comfortable .q-timeline__entry {\n  display: table-row;\n  padding: 0;\n}\n.q-timeline--comfortable .q-timeline__entry--icon .q-timeline__content {\n  padding-top: 8px;\n}\n.q-timeline--comfortable .q-timeline__subtitle, .q-timeline--comfortable .q-timeline__dot, .q-timeline--comfortable .q-timeline__content {\n  display: table-cell;\n  vertical-align: top;\n}\n.q-timeline--comfortable .q-timeline__subtitle {\n  width: 35%;\n}\n.q-timeline--comfortable .q-timeline__dot {\n  position: relative;\n  min-width: 31px;\n}\n.q-timeline--comfortable--right .q-timeline__heading .q-timeline__heading-title {\n  margin-left: -50px;\n}\n.q-timeline--comfortable--right .q-timeline__subtitle {\n  text-align: right;\n  padding-right: 30px;\n}\n.q-timeline--comfortable--right .q-timeline__content {\n  padding-left: 30px;\n}\n.q-timeline--comfortable--right .q-timeline__entry--icon .q-timeline__dot {\n  left: -8px;\n}\n.q-timeline--comfortable--left .q-timeline__heading {\n  text-align: right;\n}\n.q-timeline--comfortable--left .q-timeline__heading .q-timeline__heading-title {\n  margin-right: -50px;\n}\n.q-timeline--comfortable--left .q-timeline__subtitle {\n  padding-left: 30px;\n}\n.q-timeline--comfortable--left .q-timeline__content {\n  padding-right: 30px;\n}\n.q-timeline--comfortable--left .q-timeline__content, .q-timeline--comfortable--left .q-timeline__title {\n  text-align: right;\n}\n.q-timeline--comfortable--left .q-timeline__entry--icon .q-timeline__dot {\n  right: 0;\n}\n.q-timeline--comfortable--left .q-timeline__dot {\n  right: -8px;\n}\n.q-timeline--loose .q-timeline__heading-title {\n  text-align: center;\n  margin-left: 0;\n}\n.q-timeline--loose .q-timeline__entry, .q-timeline--loose .q-timeline__subtitle, .q-timeline--loose .q-timeline__dot, .q-timeline--loose .q-timeline__content {\n  display: block;\n  margin: 0;\n  padding: 0;\n}\n.q-timeline--loose .q-timeline__dot {\n  position: absolute;\n  left: 50%;\n  margin-left: -7.15px;\n}\n.q-timeline--loose .q-timeline__entry {\n  padding-bottom: 24px;\n  overflow: hidden;\n}\n.q-timeline--loose .q-timeline__entry--icon .q-timeline__dot {\n  margin-left: -15px;\n}\n.q-timeline--loose .q-timeline__entry--icon .q-timeline__subtitle {\n  line-height: 38px;\n}\n.q-timeline--loose .q-timeline__entry--icon .q-timeline__content {\n  padding-top: 8px;\n}\n.q-timeline--loose .q-timeline__entry--left .q-timeline__content, .q-timeline--loose .q-timeline__entry--right .q-timeline__subtitle {\n  float: left;\n  padding-right: 30px;\n  text-align: right;\n}\n.q-timeline--loose .q-timeline__entry--left .q-timeline__subtitle, .q-timeline--loose .q-timeline__entry--right .q-timeline__content {\n  float: right;\n  text-align: left;\n  padding-left: 30px;\n}\n.q-timeline--loose .q-timeline__subtitle, .q-timeline--loose .q-timeline__content {\n  width: 50%;\n}\n.q-toggle {\n  vertical-align: middle;\n}\n.q-toggle__native {\n  width: 1px;\n  height: 1px;\n}\n.q-toggle__track {\n  height: 0.35em;\n  border-radius: 0.175em;\n  opacity: 0.38;\n  background: currentColor;\n}\n.q-toggle__thumb {\n  top: 0.25em;\n  left: 0.25em;\n  width: 0.5em;\n  height: 0.5em;\n  transition: left 0.22s cubic-bezier(0.4, 0, 0.2, 1);\n  -webkit-user-select: none;\n          user-select: none;\n  z-index: 0;\n}\n.q-toggle__thumb:after {\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  border-radius: 50%;\n  background: #fff;\n  box-shadow: 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);\n}\n.q-toggle__thumb .q-icon {\n  font-size: 0.3em;\n  min-width: 1em;\n  color: #000;\n  opacity: 0.54;\n  z-index: 1;\n}\n.q-toggle__inner {\n  font-size: 40px;\n  width: 1.4em;\n  min-width: 1.4em;\n  height: 1em;\n  padding: 0.325em 0.3em;\n  -webkit-print-color-adjust: exact;\n}\n.q-toggle__inner--indet .q-toggle__thumb {\n  left: 0.45em;\n}\n.q-toggle__inner--truthy {\n  color: var(--q-primary);\n}\n.q-toggle__inner--truthy .q-toggle__track {\n  opacity: 0.54;\n}\n.q-toggle__inner--truthy .q-toggle__thumb {\n  left: 0.65em;\n}\n.q-toggle__inner--truthy .q-toggle__thumb:after {\n  background-color: currentColor;\n}\n.q-toggle__inner--truthy .q-toggle__thumb .q-icon {\n  color: #fff;\n  opacity: 1;\n}\n.q-toggle.disabled {\n  opacity: 0.75 !important;\n}\n.q-toggle--dark .q-toggle__inner {\n  color: #fff;\n}\n.q-toggle--dark .q-toggle__inner--truthy {\n  color: var(--q-primary);\n}\n.q-toggle--dark .q-toggle__thumb:before {\n  opacity: 0.32 !important;\n}\n.q-toggle--dense .q-toggle__inner {\n  width: 0.8em;\n  min-width: 0.8em;\n  height: 0.5em;\n  padding: 0.07625em 0;\n}\n.q-toggle--dense .q-toggle__thumb {\n  top: 0;\n  left: 0;\n}\n.q-toggle--dense .q-toggle__inner--indet .q-toggle__thumb {\n  left: 0.15em;\n}\n.q-toggle--dense .q-toggle__inner--truthy .q-toggle__thumb {\n  left: 0.3em;\n}\n.q-toggle--dense .q-toggle__label {\n  padding-left: 0.5em;\n}\n.q-toggle--dense.reverse .q-toggle__label {\n  padding-left: 0;\n  padding-right: 0.5em;\n}\nbody.desktop .q-toggle:not(.disabled) .q-toggle__thumb:before {\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  border-radius: 50%;\n  background: currentColor;\n  opacity: 0.12;\n  transform: scale3d(0, 0, 1);\n  transition: transform 0.22s cubic-bezier(0, 0, 0.2, 1);\n}\nbody.desktop .q-toggle:not(.disabled):focus .q-toggle__thumb:before, body.desktop .q-toggle:not(.disabled):hover .q-toggle__thumb:before {\n  transform: scale3d(2, 2, 1);\n}\nbody.desktop .q-toggle--dense:not(.disabled):focus .q-toggle__thumb:before, body.desktop .q-toggle--dense:not(.disabled):hover .q-toggle__thumb:before {\n  transform: scale3d(1.5, 1.5, 1);\n}\n.q-toolbar {\n  position: relative;\n  padding: 0 12px;\n  min-height: 50px;\n  width: 100%;\n}\n.q-toolbar--inset {\n  padding-left: 58px;\n}\n.q-toolbar .q-avatar {\n  font-size: 38px;\n}\n.q-toolbar__title {\n  flex: 1 1 0%;\n  min-width: 1px;\n  max-width: 100%;\n  font-size: 21px;\n  font-weight: normal;\n  letter-spacing: 0.01em;\n  padding: 0 12px;\n}\n.q-toolbar__title:first-child {\n  padding-left: 0;\n}\n.q-toolbar__title:last-child {\n  padding-right: 0;\n}\n.q-tooltip--style {\n  font-size: 10px;\n  color: #fafafa;\n  background: #757575;\n  border-radius: 4px;\n  text-transform: none;\n  font-weight: normal;\n}\n.q-tooltip {\n  z-index: 9000;\n  position: fixed !important;\n  overflow-y: auto;\n  overflow-x: hidden;\n  padding: 6px 10px;\n}\n@media (max-width: 599.98px) {\n  .q-tooltip {\n    font-size: 14px;\n    padding: 8px 16px;\n  }\n}\n.q-tree {\n  position: relative;\n  color: #9e9e9e;\n}\n.q-tree__node {\n  padding: 0 0 3px 22px;\n}\n.q-tree__node:after {\n  content: "";\n  position: absolute;\n  top: -3px;\n  bottom: 0;\n  width: 2px;\n  right: auto;\n  left: -13px;\n  border-left: 1px solid currentColor;\n}\n.q-tree__node:last-child:after {\n  display: none;\n}\n.q-tree__node--disabled {\n  pointer-events: none;\n}\n.q-tree__node--disabled .disabled {\n  opacity: 1 !important;\n}\n.q-tree__node--disabled > div,\n.q-tree__node--disabled > i,\n.q-tree__node--disabled > .disabled {\n  opacity: 0.6 !important;\n}\n.q-tree__node--disabled > div .q-tree__node--disabled > div,\n.q-tree__node--disabled > div .q-tree__node--disabled > i,\n.q-tree__node--disabled > div .q-tree__node--disabled > .disabled,\n.q-tree__node--disabled > i .q-tree__node--disabled > div,\n.q-tree__node--disabled > i .q-tree__node--disabled > i,\n.q-tree__node--disabled > i .q-tree__node--disabled > .disabled,\n.q-tree__node--disabled > .disabled .q-tree__node--disabled > div,\n.q-tree__node--disabled > .disabled .q-tree__node--disabled > i,\n.q-tree__node--disabled > .disabled .q-tree__node--disabled > .disabled {\n  opacity: 1 !important;\n}\n.q-tree__node-header:before {\n  content: "";\n  position: absolute;\n  top: -3px;\n  bottom: 50%;\n  width: 31px;\n  left: -35px;\n  border-left: 1px solid currentColor;\n  border-bottom: 1px solid currentColor;\n}\n.q-tree__children {\n  padding-left: 25px;\n}\n.q-tree__node-body {\n  padding: 5px 0 8px 5px;\n}\n.q-tree__node--parent {\n  padding-left: 2px;\n}\n.q-tree__node--parent > .q-tree__node-header:before {\n  width: 15px;\n  left: -15px;\n}\n.q-tree__node--parent > .q-tree__node-collapsible > .q-tree__node-body {\n  padding: 5px 0 8px 27px;\n}\n.q-tree__node--parent > .q-tree__node-collapsible > .q-tree__node-body:after {\n  content: "";\n  position: absolute;\n  top: 0;\n  width: 2px;\n  height: 100%;\n  right: auto;\n  left: 12px;\n  border-left: 1px solid currentColor;\n  bottom: 50px;\n}\n.q-tree__node--link {\n  cursor: pointer;\n}\n.q-tree__node-header {\n  padding: 4px;\n  margin-top: 3px;\n  border-radius: 4px;\n  outline: 0;\n}\n.q-tree__node-header-content {\n  color: #000;\n  transition: color 0.3s;\n}\n.q-tree__node--selected .q-tree__node-header-content {\n  color: #9e9e9e;\n}\n.q-tree__icon, .q-tree__node-header-content .q-icon {\n  font-size: 21px;\n}\n.q-tree__img {\n  height: 42px;\n  border-radius: 2px;\n}\n.q-tree__avatar, .q-tree__node-header-content .q-avatar {\n  font-size: 28px;\n  border-radius: 50%;\n  width: 28px;\n  height: 28px;\n}\n.q-tree__arrow, .q-tree__spinner {\n  font-size: 16px;\n  margin-right: 4px;\n}\n.q-tree__arrow {\n  transition: transform 0.3s;\n}\n.q-tree__arrow--rotate {\n  transform: rotate3d(0, 0, 1, 90deg);\n}\n.q-tree__tickbox {\n  margin-right: 4px;\n}\n.q-tree > .q-tree__node {\n  padding: 0;\n}\n.q-tree > .q-tree__node:after, .q-tree > .q-tree__node > .q-tree__node-header:before {\n  display: none;\n}\n.q-tree > .q-tree__node--child > .q-tree__node-header {\n  padding-left: 24px;\n}\n.q-tree--dark .q-tree__node-header-content {\n  color: #fff;\n}\n.q-tree--no-connectors .q-tree__node:after,\n.q-tree--no-connectors .q-tree__node-header:before,\n.q-tree--no-connectors .q-tree__node-body:after {\n  display: none !important;\n}\n.q-tree--dense > .q-tree__node--child > .q-tree__node-header {\n  padding-left: 1px;\n}\n.q-tree--dense .q-tree__arrow, .q-tree--dense .q-tree__spinner {\n  margin-right: 1px;\n}\n.q-tree--dense .q-tree__img {\n  height: 32px;\n}\n.q-tree--dense .q-tree__tickbox {\n  margin-right: 3px;\n}\n.q-tree--dense .q-tree__node {\n  padding: 0;\n}\n.q-tree--dense .q-tree__node:after {\n  top: 0;\n  left: -8px;\n}\n.q-tree--dense .q-tree__node-header {\n  margin-top: 0;\n  padding: 1px;\n}\n.q-tree--dense .q-tree__node-header:before {\n  top: 0;\n  left: -8px;\n  width: 8px;\n}\n.q-tree--dense .q-tree__node--child {\n  padding-left: 17px;\n}\n.q-tree--dense .q-tree__node--child > .q-tree__node-header:before {\n  left: -25px;\n  width: 21px;\n}\n.q-tree--dense .q-tree__node-body {\n  padding: 0 0 2px;\n}\n.q-tree--dense .q-tree__node--parent > .q-tree__node-collapsible > .q-tree__node-body {\n  padding: 0 0 2px 20px;\n}\n.q-tree--dense .q-tree__node--parent > .q-tree__node-collapsible > .q-tree__node-body:after {\n  left: 8px;\n}\n.q-tree--dense .q-tree__children {\n  padding-left: 16px;\n}\n[dir=rtl] .q-tree__arrow {\n  transform: rotate3d(0, 0, 1, 180deg) /* rtl:ignore */;\n}\n[dir=rtl] .q-tree__arrow--rotate {\n  transform: rotate3d(0, 0, 1, 90deg) /* rtl:ignore */;\n}\n.q-uploader {\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n  border-radius: 4px;\n  vertical-align: top;\n  background: #fff;\n  position: relative;\n  width: 320px;\n  max-height: 320px;\n}\n.q-uploader--bordered {\n  border: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-uploader__input {\n  opacity: 0;\n  width: 100%;\n  height: 100%;\n  cursor: pointer !important;\n  z-index: 1;\n}\n.q-uploader__input::-webkit-file-upload-button {\n  cursor: pointer;\n}\n.q-uploader__file:before {\n  content: "";\n  border-top-left-radius: inherit;\n  border-top-right-radius: inherit;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  pointer-events: none;\n  background: currentColor;\n  opacity: 0.04;\n}\n.q-uploader__header {\n  position: relative;\n  border-top-left-radius: inherit;\n  border-top-right-radius: inherit;\n  background-color: var(--q-primary);\n  color: #fff;\n  width: 100%;\n}\n.q-uploader__spinner {\n  font-size: 24px;\n  margin-right: 4px;\n}\n.q-uploader__header-content {\n  padding: 8px;\n}\n.q-uploader__dnd {\n  outline: 1px dashed currentColor;\n  outline-offset: -4px;\n  background: rgba(255, 255, 255, 0.6);\n}\n.q-uploader__overlay {\n  font-size: 36px;\n  color: #000;\n  background-color: rgba(255, 255, 255, 0.6);\n}\n.q-uploader__list {\n  position: relative;\n  border-bottom-left-radius: inherit;\n  border-bottom-right-radius: inherit;\n  padding: 8px;\n  min-height: 60px;\n  flex: 1 1 auto;\n}\n.q-uploader__file {\n  border-radius: 4px 4px 0 0;\n  border: 1px solid rgba(0, 0, 0, 0.12);\n}\n.q-uploader__file .q-circular-progress {\n  font-size: 24px;\n}\n.q-uploader__file--img {\n  color: #fff;\n  height: 200px;\n  min-width: 200px;\n  background-position: 50% 50%;\n  background-size: cover;\n  background-repeat: no-repeat;\n}\n.q-uploader__file--img:before {\n  content: none;\n}\n.q-uploader__file--img .q-circular-progress {\n  color: #fff;\n}\n.q-uploader__file--img .q-uploader__file-header {\n  padding-bottom: 24px;\n  background: linear-gradient(to bottom, rgba(0, 0, 0, 0.7) 20%, rgba(255, 255, 255, 0));\n}\n.q-uploader__file + .q-uploader__file {\n  margin-top: 8px;\n}\n.q-uploader__file-header {\n  position: relative;\n  padding: 4px 8px;\n  border-top-left-radius: inherit;\n  border-top-right-radius: inherit;\n}\n.q-uploader__file-header-content {\n  padding-right: 8px;\n}\n.q-uploader__file-status {\n  font-size: 24px;\n  margin-right: 4px;\n}\n.q-uploader__title {\n  font-size: 14px;\n  font-weight: bold;\n  line-height: 18px;\n  word-break: break-word;\n}\n.q-uploader__subtitle {\n  font-size: 12px;\n  line-height: 18px;\n}\n.q-uploader--disable .q-uploader__header, .q-uploader--disable .q-uploader__list {\n  pointer-events: none;\n}\n.q-uploader--dark {\n  border-color: rgba(255, 255, 255, 0.28);\n}\n.q-uploader--dark .q-uploader__file {\n  border-color: rgba(255, 255, 255, 0.28);\n}\n.q-uploader--dark .q-uploader__dnd, .q-uploader--dark .q-uploader__overlay {\n  background: rgba(255, 255, 255, 0.3);\n}\n.q-uploader--dark .q-uploader__overlay {\n  color: #fff;\n}\nimg.responsive {\n  max-width: 100%;\n  height: auto;\n}\n.q-video {\n  position: relative;\n  overflow: hidden;\n  border-radius: inherit;\n}\n.q-video iframe,\n.q-video object,\n.q-video embed {\n  width: 100%;\n  height: 100%;\n}\n.q-video--responsive {\n  height: 0;\n}\n.q-video--responsive iframe,\n.q-video--responsive object,\n.q-video--responsive embed {\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n.q-virtual-scroll:focus {\n  outline: 0;\n}\n.q-virtual-scroll__content {\n  outline: none;\n  contain: content;\n}\n.q-virtual-scroll__content > * {\n  overflow-anchor: none;\n}\n.q-virtual-scroll__content > [data-q-vs-anchor] {\n  overflow-anchor: auto;\n}\n.q-virtual-scroll__padding {\n  background: linear-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 20%, rgba(128, 128, 128, 0.03) 20%, rgba(128, 128, 128, 0.08) 50%, rgba(128, 128, 128, 0.03) 80%, rgba(255, 255, 255, 0) 80%, rgba(255, 255, 255, 0)) /* rtl:ignore */;\n  background-size: var(--q-virtual-scroll-item-width, 100%) var(--q-virtual-scroll-item-height, 50px) /* rtl:ignore */;\n}\n.q-table .q-virtual-scroll__padding tr {\n  height: 0 !important;\n}\n.q-table .q-virtual-scroll__padding td {\n  padding: 0 !important;\n}\n.q-virtual-scroll--horizontal {\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  align-items: stretch;\n}\n.q-virtual-scroll--horizontal .q-virtual-scroll__content {\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n}\n.q-virtual-scroll--horizontal .q-virtual-scroll__padding, .q-virtual-scroll--horizontal .q-virtual-scroll__content, .q-virtual-scroll--horizontal .q-virtual-scroll__content > * {\n  flex: 0 0 auto;\n}\n.q-virtual-scroll--horizontal .q-virtual-scroll__padding {\n  background: linear-gradient(to left, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 20%, rgba(128, 128, 128, 0.03) 20%, rgba(128, 128, 128, 0.08) 50%, rgba(128, 128, 128, 0.03) 80%, rgba(255, 255, 255, 0) 80%, rgba(255, 255, 255, 0)) /* rtl:ignore */;\n  background-size: var(--q-virtual-scroll-item-width, 50px) var(--q-virtual-scroll-item-height, 100%) /* rtl:ignore */;\n}\n.q-ripple {\n  position: absolute;\n  top: 0;\n  left: 0 /* rtl:ignore */;\n  width: 100%;\n  height: 100%;\n  color: inherit;\n  border-radius: inherit;\n  z-index: 0;\n  pointer-events: none;\n  overflow: hidden;\n  contain: strict;\n}\n.q-ripple__inner {\n  position: absolute;\n  top: 0;\n  left: 0 /* rtl:ignore */;\n  opacity: 0;\n  color: inherit;\n  border-radius: 50%;\n  background: currentColor;\n  pointer-events: none;\n  will-change: transform, opacity;\n}\n.q-ripple__inner--enter {\n  transition: transform 0.225s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.1s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.q-ripple__inner--leave {\n  transition: opacity 0.25s cubic-bezier(0.4, 0, 0.2, 1);\n}\n.q-morph--invisible,\n.q-morph--internal {\n  opacity: 0 !important;\n  pointer-events: none !important;\n  position: fixed !important;\n  right: 200vw !important;\n  bottom: 200vh !important;\n}\n.q-loading {\n  color: #000;\n  position: fixed !important;\n}\n.q-loading__backdrop {\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  opacity: 0.5;\n  z-index: -1;\n  background-color: #000;\n  transition: background-color 0.28s;\n}\n.q-loading__box {\n  border-radius: 4px;\n  padding: 18px;\n  color: #fff;\n  max-width: 450px;\n}\n.q-loading__message {\n  margin: 40px 20px 0;\n  text-align: center;\n}\n.q-notifications__list {\n  z-index: 9500;\n  pointer-events: none;\n  left: 0;\n  right: 0;\n  margin-bottom: 10px;\n  position: relative;\n}\n.q-notifications__list--center {\n  top: 0;\n  bottom: 0;\n}\n.q-notifications__list--top {\n  top: 0;\n}\n.q-notifications__list--bottom {\n  bottom: 0;\n}\nbody.q-ios-padding .q-notifications__list--center, body.q-ios-padding .q-notifications__list--top {\n  top: 20px;\n  top: env(safe-area-inset-top);\n}\nbody.q-ios-padding .q-notifications__list--center, body.q-ios-padding .q-notifications__list--bottom {\n  bottom: env(safe-area-inset-bottom);\n}\n.q-notification {\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n  border-radius: 4px;\n  pointer-events: all;\n  display: inline-flex;\n  margin: 10px 10px 0;\n  transition: transform 1s, opacity 1s;\n  z-index: 9500;\n  flex-shrink: 0;\n  max-width: 95vw;\n  background: #323232;\n  color: #fff;\n  font-size: 14px;\n}\n.q-notification__icon {\n  font-size: 24px;\n  flex: 0 0 1em;\n}\n.q-notification__icon--additional {\n  margin-right: 16px;\n}\n.q-notification__avatar {\n  font-size: 32px;\n}\n.q-notification__avatar--additional {\n  margin-right: 8px;\n}\n.q-notification__spinner {\n  font-size: 32px;\n}\n.q-notification__spinner--additional {\n  margin-right: 8px;\n}\n.q-notification__message {\n  padding: 8px 0;\n}\n.q-notification__caption {\n  font-size: 0.9em;\n  opacity: 0.7;\n}\n.q-notification__actions {\n  color: var(--q-primary);\n}\n.q-notification__badge {\n  animation: q-notif-badge 0.42s;\n  padding: 4px 8px;\n  position: absolute;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2), 0 1px 1px rgba(0, 0, 0, 0.14), 0 2px 1px -1px rgba(0, 0, 0, 0.12);\n  background-color: var(--q-negative);\n  color: #fff;\n  border-radius: 4px;\n  font-size: 12px;\n  line-height: 12px;\n}\n.q-notification__badge--top-left, .q-notification__badge--top-right {\n  top: -6px;\n}\n.q-notification__badge--bottom-left, .q-notification__badge--bottom-right {\n  bottom: -6px;\n}\n.q-notification__badge--top-left, .q-notification__badge--bottom-left {\n  left: -22px;\n}\n.q-notification__badge--top-right, .q-notification__badge--bottom-right {\n  right: -22px;\n}\n.q-notification__progress {\n  z-index: -1;\n  position: absolute;\n  height: 3px;\n  bottom: 0;\n  left: -10px;\n  right: -10px;\n  animation: q-notif-progress linear;\n  background: currentColor;\n  opacity: 0.3;\n  border-radius: 4px 4px 0 0;\n  transform-origin: 0 50%;\n  transform: scaleX(0);\n}\n.q-notification--standard {\n  padding: 0 16px;\n  min-height: 48px;\n}\n.q-notification--standard .q-notification__actions {\n  padding: 6px 0 6px 8px;\n  margin-right: -8px;\n}\n.q-notification--multi-line {\n  min-height: 68px;\n  padding: 8px 16px;\n}\n.q-notification--multi-line .q-notification__badge--top-left, .q-notification--multi-line .q-notification__badge--top-right {\n  top: -15px;\n}\n.q-notification--multi-line .q-notification__badge--bottom-left, .q-notification--multi-line .q-notification__badge--bottom-right {\n  bottom: -15px;\n}\n.q-notification--multi-line .q-notification__progress {\n  bottom: -8px;\n}\n.q-notification--multi-line .q-notification__actions {\n  padding: 0;\n}\n.q-notification--multi-line .q-notification__actions--with-media {\n  padding-left: 25px;\n}\n.q-notification--top-left-enter-from, .q-notification--top-left-leave-to, .q-notification--top-enter-from, .q-notification--top-leave-to, .q-notification--top-right-enter-from, .q-notification--top-right-leave-to {\n  opacity: 0;\n  transform: translateY(-50px);\n  z-index: 9499;\n}\n.q-notification--left-enter-from, .q-notification--left-leave-to, .q-notification--center-enter-from, .q-notification--center-leave-to, .q-notification--right-enter-from, .q-notification--right-leave-to {\n  opacity: 0;\n  transform: rotateX(90deg);\n  z-index: 9499;\n}\n.q-notification--bottom-left-enter-from, .q-notification--bottom-left-leave-to, .q-notification--bottom-enter-from, .q-notification--bottom-leave-to, .q-notification--bottom-right-enter-from, .q-notification--bottom-right-leave-to {\n  opacity: 0;\n  transform: translateY(50px);\n  z-index: 9499;\n}\n.q-notification--top-left-leave-active, .q-notification--top-leave-active, .q-notification--top-right-leave-active, .q-notification--left-leave-active, .q-notification--center-leave-active, .q-notification--right-leave-active, .q-notification--bottom-left-leave-active, .q-notification--bottom-leave-active, .q-notification--bottom-right-leave-active {\n  position: absolute;\n  z-index: 9499;\n  margin-left: 0;\n  margin-right: 0;\n}\n.q-notification--top-leave-active, .q-notification--center-leave-active {\n  top: 0;\n}\n.q-notification--bottom-left-leave-active, .q-notification--bottom-leave-active, .q-notification--bottom-right-leave-active {\n  bottom: 0;\n}\n@media (min-width: 600px) {\n  .q-notification {\n    max-width: 65vw;\n  }\n}\n@keyframes q-notif-badge {\n  15% {\n    transform: translate3d(-25%, 0, 0) rotate3d(0, 0, 1, -5deg);\n  }\n  30% {\n    transform: translate3d(20%, 0, 0) rotate3d(0, 0, 1, 3deg);\n  }\n  45% {\n    transform: translate3d(-15%, 0, 0) rotate3d(0, 0, 1, -3deg);\n  }\n  60% {\n    transform: translate3d(10%, 0, 0) rotate3d(0, 0, 1, 2deg);\n  }\n  75% {\n    transform: translate3d(-5%, 0, 0) rotate3d(0, 0, 1, -1deg);\n  }\n}\n@keyframes q-notif-progress {\n  0% {\n    transform: scaleX(1);\n  }\n  100% {\n    transform: scaleX(0);\n  }\n}\n/* * Animate.css additions\n * * Adapted from: https:\n * */\n:root {\n  --animate-duration: 0.3s;\n  --animate-delay: 0.3s;\n  --animate-repeat: 1;\n}\n.animated {\n  animation-duration: var(--animate-duration);\n  animation-fill-mode: both;\n}\n.animated.infinite {\n  animation-iteration-count: infinite;\n}\n.animated.hinge {\n  animation-duration: 2s;\n}\n.animated.repeat-1 {\n  animation-iteration-count: var(--animate-repeat);\n}\n.animated.repeat-2 {\n  animation-iteration-count: calc(var(--animate-repeat) * 2);\n}\n.animated.repeat-3 {\n  animation-iteration-count: calc(var(--animate-repeat) * 3);\n}\n.animated.delay-1s {\n  animation-delay: var(--animate-delay);\n}\n.animated.delay-2s {\n  animation-delay: calc(var(--animate-delay) * 2);\n}\n.animated.delay-3s {\n  animation-delay: calc(var(--animate-delay) * 3);\n}\n.animated.delay-4s {\n  animation-delay: calc(var(--animate-delay) * 4);\n}\n.animated.delay-5s {\n  animation-delay: calc(var(--animate-delay) * 5);\n}\n.animated.faster {\n  animation-duration: calc(var(--animate-duration) / 2);\n}\n.animated.fast {\n  animation-duration: calc(var(--animate-duration) * 0.8);\n}\n.animated.slow {\n  animation-duration: calc(var(--animate-duration) * 2);\n}\n.animated.slower {\n  animation-duration: calc(var(--animate-duration) * 3);\n}\n@media print, (prefers-reduced-motion: reduce) {\n  .animated {\n    animation-duration: 1ms !important;\n    transition-duration: 1ms !important;\n    animation-iteration-count: 1 !important;\n  }\n\n  .animated[class*=Out] {\n    opacity: 0;\n  }\n}\n.q-animate--scale {\n  animation: q-scale 0.15s;\n  animation-timing-function: cubic-bezier(0.25, 0.8, 0.25, 1);\n}\n@keyframes q-scale {\n  0% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(1.04);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n.q-animate--fade {\n  animation: q-fade 0.2s /* rtl:ignore */;\n}\n@keyframes q-fade {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n:root {\n  --q-primary: #47e0fb88;\n  --q-secondary: #26A69A11;\n  --q-accent: #9C27B0DD;\n  --q-positive: #21BA4588;\n  --q-negative: #C1001588;\n  --q-info: #1e7b7088;\n  --q-warning: #F2C03788;\n  --q-dark: #1d1d1d11;\n  --q-dark-page: #121212FF;\n}\n.text-dark {\n  color: var(--q-dark) !important;\n}\n.bg-dark {\n  background: var(--q-dark) !important;\n}\n.text-primary {\n  color: var(--q-primary) !important;\n}\n.bg-primary {\n  background: var(--q-primary) !important;\n}\n.text-secondary {\n  color: var(--q-secondary) !important;\n}\n.bg-secondary {\n  background: var(--q-secondary) !important;\n}\n.text-accent {\n  color: var(--q-accent) !important;\n}\n.bg-accent {\n  background: var(--q-accent) !important;\n}\n.text-positive {\n  color: var(--q-positive) !important;\n}\n.bg-positive {\n  background: var(--q-positive) !important;\n}\n.text-negative {\n  color: var(--q-negative) !important;\n}\n.bg-negative {\n  background: var(--q-negative) !important;\n}\n.text-info {\n  color: var(--q-info) !important;\n}\n.bg-info {\n  background: var(--q-info) !important;\n}\n.text-warning {\n  color: var(--q-warning) !important;\n}\n.bg-warning {\n  background: var(--q-warning) !important;\n}\n.text-white {\n  color: #fff !important;\n}\n.bg-white {\n  background: #fff !important;\n}\n.text-black {\n  color: #000 !important;\n}\n.bg-black {\n  background: #000 !important;\n}\n.text-transparent {\n  color: transparent !important;\n}\n.bg-transparent {\n  background: transparent !important;\n}\n.text-separator {\n  color: rgba(0, 0, 0, 0.12) !important;\n}\n.bg-separator {\n  background: rgba(0, 0, 0, 0.12) !important;\n}\n.text-dark-separator {\n  color: rgba(255, 255, 255, 0.28) !important;\n}\n.bg-dark-separator {\n  background: rgba(255, 255, 255, 0.28) !important;\n}\n.text-red {\n  color: #f44336 !important;\n}\n.text-red-1 {\n  color: #ffebee !important;\n}\n.text-red-2 {\n  color: #ffcdd2 !important;\n}\n.text-red-3 {\n  color: #ef9a9a !important;\n}\n.text-red-4 {\n  color: #e57373 !important;\n}\n.text-red-5 {\n  color: #ef5350 !important;\n}\n.text-red-6 {\n  color: #f44336 !important;\n}\n.text-red-7 {\n  color: #e53935 !important;\n}\n.text-red-8 {\n  color: #d32f2f !important;\n}\n.text-red-9 {\n  color: #c62828 !important;\n}\n.text-red-10 {\n  color: #b71c1c !important;\n}\n.text-red-11 {\n  color: #ff8a80 !important;\n}\n.text-red-12 {\n  color: #ff5252 !important;\n}\n.text-red-13 {\n  color: #ff1744 !important;\n}\n.text-red-14 {\n  color: #d50000 !important;\n}\n.text-pink {\n  color: #e91e63 !important;\n}\n.text-pink-1 {\n  color: #fce4ec !important;\n}\n.text-pink-2 {\n  color: #f8bbd0 !important;\n}\n.text-pink-3 {\n  color: #f48fb1 !important;\n}\n.text-pink-4 {\n  color: #f06292 !important;\n}\n.text-pink-5 {\n  color: #ec407a !important;\n}\n.text-pink-6 {\n  color: #e91e63 !important;\n}\n.text-pink-7 {\n  color: #d81b60 !important;\n}\n.text-pink-8 {\n  color: #c2185b !important;\n}\n.text-pink-9 {\n  color: #ad1457 !important;\n}\n.text-pink-10 {\n  color: #880e4f !important;\n}\n.text-pink-11 {\n  color: #ff80ab !important;\n}\n.text-pink-12 {\n  color: #ff4081 !important;\n}\n.text-pink-13 {\n  color: #f50057 !important;\n}\n.text-pink-14 {\n  color: #c51162 !important;\n}\n.text-purple {\n  color: #9c27b0 !important;\n}\n.text-purple-1 {\n  color: #f3e5f5 !important;\n}\n.text-purple-2 {\n  color: #e1bee7 !important;\n}\n.text-purple-3 {\n  color: #ce93d8 !important;\n}\n.text-purple-4 {\n  color: #ba68c8 !important;\n}\n.text-purple-5 {\n  color: #ab47bc !important;\n}\n.text-purple-6 {\n  color: #9c27b0 !important;\n}\n.text-purple-7 {\n  color: #8e24aa !important;\n}\n.text-purple-8 {\n  color: #7b1fa2 !important;\n}\n.text-purple-9 {\n  color: #6a1b9a !important;\n}\n.text-purple-10 {\n  color: #4a148c !important;\n}\n.text-purple-11 {\n  color: #ea80fc !important;\n}\n.text-purple-12 {\n  color: #e040fb !important;\n}\n.text-purple-13 {\n  color: #d500f9 !important;\n}\n.text-purple-14 {\n  color: #aa00ff !important;\n}\n.text-deep-purple {\n  color: #673ab7 !important;\n}\n.text-deep-purple-1 {\n  color: #ede7f6 !important;\n}\n.text-deep-purple-2 {\n  color: #d1c4e9 !important;\n}\n.text-deep-purple-3 {\n  color: #b39ddb !important;\n}\n.text-deep-purple-4 {\n  color: #9575cd !important;\n}\n.text-deep-purple-5 {\n  color: #7e57c2 !important;\n}\n.text-deep-purple-6 {\n  color: #673ab7 !important;\n}\n.text-deep-purple-7 {\n  color: #5e35b1 !important;\n}\n.text-deep-purple-8 {\n  color: #512da8 !important;\n}\n.text-deep-purple-9 {\n  color: #4527a0 !important;\n}\n.text-deep-purple-10 {\n  color: #311b92 !important;\n}\n.text-deep-purple-11 {\n  color: #b388ff !important;\n}\n.text-deep-purple-12 {\n  color: #7c4dff !important;\n}\n.text-deep-purple-13 {\n  color: #651fff !important;\n}\n.text-deep-purple-14 {\n  color: #6200ea !important;\n}\n.text-indigo {\n  color: #3f51b5 !important;\n}\n.text-indigo-1 {\n  color: #e8eaf6 !important;\n}\n.text-indigo-2 {\n  color: #c5cae9 !important;\n}\n.text-indigo-3 {\n  color: #9fa8da !important;\n}\n.text-indigo-4 {\n  color: #7986cb !important;\n}\n.text-indigo-5 {\n  color: #5c6bc0 !important;\n}\n.text-indigo-6 {\n  color: #3f51b5 !important;\n}\n.text-indigo-7 {\n  color: #3949ab !important;\n}\n.text-indigo-8 {\n  color: #303f9f !important;\n}\n.text-indigo-9 {\n  color: #283593 !important;\n}\n.text-indigo-10 {\n  color: #1a237e !important;\n}\n.text-indigo-11 {\n  color: #8c9eff !important;\n}\n.text-indigo-12 {\n  color: #536dfe !important;\n}\n.text-indigo-13 {\n  color: #3d5afe !important;\n}\n.text-indigo-14 {\n  color: #304ffe !important;\n}\n.text-blue {\n  color: #2196f3 !important;\n}\n.text-blue-1 {\n  color: #e3f2fd !important;\n}\n.text-blue-2 {\n  color: #bbdefb !important;\n}\n.text-blue-3 {\n  color: #90caf9 !important;\n}\n.text-blue-4 {\n  color: #64b5f6 !important;\n}\n.text-blue-5 {\n  color: #42a5f5 !important;\n}\n.text-blue-6 {\n  color: #2196f3 !important;\n}\n.text-blue-7 {\n  color: #1e88e5 !important;\n}\n.text-blue-8 {\n  color: #1976d2 !important;\n}\n.text-blue-9 {\n  color: #1565c0 !important;\n}\n.text-blue-10 {\n  color: #0d47a1 !important;\n}\n.text-blue-11 {\n  color: #82b1ff !important;\n}\n.text-blue-12 {\n  color: #448aff !important;\n}\n.text-blue-13 {\n  color: #2979ff !important;\n}\n.text-blue-14 {\n  color: #2962ff !important;\n}\n.text-light-blue {\n  color: #03a9f4 !important;\n}\n.text-light-blue-1 {\n  color: #e1f5fe !important;\n}\n.text-light-blue-2 {\n  color: #b3e5fc !important;\n}\n.text-light-blue-3 {\n  color: #81d4fa !important;\n}\n.text-light-blue-4 {\n  color: #4fc3f7 !important;\n}\n.text-light-blue-5 {\n  color: #29b6f6 !important;\n}\n.text-light-blue-6 {\n  color: #03a9f4 !important;\n}\n.text-light-blue-7 {\n  color: #039be5 !important;\n}\n.text-light-blue-8 {\n  color: #0288d1 !important;\n}\n.text-light-blue-9 {\n  color: #0277bd !important;\n}\n.text-light-blue-10 {\n  color: #01579b !important;\n}\n.text-light-blue-11 {\n  color: #80d8ff !important;\n}\n.text-light-blue-12 {\n  color: #40c4ff !important;\n}\n.text-light-blue-13 {\n  color: #00b0ff !important;\n}\n.text-light-blue-14 {\n  color: #0091ea !important;\n}\n.text-cyan {\n  color: #00bcd4 !important;\n}\n.text-cyan-1 {\n  color: #e0f7fa !important;\n}\n.text-cyan-2 {\n  color: #b2ebf2 !important;\n}\n.text-cyan-3 {\n  color: #80deea !important;\n}\n.text-cyan-4 {\n  color: #4dd0e1 !important;\n}\n.text-cyan-5 {\n  color: #26c6da !important;\n}\n.text-cyan-6 {\n  color: #00bcd4 !important;\n}\n.text-cyan-7 {\n  color: #00acc1 !important;\n}\n.text-cyan-8 {\n  color: #0097a7 !important;\n}\n.text-cyan-9 {\n  color: #00838f !important;\n}\n.text-cyan-10 {\n  color: #006064 !important;\n}\n.text-cyan-11 {\n  color: #84ffff !important;\n}\n.text-cyan-12 {\n  color: #18ffff !important;\n}\n.text-cyan-13 {\n  color: #00e5ff !important;\n}\n.text-cyan-14 {\n  color: #00b8d4 !important;\n}\n.text-teal {\n  color: #009688 !important;\n}\n.text-teal-1 {\n  color: #e0f2f1 !important;\n}\n.text-teal-2 {\n  color: #b2dfdb !important;\n}\n.text-teal-3 {\n  color: #80cbc4 !important;\n}\n.text-teal-4 {\n  color: #4db6ac !important;\n}\n.text-teal-5 {\n  color: #26a69a !important;\n}\n.text-teal-6 {\n  color: #009688 !important;\n}\n.text-teal-7 {\n  color: #00897b !important;\n}\n.text-teal-8 {\n  color: #00796b !important;\n}\n.text-teal-9 {\n  color: #00695c !important;\n}\n.text-teal-10 {\n  color: #004d40 !important;\n}\n.text-teal-11 {\n  color: #a7ffeb !important;\n}\n.text-teal-12 {\n  color: #64ffda !important;\n}\n.text-teal-13 {\n  color: #1de9b6 !important;\n}\n.text-teal-14 {\n  color: #00bfa5 !important;\n}\n.text-green {\n  color: #4caf50 !important;\n}\n.text-green-1 {\n  color: #e8f5e9 !important;\n}\n.text-green-2 {\n  color: #c8e6c9 !important;\n}\n.text-green-3 {\n  color: #a5d6a7 !important;\n}\n.text-green-4 {\n  color: #81c784 !important;\n}\n.text-green-5 {\n  color: #66bb6a !important;\n}\n.text-green-6 {\n  color: #4caf50 !important;\n}\n.text-green-7 {\n  color: #43a047 !important;\n}\n.text-green-8 {\n  color: #388e3c !important;\n}\n.text-green-9 {\n  color: #2e7d32 !important;\n}\n.text-green-10 {\n  color: #1b5e20 !important;\n}\n.text-green-11 {\n  color: #b9f6ca !important;\n}\n.text-green-12 {\n  color: #69f0ae !important;\n}\n.text-green-13 {\n  color: #00e676 !important;\n}\n.text-green-14 {\n  color: #00c853 !important;\n}\n.text-light-green {\n  color: #8bc34a !important;\n}\n.text-light-green-1 {\n  color: #f1f8e9 !important;\n}\n.text-light-green-2 {\n  color: #dcedc8 !important;\n}\n.text-light-green-3 {\n  color: #c5e1a5 !important;\n}\n.text-light-green-4 {\n  color: #aed581 !important;\n}\n.text-light-green-5 {\n  color: #9ccc65 !important;\n}\n.text-light-green-6 {\n  color: #8bc34a !important;\n}\n.text-light-green-7 {\n  color: #7cb342 !important;\n}\n.text-light-green-8 {\n  color: #689f38 !important;\n}\n.text-light-green-9 {\n  color: #558b2f !important;\n}\n.text-light-green-10 {\n  color: #33691e !important;\n}\n.text-light-green-11 {\n  color: #ccff90 !important;\n}\n.text-light-green-12 {\n  color: #b2ff59 !important;\n}\n.text-light-green-13 {\n  color: #76ff03 !important;\n}\n.text-light-green-14 {\n  color: #64dd17 !important;\n}\n.text-lime {\n  color: #cddc39 !important;\n}\n.text-lime-1 {\n  color: #f9fbe7 !important;\n}\n.text-lime-2 {\n  color: #f0f4c3 !important;\n}\n.text-lime-3 {\n  color: #e6ee9c !important;\n}\n.text-lime-4 {\n  color: #dce775 !important;\n}\n.text-lime-5 {\n  color: #d4e157 !important;\n}\n.text-lime-6 {\n  color: #cddc39 !important;\n}\n.text-lime-7 {\n  color: #c0ca33 !important;\n}\n.text-lime-8 {\n  color: #afb42b !important;\n}\n.text-lime-9 {\n  color: #9e9d24 !important;\n}\n.text-lime-10 {\n  color: #827717 !important;\n}\n.text-lime-11 {\n  color: #f4ff81 !important;\n}\n.text-lime-12 {\n  color: #eeff41 !important;\n}\n.text-lime-13 {\n  color: #c6ff00 !important;\n}\n.text-lime-14 {\n  color: #aeea00 !important;\n}\n.text-yellow {\n  color: #ffeb3b !important;\n}\n.text-yellow-1 {\n  color: #fffde7 !important;\n}\n.text-yellow-2 {\n  color: #fff9c4 !important;\n}\n.text-yellow-3 {\n  color: #fff59d !important;\n}\n.text-yellow-4 {\n  color: #fff176 !important;\n}\n.text-yellow-5 {\n  color: #ffee58 !important;\n}\n.text-yellow-6 {\n  color: #ffeb3b !important;\n}\n.text-yellow-7 {\n  color: #fdd835 !important;\n}\n.text-yellow-8 {\n  color: #fbc02d !important;\n}\n.text-yellow-9 {\n  color: #f9a825 !important;\n}\n.text-yellow-10 {\n  color: #f57f17 !important;\n}\n.text-yellow-11 {\n  color: #ffff8d !important;\n}\n.text-yellow-12 {\n  color: #ffff00 !important;\n}\n.text-yellow-13 {\n  color: #ffea00 !important;\n}\n.text-yellow-14 {\n  color: #ffd600 !important;\n}\n.text-amber {\n  color: #ffc107 !important;\n}\n.text-amber-1 {\n  color: #fff8e1 !important;\n}\n.text-amber-2 {\n  color: #ffecb3 !important;\n}\n.text-amber-3 {\n  color: #ffe082 !important;\n}\n.text-amber-4 {\n  color: #ffd54f !important;\n}\n.text-amber-5 {\n  color: #ffca28 !important;\n}\n.text-amber-6 {\n  color: #ffc107 !important;\n}\n.text-amber-7 {\n  color: #ffb300 !important;\n}\n.text-amber-8 {\n  color: #ffa000 !important;\n}\n.text-amber-9 {\n  color: #ff8f00 !important;\n}\n.text-amber-10 {\n  color: #ff6f00 !important;\n}\n.text-amber-11 {\n  color: #ffe57f !important;\n}\n.text-amber-12 {\n  color: #ffd740 !important;\n}\n.text-amber-13 {\n  color: #ffc400 !important;\n}\n.text-amber-14 {\n  color: #ffab00 !important;\n}\n.text-orange {\n  color: #ff9800 !important;\n}\n.text-orange-1 {\n  color: #fff3e0 !important;\n}\n.text-orange-2 {\n  color: #ffe0b2 !important;\n}\n.text-orange-3 {\n  color: #ffcc80 !important;\n}\n.text-orange-4 {\n  color: #ffb74d !important;\n}\n.text-orange-5 {\n  color: #ffa726 !important;\n}\n.text-orange-6 {\n  color: #ff9800 !important;\n}\n.text-orange-7 {\n  color: #fb8c00 !important;\n}\n.text-orange-8 {\n  color: #f57c00 !important;\n}\n.text-orange-9 {\n  color: #ef6c00 !important;\n}\n.text-orange-10 {\n  color: #e65100 !important;\n}\n.text-orange-11 {\n  color: #ffd180 !important;\n}\n.text-orange-12 {\n  color: #ffab40 !important;\n}\n.text-orange-13 {\n  color: #ff9100 !important;\n}\n.text-orange-14 {\n  color: #ff6d00 !important;\n}\n.text-deep-orange {\n  color: #ff5722 !important;\n}\n.text-deep-orange-1 {\n  color: #fbe9e7 !important;\n}\n.text-deep-orange-2 {\n  color: #ffccbc !important;\n}\n.text-deep-orange-3 {\n  color: #ffab91 !important;\n}\n.text-deep-orange-4 {\n  color: #ff8a65 !important;\n}\n.text-deep-orange-5 {\n  color: #ff7043 !important;\n}\n.text-deep-orange-6 {\n  color: #ff5722 !important;\n}\n.text-deep-orange-7 {\n  color: #f4511e !important;\n}\n.text-deep-orange-8 {\n  color: #e64a19 !important;\n}\n.text-deep-orange-9 {\n  color: #d84315 !important;\n}\n.text-deep-orange-10 {\n  color: #bf360c !important;\n}\n.text-deep-orange-11 {\n  color: #ff9e80 !important;\n}\n.text-deep-orange-12 {\n  color: #ff6e40 !important;\n}\n.text-deep-orange-13 {\n  color: #ff3d00 !important;\n}\n.text-deep-orange-14 {\n  color: #dd2c00 !important;\n}\n.text-brown {\n  color: #795548 !important;\n}\n.text-brown-1 {\n  color: #efebe9 !important;\n}\n.text-brown-2 {\n  color: #d7ccc8 !important;\n}\n.text-brown-3 {\n  color: #bcaaa4 !important;\n}\n.text-brown-4 {\n  color: #a1887f !important;\n}\n.text-brown-5 {\n  color: #8d6e63 !important;\n}\n.text-brown-6 {\n  color: #795548 !important;\n}\n.text-brown-7 {\n  color: #6d4c41 !important;\n}\n.text-brown-8 {\n  color: #5d4037 !important;\n}\n.text-brown-9 {\n  color: #4e342e !important;\n}\n.text-brown-10 {\n  color: #3e2723 !important;\n}\n.text-brown-11 {\n  color: #d7ccc8 !important;\n}\n.text-brown-12 {\n  color: #bcaaa4 !important;\n}\n.text-brown-13 {\n  color: #8d6e63 !important;\n}\n.text-brown-14 {\n  color: #5d4037 !important;\n}\n.text-grey {\n  color: #9e9e9e !important;\n}\n.text-grey-1 {\n  color: #fafafa !important;\n}\n.text-grey-2 {\n  color: #f5f5f5 !important;\n}\n.text-grey-3 {\n  color: #eeeeee !important;\n}\n.text-grey-4 {\n  color: #e0e0e0 !important;\n}\n.text-grey-5 {\n  color: #bdbdbd !important;\n}\n.text-grey-6 {\n  color: #9e9e9e !important;\n}\n.text-grey-7 {\n  color: #757575 !important;\n}\n.text-grey-8 {\n  color: #616161 !important;\n}\n.text-grey-9 {\n  color: #424242 !important;\n}\n.text-grey-10 {\n  color: #212121 !important;\n}\n.text-grey-11 {\n  color: #f5f5f5 !important;\n}\n.text-grey-12 {\n  color: #eeeeee !important;\n}\n.text-grey-13 {\n  color: #bdbdbd !important;\n}\n.text-grey-14 {\n  color: #616161 !important;\n}\n.text-blue-grey {\n  color: #607d8b !important;\n}\n.text-blue-grey-1 {\n  color: #eceff1 !important;\n}\n.text-blue-grey-2 {\n  color: #cfd8dc !important;\n}\n.text-blue-grey-3 {\n  color: #b0bec5 !important;\n}\n.text-blue-grey-4 {\n  color: #90a4ae !important;\n}\n.text-blue-grey-5 {\n  color: #78909c !important;\n}\n.text-blue-grey-6 {\n  color: #607d8b !important;\n}\n.text-blue-grey-7 {\n  color: #546e7a !important;\n}\n.text-blue-grey-8 {\n  color: #455a64 !important;\n}\n.text-blue-grey-9 {\n  color: #37474f !important;\n}\n.text-blue-grey-10 {\n  color: #263238 !important;\n}\n.text-blue-grey-11 {\n  color: #cfd8dc !important;\n}\n.text-blue-grey-12 {\n  color: #b0bec5 !important;\n}\n.text-blue-grey-13 {\n  color: #78909c !important;\n}\n.text-blue-grey-14 {\n  color: #455a64 !important;\n}\n.bg-red {\n  background: #f44336 !important;\n}\n.bg-red-1 {\n  background: #ffebee !important;\n}\n.bg-red-2 {\n  background: #ffcdd2 !important;\n}\n.bg-red-3 {\n  background: #ef9a9a !important;\n}\n.bg-red-4 {\n  background: #e57373 !important;\n}\n.bg-red-5 {\n  background: #ef5350 !important;\n}\n.bg-red-6 {\n  background: #f44336 !important;\n}\n.bg-red-7 {\n  background: #e53935 !important;\n}\n.bg-red-8 {\n  background: #d32f2f !important;\n}\n.bg-red-9 {\n  background: #c62828 !important;\n}\n.bg-red-10 {\n  background: #b71c1c !important;\n}\n.bg-red-11 {\n  background: #ff8a80 !important;\n}\n.bg-red-12 {\n  background: #ff5252 !important;\n}\n.bg-red-13 {\n  background: #ff1744 !important;\n}\n.bg-red-14 {\n  background: #d50000 !important;\n}\n.bg-pink {\n  background: #e91e63 !important;\n}\n.bg-pink-1 {\n  background: #fce4ec !important;\n}\n.bg-pink-2 {\n  background: #f8bbd0 !important;\n}\n.bg-pink-3 {\n  background: #f48fb1 !important;\n}\n.bg-pink-4 {\n  background: #f06292 !important;\n}\n.bg-pink-5 {\n  background: #ec407a !important;\n}\n.bg-pink-6 {\n  background: #e91e63 !important;\n}\n.bg-pink-7 {\n  background: #d81b60 !important;\n}\n.bg-pink-8 {\n  background: #c2185b !important;\n}\n.bg-pink-9 {\n  background: #ad1457 !important;\n}\n.bg-pink-10 {\n  background: #880e4f !important;\n}\n.bg-pink-11 {\n  background: #ff80ab !important;\n}\n.bg-pink-12 {\n  background: #ff4081 !important;\n}\n.bg-pink-13 {\n  background: #f50057 !important;\n}\n.bg-pink-14 {\n  background: #c51162 !important;\n}\n.bg-purple {\n  background: #9c27b0 !important;\n}\n.bg-purple-1 {\n  background: #f3e5f5 !important;\n}\n.bg-purple-2 {\n  background: #e1bee7 !important;\n}\n.bg-purple-3 {\n  background: #ce93d8 !important;\n}\n.bg-purple-4 {\n  background: #ba68c8 !important;\n}\n.bg-purple-5 {\n  background: #ab47bc !important;\n}\n.bg-purple-6 {\n  background: #9c27b0 !important;\n}\n.bg-purple-7 {\n  background: #8e24aa !important;\n}\n.bg-purple-8 {\n  background: #7b1fa2 !important;\n}\n.bg-purple-9 {\n  background: #6a1b9a !important;\n}\n.bg-purple-10 {\n  background: #4a148c !important;\n}\n.bg-purple-11 {\n  background: #ea80fc !important;\n}\n.bg-purple-12 {\n  background: #e040fb !important;\n}\n.bg-purple-13 {\n  background: #d500f9 !important;\n}\n.bg-purple-14 {\n  background: #aa00ff !important;\n}\n.bg-deep-purple {\n  background: #673ab7 !important;\n}\n.bg-deep-purple-1 {\n  background: #ede7f6 !important;\n}\n.bg-deep-purple-2 {\n  background: #d1c4e9 !important;\n}\n.bg-deep-purple-3 {\n  background: #b39ddb !important;\n}\n.bg-deep-purple-4 {\n  background: #9575cd !important;\n}\n.bg-deep-purple-5 {\n  background: #7e57c2 !important;\n}\n.bg-deep-purple-6 {\n  background: #673ab7 !important;\n}\n.bg-deep-purple-7 {\n  background: #5e35b1 !important;\n}\n.bg-deep-purple-8 {\n  background: #512da8 !important;\n}\n.bg-deep-purple-9 {\n  background: #4527a0 !important;\n}\n.bg-deep-purple-10 {\n  background: #311b92 !important;\n}\n.bg-deep-purple-11 {\n  background: #b388ff !important;\n}\n.bg-deep-purple-12 {\n  background: #7c4dff !important;\n}\n.bg-deep-purple-13 {\n  background: #651fff !important;\n}\n.bg-deep-purple-14 {\n  background: #6200ea !important;\n}\n.bg-indigo {\n  background: #3f51b5 !important;\n}\n.bg-indigo-1 {\n  background: #e8eaf6 !important;\n}\n.bg-indigo-2 {\n  background: #c5cae9 !important;\n}\n.bg-indigo-3 {\n  background: #9fa8da !important;\n}\n.bg-indigo-4 {\n  background: #7986cb !important;\n}\n.bg-indigo-5 {\n  background: #5c6bc0 !important;\n}\n.bg-indigo-6 {\n  background: #3f51b5 !important;\n}\n.bg-indigo-7 {\n  background: #3949ab !important;\n}\n.bg-indigo-8 {\n  background: #303f9f !important;\n}\n.bg-indigo-9 {\n  background: #283593 !important;\n}\n.bg-indigo-10 {\n  background: #1a237e !important;\n}\n.bg-indigo-11 {\n  background: #8c9eff !important;\n}\n.bg-indigo-12 {\n  background: #536dfe !important;\n}\n.bg-indigo-13 {\n  background: #3d5afe !important;\n}\n.bg-indigo-14 {\n  background: #304ffe !important;\n}\n.bg-blue {\n  background: #2196f3 !important;\n}\n.bg-blue-1 {\n  background: #e3f2fd !important;\n}\n.bg-blue-2 {\n  background: #bbdefb !important;\n}\n.bg-blue-3 {\n  background: #90caf9 !important;\n}\n.bg-blue-4 {\n  background: #64b5f6 !important;\n}\n.bg-blue-5 {\n  background: #42a5f5 !important;\n}\n.bg-blue-6 {\n  background: #2196f3 !important;\n}\n.bg-blue-7 {\n  background: #1e88e5 !important;\n}\n.bg-blue-8 {\n  background: #1976d2 !important;\n}\n.bg-blue-9 {\n  background: #1565c0 !important;\n}\n.bg-blue-10 {\n  background: #0d47a1 !important;\n}\n.bg-blue-11 {\n  background: #82b1ff !important;\n}\n.bg-blue-12 {\n  background: #448aff !important;\n}\n.bg-blue-13 {\n  background: #2979ff !important;\n}\n.bg-blue-14 {\n  background: #2962ff !important;\n}\n.bg-light-blue {\n  background: #03a9f4 !important;\n}\n.bg-light-blue-1 {\n  background: #e1f5fe !important;\n}\n.bg-light-blue-2 {\n  background: #b3e5fc !important;\n}\n.bg-light-blue-3 {\n  background: #81d4fa !important;\n}\n.bg-light-blue-4 {\n  background: #4fc3f7 !important;\n}\n.bg-light-blue-5 {\n  background: #29b6f6 !important;\n}\n.bg-light-blue-6 {\n  background: #03a9f4 !important;\n}\n.bg-light-blue-7 {\n  background: #039be5 !important;\n}\n.bg-light-blue-8 {\n  background: #0288d1 !important;\n}\n.bg-light-blue-9 {\n  background: #0277bd !important;\n}\n.bg-light-blue-10 {\n  background: #01579b !important;\n}\n.bg-light-blue-11 {\n  background: #80d8ff !important;\n}\n.bg-light-blue-12 {\n  background: #40c4ff !important;\n}\n.bg-light-blue-13 {\n  background: #00b0ff !important;\n}\n.bg-light-blue-14 {\n  background: #0091ea !important;\n}\n.bg-cyan {\n  background: #00bcd4 !important;\n}\n.bg-cyan-1 {\n  background: #e0f7fa !important;\n}\n.bg-cyan-2 {\n  background: #b2ebf2 !important;\n}\n.bg-cyan-3 {\n  background: #80deea !important;\n}\n.bg-cyan-4 {\n  background: #4dd0e1 !important;\n}\n.bg-cyan-5 {\n  background: #26c6da !important;\n}\n.bg-cyan-6 {\n  background: #00bcd4 !important;\n}\n.bg-cyan-7 {\n  background: #00acc1 !important;\n}\n.bg-cyan-8 {\n  background: #0097a7 !important;\n}\n.bg-cyan-9 {\n  background: #00838f !important;\n}\n.bg-cyan-10 {\n  background: #006064 !important;\n}\n.bg-cyan-11 {\n  background: #84ffff !important;\n}\n.bg-cyan-12 {\n  background: #18ffff !important;\n}\n.bg-cyan-13 {\n  background: #00e5ff !important;\n}\n.bg-cyan-14 {\n  background: #00b8d4 !important;\n}\n.bg-teal {\n  background: #009688 !important;\n}\n.bg-teal-1 {\n  background: #e0f2f1 !important;\n}\n.bg-teal-2 {\n  background: #b2dfdb !important;\n}\n.bg-teal-3 {\n  background: #80cbc4 !important;\n}\n.bg-teal-4 {\n  background: #4db6ac !important;\n}\n.bg-teal-5 {\n  background: #26a69a !important;\n}\n.bg-teal-6 {\n  background: #009688 !important;\n}\n.bg-teal-7 {\n  background: #00897b !important;\n}\n.bg-teal-8 {\n  background: #00796b !important;\n}\n.bg-teal-9 {\n  background: #00695c !important;\n}\n.bg-teal-10 {\n  background: #004d40 !important;\n}\n.bg-teal-11 {\n  background: #a7ffeb !important;\n}\n.bg-teal-12 {\n  background: #64ffda !important;\n}\n.bg-teal-13 {\n  background: #1de9b6 !important;\n}\n.bg-teal-14 {\n  background: #00bfa5 !important;\n}\n.bg-green {\n  background: #4caf50 !important;\n}\n.bg-green-1 {\n  background: #e8f5e9 !important;\n}\n.bg-green-2 {\n  background: #c8e6c9 !important;\n}\n.bg-green-3 {\n  background: #a5d6a7 !important;\n}\n.bg-green-4 {\n  background: #81c784 !important;\n}\n.bg-green-5 {\n  background: #66bb6a !important;\n}\n.bg-green-6 {\n  background: #4caf50 !important;\n}\n.bg-green-7 {\n  background: #43a047 !important;\n}\n.bg-green-8 {\n  background: #388e3c !important;\n}\n.bg-green-9 {\n  background: #2e7d32 !important;\n}\n.bg-green-10 {\n  background: #1b5e20 !important;\n}\n.bg-green-11 {\n  background: #b9f6ca !important;\n}\n.bg-green-12 {\n  background: #69f0ae !important;\n}\n.bg-green-13 {\n  background: #00e676 !important;\n}\n.bg-green-14 {\n  background: #00c853 !important;\n}\n.bg-light-green {\n  background: #8bc34a !important;\n}\n.bg-light-green-1 {\n  background: #f1f8e9 !important;\n}\n.bg-light-green-2 {\n  background: #dcedc8 !important;\n}\n.bg-light-green-3 {\n  background: #c5e1a5 !important;\n}\n.bg-light-green-4 {\n  background: #aed581 !important;\n}\n.bg-light-green-5 {\n  background: #9ccc65 !important;\n}\n.bg-light-green-6 {\n  background: #8bc34a !important;\n}\n.bg-light-green-7 {\n  background: #7cb342 !important;\n}\n.bg-light-green-8 {\n  background: #689f38 !important;\n}\n.bg-light-green-9 {\n  background: #558b2f !important;\n}\n.bg-light-green-10 {\n  background: #33691e !important;\n}\n.bg-light-green-11 {\n  background: #ccff90 !important;\n}\n.bg-light-green-12 {\n  background: #b2ff59 !important;\n}\n.bg-light-green-13 {\n  background: #76ff03 !important;\n}\n.bg-light-green-14 {\n  background: #64dd17 !important;\n}\n.bg-lime {\n  background: #cddc39 !important;\n}\n.bg-lime-1 {\n  background: #f9fbe7 !important;\n}\n.bg-lime-2 {\n  background: #f0f4c3 !important;\n}\n.bg-lime-3 {\n  background: #e6ee9c !important;\n}\n.bg-lime-4 {\n  background: #dce775 !important;\n}\n.bg-lime-5 {\n  background: #d4e157 !important;\n}\n.bg-lime-6 {\n  background: #cddc39 !important;\n}\n.bg-lime-7 {\n  background: #c0ca33 !important;\n}\n.bg-lime-8 {\n  background: #afb42b !important;\n}\n.bg-lime-9 {\n  background: #9e9d24 !important;\n}\n.bg-lime-10 {\n  background: #827717 !important;\n}\n.bg-lime-11 {\n  background: #f4ff81 !important;\n}\n.bg-lime-12 {\n  background: #eeff41 !important;\n}\n.bg-lime-13 {\n  background: #c6ff00 !important;\n}\n.bg-lime-14 {\n  background: #aeea00 !important;\n}\n.bg-yellow {\n  background: #ffeb3b !important;\n}\n.bg-yellow-1 {\n  background: #fffde7 !important;\n}\n.bg-yellow-2 {\n  background: #fff9c4 !important;\n}\n.bg-yellow-3 {\n  background: #fff59d !important;\n}\n.bg-yellow-4 {\n  background: #fff176 !important;\n}\n.bg-yellow-5 {\n  background: #ffee58 !important;\n}\n.bg-yellow-6 {\n  background: #ffeb3b !important;\n}\n.bg-yellow-7 {\n  background: #fdd835 !important;\n}\n.bg-yellow-8 {\n  background: #fbc02d !important;\n}\n.bg-yellow-9 {\n  background: #f9a825 !important;\n}\n.bg-yellow-10 {\n  background: #f57f17 !important;\n}\n.bg-yellow-11 {\n  background: #ffff8d !important;\n}\n.bg-yellow-12 {\n  background: #ffff00 !important;\n}\n.bg-yellow-13 {\n  background: #ffea00 !important;\n}\n.bg-yellow-14 {\n  background: #ffd600 !important;\n}\n.bg-amber {\n  background: #ffc107 !important;\n}\n.bg-amber-1 {\n  background: #fff8e1 !important;\n}\n.bg-amber-2 {\n  background: #ffecb3 !important;\n}\n.bg-amber-3 {\n  background: #ffe082 !important;\n}\n.bg-amber-4 {\n  background: #ffd54f !important;\n}\n.bg-amber-5 {\n  background: #ffca28 !important;\n}\n.bg-amber-6 {\n  background: #ffc107 !important;\n}\n.bg-amber-7 {\n  background: #ffb300 !important;\n}\n.bg-amber-8 {\n  background: #ffa000 !important;\n}\n.bg-amber-9 {\n  background: #ff8f00 !important;\n}\n.bg-amber-10 {\n  background: #ff6f00 !important;\n}\n.bg-amber-11 {\n  background: #ffe57f !important;\n}\n.bg-amber-12 {\n  background: #ffd740 !important;\n}\n.bg-amber-13 {\n  background: #ffc400 !important;\n}\n.bg-amber-14 {\n  background: #ffab00 !important;\n}\n.bg-orange {\n  background: #ff9800 !important;\n}\n.bg-orange-1 {\n  background: #fff3e0 !important;\n}\n.bg-orange-2 {\n  background: #ffe0b2 !important;\n}\n.bg-orange-3 {\n  background: #ffcc80 !important;\n}\n.bg-orange-4 {\n  background: #ffb74d !important;\n}\n.bg-orange-5 {\n  background: #ffa726 !important;\n}\n.bg-orange-6 {\n  background: #ff9800 !important;\n}\n.bg-orange-7 {\n  background: #fb8c00 !important;\n}\n.bg-orange-8 {\n  background: #f57c00 !important;\n}\n.bg-orange-9 {\n  background: #ef6c00 !important;\n}\n.bg-orange-10 {\n  background: #e65100 !important;\n}\n.bg-orange-11 {\n  background: #ffd180 !important;\n}\n.bg-orange-12 {\n  background: #ffab40 !important;\n}\n.bg-orange-13 {\n  background: #ff9100 !important;\n}\n.bg-orange-14 {\n  background: #ff6d00 !important;\n}\n.bg-deep-orange {\n  background: #ff5722 !important;\n}\n.bg-deep-orange-1 {\n  background: #fbe9e7 !important;\n}\n.bg-deep-orange-2 {\n  background: #ffccbc !important;\n}\n.bg-deep-orange-3 {\n  background: #ffab91 !important;\n}\n.bg-deep-orange-4 {\n  background: #ff8a65 !important;\n}\n.bg-deep-orange-5 {\n  background: #ff7043 !important;\n}\n.bg-deep-orange-6 {\n  background: #ff5722 !important;\n}\n.bg-deep-orange-7 {\n  background: #f4511e !important;\n}\n.bg-deep-orange-8 {\n  background: #e64a19 !important;\n}\n.bg-deep-orange-9 {\n  background: #d84315 !important;\n}\n.bg-deep-orange-10 {\n  background: #bf360c !important;\n}\n.bg-deep-orange-11 {\n  background: #ff9e80 !important;\n}\n.bg-deep-orange-12 {\n  background: #ff6e40 !important;\n}\n.bg-deep-orange-13 {\n  background: #ff3d00 !important;\n}\n.bg-deep-orange-14 {\n  background: #dd2c00 !important;\n}\n.bg-brown {\n  background: #795548 !important;\n}\n.bg-brown-1 {\n  background: #efebe9 !important;\n}\n.bg-brown-2 {\n  background: #d7ccc8 !important;\n}\n.bg-brown-3 {\n  background: #bcaaa4 !important;\n}\n.bg-brown-4 {\n  background: #a1887f !important;\n}\n.bg-brown-5 {\n  background: #8d6e63 !important;\n}\n.bg-brown-6 {\n  background: #795548 !important;\n}\n.bg-brown-7 {\n  background: #6d4c41 !important;\n}\n.bg-brown-8 {\n  background: #5d4037 !important;\n}\n.bg-brown-9 {\n  background: #4e342e !important;\n}\n.bg-brown-10 {\n  background: #3e2723 !important;\n}\n.bg-brown-11 {\n  background: #d7ccc8 !important;\n}\n.bg-brown-12 {\n  background: #bcaaa4 !important;\n}\n.bg-brown-13 {\n  background: #8d6e63 !important;\n}\n.bg-brown-14 {\n  background: #5d4037 !important;\n}\n.bg-grey {\n  background: #9e9e9e !important;\n}\n.bg-grey-1 {\n  background: #fafafa !important;\n}\n.bg-grey-2 {\n  background: #f5f5f5 !important;\n}\n.bg-grey-3 {\n  background: #eeeeee !important;\n}\n.bg-grey-4 {\n  background: #e0e0e0 !important;\n}\n.bg-grey-5 {\n  background: #bdbdbd !important;\n}\n.bg-grey-6 {\n  background: #9e9e9e !important;\n}\n.bg-grey-7 {\n  background: #757575 !important;\n}\n.bg-grey-8 {\n  background: #616161 !important;\n}\n.bg-grey-9 {\n  background: #424242 !important;\n}\n.bg-grey-10 {\n  background: #212121 !important;\n}\n.bg-grey-11 {\n  background: #f5f5f5 !important;\n}\n.bg-grey-12 {\n  background: #eeeeee !important;\n}\n.bg-grey-13 {\n  background: #bdbdbd !important;\n}\n.bg-grey-14 {\n  background: #616161 !important;\n}\n.bg-blue-grey {\n  background: #607d8b !important;\n}\n.bg-blue-grey-1 {\n  background: #eceff1 !important;\n}\n.bg-blue-grey-2 {\n  background: #cfd8dc !important;\n}\n.bg-blue-grey-3 {\n  background: #b0bec5 !important;\n}\n.bg-blue-grey-4 {\n  background: #90a4ae !important;\n}\n.bg-blue-grey-5 {\n  background: #78909c !important;\n}\n.bg-blue-grey-6 {\n  background: #607d8b !important;\n}\n.bg-blue-grey-7 {\n  background: #546e7a !important;\n}\n.bg-blue-grey-8 {\n  background: #455a64 !important;\n}\n.bg-blue-grey-9 {\n  background: #37474f !important;\n}\n.bg-blue-grey-10 {\n  background: #263238 !important;\n}\n.bg-blue-grey-11 {\n  background: #cfd8dc !important;\n}\n.bg-blue-grey-12 {\n  background: #b0bec5 !important;\n}\n.bg-blue-grey-13 {\n  background: #78909c !important;\n}\n.bg-blue-grey-14 {\n  background: #455a64 !important;\n}\n.shadow-transition {\n  transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1) !important;\n}\n.shadow-1 {\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2), 0 1px 1px rgba(0, 0, 0, 0.14), 0 2px 1px -1px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-1 {\n  box-shadow: 0 -1px 3px rgba(0, 0, 0, 0.2), 0 -1px 1px rgba(0, 0, 0, 0.14), 0 -2px 1px -1px rgba(0, 0, 0, 0.12);\n}\n.shadow-2 {\n  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2), 0 2px 2px rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-2 {\n  box-shadow: 0 -1px 5px rgba(0, 0, 0, 0.2), 0 -2px 2px rgba(0, 0, 0, 0.14), 0 -3px 1px -2px rgba(0, 0, 0, 0.12);\n}\n.shadow-3 {\n  box-shadow: 0 1px 8px rgba(0, 0, 0, 0.2), 0 3px 4px rgba(0, 0, 0, 0.14), 0 3px 3px -2px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-3 {\n  box-shadow: 0 -1px 8px rgba(0, 0, 0, 0.2), 0 -3px 4px rgba(0, 0, 0, 0.14), 0 -3px 3px -2px rgba(0, 0, 0, 0.12);\n}\n.shadow-4 {\n  box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.2), 0 4px 5px rgba(0, 0, 0, 0.14), 0 1px 10px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-4 {\n  box-shadow: 0 -2px 4px -1px rgba(0, 0, 0, 0.2), 0 -4px 5px rgba(0, 0, 0, 0.14), 0 -1px 10px rgba(0, 0, 0, 0.12);\n}\n.shadow-5 {\n  box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 5px 8px rgba(0, 0, 0, 0.14), 0 1px 14px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-5 {\n  box-shadow: 0 -3px 5px -1px rgba(0, 0, 0, 0.2), 0 -5px 8px rgba(0, 0, 0, 0.14), 0 -1px 14px rgba(0, 0, 0, 0.12);\n}\n.shadow-6 {\n  box-shadow: 0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px rgba(0, 0, 0, 0.14), 0 1px 18px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-6 {\n  box-shadow: 0 -3px 5px -1px rgba(0, 0, 0, 0.2), 0 -6px 10px rgba(0, 0, 0, 0.14), 0 -1px 18px rgba(0, 0, 0, 0.12);\n}\n.shadow-7 {\n  box-shadow: 0 4px 5px -2px rgba(0, 0, 0, 0.2), 0 7px 10px 1px rgba(0, 0, 0, 0.14), 0 2px 16px 1px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-7 {\n  box-shadow: 0 -4px 5px -2px rgba(0, 0, 0, 0.2), 0 -7px 10px 1px rgba(0, 0, 0, 0.14), 0 -2px 16px 1px rgba(0, 0, 0, 0.12);\n}\n.shadow-8 {\n  box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-8 {\n  box-shadow: 0 -5px 5px -3px rgba(0, 0, 0, 0.2), 0 -8px 10px 1px rgba(0, 0, 0, 0.14), 0 -3px 14px 2px rgba(0, 0, 0, 0.12);\n}\n.shadow-9 {\n  box-shadow: 0 5px 6px -3px rgba(0, 0, 0, 0.2), 0 9px 12px 1px rgba(0, 0, 0, 0.14), 0 3px 16px 2px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-9 {\n  box-shadow: 0 -5px 6px -3px rgba(0, 0, 0, 0.2), 0 -9px 12px 1px rgba(0, 0, 0, 0.14), 0 -3px 16px 2px rgba(0, 0, 0, 0.12);\n}\n.shadow-10 {\n  box-shadow: 0 6px 6px -3px rgba(0, 0, 0, 0.2), 0 10px 14px 1px rgba(0, 0, 0, 0.14), 0 4px 18px 3px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-10 {\n  box-shadow: 0 -6px 6px -3px rgba(0, 0, 0, 0.2), 0 -10px 14px 1px rgba(0, 0, 0, 0.14), 0 -4px 18px 3px rgba(0, 0, 0, 0.12);\n}\n.shadow-11 {\n  box-shadow: 0 6px 7px -4px rgba(0, 0, 0, 0.2), 0 11px 15px 1px rgba(0, 0, 0, 0.14), 0 4px 20px 3px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-11 {\n  box-shadow: 0 -6px 7px -4px rgba(0, 0, 0, 0.2), 0 -11px 15px 1px rgba(0, 0, 0, 0.14), 0 -4px 20px 3px rgba(0, 0, 0, 0.12);\n}\n.shadow-12 {\n  box-shadow: 0 7px 8px -4px rgba(0, 0, 0, 0.2), 0 12px 17px 2px rgba(0, 0, 0, 0.14), 0 5px 22px 4px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-12 {\n  box-shadow: 0 -7px 8px -4px rgba(0, 0, 0, 0.2), 0 -12px 17px 2px rgba(0, 0, 0, 0.14), 0 -5px 22px 4px rgba(0, 0, 0, 0.12);\n}\n.shadow-13 {\n  box-shadow: 0 7px 8px -4px rgba(0, 0, 0, 0.2), 0 13px 19px 2px rgba(0, 0, 0, 0.14), 0 5px 24px 4px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-13 {\n  box-shadow: 0 -7px 8px -4px rgba(0, 0, 0, 0.2), 0 -13px 19px 2px rgba(0, 0, 0, 0.14), 0 -5px 24px 4px rgba(0, 0, 0, 0.12);\n}\n.shadow-14 {\n  box-shadow: 0 7px 9px -4px rgba(0, 0, 0, 0.2), 0 14px 21px 2px rgba(0, 0, 0, 0.14), 0 5px 26px 4px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-14 {\n  box-shadow: 0 -7px 9px -4px rgba(0, 0, 0, 0.2), 0 -14px 21px 2px rgba(0, 0, 0, 0.14), 0 -5px 26px 4px rgba(0, 0, 0, 0.12);\n}\n.shadow-15 {\n  box-shadow: 0 8px 9px -5px rgba(0, 0, 0, 0.2), 0 15px 22px 2px rgba(0, 0, 0, 0.14), 0 6px 28px 5px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-15 {\n  box-shadow: 0 -8px 9px -5px rgba(0, 0, 0, 0.2), 0 -15px 22px 2px rgba(0, 0, 0, 0.14), 0 -6px 28px 5px rgba(0, 0, 0, 0.12);\n}\n.shadow-16 {\n  box-shadow: 0 8px 10px -5px rgba(0, 0, 0, 0.2), 0 16px 24px 2px rgba(0, 0, 0, 0.14), 0 6px 30px 5px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-16 {\n  box-shadow: 0 -8px 10px -5px rgba(0, 0, 0, 0.2), 0 -16px 24px 2px rgba(0, 0, 0, 0.14), 0 -6px 30px 5px rgba(0, 0, 0, 0.12);\n}\n.shadow-17 {\n  box-shadow: 0 8px 11px -5px rgba(0, 0, 0, 0.2), 0 17px 26px 2px rgba(0, 0, 0, 0.14), 0 6px 32px 5px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-17 {\n  box-shadow: 0 -8px 11px -5px rgba(0, 0, 0, 0.2), 0 -17px 26px 2px rgba(0, 0, 0, 0.14), 0 -6px 32px 5px rgba(0, 0, 0, 0.12);\n}\n.shadow-18 {\n  box-shadow: 0 9px 11px -5px rgba(0, 0, 0, 0.2), 0 18px 28px 2px rgba(0, 0, 0, 0.14), 0 7px 34px 6px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-18 {\n  box-shadow: 0 -9px 11px -5px rgba(0, 0, 0, 0.2), 0 -18px 28px 2px rgba(0, 0, 0, 0.14), 0 -7px 34px 6px rgba(0, 0, 0, 0.12);\n}\n.shadow-19 {\n  box-shadow: 0 9px 12px -6px rgba(0, 0, 0, 0.2), 0 19px 29px 2px rgba(0, 0, 0, 0.14), 0 7px 36px 6px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-19 {\n  box-shadow: 0 -9px 12px -6px rgba(0, 0, 0, 0.2), 0 -19px 29px 2px rgba(0, 0, 0, 0.14), 0 -7px 36px 6px rgba(0, 0, 0, 0.12);\n}\n.shadow-20 {\n  box-shadow: 0 10px 13px -6px rgba(0, 0, 0, 0.2), 0 20px 31px 3px rgba(0, 0, 0, 0.14), 0 8px 38px 7px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-20 {\n  box-shadow: 0 -10px 13px -6px rgba(0, 0, 0, 0.2), 0 -20px 31px 3px rgba(0, 0, 0, 0.14), 0 -8px 38px 7px rgba(0, 0, 0, 0.12);\n}\n.shadow-21 {\n  box-shadow: 0 10px 13px -6px rgba(0, 0, 0, 0.2), 0 21px 33px 3px rgba(0, 0, 0, 0.14), 0 8px 40px 7px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-21 {\n  box-shadow: 0 -10px 13px -6px rgba(0, 0, 0, 0.2), 0 -21px 33px 3px rgba(0, 0, 0, 0.14), 0 -8px 40px 7px rgba(0, 0, 0, 0.12);\n}\n.shadow-22 {\n  box-shadow: 0 10px 14px -6px rgba(0, 0, 0, 0.2), 0 22px 35px 3px rgba(0, 0, 0, 0.14), 0 8px 42px 7px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-22 {\n  box-shadow: 0 -10px 14px -6px rgba(0, 0, 0, 0.2), 0 -22px 35px 3px rgba(0, 0, 0, 0.14), 0 -8px 42px 7px rgba(0, 0, 0, 0.12);\n}\n.shadow-23 {\n  box-shadow: 0 11px 14px -7px rgba(0, 0, 0, 0.2), 0 23px 36px 3px rgba(0, 0, 0, 0.14), 0 9px 44px 8px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-23 {\n  box-shadow: 0 -11px 14px -7px rgba(0, 0, 0, 0.2), 0 -23px 36px 3px rgba(0, 0, 0, 0.14), 0 -9px 44px 8px rgba(0, 0, 0, 0.12);\n}\n.shadow-24 {\n  box-shadow: 0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14), 0 9px 46px 8px rgba(0, 0, 0, 0.12);\n}\n.shadow-up-24 {\n  box-shadow: 0 -11px 15px -7px rgba(0, 0, 0, 0.2), 0 -24px 38px 3px rgba(0, 0, 0, 0.14), 0 -9px 46px 8px rgba(0, 0, 0, 0.12);\n}\n.no-shadow, .shadow-0 {\n  box-shadow: none !important;\n}\n.inset-shadow {\n  box-shadow: 0 7px 9px -7px rgba(0, 0, 0, 0.7) inset !important;\n}\n.inset-shadow-down {\n  box-shadow: 0 -7px 9px -7px rgba(0, 0, 0, 0.7) inset !important;\n}\n.z-marginals {\n  z-index: 2000;\n}\n.z-notify {\n  z-index: 9500;\n}\n.z-fullscreen {\n  z-index: 6000;\n}\n.z-inherit {\n  z-index: inherit !important;\n}\n.row, .column, .flex {\n  display: flex;\n  flex-wrap: wrap;\n}\n.row.inline, .column.inline, .flex.inline {\n  display: inline-flex;\n}\n.row.reverse {\n  flex-direction: row-reverse;\n}\n.column {\n  flex-direction: column;\n}\n.column.reverse {\n  flex-direction: column-reverse;\n}\n.wrap {\n  flex-wrap: wrap;\n}\n.no-wrap {\n  flex-wrap: nowrap;\n}\n.reverse-wrap {\n  flex-wrap: wrap-reverse;\n}\n.order-first {\n  order: -10000;\n}\n.order-last {\n  order: 10000;\n}\n.order-none {\n  order: 0;\n}\n.justify-start {\n  justify-content: flex-start;\n}\n.justify-end {\n  justify-content: flex-end;\n}\n.justify-center, .flex-center {\n  justify-content: center;\n}\n.justify-between {\n  justify-content: space-between;\n}\n.justify-around {\n  justify-content: space-around;\n}\n.justify-evenly {\n  justify-content: space-evenly;\n}\n.items-start {\n  align-items: flex-start;\n}\n.items-end {\n  align-items: flex-end;\n}\n.items-center, .flex-center {\n  align-items: center;\n}\n.items-baseline {\n  align-items: baseline;\n}\n.items-stretch {\n  align-items: stretch;\n}\n.content-start {\n  align-content: flex-start;\n}\n.content-end {\n  align-content: flex-end;\n}\n.content-center {\n  align-content: center;\n}\n.content-stretch {\n  align-content: stretch;\n}\n.content-between {\n  align-content: space-between;\n}\n.content-around {\n  align-content: space-around;\n}\n.self-start {\n  align-self: flex-start;\n}\n.self-end {\n  align-self: flex-end;\n}\n.self-center {\n  align-self: center;\n}\n.self-baseline {\n  align-self: baseline;\n}\n.self-stretch {\n  align-self: stretch;\n}\n.q-gutter-x-none, .q-gutter-none {\n  margin-left: 0;\n}\n.q-gutter-x-none > *, .q-gutter-none > * {\n  margin-left: 0;\n}\n.q-gutter-y-none, .q-gutter-none {\n  margin-top: 0;\n}\n.q-gutter-y-none > *, .q-gutter-none > * {\n  margin-top: 0;\n}\n.q-col-gutter-x-none, .q-col-gutter-none {\n  margin-left: 0;\n}\n.q-col-gutter-x-none > *, .q-col-gutter-none > * {\n  padding-left: 0;\n}\n.q-col-gutter-y-none, .q-col-gutter-none {\n  margin-top: 0;\n}\n.q-col-gutter-y-none > *, .q-col-gutter-none > * {\n  padding-top: 0;\n}\n.q-gutter-x-xs, .q-gutter-xs {\n  margin-left: -4px;\n}\n.q-gutter-x-xs > *, .q-gutter-xs > * {\n  margin-left: 4px;\n}\n.q-gutter-y-xs, .q-gutter-xs {\n  margin-top: -4px;\n}\n.q-gutter-y-xs > *, .q-gutter-xs > * {\n  margin-top: 4px;\n}\n.q-col-gutter-x-xs, .q-col-gutter-xs {\n  margin-left: -4px;\n}\n.q-col-gutter-x-xs > *, .q-col-gutter-xs > * {\n  padding-left: 4px;\n}\n.q-col-gutter-y-xs, .q-col-gutter-xs {\n  margin-top: -4px;\n}\n.q-col-gutter-y-xs > *, .q-col-gutter-xs > * {\n  padding-top: 4px;\n}\n.q-gutter-x-sm, .q-gutter-sm {\n  margin-left: -8px;\n}\n.q-gutter-x-sm > *, .q-gutter-sm > * {\n  margin-left: 8px;\n}\n.q-gutter-y-sm, .q-gutter-sm {\n  margin-top: -8px;\n}\n.q-gutter-y-sm > *, .q-gutter-sm > * {\n  margin-top: 8px;\n}\n.q-col-gutter-x-sm, .q-col-gutter-sm {\n  margin-left: -8px;\n}\n.q-col-gutter-x-sm > *, .q-col-gutter-sm > * {\n  padding-left: 8px;\n}\n.q-col-gutter-y-sm, .q-col-gutter-sm {\n  margin-top: -8px;\n}\n.q-col-gutter-y-sm > *, .q-col-gutter-sm > * {\n  padding-top: 8px;\n}\n.q-gutter-x-md, .q-gutter-md {\n  margin-left: -16px;\n}\n.q-gutter-x-md > *, .q-gutter-md > * {\n  margin-left: 16px;\n}\n.q-gutter-y-md, .q-gutter-md {\n  margin-top: -16px;\n}\n.q-gutter-y-md > *, .q-gutter-md > * {\n  margin-top: 16px;\n}\n.q-col-gutter-x-md, .q-col-gutter-md {\n  margin-left: -16px;\n}\n.q-col-gutter-x-md > *, .q-col-gutter-md > * {\n  padding-left: 16px;\n}\n.q-col-gutter-y-md, .q-col-gutter-md {\n  margin-top: -16px;\n}\n.q-col-gutter-y-md > *, .q-col-gutter-md > * {\n  padding-top: 16px;\n}\n.q-gutter-x-lg, .q-gutter-lg {\n  margin-left: -24px;\n}\n.q-gutter-x-lg > *, .q-gutter-lg > * {\n  margin-left: 24px;\n}\n.q-gutter-y-lg, .q-gutter-lg {\n  margin-top: -24px;\n}\n.q-gutter-y-lg > *, .q-gutter-lg > * {\n  margin-top: 24px;\n}\n.q-col-gutter-x-lg, .q-col-gutter-lg {\n  margin-left: -24px;\n}\n.q-col-gutter-x-lg > *, .q-col-gutter-lg > * {\n  padding-left: 24px;\n}\n.q-col-gutter-y-lg, .q-col-gutter-lg {\n  margin-top: -24px;\n}\n.q-col-gutter-y-lg > *, .q-col-gutter-lg > * {\n  padding-top: 24px;\n}\n.q-gutter-x-xl, .q-gutter-xl {\n  margin-left: -48px;\n}\n.q-gutter-x-xl > *, .q-gutter-xl > * {\n  margin-left: 48px;\n}\n.q-gutter-y-xl, .q-gutter-xl {\n  margin-top: -48px;\n}\n.q-gutter-y-xl > *, .q-gutter-xl > * {\n  margin-top: 48px;\n}\n.q-col-gutter-x-xl, .q-col-gutter-xl {\n  margin-left: -48px;\n}\n.q-col-gutter-x-xl > *, .q-col-gutter-xl > * {\n  padding-left: 48px;\n}\n.q-col-gutter-y-xl, .q-col-gutter-xl {\n  margin-top: -48px;\n}\n.q-col-gutter-y-xl > *, .q-col-gutter-xl > * {\n  padding-top: 48px;\n}\n@media (min-width: 0) {\n  .row > .col, .flex > .col, .row > .col-auto, .flex > .col-auto, .row > .col-grow, .flex > .col-grow, .row > .col-shrink, .flex > .col-shrink, .row > .col-xs, .flex > .col-xs, .row > .col-xs-auto, .row > .col-12, .row > .col-xs-12, .row > .col-11, .row > .col-xs-11, .row > .col-10, .row > .col-xs-10, .row > .col-9, .row > .col-xs-9, .row > .col-8, .row > .col-xs-8, .row > .col-7, .row > .col-xs-7, .row > .col-6, .row > .col-xs-6, .row > .col-5, .row > .col-xs-5, .row > .col-4, .row > .col-xs-4, .row > .col-3, .row > .col-xs-3, .row > .col-2, .row > .col-xs-2, .row > .col-1, .row > .col-xs-1, .row > .col-0, .row > .col-xs-0, .flex > .col-xs-auto, .flex > .col-12, .flex > .col-xs-12, .flex > .col-11, .flex > .col-xs-11, .flex > .col-10, .flex > .col-xs-10, .flex > .col-9, .flex > .col-xs-9, .flex > .col-8, .flex > .col-xs-8, .flex > .col-7, .flex > .col-xs-7, .flex > .col-6, .flex > .col-xs-6, .flex > .col-5, .flex > .col-xs-5, .flex > .col-4, .flex > .col-xs-4, .flex > .col-3, .flex > .col-xs-3, .flex > .col-2, .flex > .col-xs-2, .flex > .col-1, .flex > .col-xs-1, .flex > .col-0, .flex > .col-xs-0, .row > .col-xs-grow, .flex > .col-xs-grow, .row > .col-xs-shrink, .flex > .col-xs-shrink {\n    width: auto;\n    min-width: 0;\n    max-width: 100%;\n  }\n  .column > .col, .flex > .col, .column > .col-auto, .flex > .col-auto, .column > .col-grow, .flex > .col-grow, .column > .col-shrink, .flex > .col-shrink, .column > .col-xs, .flex > .col-xs, .column > .col-xs-auto, .column > .col-12, .column > .col-xs-12, .column > .col-11, .column > .col-xs-11, .column > .col-10, .column > .col-xs-10, .column > .col-9, .column > .col-xs-9, .column > .col-8, .column > .col-xs-8, .column > .col-7, .column > .col-xs-7, .column > .col-6, .column > .col-xs-6, .column > .col-5, .column > .col-xs-5, .column > .col-4, .column > .col-xs-4, .column > .col-3, .column > .col-xs-3, .column > .col-2, .column > .col-xs-2, .column > .col-1, .column > .col-xs-1, .column > .col-0, .column > .col-xs-0, .flex > .col-xs-auto, .flex > .col-12, .flex > .col-xs-12, .flex > .col-11, .flex > .col-xs-11, .flex > .col-10, .flex > .col-xs-10, .flex > .col-9, .flex > .col-xs-9, .flex > .col-8, .flex > .col-xs-8, .flex > .col-7, .flex > .col-xs-7, .flex > .col-6, .flex > .col-xs-6, .flex > .col-5, .flex > .col-xs-5, .flex > .col-4, .flex > .col-xs-4, .flex > .col-3, .flex > .col-xs-3, .flex > .col-2, .flex > .col-xs-2, .flex > .col-1, .flex > .col-xs-1, .flex > .col-0, .flex > .col-xs-0, .column > .col-xs-grow, .flex > .col-xs-grow, .column > .col-xs-shrink, .flex > .col-xs-shrink {\n    height: auto;\n    min-height: 0;\n    max-height: 100%;\n  }\n  .col, .col-xs {\n    flex: 10000 1 0%;\n  }\n  .col-auto, .col-xs-auto, .col-12, .col-xs-12, .col-11, .col-xs-11, .col-10, .col-xs-10, .col-9, .col-xs-9, .col-8, .col-xs-8, .col-7, .col-xs-7, .col-6, .col-xs-6, .col-5, .col-xs-5, .col-4, .col-xs-4, .col-3, .col-xs-3, .col-2, .col-xs-2, .col-1, .col-xs-1, .col-0, .col-xs-0 {\n    flex: 0 0 auto;\n  }\n  .col-grow, .col-xs-grow {\n    flex: 1 0 auto;\n  }\n  .col-shrink, .col-xs-shrink {\n    flex: 0 1 auto;\n  }\n\n  .row > .col-0, .row > .col-xs-0 {\n    height: auto;\n    width: 0%;\n  }\n  .row > .offset-0, .row > .offset-xs-0 {\n    margin-left: 0%;\n  }\n\n  .column > .col-0, .column > .col-xs-0 {\n    height: 0%;\n    width: auto;\n  }\n\n  .row > .col-1, .row > .col-xs-1 {\n    height: auto;\n    width: 8.3333%;\n  }\n  .row > .offset-1, .row > .offset-xs-1 {\n    margin-left: 8.3333%;\n  }\n\n  .column > .col-1, .column > .col-xs-1 {\n    height: 8.3333%;\n    width: auto;\n  }\n\n  .row > .col-2, .row > .col-xs-2 {\n    height: auto;\n    width: 16.6667%;\n  }\n  .row > .offset-2, .row > .offset-xs-2 {\n    margin-left: 16.6667%;\n  }\n\n  .column > .col-2, .column > .col-xs-2 {\n    height: 16.6667%;\n    width: auto;\n  }\n\n  .row > .col-3, .row > .col-xs-3 {\n    height: auto;\n    width: 25%;\n  }\n  .row > .offset-3, .row > .offset-xs-3 {\n    margin-left: 25%;\n  }\n\n  .column > .col-3, .column > .col-xs-3 {\n    height: 25%;\n    width: auto;\n  }\n\n  .row > .col-4, .row > .col-xs-4 {\n    height: auto;\n    width: 33.3333%;\n  }\n  .row > .offset-4, .row > .offset-xs-4 {\n    margin-left: 33.3333%;\n  }\n\n  .column > .col-4, .column > .col-xs-4 {\n    height: 33.3333%;\n    width: auto;\n  }\n\n  .row > .col-5, .row > .col-xs-5 {\n    height: auto;\n    width: 41.6667%;\n  }\n  .row > .offset-5, .row > .offset-xs-5 {\n    margin-left: 41.6667%;\n  }\n\n  .column > .col-5, .column > .col-xs-5 {\n    height: 41.6667%;\n    width: auto;\n  }\n\n  .row > .col-6, .row > .col-xs-6 {\n    height: auto;\n    width: 50%;\n  }\n  .row > .offset-6, .row > .offset-xs-6 {\n    margin-left: 50%;\n  }\n\n  .column > .col-6, .column > .col-xs-6 {\n    height: 50%;\n    width: auto;\n  }\n\n  .row > .col-7, .row > .col-xs-7 {\n    height: auto;\n    width: 58.3333%;\n  }\n  .row > .offset-7, .row > .offset-xs-7 {\n    margin-left: 58.3333%;\n  }\n\n  .column > .col-7, .column > .col-xs-7 {\n    height: 58.3333%;\n    width: auto;\n  }\n\n  .row > .col-8, .row > .col-xs-8 {\n    height: auto;\n    width: 66.6667%;\n  }\n  .row > .offset-8, .row > .offset-xs-8 {\n    margin-left: 66.6667%;\n  }\n\n  .column > .col-8, .column > .col-xs-8 {\n    height: 66.6667%;\n    width: auto;\n  }\n\n  .row > .col-9, .row > .col-xs-9 {\n    height: auto;\n    width: 75%;\n  }\n  .row > .offset-9, .row > .offset-xs-9 {\n    margin-left: 75%;\n  }\n\n  .column > .col-9, .column > .col-xs-9 {\n    height: 75%;\n    width: auto;\n  }\n\n  .row > .col-10, .row > .col-xs-10 {\n    height: auto;\n    width: 83.3333%;\n  }\n  .row > .offset-10, .row > .offset-xs-10 {\n    margin-left: 83.3333%;\n  }\n\n  .column > .col-10, .column > .col-xs-10 {\n    height: 83.3333%;\n    width: auto;\n  }\n\n  .row > .col-11, .row > .col-xs-11 {\n    height: auto;\n    width: 91.6667%;\n  }\n  .row > .offset-11, .row > .offset-xs-11 {\n    margin-left: 91.6667%;\n  }\n\n  .column > .col-11, .column > .col-xs-11 {\n    height: 91.6667%;\n    width: auto;\n  }\n\n  .row > .col-12, .row > .col-xs-12 {\n    height: auto;\n    width: 100%;\n  }\n  .row > .offset-12, .row > .offset-xs-12 {\n    margin-left: 100%;\n  }\n\n  .column > .col-12, .column > .col-xs-12 {\n    height: 100%;\n    width: auto;\n  }\n\n  .row > .col-all {\n    height: auto;\n    flex: 0 0 100%;\n  }\n}\n@media (min-width: 600px) {\n  .row > .col-sm, .flex > .col-sm, .row > .col-sm-auto, .row > .col-sm-12, .row > .col-sm-11, .row > .col-sm-10, .row > .col-sm-9, .row > .col-sm-8, .row > .col-sm-7, .row > .col-sm-6, .row > .col-sm-5, .row > .col-sm-4, .row > .col-sm-3, .row > .col-sm-2, .row > .col-sm-1, .row > .col-sm-0, .flex > .col-sm-auto, .flex > .col-sm-12, .flex > .col-sm-11, .flex > .col-sm-10, .flex > .col-sm-9, .flex > .col-sm-8, .flex > .col-sm-7, .flex > .col-sm-6, .flex > .col-sm-5, .flex > .col-sm-4, .flex > .col-sm-3, .flex > .col-sm-2, .flex > .col-sm-1, .flex > .col-sm-0, .row > .col-sm-grow, .flex > .col-sm-grow, .row > .col-sm-shrink, .flex > .col-sm-shrink {\n    width: auto;\n    min-width: 0;\n    max-width: 100%;\n  }\n  .column > .col-sm, .flex > .col-sm, .column > .col-sm-auto, .column > .col-sm-12, .column > .col-sm-11, .column > .col-sm-10, .column > .col-sm-9, .column > .col-sm-8, .column > .col-sm-7, .column > .col-sm-6, .column > .col-sm-5, .column > .col-sm-4, .column > .col-sm-3, .column > .col-sm-2, .column > .col-sm-1, .column > .col-sm-0, .flex > .col-sm-auto, .flex > .col-sm-12, .flex > .col-sm-11, .flex > .col-sm-10, .flex > .col-sm-9, .flex > .col-sm-8, .flex > .col-sm-7, .flex > .col-sm-6, .flex > .col-sm-5, .flex > .col-sm-4, .flex > .col-sm-3, .flex > .col-sm-2, .flex > .col-sm-1, .flex > .col-sm-0, .column > .col-sm-grow, .flex > .col-sm-grow, .column > .col-sm-shrink, .flex > .col-sm-shrink {\n    height: auto;\n    min-height: 0;\n    max-height: 100%;\n  }\n  .col-sm {\n    flex: 10000 1 0%;\n  }\n  .col-sm-auto, .col-sm-12, .col-sm-11, .col-sm-10, .col-sm-9, .col-sm-8, .col-sm-7, .col-sm-6, .col-sm-5, .col-sm-4, .col-sm-3, .col-sm-2, .col-sm-1, .col-sm-0 {\n    flex: 0 0 auto;\n  }\n  .col-sm-grow {\n    flex: 1 0 auto;\n  }\n  .col-sm-shrink {\n    flex: 0 1 auto;\n  }\n\n  .row > .col-sm-0 {\n    height: auto;\n    width: 0%;\n  }\n  .row > .offset-sm-0 {\n    margin-left: 0%;\n  }\n\n  .column > .col-sm-0 {\n    height: 0%;\n    width: auto;\n  }\n\n  .row > .col-sm-1 {\n    height: auto;\n    width: 8.3333%;\n  }\n  .row > .offset-sm-1 {\n    margin-left: 8.3333%;\n  }\n\n  .column > .col-sm-1 {\n    height: 8.3333%;\n    width: auto;\n  }\n\n  .row > .col-sm-2 {\n    height: auto;\n    width: 16.6667%;\n  }\n  .row > .offset-sm-2 {\n    margin-left: 16.6667%;\n  }\n\n  .column > .col-sm-2 {\n    height: 16.6667%;\n    width: auto;\n  }\n\n  .row > .col-sm-3 {\n    height: auto;\n    width: 25%;\n  }\n  .row > .offset-sm-3 {\n    margin-left: 25%;\n  }\n\n  .column > .col-sm-3 {\n    height: 25%;\n    width: auto;\n  }\n\n  .row > .col-sm-4 {\n    height: auto;\n    width: 33.3333%;\n  }\n  .row > .offset-sm-4 {\n    margin-left: 33.3333%;\n  }\n\n  .column > .col-sm-4 {\n    height: 33.3333%;\n    width: auto;\n  }\n\n  .row > .col-sm-5 {\n    height: auto;\n    width: 41.6667%;\n  }\n  .row > .offset-sm-5 {\n    margin-left: 41.6667%;\n  }\n\n  .column > .col-sm-5 {\n    height: 41.6667%;\n    width: auto;\n  }\n\n  .row > .col-sm-6 {\n    height: auto;\n    width: 50%;\n  }\n  .row > .offset-sm-6 {\n    margin-left: 50%;\n  }\n\n  .column > .col-sm-6 {\n    height: 50%;\n    width: auto;\n  }\n\n  .row > .col-sm-7 {\n    height: auto;\n    width: 58.3333%;\n  }\n  .row > .offset-sm-7 {\n    margin-left: 58.3333%;\n  }\n\n  .column > .col-sm-7 {\n    height: 58.3333%;\n    width: auto;\n  }\n\n  .row > .col-sm-8 {\n    height: auto;\n    width: 66.6667%;\n  }\n  .row > .offset-sm-8 {\n    margin-left: 66.6667%;\n  }\n\n  .column > .col-sm-8 {\n    height: 66.6667%;\n    width: auto;\n  }\n\n  .row > .col-sm-9 {\n    height: auto;\n    width: 75%;\n  }\n  .row > .offset-sm-9 {\n    margin-left: 75%;\n  }\n\n  .column > .col-sm-9 {\n    height: 75%;\n    width: auto;\n  }\n\n  .row > .col-sm-10 {\n    height: auto;\n    width: 83.3333%;\n  }\n  .row > .offset-sm-10 {\n    margin-left: 83.3333%;\n  }\n\n  .column > .col-sm-10 {\n    height: 83.3333%;\n    width: auto;\n  }\n\n  .row > .col-sm-11 {\n    height: auto;\n    width: 91.6667%;\n  }\n  .row > .offset-sm-11 {\n    margin-left: 91.6667%;\n  }\n\n  .column > .col-sm-11 {\n    height: 91.6667%;\n    width: auto;\n  }\n\n  .row > .col-sm-12 {\n    height: auto;\n    width: 100%;\n  }\n  .row > .offset-sm-12 {\n    margin-left: 100%;\n  }\n\n  .column > .col-sm-12 {\n    height: 100%;\n    width: auto;\n  }\n}\n@media (min-width: 1024px) {\n  .row > .col-md, .flex > .col-md, .row > .col-md-auto, .row > .col-md-12, .row > .col-md-11, .row > .col-md-10, .row > .col-md-9, .row > .col-md-8, .row > .col-md-7, .row > .col-md-6, .row > .col-md-5, .row > .col-md-4, .row > .col-md-3, .row > .col-md-2, .row > .col-md-1, .row > .col-md-0, .flex > .col-md-auto, .flex > .col-md-12, .flex > .col-md-11, .flex > .col-md-10, .flex > .col-md-9, .flex > .col-md-8, .flex > .col-md-7, .flex > .col-md-6, .flex > .col-md-5, .flex > .col-md-4, .flex > .col-md-3, .flex > .col-md-2, .flex > .col-md-1, .flex > .col-md-0, .row > .col-md-grow, .flex > .col-md-grow, .row > .col-md-shrink, .flex > .col-md-shrink {\n    width: auto;\n    min-width: 0;\n    max-width: 100%;\n  }\n  .column > .col-md, .flex > .col-md, .column > .col-md-auto, .column > .col-md-12, .column > .col-md-11, .column > .col-md-10, .column > .col-md-9, .column > .col-md-8, .column > .col-md-7, .column > .col-md-6, .column > .col-md-5, .column > .col-md-4, .column > .col-md-3, .column > .col-md-2, .column > .col-md-1, .column > .col-md-0, .flex > .col-md-auto, .flex > .col-md-12, .flex > .col-md-11, .flex > .col-md-10, .flex > .col-md-9, .flex > .col-md-8, .flex > .col-md-7, .flex > .col-md-6, .flex > .col-md-5, .flex > .col-md-4, .flex > .col-md-3, .flex > .col-md-2, .flex > .col-md-1, .flex > .col-md-0, .column > .col-md-grow, .flex > .col-md-grow, .column > .col-md-shrink, .flex > .col-md-shrink {\n    height: auto;\n    min-height: 0;\n    max-height: 100%;\n  }\n  .col-md {\n    flex: 10000 1 0%;\n  }\n  .col-md-auto, .col-md-12, .col-md-11, .col-md-10, .col-md-9, .col-md-8, .col-md-7, .col-md-6, .col-md-5, .col-md-4, .col-md-3, .col-md-2, .col-md-1, .col-md-0 {\n    flex: 0 0 auto;\n  }\n  .col-md-grow {\n    flex: 1 0 auto;\n  }\n  .col-md-shrink {\n    flex: 0 1 auto;\n  }\n\n  .row > .col-md-0 {\n    height: auto;\n    width: 0%;\n  }\n  .row > .offset-md-0 {\n    margin-left: 0%;\n  }\n\n  .column > .col-md-0 {\n    height: 0%;\n    width: auto;\n  }\n\n  .row > .col-md-1 {\n    height: auto;\n    width: 8.3333%;\n  }\n  .row > .offset-md-1 {\n    margin-left: 8.3333%;\n  }\n\n  .column > .col-md-1 {\n    height: 8.3333%;\n    width: auto;\n  }\n\n  .row > .col-md-2 {\n    height: auto;\n    width: 16.6667%;\n  }\n  .row > .offset-md-2 {\n    margin-left: 16.6667%;\n  }\n\n  .column > .col-md-2 {\n    height: 16.6667%;\n    width: auto;\n  }\n\n  .row > .col-md-3 {\n    height: auto;\n    width: 25%;\n  }\n  .row > .offset-md-3 {\n    margin-left: 25%;\n  }\n\n  .column > .col-md-3 {\n    height: 25%;\n    width: auto;\n  }\n\n  .row > .col-md-4 {\n    height: auto;\n    width: 33.3333%;\n  }\n  .row > .offset-md-4 {\n    margin-left: 33.3333%;\n  }\n\n  .column > .col-md-4 {\n    height: 33.3333%;\n    width: auto;\n  }\n\n  .row > .col-md-5 {\n    height: auto;\n    width: 41.6667%;\n  }\n  .row > .offset-md-5 {\n    margin-left: 41.6667%;\n  }\n\n  .column > .col-md-5 {\n    height: 41.6667%;\n    width: auto;\n  }\n\n  .row > .col-md-6 {\n    height: auto;\n    width: 50%;\n  }\n  .row > .offset-md-6 {\n    margin-left: 50%;\n  }\n\n  .column > .col-md-6 {\n    height: 50%;\n    width: auto;\n  }\n\n  .row > .col-md-7 {\n    height: auto;\n    width: 58.3333%;\n  }\n  .row > .offset-md-7 {\n    margin-left: 58.3333%;\n  }\n\n  .column > .col-md-7 {\n    height: 58.3333%;\n    width: auto;\n  }\n\n  .row > .col-md-8 {\n    height: auto;\n    width: 66.6667%;\n  }\n  .row > .offset-md-8 {\n    margin-left: 66.6667%;\n  }\n\n  .column > .col-md-8 {\n    height: 66.6667%;\n    width: auto;\n  }\n\n  .row > .col-md-9 {\n    height: auto;\n    width: 75%;\n  }\n  .row > .offset-md-9 {\n    margin-left: 75%;\n  }\n\n  .column > .col-md-9 {\n    height: 75%;\n    width: auto;\n  }\n\n  .row > .col-md-10 {\n    height: auto;\n    width: 83.3333%;\n  }\n  .row > .offset-md-10 {\n    margin-left: 83.3333%;\n  }\n\n  .column > .col-md-10 {\n    height: 83.3333%;\n    width: auto;\n  }\n\n  .row > .col-md-11 {\n    height: auto;\n    width: 91.6667%;\n  }\n  .row > .offset-md-11 {\n    margin-left: 91.6667%;\n  }\n\n  .column > .col-md-11 {\n    height: 91.6667%;\n    width: auto;\n  }\n\n  .row > .col-md-12 {\n    height: auto;\n    width: 100%;\n  }\n  .row > .offset-md-12 {\n    margin-left: 100%;\n  }\n\n  .column > .col-md-12 {\n    height: 100%;\n    width: auto;\n  }\n}\n@media (min-width: 1440px) {\n  .row > .col-lg, .flex > .col-lg, .row > .col-lg-auto, .row > .col-lg-12, .row > .col-lg-11, .row > .col-lg-10, .row > .col-lg-9, .row > .col-lg-8, .row > .col-lg-7, .row > .col-lg-6, .row > .col-lg-5, .row > .col-lg-4, .row > .col-lg-3, .row > .col-lg-2, .row > .col-lg-1, .row > .col-lg-0, .flex > .col-lg-auto, .flex > .col-lg-12, .flex > .col-lg-11, .flex > .col-lg-10, .flex > .col-lg-9, .flex > .col-lg-8, .flex > .col-lg-7, .flex > .col-lg-6, .flex > .col-lg-5, .flex > .col-lg-4, .flex > .col-lg-3, .flex > .col-lg-2, .flex > .col-lg-1, .flex > .col-lg-0, .row > .col-lg-grow, .flex > .col-lg-grow, .row > .col-lg-shrink, .flex > .col-lg-shrink {\n    width: auto;\n    min-width: 0;\n    max-width: 100%;\n  }\n  .column > .col-lg, .flex > .col-lg, .column > .col-lg-auto, .column > .col-lg-12, .column > .col-lg-11, .column > .col-lg-10, .column > .col-lg-9, .column > .col-lg-8, .column > .col-lg-7, .column > .col-lg-6, .column > .col-lg-5, .column > .col-lg-4, .column > .col-lg-3, .column > .col-lg-2, .column > .col-lg-1, .column > .col-lg-0, .flex > .col-lg-auto, .flex > .col-lg-12, .flex > .col-lg-11, .flex > .col-lg-10, .flex > .col-lg-9, .flex > .col-lg-8, .flex > .col-lg-7, .flex > .col-lg-6, .flex > .col-lg-5, .flex > .col-lg-4, .flex > .col-lg-3, .flex > .col-lg-2, .flex > .col-lg-1, .flex > .col-lg-0, .column > .col-lg-grow, .flex > .col-lg-grow, .column > .col-lg-shrink, .flex > .col-lg-shrink {\n    height: auto;\n    min-height: 0;\n    max-height: 100%;\n  }\n  .col-lg {\n    flex: 10000 1 0%;\n  }\n  .col-lg-auto, .col-lg-12, .col-lg-11, .col-lg-10, .col-lg-9, .col-lg-8, .col-lg-7, .col-lg-6, .col-lg-5, .col-lg-4, .col-lg-3, .col-lg-2, .col-lg-1, .col-lg-0 {\n    flex: 0 0 auto;\n  }\n  .col-lg-grow {\n    flex: 1 0 auto;\n  }\n  .col-lg-shrink {\n    flex: 0 1 auto;\n  }\n\n  .row > .col-lg-0 {\n    height: auto;\n    width: 0%;\n  }\n  .row > .offset-lg-0 {\n    margin-left: 0%;\n  }\n\n  .column > .col-lg-0 {\n    height: 0%;\n    width: auto;\n  }\n\n  .row > .col-lg-1 {\n    height: auto;\n    width: 8.3333%;\n  }\n  .row > .offset-lg-1 {\n    margin-left: 8.3333%;\n  }\n\n  .column > .col-lg-1 {\n    height: 8.3333%;\n    width: auto;\n  }\n\n  .row > .col-lg-2 {\n    height: auto;\n    width: 16.6667%;\n  }\n  .row > .offset-lg-2 {\n    margin-left: 16.6667%;\n  }\n\n  .column > .col-lg-2 {\n    height: 16.6667%;\n    width: auto;\n  }\n\n  .row > .col-lg-3 {\n    height: auto;\n    width: 25%;\n  }\n  .row > .offset-lg-3 {\n    margin-left: 25%;\n  }\n\n  .column > .col-lg-3 {\n    height: 25%;\n    width: auto;\n  }\n\n  .row > .col-lg-4 {\n    height: auto;\n    width: 33.3333%;\n  }\n  .row > .offset-lg-4 {\n    margin-left: 33.3333%;\n  }\n\n  .column > .col-lg-4 {\n    height: 33.3333%;\n    width: auto;\n  }\n\n  .row > .col-lg-5 {\n    height: auto;\n    width: 41.6667%;\n  }\n  .row > .offset-lg-5 {\n    margin-left: 41.6667%;\n  }\n\n  .column > .col-lg-5 {\n    height: 41.6667%;\n    width: auto;\n  }\n\n  .row > .col-lg-6 {\n    height: auto;\n    width: 50%;\n  }\n  .row > .offset-lg-6 {\n    margin-left: 50%;\n  }\n\n  .column > .col-lg-6 {\n    height: 50%;\n    width: auto;\n  }\n\n  .row > .col-lg-7 {\n    height: auto;\n    width: 58.3333%;\n  }\n  .row > .offset-lg-7 {\n    margin-left: 58.3333%;\n  }\n\n  .column > .col-lg-7 {\n    height: 58.3333%;\n    width: auto;\n  }\n\n  .row > .col-lg-8 {\n    height: auto;\n    width: 66.6667%;\n  }\n  .row > .offset-lg-8 {\n    margin-left: 66.6667%;\n  }\n\n  .column > .col-lg-8 {\n    height: 66.6667%;\n    width: auto;\n  }\n\n  .row > .col-lg-9 {\n    height: auto;\n    width: 75%;\n  }\n  .row > .offset-lg-9 {\n    margin-left: 75%;\n  }\n\n  .column > .col-lg-9 {\n    height: 75%;\n    width: auto;\n  }\n\n  .row > .col-lg-10 {\n    height: auto;\n    width: 83.3333%;\n  }\n  .row > .offset-lg-10 {\n    margin-left: 83.3333%;\n  }\n\n  .column > .col-lg-10 {\n    height: 83.3333%;\n    width: auto;\n  }\n\n  .row > .col-lg-11 {\n    height: auto;\n    width: 91.6667%;\n  }\n  .row > .offset-lg-11 {\n    margin-left: 91.6667%;\n  }\n\n  .column > .col-lg-11 {\n    height: 91.6667%;\n    width: auto;\n  }\n\n  .row > .col-lg-12 {\n    height: auto;\n    width: 100%;\n  }\n  .row > .offset-lg-12 {\n    margin-left: 100%;\n  }\n\n  .column > .col-lg-12 {\n    height: 100%;\n    width: auto;\n  }\n}\n@media (min-width: 1920px) {\n  .row > .col-xl, .flex > .col-xl, .row > .col-xl-auto, .row > .col-xl-12, .row > .col-xl-11, .row > .col-xl-10, .row > .col-xl-9, .row > .col-xl-8, .row > .col-xl-7, .row > .col-xl-6, .row > .col-xl-5, .row > .col-xl-4, .row > .col-xl-3, .row > .col-xl-2, .row > .col-xl-1, .row > .col-xl-0, .flex > .col-xl-auto, .flex > .col-xl-12, .flex > .col-xl-11, .flex > .col-xl-10, .flex > .col-xl-9, .flex > .col-xl-8, .flex > .col-xl-7, .flex > .col-xl-6, .flex > .col-xl-5, .flex > .col-xl-4, .flex > .col-xl-3, .flex > .col-xl-2, .flex > .col-xl-1, .flex > .col-xl-0, .row > .col-xl-grow, .flex > .col-xl-grow, .row > .col-xl-shrink, .flex > .col-xl-shrink {\n    width: auto;\n    min-width: 0;\n    max-width: 100%;\n  }\n  .column > .col-xl, .flex > .col-xl, .column > .col-xl-auto, .column > .col-xl-12, .column > .col-xl-11, .column > .col-xl-10, .column > .col-xl-9, .column > .col-xl-8, .column > .col-xl-7, .column > .col-xl-6, .column > .col-xl-5, .column > .col-xl-4, .column > .col-xl-3, .column > .col-xl-2, .column > .col-xl-1, .column > .col-xl-0, .flex > .col-xl-auto, .flex > .col-xl-12, .flex > .col-xl-11, .flex > .col-xl-10, .flex > .col-xl-9, .flex > .col-xl-8, .flex > .col-xl-7, .flex > .col-xl-6, .flex > .col-xl-5, .flex > .col-xl-4, .flex > .col-xl-3, .flex > .col-xl-2, .flex > .col-xl-1, .flex > .col-xl-0, .column > .col-xl-grow, .flex > .col-xl-grow, .column > .col-xl-shrink, .flex > .col-xl-shrink {\n    height: auto;\n    min-height: 0;\n    max-height: 100%;\n  }\n  .col-xl {\n    flex: 10000 1 0%;\n  }\n  .col-xl-auto, .col-xl-12, .col-xl-11, .col-xl-10, .col-xl-9, .col-xl-8, .col-xl-7, .col-xl-6, .col-xl-5, .col-xl-4, .col-xl-3, .col-xl-2, .col-xl-1, .col-xl-0 {\n    flex: 0 0 auto;\n  }\n  .col-xl-grow {\n    flex: 1 0 auto;\n  }\n  .col-xl-shrink {\n    flex: 0 1 auto;\n  }\n\n  .row > .col-xl-0 {\n    height: auto;\n    width: 0%;\n  }\n  .row > .offset-xl-0 {\n    margin-left: 0%;\n  }\n\n  .column > .col-xl-0 {\n    height: 0%;\n    width: auto;\n  }\n\n  .row > .col-xl-1 {\n    height: auto;\n    width: 8.3333%;\n  }\n  .row > .offset-xl-1 {\n    margin-left: 8.3333%;\n  }\n\n  .column > .col-xl-1 {\n    height: 8.3333%;\n    width: auto;\n  }\n\n  .row > .col-xl-2 {\n    height: auto;\n    width: 16.6667%;\n  }\n  .row > .offset-xl-2 {\n    margin-left: 16.6667%;\n  }\n\n  .column > .col-xl-2 {\n    height: 16.6667%;\n    width: auto;\n  }\n\n  .row > .col-xl-3 {\n    height: auto;\n    width: 25%;\n  }\n  .row > .offset-xl-3 {\n    margin-left: 25%;\n  }\n\n  .column > .col-xl-3 {\n    height: 25%;\n    width: auto;\n  }\n\n  .row > .col-xl-4 {\n    height: auto;\n    width: 33.3333%;\n  }\n  .row > .offset-xl-4 {\n    margin-left: 33.3333%;\n  }\n\n  .column > .col-xl-4 {\n    height: 33.3333%;\n    width: auto;\n  }\n\n  .row > .col-xl-5 {\n    height: auto;\n    width: 41.6667%;\n  }\n  .row > .offset-xl-5 {\n    margin-left: 41.6667%;\n  }\n\n  .column > .col-xl-5 {\n    height: 41.6667%;\n    width: auto;\n  }\n\n  .row > .col-xl-6 {\n    height: auto;\n    width: 50%;\n  }\n  .row > .offset-xl-6 {\n    margin-left: 50%;\n  }\n\n  .column > .col-xl-6 {\n    height: 50%;\n    width: auto;\n  }\n\n  .row > .col-xl-7 {\n    height: auto;\n    width: 58.3333%;\n  }\n  .row > .offset-xl-7 {\n    margin-left: 58.3333%;\n  }\n\n  .column > .col-xl-7 {\n    height: 58.3333%;\n    width: auto;\n  }\n\n  .row > .col-xl-8 {\n    height: auto;\n    width: 66.6667%;\n  }\n  .row > .offset-xl-8 {\n    margin-left: 66.6667%;\n  }\n\n  .column > .col-xl-8 {\n    height: 66.6667%;\n    width: auto;\n  }\n\n  .row > .col-xl-9 {\n    height: auto;\n    width: 75%;\n  }\n  .row > .offset-xl-9 {\n    margin-left: 75%;\n  }\n\n  .column > .col-xl-9 {\n    height: 75%;\n    width: auto;\n  }\n\n  .row > .col-xl-10 {\n    height: auto;\n    width: 83.3333%;\n  }\n  .row > .offset-xl-10 {\n    margin-left: 83.3333%;\n  }\n\n  .column > .col-xl-10 {\n    height: 83.3333%;\n    width: auto;\n  }\n\n  .row > .col-xl-11 {\n    height: auto;\n    width: 91.6667%;\n  }\n  .row > .offset-xl-11 {\n    margin-left: 91.6667%;\n  }\n\n  .column > .col-xl-11 {\n    height: 91.6667%;\n    width: auto;\n  }\n\n  .row > .col-xl-12 {\n    height: auto;\n    width: 100%;\n  }\n  .row > .offset-xl-12 {\n    margin-left: 100%;\n  }\n\n  .column > .col-xl-12 {\n    height: 100%;\n    width: auto;\n  }\n}\n.rounded-borders {\n  border-radius: 4px;\n}\n.border-radius-inherit {\n  border-radius: inherit;\n}\n.no-transition {\n  transition: none !important;\n}\n.transition-0 {\n  transition: 0s !important;\n}\n.glossy {\n  background-image: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0) 50%, rgba(0, 0, 0, 0.12) 51%, rgba(0, 0, 0, 0.04)) !important;\n}\n.q-placeholder::placeholder {\n  color: inherit;\n  opacity: 0.7;\n}\n.q-body--fullscreen-mixin, .q-body--prevent-scroll {\n  position: fixed !important;\n}\n.q-body--force-scrollbar-x {\n  overflow-x: scroll;\n}\n.q-body--force-scrollbar-y {\n  overflow-y: scroll;\n}\n.q-no-input-spinner {\n  -moz-appearance: textfield !important;\n}\n.q-no-input-spinner::-webkit-outer-spin-button, .q-no-input-spinner::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n.q-link {\n  outline: 0;\n  text-decoration: none;\n}\n.q-link--focusable:focus-visible {\n  -webkit-text-decoration: underline dashed currentColor 1px;\n          text-decoration: underline dashed currentColor 1px;\n}\nbody.electron .q-electron-drag {\n  -webkit-user-select: none;\n  -webkit-app-region: drag;\n}\nbody.electron .q-electron-drag .q-btn-item, body.electron .q-electron-drag--exception {\n  -webkit-app-region: no-drag;\n}\nimg.responsive {\n  max-width: 100%;\n  height: auto;\n}\n.non-selectable {\n  -webkit-user-select: none !important;\n          user-select: none !important;\n}\n.scroll {\n  overflow: auto;\n}\n.scroll, .scroll-x, .scroll-y {\n  -webkit-overflow-scrolling: touch;\n  will-change: scroll-position;\n}\n.scroll-x {\n  overflow-x: auto;\n}\n.scroll-y {\n  overflow-y: auto;\n}\n.no-scroll {\n  overflow: hidden !important;\n}\n.no-pointer-events,\n.no-pointer-events--children,\n.no-pointer-events--children * {\n  pointer-events: none !important;\n}\n.all-pointer-events {\n  pointer-events: all !important;\n}\n.cursor-pointer {\n  cursor: pointer !important;\n}\n.cursor-not-allowed {\n  cursor: not-allowed !important;\n}\n.cursor-inherit {\n  cursor: inherit !important;\n}\n.cursor-none {\n  cursor: none !important;\n}\n[aria-busy=true] {\n  cursor: progress;\n}\n[aria-controls] {\n  cursor: pointer;\n}\n[aria-disabled] {\n  cursor: default;\n}\n.rotate-45 {\n  transform: rotate(45deg) /* rtl:ignore */;\n}\n.rotate-90 {\n  transform: rotate(90deg) /* rtl:ignore */;\n}\n.rotate-135 {\n  transform: rotate(135deg) /* rtl:ignore */;\n}\n.rotate-180 {\n  transform: rotate(180deg) /* rtl:ignore */;\n}\n.rotate-225 {\n  transform: rotate(225deg) /* rtl:ignore */;\n}\n.rotate-270 {\n  transform: rotate(270deg) /* rtl:ignore */;\n}\n.rotate-315 {\n  transform: rotate(315deg) /* rtl:ignore */;\n}\n.flip-horizontal {\n  transform: scaleX(-1);\n}\n.flip-vertical {\n  transform: scaleY(-1);\n}\n.float-left {\n  float: left;\n}\n.float-right {\n  float: right;\n}\n.relative-position {\n  position: relative;\n}\n.fixed,\n.fixed-full,\n.fullscreen,\n.fixed-center,\n.fixed-bottom,\n.fixed-left,\n.fixed-right,\n.fixed-top,\n.fixed-top-left,\n.fixed-top-right,\n.fixed-bottom-left,\n.fixed-bottom-right {\n  position: fixed;\n}\n.absolute,\n.absolute-full,\n.absolute-center,\n.absolute-bottom,\n.absolute-left,\n.absolute-right,\n.absolute-top,\n.absolute-top-left,\n.absolute-top-right,\n.absolute-bottom-left,\n.absolute-bottom-right {\n  position: absolute;\n}\n.fixed-top, .absolute-top {\n  top: 0;\n  left: 0;\n  right: 0;\n}\n.fixed-right, .absolute-right {\n  top: 0;\n  right: 0;\n  bottom: 0;\n}\n.fixed-bottom, .absolute-bottom {\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.fixed-left, .absolute-left {\n  top: 0;\n  bottom: 0;\n  left: 0;\n}\n.fixed-top-left, .absolute-top-left {\n  top: 0;\n  left: 0;\n}\n.fixed-top-right, .absolute-top-right {\n  top: 0;\n  right: 0;\n}\n.fixed-bottom-left, .absolute-bottom-left {\n  bottom: 0;\n  left: 0;\n}\n.fixed-bottom-right, .absolute-bottom-right {\n  bottom: 0;\n  right: 0;\n}\n.fullscreen {\n  z-index: 6000;\n  border-radius: 0 !important;\n  max-width: 100vw;\n  max-height: 100vh;\n}\nbody.q-ios-padding .fullscreen {\n  padding-top: 20px !important;\n  padding-top: env(safe-area-inset-top) !important;\n  padding-bottom: env(safe-area-inset-bottom) !important;\n}\n.absolute-full, .fullscreen, .fixed-full {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.fixed-center, .absolute-center {\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n.vertical-top {\n  vertical-align: top !important;\n}\n.vertical-middle {\n  vertical-align: middle !important;\n}\n.vertical-bottom {\n  vertical-align: bottom !important;\n}\n.on-left {\n  margin-right: 12px;\n}\n.on-right {\n  margin-left: 12px;\n}\n/* internal: */\n.q-position-engine {\n  margin-top: var(--q-pe-top, 0) !important;\n  margin-left: var(--q-pe-left, 0) !important;\n  will-change: auto;\n  visibility: collapse;\n}\n:root {\n  --q-size-xs: 0;\n  --q-size-sm: 600px;\n  --q-size-md: 1024px;\n  --q-size-lg: 1440px;\n  --q-size-xl: 1920px;\n}\n.fit {\n  width: 100% !important;\n  height: 100% !important;\n}\n.full-height {\n  height: 100% !important;\n}\n.full-width {\n  width: 100% !important;\n  margin-left: 0 !important;\n  margin-right: 0 !important;\n}\n.window-height {\n  margin-top: 0 !important;\n  margin-bottom: 0 !important;\n  height: 100vh !important;\n}\n.window-width {\n  margin-left: 0 !important;\n  margin-right: 0 !important;\n  width: 100vw !important;\n}\n.block {\n  display: block !important;\n}\n.inline-block {\n  display: inline-block !important;\n}\n.q-pa-none {\n  padding: 0 0;\n}\n.q-pl-none {\n  padding-left: 0;\n}\n.q-pr-none {\n  padding-right: 0;\n}\n.q-pt-none {\n  padding-top: 0;\n}\n.q-pb-none {\n  padding-bottom: 0;\n}\n.q-px-none {\n  padding-left: 0;\n  padding-right: 0;\n}\n.q-py-none {\n  padding-top: 0;\n  padding-bottom: 0;\n}\n.q-ma-none {\n  margin: 0 0;\n}\n.q-ml-none {\n  margin-left: 0;\n}\n.q-mr-none {\n  margin-right: 0;\n}\n.q-mt-none {\n  margin-top: 0;\n}\n.q-mb-none {\n  margin-bottom: 0;\n}\n.q-mx-none {\n  margin-left: 0;\n  margin-right: 0;\n}\n.q-my-none {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.q-pa-xs {\n  padding: 4px 4px;\n}\n.q-pl-xs {\n  padding-left: 4px;\n}\n.q-pr-xs {\n  padding-right: 4px;\n}\n.q-pt-xs {\n  padding-top: 4px;\n}\n.q-pb-xs {\n  padding-bottom: 4px;\n}\n.q-px-xs {\n  padding-left: 4px;\n  padding-right: 4px;\n}\n.q-py-xs {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n.q-ma-xs {\n  margin: 4px 4px;\n}\n.q-ml-xs {\n  margin-left: 4px;\n}\n.q-mr-xs {\n  margin-right: 4px;\n}\n.q-mt-xs {\n  margin-top: 4px;\n}\n.q-mb-xs {\n  margin-bottom: 4px;\n}\n.q-mx-xs {\n  margin-left: 4px;\n  margin-right: 4px;\n}\n.q-my-xs {\n  margin-top: 4px;\n  margin-bottom: 4px;\n}\n.q-pa-sm {\n  padding: 8px 8px;\n}\n.q-pl-sm {\n  padding-left: 8px;\n}\n.q-pr-sm {\n  padding-right: 8px;\n}\n.q-pt-sm {\n  padding-top: 8px;\n}\n.q-pb-sm {\n  padding-bottom: 8px;\n}\n.q-px-sm {\n  padding-left: 8px;\n  padding-right: 8px;\n}\n.q-py-sm {\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n.q-ma-sm {\n  margin: 8px 8px;\n}\n.q-ml-sm {\n  margin-left: 8px;\n}\n.q-mr-sm {\n  margin-right: 8px;\n}\n.q-mt-sm {\n  margin-top: 8px;\n}\n.q-mb-sm {\n  margin-bottom: 8px;\n}\n.q-mx-sm {\n  margin-left: 8px;\n  margin-right: 8px;\n}\n.q-my-sm {\n  margin-top: 8px;\n  margin-bottom: 8px;\n}\n.q-pa-md {\n  padding: 16px 16px;\n}\n.q-pl-md {\n  padding-left: 16px;\n}\n.q-pr-md {\n  padding-right: 16px;\n}\n.q-pt-md {\n  padding-top: 16px;\n}\n.q-pb-md {\n  padding-bottom: 16px;\n}\n.q-px-md {\n  padding-left: 16px;\n  padding-right: 16px;\n}\n.q-py-md {\n  padding-top: 16px;\n  padding-bottom: 16px;\n}\n.q-ma-md {\n  margin: 16px 16px;\n}\n.q-ml-md {\n  margin-left: 16px;\n}\n.q-mr-md {\n  margin-right: 16px;\n}\n.q-mt-md {\n  margin-top: 16px;\n}\n.q-mb-md {\n  margin-bottom: 16px;\n}\n.q-mx-md {\n  margin-left: 16px;\n  margin-right: 16px;\n}\n.q-my-md {\n  margin-top: 16px;\n  margin-bottom: 16px;\n}\n.q-pa-lg {\n  padding: 24px 24px;\n}\n.q-pl-lg {\n  padding-left: 24px;\n}\n.q-pr-lg {\n  padding-right: 24px;\n}\n.q-pt-lg {\n  padding-top: 24px;\n}\n.q-pb-lg {\n  padding-bottom: 24px;\n}\n.q-px-lg {\n  padding-left: 24px;\n  padding-right: 24px;\n}\n.q-py-lg {\n  padding-top: 24px;\n  padding-bottom: 24px;\n}\n.q-ma-lg {\n  margin: 24px 24px;\n}\n.q-ml-lg {\n  margin-left: 24px;\n}\n.q-mr-lg {\n  margin-right: 24px;\n}\n.q-mt-lg {\n  margin-top: 24px;\n}\n.q-mb-lg {\n  margin-bottom: 24px;\n}\n.q-mx-lg {\n  margin-left: 24px;\n  margin-right: 24px;\n}\n.q-my-lg {\n  margin-top: 24px;\n  margin-bottom: 24px;\n}\n.q-pa-xl {\n  padding: 48px 48px;\n}\n.q-pl-xl {\n  padding-left: 48px;\n}\n.q-pr-xl {\n  padding-right: 48px;\n}\n.q-pt-xl {\n  padding-top: 48px;\n}\n.q-pb-xl {\n  padding-bottom: 48px;\n}\n.q-px-xl {\n  padding-left: 48px;\n  padding-right: 48px;\n}\n.q-py-xl {\n  padding-top: 48px;\n  padding-bottom: 48px;\n}\n.q-ma-xl {\n  margin: 48px 48px;\n}\n.q-ml-xl {\n  margin-left: 48px;\n}\n.q-mr-xl {\n  margin-right: 48px;\n}\n.q-mt-xl {\n  margin-top: 48px;\n}\n.q-mb-xl {\n  margin-bottom: 48px;\n}\n.q-mx-xl {\n  margin-left: 48px;\n  margin-right: 48px;\n}\n.q-my-xl {\n  margin-top: 48px;\n  margin-bottom: 48px;\n}\n.q-mt-auto, .q-my-auto {\n  margin-top: auto;\n}\n.q-ml-auto {\n  margin-left: auto;\n}\n.q-mb-auto, .q-my-auto {\n  margin-bottom: auto;\n}\n.q-mr-auto {\n  margin-right: auto;\n}\n.q-mx-auto {\n  margin-left: auto;\n  margin-right: auto;\n}\n.q-touch {\n  -webkit-user-select: none;\n          user-select: none;\n  user-drag: none;\n  -khtml-user-drag: none;\n  -webkit-user-drag: none;\n}\n.q-touch-x {\n  touch-action: pan-x;\n}\n.q-touch-y {\n  touch-action: pan-y;\n}\n:root {\n  --q-transition-duration: .3s;\n}\n.q-transition--slide-right-enter-active, .q-transition--slide-right-leave-active, .q-transition--slide-left-enter-active, .q-transition--slide-left-leave-active, .q-transition--slide-up-enter-active, .q-transition--slide-up-leave-active, .q-transition--slide-down-enter-active, .q-transition--slide-down-leave-active, .q-transition--jump-right-enter-active, .q-transition--jump-right-leave-active, .q-transition--jump-left-enter-active, .q-transition--jump-left-leave-active, .q-transition--jump-up-enter-active, .q-transition--jump-up-leave-active, .q-transition--jump-down-enter-active, .q-transition--jump-down-leave-active, .q-transition--fade-enter-active, .q-transition--fade-leave-active, .q-transition--scale-enter-active, .q-transition--scale-leave-active, .q-transition--rotate-enter-active, .q-transition--rotate-leave-active, .q-transition--flip-enter-active, .q-transition--flip-leave-active {\n  --q-transition-duration: .3s;\n  --q-transition-easing: cubic-bezier(0.215,0.61,0.355,1);\n}\n.q-transition--slide-right-leave-active, .q-transition--slide-left-leave-active, .q-transition--slide-up-leave-active, .q-transition--slide-down-leave-active, .q-transition--jump-right-leave-active, .q-transition--jump-left-leave-active, .q-transition--jump-up-leave-active, .q-transition--jump-down-leave-active, .q-transition--fade-leave-active, .q-transition--scale-leave-active, .q-transition--rotate-leave-active, .q-transition--flip-leave-active {\n  position: absolute;\n}\n.q-transition--slide-right-enter-active, .q-transition--slide-right-leave-active, .q-transition--slide-left-enter-active, .q-transition--slide-left-leave-active, .q-transition--slide-up-enter-active, .q-transition--slide-up-leave-active, .q-transition--slide-down-enter-active, .q-transition--slide-down-leave-active {\n  transition: transform var(--q-transition-duration) var(--q-transition-easing);\n}\n.q-transition--slide-right-enter-from {\n  transform: translate3d(-100%, 0, 0);\n}\n.q-transition--slide-right-leave-to {\n  transform: translate3d(100%, 0, 0);\n}\n.q-transition--slide-left-enter-from {\n  transform: translate3d(100%, 0, 0);\n}\n.q-transition--slide-left-leave-to {\n  transform: translate3d(-100%, 0, 0);\n}\n.q-transition--slide-up-enter-from {\n  transform: translate3d(0, 100%, 0);\n}\n.q-transition--slide-up-leave-to {\n  transform: translate3d(0, -100%, 0);\n}\n.q-transition--slide-down-enter-from {\n  transform: translate3d(0, -100%, 0);\n}\n.q-transition--slide-down-leave-to {\n  transform: translate3d(0, 100%, 0);\n}\n.q-transition--jump-right-enter-active, .q-transition--jump-right-leave-active, .q-transition--jump-left-enter-active, .q-transition--jump-left-leave-active, .q-transition--jump-up-enter-active, .q-transition--jump-up-leave-active, .q-transition--jump-down-enter-active, .q-transition--jump-down-leave-active {\n  transition: opacity var(--q-transition-duration), transform var(--q-transition-duration);\n}\n.q-transition--jump-right-enter-from, .q-transition--jump-right-leave-to, .q-transition--jump-left-enter-from, .q-transition--jump-left-leave-to, .q-transition--jump-up-enter-from, .q-transition--jump-up-leave-to, .q-transition--jump-down-enter-from, .q-transition--jump-down-leave-to {\n  opacity: 0;\n}\n.q-transition--jump-right-enter-from {\n  transform: translate3d(-15px, 0, 0);\n}\n.q-transition--jump-right-leave-to {\n  transform: translate3d(15px, 0, 0);\n}\n.q-transition--jump-left-enter-from {\n  transform: translate3d(15px, 0, 0);\n}\n.q-transition--jump-left-leave-to {\n  transform: translateX(-15px);\n}\n.q-transition--jump-up-enter-from {\n  transform: translate3d(0, 15px, 0);\n}\n.q-transition--jump-up-leave-to {\n  transform: translate3d(0, -15px, 0);\n}\n.q-transition--jump-down-enter-from {\n  transform: translate3d(0, -15px, 0);\n}\n.q-transition--jump-down-leave-to {\n  transform: translate3d(0, 15px, 0);\n}\n.q-transition--fade-enter-active, .q-transition--fade-leave-active {\n  transition: opacity var(--q-transition-duration) ease-out;\n}\n.q-transition--fade-enter-from, .q-transition--fade-leave-to {\n  opacity: 0;\n}\n.q-transition--scale-enter-active, .q-transition--scale-leave-active {\n  transition: opacity var(--q-transition-duration), transform var(--q-transition-duration) var(--q-transition-easing);\n}\n.q-transition--scale-enter-from, .q-transition--scale-leave-to {\n  opacity: 0;\n  transform: scale3d(0, 0, 1);\n}\n.q-transition--rotate-enter-active, .q-transition--rotate-leave-active {\n  transition: opacity var(--q-transition-duration), transform var(--q-transition-duration) var(--q-transition-easing);\n  transform-style: preserve-3d;\n}\n.q-transition--rotate-enter-from, .q-transition--rotate-leave-to {\n  opacity: 0;\n  transform: scale3d(0, 0, 1) rotate3d(0, 0, 1, 90deg);\n}\n.q-transition--flip-right-enter-active, .q-transition--flip-right-leave-active, .q-transition--flip-left-enter-active, .q-transition--flip-left-leave-active, .q-transition--flip-up-enter-active, .q-transition--flip-up-leave-active, .q-transition--flip-down-enter-active, .q-transition--flip-down-leave-active {\n  transition: transform var(--q-transition-duration);\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n}\n.q-transition--flip-right-enter-to, .q-transition--flip-right-leave-from, .q-transition--flip-left-enter-to, .q-transition--flip-left-leave-from, .q-transition--flip-up-enter-to, .q-transition--flip-up-leave-from, .q-transition--flip-down-enter-to, .q-transition--flip-down-leave-from {\n  transform: perspective(400px) rotate3d(1, 1, 0, 0deg);\n}\n.q-transition--flip-right-enter-from {\n  transform: perspective(400px) rotate3d(0, 1, 0, -180deg);\n}\n.q-transition--flip-right-leave-to {\n  transform: perspective(400px) rotate3d(0, 1, 0, 180deg);\n}\n.q-transition--flip-left-enter-from {\n  transform: perspective(400px) rotate3d(0, 1, 0, 180deg);\n}\n.q-transition--flip-left-leave-to {\n  transform: perspective(400px) rotate3d(0, 1, 0, -180deg);\n}\n.q-transition--flip-up-enter-from {\n  transform: perspective(400px) rotate3d(1, 0, 0, -180deg);\n}\n.q-transition--flip-up-leave-to {\n  transform: perspective(400px) rotate3d(1, 0, 0, 180deg);\n}\n.q-transition--flip-down-enter-from {\n  transform: perspective(400px) rotate3d(1, 0, 0, 180deg);\n}\n.q-transition--flip-down-leave-to {\n  transform: perspective(400px) rotate3d(1, 0, 0, -180deg);\n}\nbody {\n  min-width: 100px;\n  min-height: 100%;\n  font-family: "Roboto", "-apple-system", "Helvetica Neue", Helvetica, Arial, sans-serif;\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  font-smoothing: antialiased;\n  line-height: 1.5;\n  font-size: 14px;\n}\nh1 {\n  font-size: 6rem;\n  font-weight: 300;\n  line-height: 6rem;\n  letter-spacing: -0.01562em;\n}\nh2 {\n  font-size: 3.75rem;\n  font-weight: 300;\n  line-height: 3.75rem;\n  letter-spacing: -0.00833em;\n}\nh3 {\n  font-size: 3rem;\n  font-weight: 400;\n  line-height: 3.125rem;\n  letter-spacing: normal;\n}\nh4 {\n  font-size: 2.125rem;\n  font-weight: 400;\n  line-height: 2.5rem;\n  letter-spacing: 0.00735em;\n}\nh5 {\n  font-size: 1.5rem;\n  font-weight: 400;\n  line-height: 2rem;\n  letter-spacing: normal;\n}\nh6 {\n  font-size: 1.25rem;\n  font-weight: 500;\n  line-height: 2rem;\n  letter-spacing: 0.0125em;\n}\np {\n  margin: 0 0 16px;\n}\n.text-h1 {\n  font-size: 6rem;\n  font-weight: 300;\n  line-height: 6rem;\n  letter-spacing: -0.01562em;\n}\n.text-h2 {\n  font-size: 3.75rem;\n  font-weight: 300;\n  line-height: 3.75rem;\n  letter-spacing: -0.00833em;\n}\n.text-h3 {\n  font-size: 3rem;\n  font-weight: 400;\n  line-height: 3.125rem;\n  letter-spacing: normal;\n}\n.text-h4 {\n  font-size: 2.125rem;\n  font-weight: 400;\n  line-height: 2.5rem;\n  letter-spacing: 0.00735em;\n}\n.text-h5 {\n  font-size: 1.5rem;\n  font-weight: 400;\n  line-height: 2rem;\n  letter-spacing: normal;\n}\n.text-h6 {\n  font-size: 1.25rem;\n  font-weight: 500;\n  line-height: 2rem;\n  letter-spacing: 0.0125em;\n}\n.text-subtitle1 {\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.75rem;\n  letter-spacing: 0.00937em;\n}\n.text-subtitle2 {\n  font-size: 0.875rem;\n  font-weight: 500;\n  line-height: 1.375rem;\n  letter-spacing: 0.00714em;\n}\n.text-body1 {\n  font-size: 1rem;\n  font-weight: 400;\n  line-height: 1.5rem;\n  letter-spacing: 0.03125em;\n}\n.text-body2 {\n  font-size: 0.875rem;\n  font-weight: 400;\n  line-height: 1.25rem;\n  letter-spacing: 0.01786em;\n}\n.text-overline {\n  font-size: 0.75rem;\n  font-weight: 500;\n  line-height: 2rem;\n  letter-spacing: 0.16667em;\n}\n.text-caption {\n  font-size: 0.75rem;\n  font-weight: 400;\n  line-height: 1.25rem;\n  letter-spacing: 0.03333em;\n}\n.text-uppercase {\n  text-transform: uppercase;\n}\n.text-lowercase {\n  text-transform: lowercase;\n}\n.text-capitalize {\n  text-transform: capitalize;\n}\n.text-center {\n  text-align: center;\n}\n.text-left {\n  text-align: left;\n}\n.text-right {\n  text-align: right;\n}\n.text-justify {\n  text-align: justify;\n  -webkit-hyphens: auto;\n          hyphens: auto;\n}\n.text-italic {\n  font-style: italic;\n}\n.text-bold {\n  font-weight: bold;\n}\n.text-no-wrap {\n  white-space: nowrap;\n}\n.text-strike {\n  text-decoration: line-through;\n}\n.text-weight-thin {\n  font-weight: 100;\n}\n.text-weight-light {\n  font-weight: 300;\n}\n.text-weight-regular {\n  font-weight: 400;\n}\n.text-weight-medium {\n  font-weight: 500;\n}\n.text-weight-bold {\n  font-weight: 700;\n}\n.text-weight-bolder {\n  font-weight: 900;\n}\nsmall {\n  font-size: 80%;\n}\nbig {\n  font-size: 170%;\n}\nsub {\n  bottom: -0.25em;\n}\nsup {\n  top: -0.5em;\n}\n.no-margin {\n  margin: 0 !important;\n}\n.no-padding {\n  padding: 0 !important;\n}\n.no-border {\n  border: 0 !important;\n}\n.no-border-radius {\n  border-radius: 0 !important;\n}\n.no-box-shadow {\n  box-shadow: none !important;\n}\n.no-outline {\n  outline: 0 !important;\n}\n.ellipsis {\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n.ellipsis-2-lines, .ellipsis-3-lines {\n  overflow: hidden;\n  display: -webkit-box;\n  -webkit-box-orient: vertical;\n}\n.ellipsis-2-lines {\n  -webkit-line-clamp: 2;\n}\n.ellipsis-3-lines {\n  -webkit-line-clamp: 3;\n}\n.readonly {\n  cursor: default !important;\n}\n.disabled, .disabled *, [disabled], [disabled] * {\n  outline: 0 !important;\n  cursor: not-allowed !important;\n}\n.disabled, [disabled] {\n  opacity: 0.6 !important;\n}\n.hidden {\n  display: none !important;\n}\n.invisible {\n  visibility: hidden !important;\n}\n.transparent {\n  background: transparent !important;\n}\n.overflow-auto {\n  overflow: auto !important;\n}\n.overflow-hidden {\n  overflow: hidden !important;\n}\n.overflow-hidden-y {\n  overflow-y: hidden !important;\n}\n.hide-scrollbar {\n  scrollbar-width: none;\n  -ms-overflow-style: none;\n}\n.hide-scrollbar::-webkit-scrollbar {\n  width: 0;\n  height: 0;\n  display: none;\n}\n.dimmed:after, .light-dimmed:after {\n  content: "";\n  position: absolute;\n  top: 0;\n  right: 0 /* rtl:ignore */;\n  bottom: 0;\n  left: 0 /* rtl:ignore */;\n}\n.dimmed:after {\n  background: rgba(0, 0, 0, 0.4) !important;\n}\n.light-dimmed:after {\n  background: rgba(255, 255, 255, 0.6) !important;\n}\n.z-top {\n  z-index: 7000 !important;\n}\n.z-max {\n  z-index: 9998 !important;\n}\nbody:not(.desktop) .desktop-only,\nbody.desktop .desktop-hide {\n  display: none !important;\n}\nbody:not(.mobile) .mobile-only,\nbody.mobile .mobile-hide {\n  display: none !important;\n}\nbody:not(.native-mobile) .native-mobile-only,\nbody.native-mobile .native-mobile-hide {\n  display: none !important;\n}\nbody:not(.cordova) .cordova-only,\nbody.cordova .cordova-hide {\n  display: none !important;\n}\nbody:not(.capacitor) .capacitor-only,\nbody.capacitor .capacitor-hide {\n  display: none !important;\n}\nbody:not(.electron) .electron-only,\nbody.electron .electron-hide {\n  display: none !important;\n}\nbody:not(.touch) .touch-only,\nbody.touch .touch-hide {\n  display: none !important;\n}\nbody:not(.within-iframe) .within-iframe-only,\nbody.within-iframe .within-iframe-hide {\n  display: none !important;\n}\nbody:not(.platform-ios) .platform-ios-only,\nbody.platform-ios .platform-ios-hide {\n  display: none !important;\n}\nbody:not(.platform-android) .platform-android-only,\nbody.platform-android .platform-android-hide {\n  display: none !important;\n}\n@media all and (orientation: portrait) {\n  .orientation-landscape {\n    display: none !important;\n  }\n}\n@media all and (orientation: landscape) {\n  .orientation-portrait {\n    display: none !important;\n  }\n}\n@media screen {\n  .print-only {\n    display: none !important;\n  }\n}\n@media print {\n  .print-hide {\n    display: none !important;\n  }\n}\n@media (max-width: 599.98px) {\n  .xs-hide, .gt-xs, .sm, .gt-sm, .md, .gt-md, .lg, .gt-lg, .xl {\n    display: none !important;\n  }\n}\n@media (min-width: 600px) and (max-width: 1023.98px) {\n  .sm-hide, .xs, .lt-sm, .gt-sm, .md, .gt-md, .lg, .gt-lg, .xl {\n    display: none !important;\n  }\n}\n@media (min-width: 1024px) and (max-width: 1439.98px) {\n  .md-hide, .xs, .lt-sm, .sm, .lt-md, .gt-md, .lg, .gt-lg, .xl {\n    display: none !important;\n  }\n}\n@media (min-width: 1440px) and (max-width: 1919.98px) {\n  .lg-hide, .xs, .lt-sm, .sm, .lt-md, .md, .lt-lg, .gt-lg, .xl {\n    display: none !important;\n  }\n}\n@media (min-width: 1920px) {\n  .xl-hide, .xs, .lt-sm, .sm, .lt-md, .md, .lt-lg, .lg, .lt-xl {\n    display: none !important;\n  }\n}\n.q-focus-helper, .q-focusable, .q-manual-focusable, .q-hoverable {\n  outline: 0;\n}\nbody.desktop .q-focus-helper {\n  position: absolute;\n  top: 0;\n  left: 0 /* rtl:ignore */;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  border-radius: inherit;\n  opacity: 0;\n  transition: background-color 0.3s cubic-bezier(0.25, 0.8, 0.5, 1), opacity 0.4s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\nbody.desktop .q-focus-helper:before, body.desktop .q-focus-helper:after {\n  content: "";\n  position: absolute;\n  top: 0;\n  left: 0 /* rtl:ignore */;\n  width: 100%;\n  height: 100%;\n  opacity: 0;\n  border-radius: inherit;\n  transition: background-color 0.3s cubic-bezier(0.25, 0.8, 0.5, 1), opacity 0.6s cubic-bezier(0.25, 0.8, 0.5, 1);\n}\nbody.desktop .q-focus-helper:before {\n  background: #000;\n}\nbody.desktop .q-focus-helper:after {\n  background: #fff;\n}\nbody.desktop .q-focus-helper--rounded {\n  border-radius: 4px;\n}\nbody.desktop .q-focus-helper--round {\n  border-radius: 50%;\n}\nbody.desktop .q-focusable:focus > .q-focus-helper, body.desktop .q-manual-focusable--focused > .q-focus-helper, body.desktop .q-hoverable:hover > .q-focus-helper {\n  background: currentColor;\n  opacity: 0.15;\n}\nbody.desktop .q-focusable:focus > .q-focus-helper:before, body.desktop .q-manual-focusable--focused > .q-focus-helper:before, body.desktop .q-hoverable:hover > .q-focus-helper:before {\n  opacity: 0.1;\n}\nbody.desktop .q-focusable:focus > .q-focus-helper:after, body.desktop .q-manual-focusable--focused > .q-focus-helper:after, body.desktop .q-hoverable:hover > .q-focus-helper:after {\n  opacity: 0.4;\n}\nbody.desktop .q-focusable:focus > .q-focus-helper, body.desktop .q-manual-focusable--focused > .q-focus-helper {\n  opacity: 0.22;\n}\nbody.body--dark {\n  color: #fff;\n  background: var(--q-dark-page);\n}\n.q-dark {\n  color: #fff;\n  background: var(--q-dark);\n}')();
var app = /* @__PURE__ */ (() => ".rows {\n  display: flex;\n  flex-direction: column;\n  gap: 3px;\n  width: 100%;\n}\n\n.cols {\n  display: flex;\n  flex-direction: row;\n  gap: 3px;\n  margin: 3px;\n  width: 100%;\n}\n\n.cols.wrap {\n  flex-wrap: wrap;\n}\n\n.cols.inline {\n  display: inline-flex;\n}\n\n.firstSmall > :first-child {\n  flex: 0 1 fit-content;\n  margin-right: auto;\n}\n\n.lastSmall > :last-child {\n  flex: 0 1 fit-content;\n  margin-left: auto;\n}\n\n.q-drawer__content {\n  background-color: transparent;\n  overflow: visible;\n}\n\naside.q-drawer {\n  background-color: transparent;\n  -webkit-backdrop-filter: brightness(85%) blur(2px);\n          backdrop-filter: brightness(85%) blur(2px);\n  isolation: isolate;\n}\n\n.bg-transparent {\n  -webkit-backdrop-filter: brightness(85%) blur(2px);\n          backdrop-filter: brightness(85%) blur(2px);\n}\n\n.bg-transparent-dark {\n  -webkit-backdrop-filter: brightness(65%) blur(2px);\n          backdrop-filter: brightness(65%) blur(2px);\n  background-color: #00000000;\n}\n\n.tex {\n  background-color: #00000035;\n}\n\n.CtxtMenu_MenuFrame {\n  z-index: 99999 !important;\n}\n\n.data-table {\n  /* height or max-height is important */\n  /* this is when the loading indicator appears */\n}\n\n.data-table .q-table__bottom {\n  bottom: 0;\n  position: sticky;\n}\n\n.data-table .q-table__top,\n.data-table .q-table__bottom,\n.data-table thead tr:first-child th {\n  /* bg color is important for th; just specify one */\n  background-color: black;\n}\n\n.data-table thead tr th {\n  position: sticky;\n  z-index: 1;\n}\n\n.data-table thead tr:first-child th {\n  top: 0;\n}\n\n.data-table.q-table--loading thead tr:last-child th {\n  /* height of all previous header rows */\n  top: 48px;\n}\n\n.q-menu {\n  background-color: #000000BB;\n  -webkit-backdrop-filter: brightness(85%) blur(2px);\n          backdrop-filter: brightness(85%) blur(2px);\n}")();
function injectProp(target, propName, get11, set3) {
  Object.defineProperty(target, propName, {
    get: get11,
    set: set3,
    enumerable: true
  });
}
function injectMultipleProps(target, props) {
  for (const key in props) {
    injectProp(target, key, props[key]);
  }
}
const isRuntimeSsrPreHydration = ref(
  false
);
let iosCorrection;
function getMatch(userAgent2, platformMatch) {
  const match = /(edg|edge|edga|edgios)\/([\w.]+)/.exec(userAgent2) || /(opr)[\/]([\w.]+)/.exec(userAgent2) || /(vivaldi)[\/]([\w.]+)/.exec(userAgent2) || /(chrome|crios)[\/]([\w.]+)/.exec(userAgent2) || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent2) || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(userAgent2) || /(firefox|fxios)[\/]([\w.]+)/.exec(userAgent2) || /(webkit)[\/]([\w.]+)/.exec(userAgent2) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(userAgent2) || [];
  return {
    browser: match[5] || match[3] || match[1] || "",
    version: match[2] || match[4] || "0",
    versionNumber: match[4] || match[2] || "0",
    platform: platformMatch[0] || ""
  };
}
function getPlatformMatch(userAgent2) {
  return /(ipad)/.exec(userAgent2) || /(ipod)/.exec(userAgent2) || /(windows phone)/.exec(userAgent2) || /(iphone)/.exec(userAgent2) || /(kindle)/.exec(userAgent2) || /(silk)/.exec(userAgent2) || /(android)/.exec(userAgent2) || /(win)/.exec(userAgent2) || /(mac)/.exec(userAgent2) || /(linux)/.exec(userAgent2) || /(cros)/.exec(userAgent2) || /(playbook)/.exec(userAgent2) || /(bb)/.exec(userAgent2) || /(blackberry)/.exec(userAgent2) || [];
}
const hasTouch = "ontouchstart" in window || window.navigator.maxTouchPoints > 0;
function applyIosCorrection(is2) {
  iosCorrection = { is: { ...is2 } };
  delete is2.mac;
  delete is2.desktop;
  const platform = Math.min(window.innerHeight, window.innerWidth) > 414 ? "ipad" : "iphone";
  Object.assign(is2, {
    mobile: true,
    ios: true,
    platform,
    [platform]: true
  });
}
function getPlatform(UA) {
  const userAgent2 = UA.toLowerCase(), platformMatch = getPlatformMatch(userAgent2), matched = getMatch(userAgent2, platformMatch), browser = {};
  if (matched.browser) {
    browser[matched.browser] = true;
    browser.version = matched.version;
    browser.versionNumber = parseInt(matched.versionNumber, 10);
  }
  if (matched.platform) {
    browser[matched.platform] = true;
  }
  const knownMobiles = browser.android || browser.ios || browser.bb || browser.blackberry || browser.ipad || browser.iphone || browser.ipod || browser.kindle || browser.playbook || browser.silk || browser["windows phone"];
  if (knownMobiles === true || userAgent2.indexOf("mobile") > -1) {
    browser.mobile = true;
    if (browser.edga || browser.edgios) {
      browser.edge = true;
      matched.browser = "edge";
    } else if (browser.crios) {
      browser.chrome = true;
      matched.browser = "chrome";
    } else if (browser.fxios) {
      browser.firefox = true;
      matched.browser = "firefox";
    }
  } else {
    browser.desktop = true;
  }
  if (browser.ipod || browser.ipad || browser.iphone) {
    browser.ios = true;
  }
  if (browser["windows phone"]) {
    browser.winphone = true;
    delete browser["windows phone"];
  }
  if (browser.chrome || browser.opr || browser.safari || browser.vivaldi || browser.mobile === true && browser.ios !== true && knownMobiles !== true) {
    browser.webkit = true;
  }
  if (browser.edg) {
    matched.browser = "edgechromium";
    browser.edgeChromium = true;
  }
  if (browser.safari && browser.blackberry || browser.bb) {
    matched.browser = "blackberry";
    browser.blackberry = true;
  }
  if (browser.safari && browser.playbook) {
    matched.browser = "playbook";
    browser.playbook = true;
  }
  if (browser.opr) {
    matched.browser = "opera";
    browser.opera = true;
  }
  if (browser.safari && browser.android) {
    matched.browser = "android";
    browser.android = true;
  }
  if (browser.safari && browser.kindle) {
    matched.browser = "kindle";
    browser.kindle = true;
  }
  if (browser.safari && browser.silk) {
    matched.browser = "silk";
    browser.silk = true;
  }
  if (browser.vivaldi) {
    matched.browser = "vivaldi";
    browser.vivaldi = true;
  }
  browser.name = matched.browser;
  browser.platform = matched.platform;
  {
    if (userAgent2.indexOf("electron") > -1) {
      browser.electron = true;
    } else if (document.location.href.indexOf("-extension://") > -1) {
      browser.bex = true;
    } else {
      if (window.Capacitor !== void 0) {
        browser.capacitor = true;
        browser.nativeMobile = true;
        browser.nativeMobileWrapper = "capacitor";
      } else if (window._cordovaNative !== void 0 || window.cordova !== void 0) {
        browser.cordova = true;
        browser.nativeMobile = true;
        browser.nativeMobileWrapper = "cordova";
      }
      if (hasTouch === true && browser.mac === true && (browser.desktop === true && browser.safari === true || browser.nativeMobile === true && browser.android !== true && browser.ios !== true && browser.ipad !== true)) {
        applyIosCorrection(browser);
      }
    }
  }
  return browser;
}
const userAgent = navigator.userAgent || navigator.vendor || window.opera;
const ssrClient = {
  has: {
    touch: false,
    webStorage: false
  },
  within: { iframe: false }
};
const client = {
  userAgent,
  is: getPlatform(userAgent),
  has: {
    touch: hasTouch
  },
  within: {
    iframe: window.self !== window.top
  }
};
const Platform = {
  install(opts) {
    const { $q } = opts;
    if (isRuntimeSsrPreHydration.value === true) {
      opts.onSSRHydrated.push(() => {
        isRuntimeSsrPreHydration.value = false;
        Object.assign($q.platform, client);
        iosCorrection = void 0;
      });
      $q.platform = reactive(this);
    } else {
      $q.platform = this;
    }
  }
};
{
  let hasWebStorage;
  injectProp(client.has, "webStorage", () => {
    if (hasWebStorage !== void 0) {
      return hasWebStorage;
    }
    try {
      if (window.localStorage) {
        hasWebStorage = true;
        return true;
      }
    } catch (e2) {
    }
    hasWebStorage = false;
    return false;
  });
  client.is.ios === true && window.navigator.vendor.toLowerCase().indexOf("apple") === -1;
  if (isRuntimeSsrPreHydration.value === true) {
    Object.assign(Platform, client, iosCorrection, ssrClient);
  } else {
    Object.assign(Platform, client);
  }
}
var defineReactivePlugin = (state2, plugin) => {
  const reactiveState = reactive(state2);
  for (const name2 in state2) {
    injectProp(
      plugin,
      name2,
      () => reactiveState[name2],
      (val) => {
        reactiveState[name2] = val;
      }
    );
  }
  return plugin;
};
const listenOpts = {
  hasPassive: false,
  passiveCapture: true,
  notPassiveCapture: true
};
try {
  const opts = Object.defineProperty({}, "passive", {
    get() {
      Object.assign(listenOpts, {
        hasPassive: true,
        passive: { passive: true },
        notPassive: { passive: false },
        passiveCapture: { passive: true, capture: true },
        notPassiveCapture: { passive: false, capture: true }
      });
    }
  });
  window.addEventListener("qtest", null, opts);
  window.removeEventListener("qtest", null, opts);
} catch (e2) {
}
function noop$1() {
}
function leftClick(e2) {
  return e2.button === 0;
}
function position(e2) {
  if (e2.touches && e2.touches[0]) {
    e2 = e2.touches[0];
  } else if (e2.changedTouches && e2.changedTouches[0]) {
    e2 = e2.changedTouches[0];
  } else if (e2.targetTouches && e2.targetTouches[0]) {
    e2 = e2.targetTouches[0];
  }
  return {
    top: e2.clientY,
    left: e2.clientX
  };
}
function getEventPath(e2) {
  if (e2.path) {
    return e2.path;
  }
  if (e2.composedPath) {
    return e2.composedPath();
  }
  const path = [];
  let el = e2.target;
  while (el) {
    path.push(el);
    if (el.tagName === "HTML") {
      path.push(document);
      path.push(window);
      return path;
    }
    el = el.parentElement;
  }
}
function stop(e2) {
  e2.stopPropagation();
}
function prevent(e2) {
  e2.cancelable !== false && e2.preventDefault();
}
function stopAndPrevent(e2) {
  e2.cancelable !== false && e2.preventDefault();
  e2.stopPropagation();
}
function preventDraggable(el, status) {
  if (el === void 0 || status === true && el.__dragPrevented === true) {
    return;
  }
  const fn = status === true ? (el2) => {
    el2.__dragPrevented = true;
    el2.addEventListener("dragstart", prevent, listenOpts.notPassiveCapture);
  } : (el2) => {
    delete el2.__dragPrevented;
    el2.removeEventListener("dragstart", prevent, listenOpts.notPassiveCapture);
  };
  el.querySelectorAll("a, img").forEach(fn);
}
function addEvt(ctx, targetName, events) {
  const name2 = `__q_${targetName}_evt`;
  ctx[name2] = ctx[name2] !== void 0 ? ctx[name2].concat(events) : events;
  events.forEach((evt) => {
    evt[0].addEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
  });
}
function cleanEvt(ctx, targetName) {
  const name2 = `__q_${targetName}_evt`;
  if (ctx[name2] !== void 0) {
    ctx[name2].forEach((evt) => {
      evt[0].removeEventListener(evt[1], ctx[evt[2]], listenOpts[evt[3]]);
    });
    ctx[name2] = void 0;
  }
}
function debounce(fn, wait = 250, immediate) {
  let timeout;
  function debounced() {
    const args = arguments;
    const later = () => {
      timeout = void 0;
      if (immediate !== true) {
        fn.apply(this, args);
      }
    };
    clearTimeout(timeout);
    if (immediate === true && timeout === void 0) {
      fn.apply(this, args);
    }
    timeout = setTimeout(later, wait);
  }
  debounced.cancel = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
const SIZE_LIST = ["sm", "md", "lg", "xl"];
const { passive } = listenOpts;
var Screen = defineReactivePlugin({
  width: 0,
  height: 0,
  name: "xs",
  sizes: {
    sm: 600,
    md: 1024,
    lg: 1440,
    xl: 1920
  },
  lt: {
    sm: true,
    md: true,
    lg: true,
    xl: true
  },
  gt: {
    xs: false,
    sm: false,
    md: false,
    lg: false
  },
  xs: true,
  sm: false,
  md: false,
  lg: false,
  xl: false
}, {
  setSizes: noop$1,
  setDebounce: noop$1,
  install({ $q, onSSRHydrated }) {
    $q.screen = this;
    if (this.__installed === true) {
      if ($q.config.screen !== void 0) {
        if ($q.config.screen.bodyClasses === false) {
          document.body.classList.remove(`screen--${this.name}`);
        } else {
          this.__update(true);
        }
      }
      return;
    }
    const { visualViewport } = window;
    const target = visualViewport || window;
    const scrollingElement = document.scrollingElement || document.documentElement;
    const getSize = visualViewport === void 0 || client.is.mobile === true ? () => [
      Math.max(window.innerWidth, scrollingElement.clientWidth),
      Math.max(window.innerHeight, scrollingElement.clientHeight)
    ] : () => [
      visualViewport.width * visualViewport.scale + window.innerWidth - scrollingElement.clientWidth,
      visualViewport.height * visualViewport.scale + window.innerHeight - scrollingElement.clientHeight
    ];
    const classes2 = $q.config.screen !== void 0 && $q.config.screen.bodyClasses === true;
    this.__update = (force) => {
      const [w, h2] = getSize();
      if (h2 !== this.height) {
        this.height = h2;
      }
      if (w !== this.width) {
        this.width = w;
      } else if (force !== true) {
        return;
      }
      let s = this.sizes;
      this.gt.xs = w >= s.sm;
      this.gt.sm = w >= s.md;
      this.gt.md = w >= s.lg;
      this.gt.lg = w >= s.xl;
      this.lt.sm = w < s.sm;
      this.lt.md = w < s.md;
      this.lt.lg = w < s.lg;
      this.lt.xl = w < s.xl;
      this.xs = this.lt.sm;
      this.sm = this.gt.xs === true && this.lt.md === true;
      this.md = this.gt.sm === true && this.lt.lg === true;
      this.lg = this.gt.md === true && this.lt.xl === true;
      this.xl = this.gt.lg;
      s = this.xs === true && "xs" || this.sm === true && "sm" || this.md === true && "md" || this.lg === true && "lg" || "xl";
      if (s !== this.name) {
        if (classes2 === true) {
          document.body.classList.remove(`screen--${this.name}`);
          document.body.classList.add(`screen--${s}`);
        }
        this.name = s;
      }
    };
    let updateEvt, updateSizes = {}, updateDebounce = 16;
    this.setSizes = (sizes) => {
      SIZE_LIST.forEach((name2) => {
        if (sizes[name2] !== void 0) {
          updateSizes[name2] = sizes[name2];
        }
      });
    };
    this.setDebounce = (deb) => {
      updateDebounce = deb;
    };
    const start2 = () => {
      const style = getComputedStyle(document.body);
      if (style.getPropertyValue("--q-size-sm")) {
        SIZE_LIST.forEach((name2) => {
          this.sizes[name2] = parseInt(style.getPropertyValue(`--q-size-${name2}`), 10);
        });
      }
      this.setSizes = (sizes) => {
        SIZE_LIST.forEach((name2) => {
          if (sizes[name2]) {
            this.sizes[name2] = sizes[name2];
          }
        });
        this.__update(true);
      };
      this.setDebounce = (delay) => {
        updateEvt !== void 0 && target.removeEventListener("resize", updateEvt, passive);
        updateEvt = delay > 0 ? debounce(this.__update, delay) : this.__update;
        target.addEventListener("resize", updateEvt, passive);
      };
      this.setDebounce(updateDebounce);
      if (Object.keys(updateSizes).length > 0) {
        this.setSizes(updateSizes);
        updateSizes = void 0;
      } else {
        this.__update();
      }
      classes2 === true && this.name === "xs" && document.body.classList.add("screen--xs");
    };
    if (isRuntimeSsrPreHydration.value === true) {
      onSSRHydrated.push(start2);
    } else {
      start2();
    }
  }
});
const Plugin$2 = defineReactivePlugin({
  isActive: false,
  mode: false
}, {
  __media: void 0,
  set(val) {
    Plugin$2.mode = val;
    if (val === "auto") {
      if (Plugin$2.__media === void 0) {
        Plugin$2.__media = window.matchMedia("(prefers-color-scheme: dark)");
        Plugin$2.__updateMedia = () => {
          Plugin$2.set("auto");
        };
        Plugin$2.__media.addListener(Plugin$2.__updateMedia);
      }
      val = Plugin$2.__media.matches;
    } else if (Plugin$2.__media !== void 0) {
      Plugin$2.__media.removeListener(Plugin$2.__updateMedia);
      Plugin$2.__media = void 0;
    }
    Plugin$2.isActive = val === true;
    document.body.classList.remove(`body--${val === true ? "light" : "dark"}`);
    document.body.classList.add(`body--${val === true ? "dark" : "light"}`);
  },
  toggle() {
    {
      Plugin$2.set(Plugin$2.isActive === false);
    }
  },
  install({ $q, onSSRHydrated, ssrContext }) {
    const { dark } = $q.config;
    $q.dark = this;
    if (this.__installed === true && dark === void 0) {
      return;
    }
    this.isActive = dark === true;
    const initialVal = dark !== void 0 ? dark : false;
    if (isRuntimeSsrPreHydration.value === true) {
      const ssrSet = (val) => {
        this.__fromSSR = val;
      };
      const originalSet = this.set;
      this.set = ssrSet;
      ssrSet(initialVal);
      onSSRHydrated.push(() => {
        this.set = originalSet;
        this.set(this.__fromSSR);
      });
    } else {
      this.set(initialVal);
    }
  }
});
const getTrue = () => true;
function filterInvalidPath(path) {
  return typeof path === "string" && path !== "" && path !== "/" && path !== "#/";
}
function normalizeExitPath(path) {
  path.startsWith("#") === true && (path = path.substring(1));
  path.startsWith("/") === false && (path = "/" + path);
  path.endsWith("/") === true && (path = path.substring(0, path.length - 1));
  return "#" + path;
}
function getShouldExitFn(cfg) {
  if (cfg.backButtonExit === false) {
    return () => false;
  }
  if (cfg.backButtonExit === "*") {
    return getTrue;
  }
  const exitPaths = ["#/"];
  Array.isArray(cfg.backButtonExit) === true && exitPaths.push(
    ...cfg.backButtonExit.filter(filterInvalidPath).map(normalizeExitPath)
  );
  return () => exitPaths.includes(window.location.hash);
}
var History = {
  __history: [],
  add: noop$1,
  remove: noop$1,
  install({ $q }) {
    if (this.__installed === true) {
      return;
    }
    const { cordova, capacitor } = client.is;
    if (cordova !== true && capacitor !== true) {
      return;
    }
    const qConf = $q.config[cordova === true ? "cordova" : "capacitor"];
    if (qConf !== void 0 && qConf.backButton === false) {
      return;
    }
    if (capacitor === true && (window.Capacitor === void 0 || window.Capacitor.Plugins.App === void 0)) {
      return;
    }
    this.add = (entry) => {
      if (entry.condition === void 0) {
        entry.condition = getTrue;
      }
      this.__history.push(entry);
    };
    this.remove = (entry) => {
      const index2 = this.__history.indexOf(entry);
      if (index2 >= 0) {
        this.__history.splice(index2, 1);
      }
    };
    const shouldExit = getShouldExitFn(
      Object.assign(
        { backButtonExit: true },
        qConf
      )
    );
    const backHandler = () => {
      if (this.__history.length) {
        const entry = this.__history[this.__history.length - 1];
        if (entry.condition() === true) {
          this.__history.pop();
          entry.handler();
        }
      } else if (shouldExit() === true) {
        navigator.app.exitApp();
      } else {
        window.history.back();
      }
    };
    if (cordova === true) {
      document.addEventListener("deviceready", () => {
        document.addEventListener("backbutton", backHandler, false);
      });
    } else {
      window.Capacitor.Plugins.App.addListener("backButton", backHandler);
    }
  }
};
var defaultLang = {
  isoName: "en-US",
  nativeName: "English (US)",
  label: {
    clear: "Clear",
    ok: "OK",
    cancel: "Cancel",
    close: "Close",
    set: "Set",
    select: "Select",
    reset: "Reset",
    remove: "Remove",
    update: "Update",
    create: "Create",
    search: "Search",
    filter: "Filter",
    refresh: "Refresh"
  },
  date: {
    days: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
    daysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
    months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
    monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
    firstDayOfWeek: 0,
    format24h: false,
    pluralDay: "days"
  },
  table: {
    noData: "No data available",
    noResults: "No matching records found",
    loading: "Loading...",
    selectedRecords: (rows) => rows === 1 ? "1 record selected." : (rows === 0 ? "No" : rows) + " records selected.",
    recordsPerPage: "Records per page:",
    allRows: "All",
    pagination: (start2, end, total) => start2 + "-" + end + " of " + total,
    columns: "Columns"
  },
  editor: {
    url: "URL",
    bold: "Bold",
    italic: "Italic",
    strikethrough: "Strikethrough",
    underline: "Underline",
    unorderedList: "Unordered List",
    orderedList: "Ordered List",
    subscript: "Subscript",
    superscript: "Superscript",
    hyperlink: "Hyperlink",
    toggleFullscreen: "Toggle Fullscreen",
    quote: "Quote",
    left: "Left align",
    center: "Center align",
    right: "Right align",
    justify: "Justify align",
    print: "Print",
    outdent: "Decrease indentation",
    indent: "Increase indentation",
    removeFormat: "Remove formatting",
    formatting: "Formatting",
    fontSize: "Font Size",
    align: "Align",
    hr: "Insert Horizontal Rule",
    undo: "Undo",
    redo: "Redo",
    heading1: "Heading 1",
    heading2: "Heading 2",
    heading3: "Heading 3",
    heading4: "Heading 4",
    heading5: "Heading 5",
    heading6: "Heading 6",
    paragraph: "Paragraph",
    code: "Code",
    size1: "Very small",
    size2: "A bit small",
    size3: "Normal",
    size4: "Medium-large",
    size5: "Big",
    size6: "Very big",
    size7: "Maximum",
    defaultFont: "Default Font",
    viewSource: "View Source"
  },
  tree: {
    noNodes: "No nodes available",
    noResults: "No matching nodes found"
  }
};
function getLocale() {
  const val = Array.isArray(navigator.languages) === true && navigator.languages.length > 0 ? navigator.languages[0] : navigator.language;
  if (typeof val === "string") {
    return val.split(/[-_]/).map((v, i2) => i2 === 0 ? v.toLowerCase() : i2 > 1 || v.length < 4 ? v.toUpperCase() : v[0].toUpperCase() + v.slice(1).toLowerCase()).join("-");
  }
}
const Plugin$1 = defineReactivePlugin({
  __langPack: {}
}, {
  getLocale,
  set(langObject = defaultLang, ssrContext) {
    const lang = {
      ...langObject,
      rtl: langObject.rtl === true,
      getLocale
    };
    {
      const el = document.documentElement;
      el.setAttribute("dir", lang.rtl === true ? "rtl" : "ltr");
      el.setAttribute("lang", lang.isoName);
      lang.set = Plugin$1.set;
      Object.assign(Plugin$1.__langPack, lang);
      Plugin$1.props = lang;
      Plugin$1.isoName = lang.isoName;
      Plugin$1.nativeName = lang.nativeName;
    }
  },
  install({ $q, lang, ssrContext }) {
    {
      $q.lang = Plugin$1.__langPack;
      if (this.__installed === true) {
        lang !== void 0 && this.set(lang);
      } else {
        this.set(lang || defaultLang);
      }
    }
  }
});
function setCssVar(propName, value, element = document.body) {
  if (typeof propName !== "string") {
    throw new TypeError("Expected a string as propName");
  }
  if (typeof value !== "string") {
    throw new TypeError("Expected a string as value");
  }
  if (!(element instanceof Element)) {
    throw new TypeError("Expected a DOM element");
  }
  element.style.setProperty(`--q-${propName}`, value);
}
let lastKeyCompositionStatus = false;
function onKeyDownComposition(evt) {
  lastKeyCompositionStatus = evt.isComposing === true;
}
function shouldIgnoreKey(evt) {
  return lastKeyCompositionStatus === true || evt !== Object(evt) || evt.isComposing === true || evt.qKeyEvent === true;
}
function isKeyCode(evt, keyCodes) {
  return shouldIgnoreKey(evt) === true ? false : [].concat(keyCodes).includes(evt.keyCode);
}
function getMobilePlatform(is2) {
  if (is2.ios === true)
    return "ios";
  if (is2.android === true)
    return "android";
}
function getBodyClasses({ is: is2, has: has5, within }, cfg) {
  const cls = [
    is2.desktop === true ? "desktop" : "mobile",
    `${has5.touch === false ? "no-" : ""}touch`
  ];
  if (is2.mobile === true) {
    const mobile = getMobilePlatform(is2);
    mobile !== void 0 && cls.push("platform-" + mobile);
  }
  if (is2.nativeMobile === true) {
    const type = is2.nativeMobileWrapper;
    cls.push(type);
    cls.push("native-mobile");
    if (is2.ios === true && (cfg[type] === void 0 || cfg[type].iosStatusBarPadding !== false)) {
      cls.push("q-ios-padding");
    }
  } else if (is2.electron === true) {
    cls.push("electron");
  } else if (is2.bex === true) {
    cls.push("bex");
  }
  within.iframe === true && cls.push("within-iframe");
  return cls;
}
function applyClientSsrCorrections() {
  const classes2 = document.body.className;
  let newCls = classes2;
  if (iosCorrection !== void 0) {
    newCls = newCls.replace("desktop", "platform-ios mobile");
  }
  if (client.has.touch === true) {
    newCls = newCls.replace("no-touch", "touch");
  }
  if (client.within.iframe === true) {
    newCls += " within-iframe";
  }
  if (classes2 !== newCls) {
    document.body.className = newCls;
  }
}
function setColors(brand) {
  for (const color in brand) {
    setCssVar(color, brand[color]);
  }
}
var Body = {
  install(opts) {
    if (this.__installed === true) {
      return;
    }
    if (isRuntimeSsrPreHydration.value === true) {
      applyClientSsrCorrections();
    } else {
      const { $q } = opts;
      $q.config.brand !== void 0 && setColors($q.config.brand);
      const cls = getBodyClasses(client, $q.config);
      document.body.classList.add.apply(document.body.classList, cls);
    }
    if (client.is.ios === true) {
      document.body.addEventListener("touchstart", noop$1);
    }
    window.addEventListener("keydown", onKeyDownComposition, true);
  }
};
var materialIcons = {
  name: "material-icons",
  type: {
    positive: "check_circle",
    negative: "warning",
    info: "info",
    warning: "priority_high"
  },
  arrow: {
    up: "arrow_upward",
    right: "arrow_forward",
    down: "arrow_downward",
    left: "arrow_back",
    dropdown: "arrow_drop_down"
  },
  chevron: {
    left: "chevron_left",
    right: "chevron_right"
  },
  colorPicker: {
    spectrum: "gradient",
    tune: "tune",
    palette: "style"
  },
  pullToRefresh: {
    icon: "refresh"
  },
  carousel: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down",
    navigationIcon: "lens"
  },
  chip: {
    remove: "cancel",
    selected: "check"
  },
  datetime: {
    arrowLeft: "chevron_left",
    arrowRight: "chevron_right",
    now: "access_time",
    today: "today"
  },
  editor: {
    bold: "format_bold",
    italic: "format_italic",
    strikethrough: "strikethrough_s",
    underline: "format_underlined",
    unorderedList: "format_list_bulleted",
    orderedList: "format_list_numbered",
    subscript: "vertical_align_bottom",
    superscript: "vertical_align_top",
    hyperlink: "link",
    toggleFullscreen: "fullscreen",
    quote: "format_quote",
    left: "format_align_left",
    center: "format_align_center",
    right: "format_align_right",
    justify: "format_align_justify",
    print: "print",
    outdent: "format_indent_decrease",
    indent: "format_indent_increase",
    removeFormat: "format_clear",
    formatting: "text_format",
    fontSize: "format_size",
    align: "format_align_left",
    hr: "remove",
    undo: "undo",
    redo: "redo",
    heading: "format_size",
    code: "code",
    size: "format_size",
    font: "font_download",
    viewSource: "code"
  },
  expansionItem: {
    icon: "keyboard_arrow_down",
    denseIcon: "arrow_drop_down"
  },
  fab: {
    icon: "add",
    activeIcon: "close"
  },
  field: {
    clear: "cancel",
    error: "error"
  },
  pagination: {
    first: "first_page",
    prev: "keyboard_arrow_left",
    next: "keyboard_arrow_right",
    last: "last_page"
  },
  rating: {
    icon: "grade"
  },
  stepper: {
    done: "check",
    active: "edit",
    error: "warning"
  },
  tabs: {
    left: "chevron_left",
    right: "chevron_right",
    up: "keyboard_arrow_up",
    down: "keyboard_arrow_down"
  },
  table: {
    arrowUp: "arrow_upward",
    warning: "warning",
    firstPage: "first_page",
    prevPage: "chevron_left",
    nextPage: "chevron_right",
    lastPage: "last_page"
  },
  tree: {
    icon: "play_arrow"
  },
  uploader: {
    done: "done",
    clear: "clear",
    add: "add_box",
    upload: "cloud_upload",
    removeQueue: "clear_all",
    removeUploaded: "done_all"
  }
};
const Plugin = defineReactivePlugin({
  iconMapFn: null,
  __icons: {}
}, {
  set(setObject, ssrContext) {
    const def2 = { ...setObject, rtl: setObject.rtl === true };
    {
      def2.set = Plugin.set;
      Object.assign(Plugin.__icons, def2);
    }
  },
  install({ $q, iconSet, ssrContext }) {
    {
      if ($q.config.iconMapFn !== void 0) {
        this.iconMapFn = $q.config.iconMapFn;
      }
      $q.iconSet = this.__icons;
      injectProp($q, "iconMapFn", () => this.iconMapFn, (val) => {
        this.iconMapFn = val;
      });
      if (this.__installed === true) {
        iconSet !== void 0 && this.set(iconSet);
      } else {
        this.set(iconSet || materialIcons);
      }
    }
  }
});
const quasarKey = "_q_";
const layoutKey = "_q_l_";
const pageContainerKey = "_q_pc_";
const formKey = "_q_fo_";
const tabsKey = "_q_tabs_";
const globalConfig = {};
let globalConfigIsFrozen = false;
function freezeGlobalConfig() {
  globalConfigIsFrozen = true;
}
const hasMap = typeof Map === "function", hasSet = typeof Set === "function", hasArrayBuffer = typeof ArrayBuffer === "function";
function isDeepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (a !== null && b !== null && typeof a === "object" && typeof b === "object") {
    if (a.constructor !== b.constructor) {
      return false;
    }
    let length, i2;
    if (a.constructor === Array) {
      length = a.length;
      if (length !== b.length) {
        return false;
      }
      for (i2 = length; i2-- !== 0; ) {
        if (isDeepEqual(a[i2], b[i2]) !== true) {
          return false;
        }
      }
      return true;
    }
    if (hasMap === true && a.constructor === Map) {
      if (a.size !== b.size) {
        return false;
      }
      i2 = a.entries().next();
      while (i2.done !== true) {
        if (b.has(i2.value[0]) !== true) {
          return false;
        }
        i2 = i2.next();
      }
      i2 = a.entries().next();
      while (i2.done !== true) {
        if (isDeepEqual(i2.value[1], b.get(i2.value[0])) !== true) {
          return false;
        }
        i2 = i2.next();
      }
      return true;
    }
    if (hasSet === true && a.constructor === Set) {
      if (a.size !== b.size) {
        return false;
      }
      i2 = a.entries().next();
      while (i2.done !== true) {
        if (b.has(i2.value[0]) !== true) {
          return false;
        }
        i2 = i2.next();
      }
      return true;
    }
    if (hasArrayBuffer === true && a.buffer != null && a.buffer.constructor === ArrayBuffer) {
      length = a.length;
      if (length !== b.length) {
        return false;
      }
      for (i2 = length; i2-- !== 0; ) {
        if (a[i2] !== b[i2]) {
          return false;
        }
      }
      return true;
    }
    if (a.constructor === RegExp) {
      return a.source === b.source && a.flags === b.flags;
    }
    if (a.valueOf !== Object.prototype.valueOf) {
      return a.valueOf() === b.valueOf();
    }
    if (a.toString !== Object.prototype.toString) {
      return a.toString() === b.toString();
    }
    const keys2 = Object.keys(a).filter((key) => a[key] !== void 0);
    length = keys2.length;
    if (length !== Object.keys(b).filter((key) => b[key] !== void 0).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys2[i2];
      if (isDeepEqual(a[key], b[key]) !== true) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function isObject$1(v) {
  return v !== null && typeof v === "object" && Array.isArray(v) !== true;
}
function isDate$1(v) {
  return Object.prototype.toString.call(v) === "[object Date]";
}
function isNumber$2(v) {
  return typeof v === "number" && isFinite(v);
}
const autoInstalledPlugins = [
  Platform,
  Body,
  Plugin$2,
  Screen,
  History,
  Plugin$1,
  Plugin
];
function installPlugins(pluginOpts, pluginList) {
  pluginList.forEach((Plugin2) => {
    Plugin2.install(pluginOpts);
    Plugin2.__installed = true;
  });
}
function prepareApp(app2, uiOpts, pluginOpts) {
  app2.config.globalProperties.$q = pluginOpts.$q;
  app2.provide(quasarKey, pluginOpts.$q);
  installPlugins(pluginOpts, autoInstalledPlugins);
  uiOpts.components !== void 0 && Object.values(uiOpts.components).forEach((c) => {
    if (isObject$1(c) === true && c.name !== void 0) {
      app2.component(c.name, c);
    }
  });
  uiOpts.directives !== void 0 && Object.values(uiOpts.directives).forEach((d) => {
    if (isObject$1(d) === true && d.name !== void 0) {
      app2.directive(d.name, d);
    }
  });
  uiOpts.plugins !== void 0 && installPlugins(
    pluginOpts,
    Object.values(uiOpts.plugins).filter(
      (p2) => typeof p2.install === "function" && autoInstalledPlugins.includes(p2) === false
    )
  );
  if (isRuntimeSsrPreHydration.value === true) {
    pluginOpts.$q.onSSRHydrated = () => {
      pluginOpts.onSSRHydrated.forEach((fn) => {
        fn();
      });
      pluginOpts.$q.onSSRHydrated = () => {
      };
    };
  }
}
var installQuasar = function(parentApp, opts = {}) {
  const $q = { version: "2.7.5" };
  if (globalConfigIsFrozen === false) {
    if (opts.config !== void 0) {
      Object.assign(globalConfig, opts.config);
    }
    $q.config = { ...globalConfig };
    freezeGlobalConfig();
  } else {
    $q.config = opts.config || {};
  }
  prepareApp(parentApp, opts, {
    parentApp,
    $q,
    lang: opts.lang,
    iconSet: opts.iconSet,
    onSSRHydrated: []
  });
};
var Quasar = {
  version: "2.7.5",
  install: installQuasar,
  lang: Plugin$1,
  iconSet: Plugin
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var lzString = { exports: {} };
(function(module) {
  var LZString = function() {
    var f = String.fromCharCode;
    var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
    var baseReverseDic = {};
    function getBaseValue(alphabet, character) {
      if (!baseReverseDic[alphabet]) {
        baseReverseDic[alphabet] = {};
        for (var i2 = 0; i2 < alphabet.length; i2++) {
          baseReverseDic[alphabet][alphabet.charAt(i2)] = i2;
        }
      }
      return baseReverseDic[alphabet][character];
    }
    var LZString2 = {
      compressToBase64: function(input) {
        if (input == null)
          return "";
        var res = LZString2._compress(input, 6, function(a) {
          return keyStrBase64.charAt(a);
        });
        switch (res.length % 4) {
          default:
          case 0:
            return res;
          case 1:
            return res + "===";
          case 2:
            return res + "==";
          case 3:
            return res + "=";
        }
      },
      decompressFromBase64: function(input) {
        if (input == null)
          return "";
        if (input == "")
          return null;
        return LZString2._decompress(input.length, 32, function(index2) {
          return getBaseValue(keyStrBase64, input.charAt(index2));
        });
      },
      compressToUTF16: function(input) {
        if (input == null)
          return "";
        return LZString2._compress(input, 15, function(a) {
          return f(a + 32);
        }) + " ";
      },
      decompressFromUTF16: function(compressed) {
        if (compressed == null)
          return "";
        if (compressed == "")
          return null;
        return LZString2._decompress(compressed.length, 16384, function(index2) {
          return compressed.charCodeAt(index2) - 32;
        });
      },
      compressToUint8Array: function(uncompressed) {
        var compressed = LZString2.compress(uncompressed);
        var buf = new Uint8Array(compressed.length * 2);
        for (var i2 = 0, TotalLen = compressed.length; i2 < TotalLen; i2++) {
          var current_value = compressed.charCodeAt(i2);
          buf[i2 * 2] = current_value >>> 8;
          buf[i2 * 2 + 1] = current_value % 256;
        }
        return buf;
      },
      decompressFromUint8Array: function(compressed) {
        if (compressed === null || compressed === void 0) {
          return LZString2.decompress(compressed);
        } else {
          var buf = new Array(compressed.length / 2);
          for (var i2 = 0, TotalLen = buf.length; i2 < TotalLen; i2++) {
            buf[i2] = compressed[i2 * 2] * 256 + compressed[i2 * 2 + 1];
          }
          var result = [];
          buf.forEach(function(c) {
            result.push(f(c));
          });
          return LZString2.decompress(result.join(""));
        }
      },
      compressToEncodedURIComponent: function(input) {
        if (input == null)
          return "";
        return LZString2._compress(input, 6, function(a) {
          return keyStrUriSafe.charAt(a);
        });
      },
      decompressFromEncodedURIComponent: function(input) {
        if (input == null)
          return "";
        if (input == "")
          return null;
        input = input.replace(/ /g, "+");
        return LZString2._decompress(input.length, 32, function(index2) {
          return getBaseValue(keyStrUriSafe, input.charAt(index2));
        });
      },
      compress: function(uncompressed) {
        return LZString2._compress(uncompressed, 16, function(a) {
          return f(a);
        });
      },
      _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
        if (uncompressed == null)
          return "";
        var i2, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
        for (ii = 0; ii < uncompressed.length; ii += 1) {
          context_c = uncompressed.charAt(ii);
          if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
            context_dictionary[context_c] = context_dictSize++;
            context_dictionaryToCreate[context_c] = true;
          }
          context_wc = context_w + context_c;
          if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
            context_w = context_wc;
          } else {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i2 = 0; i2 < context_numBits; i2++) {
                  context_data_val = context_data_val << 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                }
                value = context_w.charCodeAt(0);
                for (i2 = 0; i2 < 8; i2++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i2 = 0; i2 < context_numBits; i2++) {
                  context_data_val = context_data_val << 1 | value;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i2 = 0; i2 < 16; i2++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i2 = 0; i2 < context_numBits; i2++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            context_dictionary[context_wc] = context_dictSize++;
            context_w = String(context_c);
          }
        }
        if (context_w !== "") {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
              for (i2 = 0; i2 < context_numBits; i2++) {
                context_data_val = context_data_val << 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
              }
              value = context_w.charCodeAt(0);
              for (i2 = 0; i2 < 8; i2++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            } else {
              value = 1;
              for (i2 = 0; i2 < context_numBits; i2++) {
                context_data_val = context_data_val << 1 | value;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (i2 = 0; i2 < 16; i2++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (i2 = 0; i2 < context_numBits; i2++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
        }
        value = 2;
        for (i2 = 0; i2 < context_numBits; i2++) {
          context_data_val = context_data_val << 1 | value & 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }
        while (true) {
          context_data_val = context_data_val << 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data.push(getCharFromInt(context_data_val));
            break;
          } else
            context_data_position++;
        }
        return context_data.join("");
      },
      decompress: function(compressed) {
        if (compressed == null)
          return "";
        if (compressed == "")
          return null;
        return LZString2._decompress(compressed.length, 32768, function(index2) {
          return compressed.charCodeAt(index2);
        });
      },
      _decompress: function(length, resetValue, getNextValue) {
        var dictionary = [], enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i2, w, bits, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };
        for (i2 = 0; i2 < 3; i2 += 1) {
          dictionary[i2] = i2;
        }
        bits = 0;
        maxpower = Math.pow(2, 2);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        switch (bits) {
          case 0:
            bits = 0;
            maxpower = Math.pow(2, 8);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            c = f(bits);
            break;
          case 1:
            bits = 0;
            maxpower = Math.pow(2, 16);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            c = f(bits);
            break;
          case 2:
            return "";
        }
        dictionary[3] = c;
        w = c;
        result.push(c);
        while (true) {
          if (data.index > length) {
            return "";
          }
          bits = 0;
          maxpower = Math.pow(2, numBits);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          switch (c = bits) {
            case 0:
              bits = 0;
              maxpower = Math.pow(2, 8);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              dictionary[dictSize++] = f(bits);
              c = dictSize - 1;
              enlargeIn--;
              break;
            case 1:
              bits = 0;
              maxpower = Math.pow(2, 16);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              dictionary[dictSize++] = f(bits);
              c = dictSize - 1;
              enlargeIn--;
              break;
            case 2:
              return result.join("");
          }
          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
          if (dictionary[c]) {
            entry = dictionary[c];
          } else {
            if (c === dictSize) {
              entry = w + w.charAt(0);
            } else {
              return null;
            }
          }
          result.push(entry);
          dictionary[dictSize++] = w + entry.charAt(0);
          enlargeIn--;
          w = entry;
          if (enlargeIn == 0) {
            enlargeIn = Math.pow(2, numBits);
            numBits++;
          }
        }
      }
    };
    return LZString2;
  }();
  if (module != null) {
    module.exports = LZString;
  }
})(lzString);
function unique(arr) {
  const check = (value, index2, self2) => self2.indexOf(value) === index2;
  return arr.filter(check);
}
function defined(x) {
  return typeof x !== "undefined" && x !== null;
}
function hasProp(x, prop) {
  return typeof x === "object" && defined(x) && x.hasOwnProperty(prop);
}
function hasPropIs(x, prop, is2) {
  return hasProp(x, prop) && is2(x[prop]);
}
function assert(p2, msg) {
  if (!p2) {
    throw new Error(msg);
  }
}
assert.defined = (x) => assert(defined(x), `undefined: $x`);
assert.props = (x, ...props) => {
  assert(typeof x === "object", "crud");
  assert.defined(x);
  assert(x.hasOwnProperty(props[0]), "crud");
};
assert.is = (x, f, typeName) => {
  assert(f(x), `invalid type ${typeName != null ? typeName : ""}`);
};
assert.mayBe = (x, f, typeName) => {
  assert(typeof x === "undefined" || f(x), `invalid type ${typeName != null ? typeName : ""}`);
};
assert.propIs = (x, prop, is2) => {
  assert.props(x, prop);
  assert.is(x, is2);
};
assert.propMayBe = (x, prop, is2) => {
  if (!hasProp(x, prop) || !defined(x[prop])) {
    return;
  }
  assert.is(x[prop], is2);
};
function tagged(x, tag2) {
  return hasProp(x, "_tag") && x._tag === tag2;
}
function isBoolean$1(x) {
  return typeof x === "boolean";
}
function isString$1(x) {
  return typeof x === "string";
}
function notBlank(s) {
  return defined(s) && defined(s.match(/\S/));
}
function isNumber$1(x) {
  return typeof x === "number";
}
function isValidNumber(x) {
  return isNumber$1(x) && !isNaN(x) && isFinite(x);
}
function* mapIter(iterable, callback) {
  for (const x of iterable) {
    yield callback(x);
  }
}
const tuple$1 = (t, u) => [t, u];
const Left = (value) => ({
  _tag: "Left",
  value
});
const Right = (value) => ({
  _tag: "Right",
  value
});
const isLeft = (x) => tagged(x, "Left") && hasProp(x, "value");
function errorable(f) {
  try {
    return Right(f());
  } catch (e2) {
    return e2 instanceof Error ? Left(e2) : Left(new Error(String(e2)));
  }
}
function map$2(x, f) {
  return isLeft(x) ? x : Right(f(x.value));
}
function on(x, go) {
  return isLeft(x) ? go.Left(x.value) : go.Right(x.value);
}
function raise(e2) {
  if (isLeft(e2)) {
    throw e2.value;
  }
  return e2;
}
const Either = { on, map: map$2 };
const Errorable = {
  on,
  map: map$2,
  handle: (e2, onError, defaultValue) => {
    if (isLeft(e2)) {
      onError(e2.value);
      return defaultValue;
    }
    return e2.value;
  },
  catch: (e2, onError) => {
    if (isLeft(e2)) {
      onError(e2.value);
    }
  },
  raise
};
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var DEFAULT_CONFIG = {
  epsilon: 1e-12,
  matrix: "Matrix",
  number: "number",
  precision: 64,
  predictable: false,
  randomSeed: null
};
function isNumber(x) {
  return typeof x === "number";
}
function isBigNumber(x) {
  if (!x || typeof x !== "object" || typeof x.constructor !== "function") {
    return false;
  }
  if (x.isBigNumber === true && typeof x.constructor.prototype === "object" && x.constructor.prototype.isBigNumber === true) {
    return true;
  }
  if (typeof x.constructor.isDecimal === "function" && x.constructor.isDecimal(x) === true) {
    return true;
  }
  return false;
}
function isComplex(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isComplex === true || false;
}
function isFraction(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isFraction === true || false;
}
function isUnit(x) {
  return x && x.constructor.prototype.isUnit === true || false;
}
function isString(x) {
  return typeof x === "string";
}
var isArray$1 = Array.isArray;
function isMatrix(x) {
  return x && x.constructor.prototype.isMatrix === true || false;
}
function isCollection$1(x) {
  return Array.isArray(x) || isMatrix(x);
}
function isDenseMatrix(x) {
  return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isSparseMatrix(x) {
  return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isRange(x) {
  return x && x.constructor.prototype.isRange === true || false;
}
function isIndex(x) {
  return x && x.constructor.prototype.isIndex === true || false;
}
function isBoolean(x) {
  return typeof x === "boolean";
}
function isResultSet(x) {
  return x && x.constructor.prototype.isResultSet === true || false;
}
function isHelp(x) {
  return x && x.constructor.prototype.isHelp === true || false;
}
function isFunction(x) {
  return typeof x === "function";
}
function isDate(x) {
  return x instanceof Date;
}
function isRegExp(x) {
  return x instanceof RegExp;
}
function isObject(x) {
  return !!(x && typeof x === "object" && x.constructor === Object && !isComplex(x) && !isFraction(x));
}
function isNull(x) {
  return x === null;
}
function isUndefined(x) {
  return x === void 0;
}
function isAccessorNode(x) {
  return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
}
function isArrayNode(x) {
  return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
}
function isAssignmentNode(x) {
  return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isBlockNode(x) {
  return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
}
function isConditionalNode(x) {
  return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
}
function isConstantNode(x) {
  return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
}
function rule2Node(node) {
  return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && "-+~".includes(node.op);
}
function isFunctionAssignmentNode(x) {
  return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isFunctionNode(x) {
  return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
}
function isIndexNode(x) {
  return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
}
function isNode(x) {
  return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
}
function isObjectNode(x) {
  return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
}
function isOperatorNode(x) {
  return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
}
function isParenthesisNode(x) {
  return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
}
function isRangeNode(x) {
  return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
}
function isSymbolNode(x) {
  return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
}
function isChain(x) {
  return x && x.constructor.prototype.isChain === true || false;
}
function typeOf$1(x) {
  var t = typeof x;
  if (t === "object") {
    if (x === null)
      return "null";
    if (isBigNumber(x))
      return "BigNumber";
    if (x.constructor && x.constructor.name)
      return x.constructor.name;
    return "Object";
  }
  return t;
}
function clone$2(x) {
  var type = typeof x;
  if (type === "number" || type === "string" || type === "boolean" || x === null || x === void 0) {
    return x;
  }
  if (typeof x.clone === "function") {
    return x.clone();
  }
  if (Array.isArray(x)) {
    return x.map(function(value) {
      return clone$2(value);
    });
  }
  if (x instanceof Date)
    return new Date(x.valueOf());
  if (isBigNumber(x))
    return x;
  if (x instanceof RegExp)
    throw new TypeError("Cannot clone " + x);
  return mapObject(x, clone$2);
}
function mapObject(object, callback) {
  var clone2 = {};
  for (var key in object) {
    if (hasOwnProperty$2(object, key)) {
      clone2[key] = callback(object[key]);
    }
  }
  return clone2;
}
function extend(a, b) {
  for (var prop in b) {
    if (hasOwnProperty$2(b, prop)) {
      a[prop] = b[prop];
    }
  }
  return a;
}
function deepStrictEqual(a, b) {
  var prop, i2, len;
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (i2 = 0, len = a.length; i2 < len; i2++) {
      if (!deepStrictEqual(a[i2], b[i2])) {
        return false;
      }
    }
    return true;
  } else if (typeof a === "function") {
    return a === b;
  } else if (a instanceof Object) {
    if (Array.isArray(b) || !(b instanceof Object)) {
      return false;
    }
    for (prop in a) {
      if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
        return false;
      }
    }
    for (prop in b) {
      if (!(prop in a)) {
        return false;
      }
    }
    return true;
  } else {
    return a === b;
  }
}
function lazy(object, prop, valueResolver) {
  var _uninitialized = true;
  var _value;
  Object.defineProperty(object, prop, {
    get: function get11() {
      if (_uninitialized) {
        _value = valueResolver();
        _uninitialized = false;
      }
      return _value;
    },
    set: function set3(value) {
      _value = value;
      _uninitialized = false;
    },
    configurable: true,
    enumerable: true
  });
}
function hasOwnProperty$2(object, property) {
  return object && Object.hasOwnProperty.call(object, property);
}
function pickShallow(object, properties2) {
  var copy2 = {};
  for (var i2 = 0; i2 < properties2.length; i2++) {
    var key = properties2[i2];
    var value = object[key];
    if (value !== void 0) {
      copy2[key] = value;
    }
  }
  return copy2;
}
var MATRIX_OPTIONS = ["Matrix", "Array"];
var NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];
var config$1 = function config(options) {
  if (options) {
    throw new Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");
  }
  return Object.freeze(DEFAULT_CONFIG);
};
_extends$1(config$1, DEFAULT_CONFIG, {
  MATRIX_OPTIONS,
  NUMBER_OPTIONS
});
var typedFunction$1 = { exports: {} };
(function(module, exports) {
  (function(root, factory2) {
    {
      module.exports = factory2();
    }
  })(commonjsGlobal, function() {
    function ok() {
      return true;
    }
    function notOk() {
      return false;
    }
    function undef() {
      return void 0;
    }
    const NOT_TYPED_FUNCTION = "Argument is not a typed-function.";
    function create2() {
      function isPlainObject2(x) {
        return typeof x === "object" && x !== null && x.constructor === Object;
      }
      const _types = [
        { name: "number", test: function(x) {
          return typeof x === "number";
        } },
        { name: "string", test: function(x) {
          return typeof x === "string";
        } },
        { name: "boolean", test: function(x) {
          return typeof x === "boolean";
        } },
        { name: "Function", test: function(x) {
          return typeof x === "function";
        } },
        { name: "Array", test: Array.isArray },
        { name: "Date", test: function(x) {
          return x instanceof Date;
        } },
        { name: "RegExp", test: function(x) {
          return x instanceof RegExp;
        } },
        { name: "Object", test: isPlainObject2 },
        { name: "null", test: function(x) {
          return x === null;
        } },
        { name: "undefined", test: function(x) {
          return x === void 0;
        } }
      ];
      const anyType = {
        name: "any",
        test: ok,
        isAny: true
      };
      let typeMap;
      let typeList;
      let nConversions = 0;
      let typed2 = { createCount: 0 };
      function findType(typeName) {
        const type = typeMap.get(typeName);
        if (type) {
          return type;
        }
        let message = 'Unknown type "' + typeName + '"';
        const name2 = typeName.toLowerCase();
        let otherName;
        for (otherName of typeList) {
          if (otherName.toLowerCase() === name2) {
            message += '. Did you mean "' + otherName + '" ?';
            break;
          }
        }
        throw new TypeError(message);
      }
      function addTypes(types, beforeSpec = "any") {
        const beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;
        const newTypes = [];
        for (var i2 = 0; i2 < types.length; ++i2) {
          if (!types[i2] || typeof types[i2].name !== "string" || typeof types[i2].test !== "function") {
            throw new TypeError("Object with properties {name: string, test: function} expected");
          }
          const typeName = types[i2].name;
          if (typeMap.has(typeName)) {
            throw new TypeError('Duplicate type name "' + typeName + '"');
          }
          newTypes.push(typeName);
          typeMap.set(typeName, {
            name: typeName,
            test: types[i2].test,
            isAny: types[i2].isAny,
            index: beforeIndex + i2,
            conversionsTo: []
          });
        }
        const affectedTypes = typeList.slice(beforeIndex);
        typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes);
        for (var i2 = beforeIndex + newTypes.length; i2 < typeList.length; ++i2) {
          typeMap.get(typeList[i2]).index = i2;
        }
      }
      function clear3() {
        typeMap = /* @__PURE__ */ new Map();
        typeList = [];
        nConversions = 0;
        addTypes([anyType], false);
      }
      clear3();
      addTypes(_types);
      function clearConversions() {
        let typeName;
        for (typeName of typeList) {
          typeMap.get(typeName).conversionsTo = [];
        }
        nConversions = 0;
      }
      function findTypeNames(value) {
        const matches2 = typeList.filter((name2) => {
          const type = typeMap.get(name2);
          return !type.isAny && type.test(value);
        });
        if (matches2.length) {
          return matches2;
        }
        return ["any"];
      }
      function isTypedFunction(entity) {
        return entity && typeof entity === "function" && "_typedFunctionData" in entity;
      }
      function findSignature(fn, signature, exactSpec) {
        if (!isTypedFunction(fn)) {
          throw new TypeError(NOT_TYPED_FUNCTION);
        }
        const exact = exactSpec && exactSpec.exact;
        const stringSignature = Array.isArray(signature) ? signature.join(",") : signature;
        const params = parseSignature(stringSignature);
        const canonicalSignature = stringifyParams(params);
        if (!exact || canonicalSignature in fn.signatures) {
          const match = fn._typedFunctionData.signatureMap.get(canonicalSignature);
          if (match) {
            return match;
          }
        }
        const nParams = params.length;
        let remainingSignatures;
        if (exact) {
          remainingSignatures = [];
          let name2;
          for (name2 in fn.signatures) {
            remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name2));
          }
        } else {
          remainingSignatures = fn._typedFunctionData.signatures;
        }
        for (var i2 = 0; i2 < nParams; ++i2) {
          const want = params[i2];
          const filteredSignatures = [];
          let possibility;
          for (possibility of remainingSignatures) {
            const have = getParamAtIndex(possibility.params, i2);
            if (!have || want.restParam && !have.restParam) {
              continue;
            }
            if (!have.hasAny) {
              const haveTypes = paramTypeSet(have);
              if (want.types.some((wtype) => !haveTypes.has(wtype.name))) {
                continue;
              }
            }
            filteredSignatures.push(possibility);
          }
          remainingSignatures = filteredSignatures;
          if (remainingSignatures.length === 0)
            break;
        }
        let candidate;
        for (candidate of remainingSignatures) {
          if (candidate.params.length <= nParams) {
            return candidate;
          }
        }
        throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + stringifyParams(params, ", ") + "))");
      }
      function find2(fn, signature, exact) {
        return findSignature(fn, signature, exact).implementation;
      }
      function convert(value, typeName) {
        const type = findType(typeName);
        if (type.test(value)) {
          return value;
        }
        const conversions = type.conversionsTo;
        if (conversions.length === 0) {
          throw new Error(
            "There are no conversions to " + typeName + " defined."
          );
        }
        for (var i2 = 0; i2 < conversions.length; i2++) {
          const fromType = findType(conversions[i2].from);
          if (fromType.test(value)) {
            return conversions[i2].convert(value);
          }
        }
        throw new Error("Cannot convert " + value + " to " + typeName);
      }
      function stringifyParams(params, separator = ",") {
        return params.map((p2) => p2.name).join(separator);
      }
      function parseParam(param) {
        const restParam = param.indexOf("...") === 0;
        const types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
        const typeDefs = types.split("|").map((s) => findType(s.trim()));
        let hasAny = false;
        let paramName = restParam ? "..." : "";
        const exactTypes = typeDefs.map(function(type) {
          hasAny = type.isAny || hasAny;
          paramName += type.name + "|";
          return {
            name: type.name,
            typeIndex: type.index,
            test: type.test,
            isAny: type.isAny,
            conversion: null,
            conversionIndex: -1
          };
        });
        return {
          types: exactTypes,
          name: paramName.slice(0, -1),
          hasAny,
          hasConversion: false,
          restParam
        };
      }
      function expandParam(param) {
        const typeNames = param.types.map((t) => t.name);
        const matchingConversions = availableConversions(typeNames);
        let hasAny = param.hasAny;
        let newName = param.name;
        const convertibleTypes = matchingConversions.map(function(conversion) {
          const type = findType(conversion.from);
          hasAny = type.isAny || hasAny;
          newName += "|" + conversion.from;
          return {
            name: conversion.from,
            typeIndex: type.index,
            test: type.test,
            isAny: type.isAny,
            conversion,
            conversionIndex: conversion.index
          };
        });
        return {
          types: param.types.concat(convertibleTypes),
          name: newName,
          hasAny,
          hasConversion: convertibleTypes.length > 0,
          restParam: param.restParam
        };
      }
      function paramTypeSet(param) {
        if (!param.typeSet) {
          param.typeSet = /* @__PURE__ */ new Set();
          param.types.forEach((type) => param.typeSet.add(type.name));
        }
        return param.typeSet;
      }
      function parseSignature(rawSignature) {
        const params = [];
        if (typeof rawSignature !== "string") {
          throw new TypeError("Signatures must be strings");
        }
        const signature = rawSignature.trim();
        if (signature === "") {
          return params;
        }
        const rawParams = signature.split(",");
        for (var i2 = 0; i2 < rawParams.length; ++i2) {
          const parsedParam = parseParam(rawParams[i2].trim());
          if (parsedParam.restParam && i2 !== rawParams.length - 1) {
            throw new SyntaxError(
              'Unexpected rest parameter "' + rawParams[i2] + '": only allowed for the last parameter'
            );
          }
          if (parsedParam.types.length == 0) {
            return null;
          }
          params.push(parsedParam);
        }
        return params;
      }
      function hasRestParam(params) {
        const param = last3(params);
        return param ? param.restParam : false;
      }
      function compileTest(param) {
        if (!param || param.types.length === 0) {
          return ok;
        } else if (param.types.length === 1) {
          return findType(param.types[0].name).test;
        } else if (param.types.length === 2) {
          const test0 = findType(param.types[0].name).test;
          const test1 = findType(param.types[1].name).test;
          return function or2(x) {
            return test0(x) || test1(x);
          };
        } else {
          const tests = param.types.map(function(type) {
            return findType(type.name).test;
          });
          return function or2(x) {
            for (var i2 = 0; i2 < tests.length; i2++) {
              if (tests[i2](x)) {
                return true;
              }
            }
            return false;
          };
        }
      }
      function compileTests(params) {
        let tests, test0, test1;
        if (hasRestParam(params)) {
          tests = initial(params).map(compileTest);
          const varIndex = tests.length;
          const lastTest = compileTest(last3(params));
          const testRestParam = function(args) {
            for (var i2 = varIndex; i2 < args.length; i2++) {
              if (!lastTest(args[i2])) {
                return false;
              }
            }
            return true;
          };
          return function testArgs(args) {
            for (var i2 = 0; i2 < tests.length; i2++) {
              if (!tests[i2](args[i2])) {
                return false;
              }
            }
            return testRestParam(args) && args.length >= varIndex + 1;
          };
        } else {
          if (params.length === 0) {
            return function testArgs(args) {
              return args.length === 0;
            };
          } else if (params.length === 1) {
            test0 = compileTest(params[0]);
            return function testArgs(args) {
              return test0(args[0]) && args.length === 1;
            };
          } else if (params.length === 2) {
            test0 = compileTest(params[0]);
            test1 = compileTest(params[1]);
            return function testArgs(args) {
              return test0(args[0]) && test1(args[1]) && args.length === 2;
            };
          } else {
            tests = params.map(compileTest);
            return function testArgs(args) {
              for (var i2 = 0; i2 < tests.length; i2++) {
                if (!tests[i2](args[i2])) {
                  return false;
                }
              }
              return args.length === tests.length;
            };
          }
        }
      }
      function getParamAtIndex(params, index2) {
        return index2 < params.length ? params[index2] : hasRestParam(params) ? last3(params) : null;
      }
      function getTypeSetAtIndex(params, index2) {
        const param = getParamAtIndex(params, index2);
        if (!param) {
          return /* @__PURE__ */ new Set();
        }
        return paramTypeSet(param);
      }
      function isExactType(type) {
        return type.conversion === null || type.conversion === void 0;
      }
      function mergeExpectedParams(signatures, index2) {
        const typeSet = /* @__PURE__ */ new Set();
        signatures.forEach((signature) => {
          const paramSet = getTypeSetAtIndex(signature.params, index2);
          let name2;
          for (name2 of paramSet) {
            typeSet.add(name2);
          }
        });
        return typeSet.has("any") ? ["any"] : Array.from(typeSet);
      }
      function createError(name2, args, signatures) {
        let err, expected;
        const _name = name2 || "unnamed";
        let matchingSignatures = signatures;
        for (var index2 = 0; index2 < args.length; index2++) {
          const nextMatchingDefs = [];
          matchingSignatures.forEach((signature) => {
            const param = getParamAtIndex(signature.params, index2);
            const test = compileTest(param);
            if ((index2 < signature.params.length || hasRestParam(signature.params)) && test(args[index2])) {
              nextMatchingDefs.push(signature);
            }
          });
          if (nextMatchingDefs.length === 0) {
            expected = mergeExpectedParams(matchingSignatures, index2);
            if (expected.length > 0) {
              const actualTypes = findTypeNames(args[index2]);
              err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualTypes.join(" | ") + ", index: " + index2 + ")");
              err.data = {
                category: "wrongType",
                fn: _name,
                index: index2,
                actual: actualTypes,
                expected
              };
              return err;
            }
          } else {
            matchingSignatures = nextMatchingDefs;
          }
        }
        const lengths = matchingSignatures.map(function(signature) {
          return hasRestParam(signature.params) ? Infinity : signature.params.length;
        });
        if (args.length < Math.min.apply(null, lengths)) {
          expected = mergeExpectedParams(matchingSignatures, index2);
          err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
          err.data = {
            category: "tooFewArgs",
            fn: _name,
            index: args.length,
            expected
          };
          return err;
        }
        const maxLength = Math.max.apply(null, lengths);
        if (args.length > maxLength) {
          err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
          err.data = {
            category: "tooManyArgs",
            fn: _name,
            index: args.length,
            expectedLength: maxLength
          };
          return err;
        }
        const argTypes = [];
        for (var i2 = 0; i2 < args.length; ++i2) {
          argTypes.push(findTypeNames(args[i2]).join("|"));
        }
        err = new TypeError('Arguments of type "' + argTypes.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
        err.data = {
          category: "mismatch",
          actual: argTypes
        };
        return err;
      }
      function getLowestTypeIndex(param) {
        let min3 = typeList.length + 1;
        for (var i2 = 0; i2 < param.types.length; i2++) {
          if (isExactType(param.types[i2])) {
            min3 = Math.min(min3, param.types[i2].typeIndex);
          }
        }
        return min3;
      }
      function getLowestConversionIndex(param) {
        let min3 = nConversions + 1;
        for (var i2 = 0; i2 < param.types.length; i2++) {
          if (!isExactType(param.types[i2])) {
            min3 = Math.min(min3, param.types[i2].conversionIndex);
          }
        }
        return min3;
      }
      function compareParams(param1, param2) {
        if (param1.hasAny) {
          if (!param2.hasAny) {
            return 1;
          }
        } else if (param2.hasAny) {
          return -1;
        }
        if (param1.restParam) {
          if (!param2.restParam) {
            return 1;
          }
        } else if (param2.restParam) {
          return -1;
        }
        if (param1.hasConversion) {
          if (!param2.hasConversion) {
            return 1;
          }
        } else if (param2.hasConversion) {
          return -1;
        }
        const typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
        if (typeDiff < 0) {
          return -1;
        }
        if (typeDiff > 0) {
          return 1;
        }
        const convDiff = getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
        if (convDiff < 0) {
          return -1;
        }
        if (convDiff > 0) {
          return 1;
        }
        return 0;
      }
      function compareSignatures(signature1, signature2) {
        const pars1 = signature1.params;
        const pars2 = signature2.params;
        const last1 = last3(pars1);
        const last22 = last3(pars2);
        const hasRest1 = hasRestParam(pars1);
        const hasRest2 = hasRestParam(pars2);
        if (hasRest1 && last1.hasAny) {
          if (!hasRest2 || !last22.hasAny) {
            return 1;
          }
        } else if (hasRest2 && last22.hasAny) {
          return -1;
        }
        let any1 = 0;
        let conv1 = 0;
        let par;
        for (par of pars1) {
          if (par.hasAny)
            ++any1;
          if (par.hasConversion)
            ++conv1;
        }
        let any2 = 0;
        let conv2 = 0;
        for (par of pars2) {
          if (par.hasAny)
            ++any2;
          if (par.hasConversion)
            ++conv2;
        }
        if (any1 !== any2) {
          return any1 - any2;
        }
        if (hasRest1 && last1.hasConversion) {
          if (!hasRest2 || !last22.hasConversion) {
            return 1;
          }
        } else if (hasRest2 && last22.hasConversion) {
          return -1;
        }
        if (conv1 !== conv2) {
          return conv1 - conv2;
        }
        if (hasRest1) {
          if (!hasRest2) {
            return 1;
          }
        } else if (hasRest2) {
          return -1;
        }
        const lengthCriterion = (pars1.length - pars2.length) * (hasRest1 ? -1 : 1);
        if (lengthCriterion !== 0) {
          return lengthCriterion;
        }
        const comparisons = [];
        let tc = 0;
        for (let i2 = 0; i2 < pars1.length; ++i2) {
          const thisComparison = compareParams(pars1[i2], pars2[i2]);
          comparisons.push(thisComparison);
          tc += thisComparison;
        }
        if (tc !== 0) {
          return tc;
        }
        let c;
        for (c of comparisons) {
          if (c !== 0) {
            return c;
          }
        }
        return 0;
      }
      function availableConversions(typeNames) {
        if (typeNames.length === 0) {
          return [];
        }
        const types = typeNames.map(findType);
        if (typeNames.length > 1) {
          types.sort((t1, t2) => t1.index - t2.index);
        }
        let matches2 = types[0].conversionsTo;
        if (typeNames.length === 1) {
          return matches2;
        }
        matches2 = matches2.concat([]);
        const knownTypes = new Set(typeNames);
        for (var i2 = 1; i2 < types.length; ++i2) {
          let newMatch;
          for (newMatch of types[i2].conversionsTo) {
            if (!knownTypes.has(newMatch.from)) {
              matches2.push(newMatch);
              knownTypes.add(newMatch.from);
            }
          }
        }
        return matches2;
      }
      function compileArgsPreprocessing(params, fn) {
        let fnConvert = fn;
        if (params.some((p2) => p2.hasConversion)) {
          const restParam = hasRestParam(params);
          const compiledConversions = params.map(compileArgConversion);
          fnConvert = function convertArgs() {
            const args = [];
            const last4 = restParam ? arguments.length - 1 : arguments.length;
            for (var i2 = 0; i2 < last4; i2++) {
              args[i2] = compiledConversions[i2](arguments[i2]);
            }
            if (restParam) {
              args[last4] = arguments[last4].map(compiledConversions[last4]);
            }
            return fn.apply(this, args);
          };
        }
        let fnPreprocess = fnConvert;
        if (hasRestParam(params)) {
          const offset = params.length - 1;
          fnPreprocess = function preprocessRestParams() {
            return fnConvert.apply(
              this,
              slice3(arguments, 0, offset).concat([slice3(arguments, offset)])
            );
          };
        }
        return fnPreprocess;
      }
      function compileArgConversion(param) {
        let test0, test1, conversion0, conversion1;
        const tests = [];
        const conversions = [];
        param.types.forEach(function(type) {
          if (type.conversion) {
            tests.push(findType(type.conversion.from).test);
            conversions.push(type.conversion.convert);
          }
        });
        switch (conversions.length) {
          case 0:
            return function convertArg(arg2) {
              return arg2;
            };
          case 1:
            test0 = tests[0];
            conversion0 = conversions[0];
            return function convertArg(arg2) {
              if (test0(arg2)) {
                return conversion0(arg2);
              }
              return arg2;
            };
          case 2:
            test0 = tests[0];
            test1 = tests[1];
            conversion0 = conversions[0];
            conversion1 = conversions[1];
            return function convertArg(arg2) {
              if (test0(arg2)) {
                return conversion0(arg2);
              }
              if (test1(arg2)) {
                return conversion1(arg2);
              }
              return arg2;
            };
          default:
            return function convertArg(arg2) {
              for (var i2 = 0; i2 < conversions.length; i2++) {
                if (tests[i2](arg2)) {
                  return conversions[i2](arg2);
                }
              }
              return arg2;
            };
        }
      }
      function splitParams(params) {
        function _splitParams(params2, index2, paramsSoFar) {
          if (index2 < params2.length) {
            const param = params2[index2];
            let resultingParams = [];
            if (param.restParam) {
              const exactTypes = param.types.filter(isExactType);
              if (exactTypes.length < param.types.length) {
                resultingParams.push({
                  types: exactTypes,
                  name: "..." + exactTypes.map((t) => t.name).join("|"),
                  hasAny: exactTypes.some((t) => t.isAny),
                  hasConversion: false,
                  restParam: true
                });
              }
              resultingParams.push(param);
            } else {
              resultingParams = param.types.map(function(type) {
                return {
                  types: [type],
                  name: type.name,
                  hasAny: type.isAny,
                  hasConversion: type.conversion,
                  restParam: false
                };
              });
            }
            return flatMap2(resultingParams, function(nextParam) {
              return _splitParams(params2, index2 + 1, paramsSoFar.concat([nextParam]));
            });
          } else {
            return [paramsSoFar];
          }
        }
        return _splitParams(params, 0, []);
      }
      function conflicting(params1, params2) {
        const ii = Math.max(params1.length, params2.length);
        for (var i2 = 0; i2 < ii; i2++) {
          const typeSet1 = getTypeSetAtIndex(params1, i2);
          const typeSet2 = getTypeSetAtIndex(params2, i2);
          let overlap = false;
          let name2;
          for (name2 of typeSet2) {
            if (typeSet1.has(name2)) {
              overlap = true;
              break;
            }
          }
          if (!overlap) {
            return false;
          }
        }
        const len1 = params1.length;
        const len2 = params2.length;
        const restParam1 = hasRestParam(params1);
        const restParam2 = hasRestParam(params2);
        return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
      }
      function clearResolutions(functionList) {
        return functionList.map((fn) => {
          if (isReferToSelf(fn)) {
            return referToSelf(fn.referToSelf.callback);
          }
          if (isReferTo(fn)) {
            return makeReferTo(fn.referTo.references, fn.referTo.callback);
          }
          return fn;
        });
      }
      function collectResolutions(references, functionList, signatureMap) {
        const resolvedReferences = [];
        let reference;
        for (reference of references) {
          let resolution = signatureMap[reference];
          if (typeof resolution !== "number") {
            throw new TypeError(
              'No definition for referenced signature "' + reference + '"'
            );
          }
          resolution = functionList[resolution];
          if (typeof resolution !== "function") {
            return false;
          }
          resolvedReferences.push(resolution);
        }
        return resolvedReferences;
      }
      function resolveReferences(functionList, signatureMap, self2) {
        let resolvedFunctions = clearResolutions(functionList);
        let leftUnresolved = true;
        while (leftUnresolved) {
          leftUnresolved = false;
          let nothingResolved = true;
          for (var i2 = 0; i2 < resolvedFunctions.length; ++i2) {
            const fn = resolvedFunctions[i2];
            if (isReferToSelf(fn)) {
              resolvedFunctions[i2] = fn.referToSelf.callback(self2);
              resolvedFunctions[i2].referToSelf = fn.referToSelf;
              nothingResolved = false;
            } else if (isReferTo(fn)) {
              const resolvedReferences = collectResolutions(
                fn.referTo.references,
                resolvedFunctions,
                signatureMap
              );
              if (resolvedReferences) {
                resolvedFunctions[i2] = fn.referTo.callback.apply(this, resolvedReferences);
                resolvedFunctions[i2].referTo = fn.referTo;
                nothingResolved = false;
              } else {
                leftUnresolved = true;
              }
            }
          }
          if (nothingResolved && leftUnresolved) {
            throw new SyntaxError(
              "Circular reference detected in resolving typed.referTo"
            );
          }
        }
        return resolvedFunctions;
      }
      function validateDeprecatedThis(signaturesMap) {
        var deprecatedThisRegex = /\bthis(\(|\.signatures\b)/;
        Object.keys(signaturesMap).forEach((signature) => {
          var fn = signaturesMap[signature];
          if (deprecatedThisRegex.test(fn.toString())) {
            throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.");
          }
        });
      }
      function createTypedFunction(name2, rawSignaturesMap) {
        typed2.createCount++;
        if (Object.keys(rawSignaturesMap).length === 0) {
          throw new SyntaxError("No signatures provided");
        }
        if (typed2.warnAgainstDeprecatedThis) {
          validateDeprecatedThis(rawSignaturesMap);
        }
        const parsedParams = [];
        const originalFunctions = [];
        const signaturesMap = {};
        const preliminarySignatures = [];
        let signature;
        for (signature in rawSignaturesMap) {
          if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {
            continue;
          }
          const params = parseSignature(signature);
          if (!params)
            continue;
          parsedParams.forEach(function(pp) {
            if (conflicting(pp, params)) {
              throw new TypeError('Conflicting signatures "' + stringifyParams(pp) + '" and "' + stringifyParams(params) + '".');
            }
          });
          parsedParams.push(params);
          const functionIndex = originalFunctions.length;
          originalFunctions.push(rawSignaturesMap[signature]);
          const conversionParams = params.map(expandParam);
          let sp;
          for (sp of splitParams(conversionParams)) {
            const spName = stringifyParams(sp);
            preliminarySignatures.push(
              { params: sp, name: spName, fn: functionIndex }
            );
            if (sp.every((p2) => !p2.hasConversion)) {
              signaturesMap[spName] = functionIndex;
            }
          }
        }
        preliminarySignatures.sort(compareSignatures);
        const resolvedFunctions = resolveReferences(originalFunctions, signaturesMap, the_typed_fn);
        let s;
        for (s in signaturesMap) {
          if (Object.prototype.hasOwnProperty.call(signaturesMap, s)) {
            signaturesMap[s] = resolvedFunctions[signaturesMap[s]];
          }
        }
        const signatures = [];
        const internalSignatureMap = /* @__PURE__ */ new Map();
        for (s of preliminarySignatures) {
          if (!internalSignatureMap.has(s.name)) {
            s.fn = resolvedFunctions[s.fn];
            signatures.push(s);
            internalSignatureMap.set(s.name, s);
          }
        }
        const ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
        const ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
        const ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
        const ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
        const ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
        const ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
        const allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
        for (var i2 = 0; i2 < signatures.length; ++i2) {
          signatures[i2].test = compileTests(signatures[i2].params);
        }
        const test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
        const test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
        const test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
        const test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
        const test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
        const test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
        const test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
        const test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
        const test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
        const test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
        const test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
        const test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
        for (var i2 = 0; i2 < signatures.length; ++i2) {
          signatures[i2].implementation = compileArgsPreprocessing(signatures[i2].params, signatures[i2].fn);
        }
        const fn0 = ok0 ? signatures[0].implementation : undef;
        const fn1 = ok1 ? signatures[1].implementation : undef;
        const fn2 = ok2 ? signatures[2].implementation : undef;
        const fn3 = ok3 ? signatures[3].implementation : undef;
        const fn4 = ok4 ? signatures[4].implementation : undef;
        const fn5 = ok5 ? signatures[5].implementation : undef;
        const len0 = ok0 ? signatures[0].params.length : -1;
        const len1 = ok1 ? signatures[1].params.length : -1;
        const len2 = ok2 ? signatures[2].params.length : -1;
        const len3 = ok3 ? signatures[3].params.length : -1;
        const len4 = ok4 ? signatures[4].params.length : -1;
        const len5 = ok5 ? signatures[5].params.length : -1;
        const iStart = allOk ? 6 : 0;
        const iEnd = signatures.length;
        const tests = signatures.map((s2) => s2.test);
        const fns = signatures.map((s2) => s2.implementation);
        const generic = function generic2() {
          for (var i3 = iStart; i3 < iEnd; i3++) {
            if (tests[i3](arguments)) {
              return fns[i3].apply(this, arguments);
            }
          }
          return typed2.onMismatch(name2, arguments, signatures);
        };
        function the_typed_fn(arg0, arg1) {
          if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
            return fn0.apply(this, arguments);
          }
          if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
            return fn1.apply(this, arguments);
          }
          if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
            return fn2.apply(this, arguments);
          }
          if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
            return fn3.apply(this, arguments);
          }
          if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
            return fn4.apply(this, arguments);
          }
          if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
            return fn5.apply(this, arguments);
          }
          return generic.apply(this, arguments);
        }
        try {
          Object.defineProperty(the_typed_fn, "name", { value: name2 });
        } catch (err) {
        }
        the_typed_fn.signatures = signaturesMap;
        the_typed_fn._typedFunctionData = {
          signatures,
          signatureMap: internalSignatureMap
        };
        return the_typed_fn;
      }
      function _onMismatch(name2, args, signatures) {
        throw createError(name2, args, signatures);
      }
      function initial(arr) {
        return slice3(arr, 0, arr.length - 1);
      }
      function last3(arr) {
        return arr[arr.length - 1];
      }
      function slice3(arr, start2, end) {
        return Array.prototype.slice.call(arr, start2, end);
      }
      function findInArray(arr, test) {
        for (var i2 = 0; i2 < arr.length; i2++) {
          if (test(arr[i2])) {
            return arr[i2];
          }
        }
        return void 0;
      }
      function flatMap2(arr, callback) {
        return Array.prototype.concat.apply([], arr.map(callback));
      }
      function referTo() {
        let references = initial(arguments).map((s) => stringifyParams(parseSignature(s)));
        const callback = last3(arguments);
        if (typeof callback !== "function") {
          throw new TypeError("Callback function expected as last argument");
        }
        return makeReferTo(references, callback);
      }
      function makeReferTo(references, callback) {
        return { referTo: { references, callback } };
      }
      function referToSelf(callback) {
        if (typeof callback !== "function") {
          throw new TypeError("Callback function expected as first argument");
        }
        return { referToSelf: { callback } };
      }
      function isReferTo(objectOrFn) {
        return objectOrFn && typeof objectOrFn.referTo === "object" && Array.isArray(objectOrFn.referTo.references) && typeof objectOrFn.referTo.callback === "function";
      }
      function isReferToSelf(objectOrFn) {
        return objectOrFn && typeof objectOrFn.referToSelf === "object" && typeof objectOrFn.referToSelf.callback === "function";
      }
      function checkName(nameSoFar, newName) {
        if (!nameSoFar) {
          return newName;
        }
        if (newName && newName != nameSoFar) {
          const err = new Error("Function names do not match (expected: " + nameSoFar + ", actual: " + newName + ")");
          err.data = { actual: newName, expected: nameSoFar };
          throw err;
        }
        return nameSoFar;
      }
      function getObjectName(obj) {
        let name2;
        for (let key in obj) {
          if (obj.hasOwnProperty(key) && (isTypedFunction(obj[key]) || typeof obj[key].signature === "string")) {
            name2 = checkName(name2, obj[key].name);
          }
        }
        return name2;
      }
      function mergeSignatures(dest, source) {
        let key;
        for (key in source) {
          if (source.hasOwnProperty(key)) {
            if (key in dest) {
              if (source[key] !== dest[key]) {
                const err = new Error('Signature "' + key + '" is defined twice');
                err.data = {
                  signature: key,
                  sourceFunction: source[key],
                  destFunction: dest[key]
                };
                throw err;
              }
            }
            dest[key] = source[key];
          }
        }
      }
      const saveTyped = typed2;
      typed2 = function(maybeName) {
        const named = typeof maybeName === "string";
        const start2 = named ? 1 : 0;
        let name2 = named ? maybeName : "";
        const allSignatures = {};
        for (let i2 = start2; i2 < arguments.length; ++i2) {
          const item = arguments[i2];
          let theseSignatures = {};
          let thisName;
          if (typeof item === "function") {
            thisName = item.name;
            if (typeof item.signature === "string") {
              theseSignatures[item.signature] = item;
            } else if (isTypedFunction(item)) {
              theseSignatures = item.signatures;
            }
          } else if (isPlainObject2(item)) {
            theseSignatures = item;
            if (!named) {
              thisName = getObjectName(item);
            }
          }
          if (Object.keys(theseSignatures).length === 0) {
            const err = new TypeError(
              "Argument to 'typed' at index " + i2 + " is not a (typed) function, nor an object with signatures as keys and functions as values."
            );
            err.data = { index: i2, argument: item };
            throw err;
          }
          if (!named) {
            name2 = checkName(name2, thisName);
          }
          mergeSignatures(allSignatures, theseSignatures);
        }
        return createTypedFunction(name2 || "", allSignatures);
      };
      typed2.create = create2;
      typed2.createCount = saveTyped.createCount;
      typed2.onMismatch = _onMismatch;
      typed2.throwMismatchError = _onMismatch;
      typed2.createError = createError;
      typed2.clear = clear3;
      typed2.clearConversions = clearConversions;
      typed2.addTypes = addTypes;
      typed2._findType = findType;
      typed2.referTo = referTo;
      typed2.referToSelf = referToSelf;
      typed2.convert = convert;
      typed2.findSignature = findSignature;
      typed2.find = find2;
      typed2.isTypedFunction = isTypedFunction;
      typed2.warnAgainstDeprecatedThis = true;
      typed2.addType = function(type, beforeObjectTest) {
        let before = "any";
        if (beforeObjectTest !== false) {
          before = "Object";
        }
        typed2.addTypes([type], before);
      };
      function _validateConversion(conversion) {
        if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
          throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
        }
        if (conversion.to === conversion.from) {
          throw new SyntaxError(
            'Illegal to define conversion from "' + conversion.from + '" to itself.'
          );
        }
      }
      typed2.addConversion = function(conversion) {
        _validateConversion(conversion);
        const to2 = findType(conversion.to);
        if (to2.conversionsTo.every(function(other) {
          return other.from !== conversion.from;
        })) {
          to2.conversionsTo.push({
            from: conversion.from,
            convert: conversion.convert,
            index: nConversions++
          });
        } else {
          throw new Error(
            'There is already a conversion from "' + conversion.from + '" to "' + to2.name + '"'
          );
        }
      };
      typed2.addConversions = function(conversions) {
        conversions.forEach(typed2.addConversion);
      };
      typed2.removeConversion = function(conversion) {
        _validateConversion(conversion);
        const to2 = findType(conversion.to);
        const existingConversion = findInArray(to2.conversionsTo, (c) => c.from === conversion.from);
        if (!existingConversion) {
          throw new Error(
            "Attempt to remove nonexistent conversion from " + conversion.from + " to " + conversion.to
          );
        }
        if (existingConversion.convert !== conversion.convert) {
          throw new Error(
            "Conversion to remove does not match existing conversion"
          );
        }
        const index2 = to2.conversionsTo.indexOf(existingConversion);
        to2.conversionsTo.splice(index2, 1);
      };
      typed2.resolve = function(tf, argList) {
        if (!isTypedFunction(tf)) {
          throw new TypeError(NOT_TYPED_FUNCTION);
        }
        const sigs = tf._typedFunctionData.signatures;
        for (var i2 = 0; i2 < sigs.length; ++i2) {
          if (sigs[i2].test(argList)) {
            return sigs[i2];
          }
        }
        return null;
      };
      return typed2;
    }
    return create2();
  });
})(typedFunction$1);
var typedFunction = typedFunction$1.exports;
function isInteger$1(value) {
  if (typeof value === "boolean") {
    return true;
  }
  return isFinite(value) ? value === Math.round(value) : false;
}
var sign$2 = Math.sign || function(x) {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return -1;
  } else {
    return 0;
  }
};
var log2$2 = Math.log2 || function log2(x) {
  return Math.log(x) / Math.LN2;
};
var log10$2 = Math.log10 || function log10(x) {
  return Math.log(x) / Math.LN10;
};
var log1p$1 = Math.log1p || function(x) {
  return Math.log(x + 1);
};
var cbrt$2 = Math.cbrt || function cbrt(x) {
  if (x === 0) {
    return x;
  }
  var negate = x < 0;
  var result;
  if (negate) {
    x = -x;
  }
  if (isFinite(x)) {
    result = Math.exp(Math.log(x) / 3);
    result = (x / (result * result) + 2 * result) / 3;
  } else {
    result = x;
  }
  return negate ? -result : result;
};
var expm1$1 = Math.expm1 || function expm1(x) {
  return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
};
function formatNumberToBase(n, base2, size2) {
  var prefixes2 = {
    2: "0b",
    8: "0o",
    16: "0x"
  };
  var prefix = prefixes2[base2];
  var suffix = "";
  if (size2) {
    if (size2 < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger$1(size2)) {
      throw new Error("size must be an integer");
    }
    if (n > 2 ** (size2 - 1) - 1 || n < -(2 ** (size2 - 1))) {
      throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
    }
    if (!isInteger$1(n)) {
      throw new Error("Value must be an integer");
    }
    if (n < 0) {
      n = n + 2 ** size2;
    }
    suffix = "i".concat(size2);
  }
  var sign2 = "";
  if (n < 0) {
    n = -n;
    sign2 = "-";
  }
  return "".concat(sign2).concat(prefix).concat(n.toString(base2)).concat(suffix);
}
function format$3(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (value === Infinity) {
    return "Infinity";
  } else if (value === -Infinity) {
    return "-Infinity";
  } else if (isNaN(value)) {
    return "NaN";
  }
  var notation = "auto";
  var precision;
  var wordSize;
  if (options) {
    if (options.notation) {
      notation = options.notation;
    }
    if (isNumber(options)) {
      precision = options;
    } else if (isNumber(options.precision)) {
      precision = options.precision;
    }
    if (options.wordSize) {
      wordSize = options.wordSize;
      if (typeof wordSize !== "number") {
        throw new Error('Option "wordSize" must be a number');
      }
    }
  }
  switch (notation) {
    case "fixed":
      return toFixed$1(value, precision);
    case "exponential":
      return toExponential$1(value, precision);
    case "engineering":
      return toEngineering$1(value, precision);
    case "bin":
      return formatNumberToBase(value, 2, wordSize);
    case "oct":
      return formatNumberToBase(value, 8, wordSize);
    case "hex":
      return formatNumberToBase(value, 16, wordSize);
    case "auto":
      return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e2 = arguments[4];
        return digits2 !== "." ? digits2 + e2 : e2;
      });
    default:
      throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function splitNumber(value) {
  var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!match) {
    throw new SyntaxError("Invalid number " + value);
  }
  var sign2 = match[1];
  var digits2 = match[2];
  var exponent = parseFloat(match[4] || "0");
  var dot2 = digits2.indexOf(".");
  exponent += dot2 !== -1 ? dot2 - 1 : digits2.length - 1;
  var coefficients = digits2.replace(".", "").replace(/^0*/, function(zeros2) {
    exponent -= zeros2.length;
    return "";
  }).replace(/0*$/, "").split("").map(function(d) {
    return parseInt(d);
  });
  if (coefficients.length === 0) {
    coefficients.push(0);
    exponent++;
  }
  return {
    sign: sign2,
    coefficients,
    exponent
  };
}
function toEngineering$1(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = roundDigits(split, precision);
  var e2 = rounded.exponent;
  var c = rounded.coefficients;
  var newExp = e2 % 3 === 0 ? e2 : e2 < 0 ? e2 - 3 - e2 % 3 : e2 - e2 % 3;
  if (isNumber(precision)) {
    while (precision > c.length || e2 - newExp + 1 > c.length) {
      c.push(0);
    }
  } else {
    var missingZeros = Math.abs(e2 - newExp) - (c.length - 1);
    for (var i2 = 0; i2 < missingZeros; i2++) {
      c.push(0);
    }
  }
  var expDiff = Math.abs(e2 - newExp);
  var decimalIdx = 1;
  while (expDiff > 0) {
    decimalIdx++;
    expDiff--;
  }
  var decimals = c.slice(decimalIdx).join("");
  var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
  var str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e2 >= 0 ? "+" : "") + newExp.toString();
  return rounded.sign + str;
}
function toFixed$1(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var splitValue = splitNumber(value);
  var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
  var c = rounded.coefficients;
  var p2 = rounded.exponent + 1;
  var pp = p2 + (precision || 0);
  if (c.length < pp) {
    c = c.concat(zeros$1(pp - c.length));
  }
  if (p2 < 0) {
    c = zeros$1(-p2 + 1).concat(c);
    p2 = 1;
  }
  if (p2 < c.length) {
    c.splice(p2, 0, p2 === 0 ? "0." : ".");
  }
  return rounded.sign + c.join("");
}
function toExponential$1(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  var c = rounded.coefficients;
  var e2 = rounded.exponent;
  if (c.length < precision) {
    c = c.concat(zeros$1(precision - c.length));
  }
  var first3 = c.shift();
  return rounded.sign + first3 + (c.length > 0 ? "." + c.join("") : "") + "e" + (e2 >= 0 ? "+" : "") + e2;
}
function toPrecision(value, precision, options) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
  var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
    return toExponential$1(value, precision);
  } else {
    var c = rounded.coefficients;
    var e2 = rounded.exponent;
    if (c.length < precision) {
      c = c.concat(zeros$1(precision - c.length));
    }
    c = c.concat(zeros$1(e2 - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
    c = zeros$1(-e2).concat(c);
    var dot2 = e2 > 0 ? e2 : 0;
    if (dot2 < c.length - 1) {
      c.splice(dot2 + 1, 0, ".");
    }
    return rounded.sign + c.join("");
  }
}
function roundDigits(split, precision) {
  var rounded = {
    sign: split.sign,
    coefficients: split.coefficients,
    exponent: split.exponent
  };
  var c = rounded.coefficients;
  while (precision <= 0) {
    c.unshift(0);
    rounded.exponent++;
    precision++;
  }
  if (c.length > precision) {
    var removed = c.splice(precision, c.length - precision);
    if (removed[0] >= 5) {
      var i2 = precision - 1;
      c[i2]++;
      while (c[i2] === 10) {
        c.pop();
        if (i2 === 0) {
          c.unshift(0);
          rounded.exponent++;
          i2++;
        }
        i2--;
        c[i2]++;
      }
    }
  }
  return rounded;
}
function zeros$1(length) {
  var arr = [];
  for (var i2 = 0; i2 < length; i2++) {
    arr.push(0);
  }
  return arr;
}
function digits(value) {
  return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
}
var DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
function nearlyEqual$1(x, y, epsilon) {
  if (epsilon === null || epsilon === void 0) {
    return x === y;
  }
  if (x === y) {
    return true;
  }
  if (isNaN(x) || isNaN(y)) {
    return false;
  }
  if (isFinite(x) && isFinite(y)) {
    var diff2 = Math.abs(x - y);
    if (diff2 < DBL_EPSILON) {
      return true;
    } else {
      return diff2 <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
    }
  }
  return false;
}
var acosh$2 = Math.acosh || function(x) {
  return Math.log(Math.sqrt(x * x - 1) + x);
};
var asinh$2 = Math.asinh || function(x) {
  return Math.log(Math.sqrt(x * x + 1) + x);
};
var atanh$2 = Math.atanh || function(x) {
  return Math.log((1 + x) / (1 - x)) / 2;
};
var cosh$2 = Math.cosh || function(x) {
  return (Math.exp(x) + Math.exp(-x)) / 2;
};
var sinh$2 = Math.sinh || function(x) {
  return (Math.exp(x) - Math.exp(-x)) / 2;
};
var tanh$2 = Math.tanh || function(x) {
  var e2 = Math.exp(2 * x);
  return (e2 - 1) / (e2 + 1);
};
function copysign(x, y) {
  var signx = x > 0 ? true : x < 0 ? false : 1 / x === Infinity;
  var signy = y > 0 ? true : y < 0 ? false : 1 / y === Infinity;
  return signx ^ signy ? -x : x;
}
function formatBigNumberToBase(n, base2, size2) {
  var BigNumberCtor = n.constructor;
  var big2 = new BigNumberCtor(2);
  var suffix = "";
  if (size2) {
    if (size2 < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger$1(size2)) {
      throw new Error("size must be an integer");
    }
    if (n.greaterThan(big2.pow(size2 - 1).sub(1)) || n.lessThan(big2.pow(size2 - 1).mul(-1))) {
      throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
    }
    if (!n.isInteger()) {
      throw new Error("Value must be an integer");
    }
    if (n.lessThan(0)) {
      n = n.add(big2.pow(size2));
    }
    suffix = "i".concat(size2);
  }
  switch (base2) {
    case 2:
      return "".concat(n.toBinary()).concat(suffix);
    case 8:
      return "".concat(n.toOctal()).concat(suffix);
    case 16:
      return "".concat(n.toHexadecimal()).concat(suffix);
    default:
      throw new Error("Base ".concat(base2, " not supported "));
  }
}
function format$2(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (!value.isFinite()) {
    return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
  }
  var notation = "auto";
  var precision;
  var wordSize;
  if (options !== void 0) {
    if (options.notation) {
      notation = options.notation;
    }
    if (typeof options === "number") {
      precision = options;
    } else if (options.precision) {
      precision = options.precision;
    }
    if (options.wordSize) {
      wordSize = options.wordSize;
      if (typeof wordSize !== "number") {
        throw new Error('Option "wordSize" must be a number');
      }
    }
  }
  switch (notation) {
    case "fixed":
      return toFixed(value, precision);
    case "exponential":
      return toExponential(value, precision);
    case "engineering":
      return toEngineering(value, precision);
    case "bin":
      return formatBigNumberToBase(value, 2, wordSize);
    case "oct":
      return formatBigNumberToBase(value, 8, wordSize);
    case "hex":
      return formatBigNumberToBase(value, 16, wordSize);
    case "auto": {
      var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
      var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
      if (value.isZero())
        return "0";
      var str;
      var rounded = value.toSignificantDigits(precision);
      var exp2 = rounded.e;
      if (exp2 >= lowerExp && exp2 < upperExp) {
        str = rounded.toFixed();
      } else {
        str = toExponential(value, precision);
      }
      return str.replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e2 = arguments[4];
        return digits2 !== "." ? digits2 + e2 : e2;
      });
    }
    default:
      throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function toEngineering(value, precision) {
  var e2 = value.e;
  var newExp = e2 % 3 === 0 ? e2 : e2 < 0 ? e2 - 3 - e2 % 3 : e2 - e2 % 3;
  var valueWithoutExp = value.mul(Math.pow(10, -newExp));
  var valueStr = valueWithoutExp.toPrecision(precision);
  if (valueStr.indexOf("e") !== -1) {
    valueStr = valueWithoutExp.toString();
  }
  return valueStr + "e" + (e2 >= 0 ? "+" : "") + newExp.toString();
}
function toExponential(value, precision) {
  if (precision !== void 0) {
    return value.toExponential(precision - 1);
  } else {
    return value.toExponential();
  }
}
function toFixed(value, precision) {
  return value.toFixed(precision);
}
function endsWith(text, search) {
  var start2 = text.length - search.length;
  var end = text.length;
  return text.substring(start2, end) === search;
}
function format$1(value, options) {
  var result = _format(value, options);
  if (options && typeof options === "object" && "truncate" in options && result.length > options.truncate) {
    return result.substring(0, options.truncate - 3) + "...";
  }
  return result;
}
function _format(value, options) {
  if (typeof value === "number") {
    return format$3(value, options);
  }
  if (isBigNumber(value)) {
    return format$2(value, options);
  }
  if (looksLikeFraction(value)) {
    if (!options || options.fraction !== "decimal") {
      return value.s * value.n + "/" + value.d;
    } else {
      return value.toString();
    }
  }
  if (Array.isArray(value)) {
    return formatArray(value, options);
  }
  if (isString(value)) {
    return '"' + value + '"';
  }
  if (typeof value === "function") {
    return value.syntax ? String(value.syntax) : "function";
  }
  if (value && typeof value === "object") {
    if (typeof value.format === "function") {
      return value.format(options);
    } else if (value && value.toString(options) !== {}.toString()) {
      return value.toString(options);
    } else {
      var entries3 = Object.keys(value).map((key) => {
        return '"' + key + '": ' + format$1(value[key], options);
      });
      return "{" + entries3.join(", ") + "}";
    }
  }
  return String(value);
}
function stringify(value) {
  var text = String(value);
  var escaped = "";
  var i2 = 0;
  while (i2 < text.length) {
    var c = text.charAt(i2);
    if (c === "\\") {
      escaped += c;
      i2++;
      c = text.charAt(i2);
      if (c === "" || '"\\/bfnrtu'.indexOf(c) === -1) {
        escaped += "\\";
      }
      escaped += c;
    } else if (c === '"') {
      escaped += '\\"';
    } else {
      escaped += c;
    }
    i2++;
  }
  return '"' + escaped + '"';
}
function escape(value) {
  var text = String(value);
  text = text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  return text;
}
function formatArray(array, options) {
  if (Array.isArray(array)) {
    var str = "[";
    var len = array.length;
    for (var i2 = 0; i2 < len; i2++) {
      if (i2 !== 0) {
        str += ", ";
      }
      str += formatArray(array[i2], options);
    }
    str += "]";
    return str;
  } else {
    return format$1(array, options);
  }
}
function looksLikeFraction(value) {
  return value && typeof value === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
}
function compareText$1(x, y) {
  if (!isString(x)) {
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf$1(x) + ", index: 0)");
  }
  if (!isString(y)) {
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf$1(y) + ", index: 1)");
  }
  return x === y ? 0 : x > y ? 1 : -1;
}
function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.actual = actual;
  this.expected = expected;
  this.relation = relation;
  this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
  this.stack = new Error().stack;
}
DimensionError.prototype = new RangeError();
DimensionError.prototype.constructor = RangeError;
DimensionError.prototype.name = "DimensionError";
DimensionError.prototype.isDimensionError = true;
function IndexError(index2, min3, max3) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.index = index2;
  if (arguments.length < 3) {
    this.min = 0;
    this.max = min3;
  } else {
    this.min = min3;
    this.max = max3;
  }
  if (this.min !== void 0 && this.index < this.min) {
    this.message = "Index out of range (" + this.index + " < " + this.min + ")";
  } else if (this.max !== void 0 && this.index >= this.max) {
    this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
  } else {
    this.message = "Index out of range (" + this.index + ")";
  }
  this.stack = new Error().stack;
}
IndexError.prototype = new RangeError();
IndexError.prototype.constructor = RangeError;
IndexError.prototype.name = "IndexError";
IndexError.prototype.isIndexError = true;
function arraySize(x) {
  var s = [];
  while (Array.isArray(x)) {
    s.push(x.length);
    x = x[0];
  }
  return s;
}
function _validate(array, size2, dim) {
  var i2;
  var len = array.length;
  if (len !== size2[dim]) {
    throw new DimensionError(len, size2[dim]);
  }
  if (dim < size2.length - 1) {
    var dimNext = dim + 1;
    for (i2 = 0; i2 < len; i2++) {
      var child = array[i2];
      if (!Array.isArray(child)) {
        throw new DimensionError(size2.length - 1, size2.length, "<");
      }
      _validate(array[i2], size2, dimNext);
    }
  } else {
    for (i2 = 0; i2 < len; i2++) {
      if (Array.isArray(array[i2])) {
        throw new DimensionError(size2.length + 1, size2.length, ">");
      }
    }
  }
}
function validate(array, size2) {
  var isScalar = size2.length === 0;
  if (isScalar) {
    if (Array.isArray(array)) {
      throw new DimensionError(array.length, 0);
    }
  } else {
    _validate(array, size2, 0);
  }
}
function validateIndex(index2, length) {
  if (!isNumber(index2) || !isInteger$1(index2)) {
    throw new TypeError("Index must be an integer (value: " + index2 + ")");
  }
  if (index2 < 0 || typeof length === "number" && index2 >= length) {
    throw new IndexError(index2, length);
  }
}
function resize$1(array, size2, defaultValue) {
  if (!Array.isArray(array) || !Array.isArray(size2)) {
    throw new TypeError("Array expected");
  }
  if (size2.length === 0) {
    throw new Error("Resizing to scalar is not supported");
  }
  size2.forEach(function(value) {
    if (!isNumber(value) || !isInteger$1(value) || value < 0) {
      throw new TypeError("Invalid size, must contain positive integers (size: " + format$1(size2) + ")");
    }
  });
  var _defaultValue = defaultValue !== void 0 ? defaultValue : 0;
  _resize(array, size2, 0, _defaultValue);
  return array;
}
function _resize(array, size2, dim, defaultValue) {
  var i2;
  var elem;
  var oldLen = array.length;
  var newLen = size2[dim];
  var minLen = Math.min(oldLen, newLen);
  array.length = newLen;
  if (dim < size2.length - 1) {
    var dimNext = dim + 1;
    for (i2 = 0; i2 < minLen; i2++) {
      elem = array[i2];
      if (!Array.isArray(elem)) {
        elem = [elem];
        array[i2] = elem;
      }
      _resize(elem, size2, dimNext, defaultValue);
    }
    for (i2 = minLen; i2 < newLen; i2++) {
      elem = [];
      array[i2] = elem;
      _resize(elem, size2, dimNext, defaultValue);
    }
  } else {
    for (i2 = 0; i2 < minLen; i2++) {
      while (Array.isArray(array[i2])) {
        array[i2] = array[i2][0];
      }
    }
    for (i2 = minLen; i2 < newLen; i2++) {
      array[i2] = defaultValue;
    }
  }
}
function reshape$1(array, sizes) {
  var flatArray = flatten$1(array);
  var currentLength = flatArray.length;
  if (!Array.isArray(array) || !Array.isArray(sizes)) {
    throw new TypeError("Array expected");
  }
  if (sizes.length === 0) {
    throw new DimensionError(0, currentLength, "!=");
  }
  sizes = processSizesWildcard(sizes, currentLength);
  var newLength = product$1(sizes);
  if (currentLength !== newLength) {
    throw new DimensionError(newLength, currentLength, "!=");
  }
  try {
    return _reshape(flatArray, sizes);
  } catch (e2) {
    if (e2 instanceof DimensionError) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    throw e2;
  }
}
function processSizesWildcard(sizes, currentLength) {
  var newLength = product$1(sizes);
  var processedSizes = sizes.slice();
  var WILDCARD = -1;
  var wildCardIndex = sizes.indexOf(WILDCARD);
  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
  if (isMoreThanOneWildcard) {
    throw new Error("More than one wildcard in sizes");
  }
  var hasWildcard = wildCardIndex >= 0;
  var canReplaceWildcard = currentLength % newLength === 0;
  if (hasWildcard) {
    if (canReplaceWildcard) {
      processedSizes[wildCardIndex] = -currentLength / newLength;
    } else {
      throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
    }
  }
  return processedSizes;
}
function product$1(array) {
  return array.reduce((prev, curr) => prev * curr, 1);
}
function _reshape(array, sizes) {
  var tmpArray = array;
  var tmpArray2;
  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
    var size2 = sizes[sizeIndex];
    tmpArray2 = [];
    var length = tmpArray.length / size2;
    for (var i2 = 0; i2 < length; i2++) {
      tmpArray2.push(tmpArray.slice(i2 * size2, (i2 + 1) * size2));
    }
    tmpArray = tmpArray2;
  }
  return tmpArray;
}
function squeeze$1(array, size2) {
  var s = size2 || arraySize(array);
  while (Array.isArray(array) && array.length === 1) {
    array = array[0];
    s.shift();
  }
  var dims = s.length;
  while (s[dims - 1] === 1) {
    dims--;
  }
  if (dims < s.length) {
    array = _squeeze(array, dims, 0);
    s.length = dims;
  }
  return array;
}
function _squeeze(array, dims, dim) {
  var i2, ii;
  if (dim < dims) {
    var next = dim + 1;
    for (i2 = 0, ii = array.length; i2 < ii; i2++) {
      array[i2] = _squeeze(array[i2], dims, next);
    }
  } else {
    while (Array.isArray(array)) {
      array = array[0];
    }
  }
  return array;
}
function unsqueeze(array, dims, outer, size2) {
  var s = size2 || arraySize(array);
  if (outer) {
    for (var i2 = 0; i2 < outer; i2++) {
      array = [array];
      s.unshift(1);
    }
  }
  array = _unsqueeze(array, dims, 0);
  while (s.length < dims) {
    s.push(1);
  }
  return array;
}
function _unsqueeze(array, dims, dim) {
  var i2, ii;
  if (Array.isArray(array)) {
    var next = dim + 1;
    for (i2 = 0, ii = array.length; i2 < ii; i2++) {
      array[i2] = _unsqueeze(array[i2], dims, next);
    }
  } else {
    for (var d = dim; d < dims; d++) {
      array = [array];
    }
  }
  return array;
}
function flatten$1(array) {
  if (!Array.isArray(array)) {
    return array;
  }
  var flat = [];
  array.forEach(function callback(value) {
    if (Array.isArray(value)) {
      value.forEach(callback);
    } else {
      flat.push(value);
    }
  });
  return flat;
}
function map$1(array, callback) {
  return Array.prototype.map.call(array, callback);
}
function forEach$1(array, callback) {
  Array.prototype.forEach.call(array, callback);
}
function filter$1(array, callback) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array, callback);
}
function filterRegExp(array, regexp) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array, (entry) => regexp.test(entry));
}
function join(array, separator) {
  return Array.prototype.join.call(array, separator);
}
function identify(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return a;
  }
  var b = [];
  var count3 = 0;
  b[0] = {
    value: a[0],
    identifier: 0
  };
  for (var i2 = 1; i2 < a.length; i2++) {
    if (a[i2] === a[i2 - 1]) {
      count3++;
    } else {
      count3 = 0;
    }
    b.push({
      value: a[i2],
      identifier: count3
    });
  }
  return b;
}
function generalize(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return a;
  }
  var b = [];
  for (var i2 = 0; i2 < a.length; i2++) {
    b.push(a[i2].value);
  }
  return b;
}
function getArrayDataType(array, typeOf2) {
  var type;
  var length = 0;
  for (var i2 = 0; i2 < array.length; i2++) {
    var item = array[i2];
    var isArray2 = Array.isArray(item);
    if (i2 === 0 && isArray2) {
      length = item.length;
    }
    if (isArray2 && item.length !== length) {
      return void 0;
    }
    var itemType = isArray2 ? getArrayDataType(item, typeOf2) : typeOf2(item);
    if (type === void 0) {
      type = itemType;
    } else if (type !== itemType) {
      return "mixed";
    } else
      ;
  }
  return type;
}
function factory(name2, dependencies2, create2, meta) {
  function assertAndCreate(scope) {
    var deps = pickShallow(scope, dependencies2.map(stripOptionalNotation));
    assertDependencies(name2, dependencies2, scope);
    return create2(deps);
  }
  assertAndCreate.isFactory = true;
  assertAndCreate.fn = name2;
  assertAndCreate.dependencies = dependencies2.slice().sort();
  if (meta) {
    assertAndCreate.meta = meta;
  }
  return assertAndCreate;
}
function assertDependencies(name2, dependencies2, scope) {
  var allDefined = dependencies2.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== void 0);
  if (!allDefined) {
    var missingDependencies = dependencies2.filter((dependency) => scope[dependency] === void 0);
    throw new Error('Cannot create function "'.concat(name2, '", ') + "some dependencies are missing: ".concat(missingDependencies.map((d) => '"'.concat(d, '"')).join(", "), "."));
  }
}
function isOptionalDependency(dependency) {
  return dependency && dependency[0] === "?";
}
function stripOptionalNotation(dependency) {
  return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
}
function getSafeProperty(object, prop) {
  if (isPlainObject$1(object) && isSafeProperty(object, prop)) {
    return object[prop];
  }
  if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
    throw new Error('Cannot access method "' + prop + '" as a property');
  }
  throw new Error('No access to property "' + prop + '"');
}
function setSafeProperty(object, prop, value) {
  if (isPlainObject$1(object) && isSafeProperty(object, prop)) {
    object[prop] = value;
    return value;
  }
  throw new Error('No access to property "' + prop + '"');
}
function hasSafeProperty(object, prop) {
  return prop in object;
}
function isSafeProperty(object, prop) {
  if (!object || typeof object !== "object") {
    return false;
  }
  if (hasOwnProperty$2(safeNativeProperties, prop)) {
    return true;
  }
  if (prop in Object.prototype) {
    return false;
  }
  if (prop in Function.prototype) {
    return false;
  }
  return true;
}
function validateSafeMethod(object, method) {
  if (!isSafeMethod(object, method)) {
    throw new Error('No access to method "' + method + '"');
  }
}
function isSafeMethod(object, method) {
  if (object === null || object === void 0 || typeof object[method] !== "function") {
    return false;
  }
  if (hasOwnProperty$2(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
    return false;
  }
  if (hasOwnProperty$2(safeNativeMethods, method)) {
    return true;
  }
  if (method in Object.prototype) {
    return false;
  }
  if (method in Function.prototype) {
    return false;
  }
  return true;
}
function isPlainObject$1(object) {
  return typeof object === "object" && object && object.constructor === Object;
}
var safeNativeProperties = {
  length: true,
  name: true
};
var safeNativeMethods = {
  toString: true,
  valueOf: true,
  toLocaleString: true
};
class ObjectWrappingMap {
  constructor(object) {
    this.wrappedObject = object;
  }
  keys() {
    return Object.keys(this.wrappedObject);
  }
  get(key) {
    return getSafeProperty(this.wrappedObject, key);
  }
  set(key, value) {
    setSafeProperty(this.wrappedObject, key, value);
    return this;
  }
  has(key) {
    return hasSafeProperty(this.wrappedObject, key);
  }
}
function createEmptyMap() {
  return /* @__PURE__ */ new Map();
}
function createMap$1(mapOrObject) {
  if (!mapOrObject) {
    return createEmptyMap();
  }
  if (isMap$1(mapOrObject)) {
    return mapOrObject;
  }
  if (isObject(mapOrObject)) {
    return new ObjectWrappingMap(mapOrObject);
  }
  throw new Error("createMap can create maps from objects or Maps");
}
function toObject$1(map3) {
  if (map3 instanceof ObjectWrappingMap) {
    return map3.wrappedObject;
  }
  var object = {};
  for (var key of map3.keys()) {
    var value = map3.get(key);
    setSafeProperty(object, key, value);
  }
  return object;
}
function isMap$1(object) {
  if (!object) {
    return false;
  }
  return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === "function" && typeof object.get === "function" && typeof object.keys === "function" && typeof object.has === "function";
}
function assign$1(map3) {
  for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    objects[_key - 1] = arguments[_key];
  }
  for (var args of objects) {
    if (!args) {
      continue;
    }
    if (isMap$1(args)) {
      for (var key of args.keys()) {
        map3.set(key, args.get(key));
      }
    } else if (isObject(args)) {
      for (var _key2 of Object.keys(args)) {
        map3.set(_key2, args[_key2]);
      }
    }
  }
  return map3;
}
var _createTyped2 = function _createTyped() {
  _createTyped2 = typedFunction.create;
  return typedFunction;
};
var dependencies$4E = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
var createTyped = /* @__PURE__ */ factory("typed", dependencies$4E, function createTyped2(_ref) {
  var {
    BigNumber: BigNumber2,
    Complex: Complex2,
    DenseMatrix: DenseMatrix2,
    Fraction: Fraction2
  } = _ref;
  var typed2 = _createTyped2();
  typed2.clear();
  typed2.addTypes([
    {
      name: "number",
      test: isNumber
    },
    {
      name: "Complex",
      test: isComplex
    },
    {
      name: "BigNumber",
      test: isBigNumber
    },
    {
      name: "Fraction",
      test: isFraction
    },
    {
      name: "Unit",
      test: isUnit
    },
    {
      name: "identifier",
      test: (s) => isString && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])*$/.test(s)
    },
    {
      name: "string",
      test: isString
    },
    {
      name: "Chain",
      test: isChain
    },
    {
      name: "Array",
      test: isArray$1
    },
    {
      name: "Matrix",
      test: isMatrix
    },
    {
      name: "DenseMatrix",
      test: isDenseMatrix
    },
    {
      name: "SparseMatrix",
      test: isSparseMatrix
    },
    {
      name: "Range",
      test: isRange
    },
    {
      name: "Index",
      test: isIndex
    },
    {
      name: "boolean",
      test: isBoolean
    },
    {
      name: "ResultSet",
      test: isResultSet
    },
    {
      name: "Help",
      test: isHelp
    },
    {
      name: "function",
      test: isFunction
    },
    {
      name: "Date",
      test: isDate
    },
    {
      name: "RegExp",
      test: isRegExp
    },
    {
      name: "null",
      test: isNull
    },
    {
      name: "undefined",
      test: isUndefined
    },
    {
      name: "AccessorNode",
      test: isAccessorNode
    },
    {
      name: "ArrayNode",
      test: isArrayNode
    },
    {
      name: "AssignmentNode",
      test: isAssignmentNode
    },
    {
      name: "BlockNode",
      test: isBlockNode
    },
    {
      name: "ConditionalNode",
      test: isConditionalNode
    },
    {
      name: "ConstantNode",
      test: isConstantNode
    },
    {
      name: "FunctionNode",
      test: isFunctionNode
    },
    {
      name: "FunctionAssignmentNode",
      test: isFunctionAssignmentNode
    },
    {
      name: "IndexNode",
      test: isIndexNode
    },
    {
      name: "Node",
      test: isNode
    },
    {
      name: "ObjectNode",
      test: isObjectNode
    },
    {
      name: "OperatorNode",
      test: isOperatorNode
    },
    {
      name: "ParenthesisNode",
      test: isParenthesisNode
    },
    {
      name: "RangeNode",
      test: isRangeNode
    },
    {
      name: "SymbolNode",
      test: isSymbolNode
    },
    {
      name: "Map",
      test: isMap$1
    },
    {
      name: "Object",
      test: isObject
    }
  ]);
  typed2.addConversions([{
    from: "number",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber2) {
        throwNoBignumber(x);
      }
      if (digits(x) > 15) {
        throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x + "). Use function bignumber(x) to convert to BigNumber.");
      }
      return new BigNumber2(x);
    }
  }, {
    from: "number",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex2) {
        throwNoComplex(x);
      }
      return new Complex2(x, 0);
    }
  }, {
    from: "BigNumber",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex2) {
        throwNoComplex(x);
      }
      return new Complex2(x.toNumber(), 0);
    }
  }, {
    from: "Fraction",
    to: "BigNumber",
    convert: function convert(x) {
      throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
    }
  }, {
    from: "Fraction",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex2) {
        throwNoComplex(x);
      }
      return new Complex2(x.valueOf(), 0);
    }
  }, {
    from: "number",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction2) {
        throwNoFraction(x);
      }
      var f = new Fraction2(x);
      if (f.valueOf() !== x) {
        throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x + "). Use function fraction(x) to convert to Fraction.");
      }
      return f;
    }
  }, {
    from: "string",
    to: "number",
    convert: function convert(x) {
      var n = Number(x);
      if (isNaN(n)) {
        throw new Error('Cannot convert "' + x + '" to a number');
      }
      return n;
    }
  }, {
    from: "string",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber2) {
        throwNoBignumber(x);
      }
      try {
        return new BigNumber2(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to BigNumber');
      }
    }
  }, {
    from: "string",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction2) {
        throwNoFraction(x);
      }
      try {
        return new Fraction2(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to Fraction');
      }
    }
  }, {
    from: "string",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex2) {
        throwNoComplex(x);
      }
      try {
        return new Complex2(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to Complex');
      }
    }
  }, {
    from: "boolean",
    to: "number",
    convert: function convert(x) {
      return +x;
    }
  }, {
    from: "boolean",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber2) {
        throwNoBignumber(x);
      }
      return new BigNumber2(+x);
    }
  }, {
    from: "boolean",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction2) {
        throwNoFraction(x);
      }
      return new Fraction2(+x);
    }
  }, {
    from: "boolean",
    to: "string",
    convert: function convert(x) {
      return String(x);
    }
  }, {
    from: "Array",
    to: "Matrix",
    convert: function convert(array) {
      if (!DenseMatrix2) {
        throwNoMatrix();
      }
      return new DenseMatrix2(array);
    }
  }, {
    from: "Matrix",
    to: "Array",
    convert: function convert(matrix2) {
      return matrix2.valueOf();
    }
  }]);
  typed2.onMismatch = (name2, args, signatures) => {
    var usualError = typed2.createError(name2, args, signatures);
    if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection$1(args[0]) && signatures.some((sig) => !sig.params.includes(","))) {
      var err = new TypeError("Function '".concat(name2, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name2, ")'."));
      err.data = usualError.data;
      throw err;
    }
    throw usualError;
  };
  typed2.onMismatch = (name2, args, signatures) => {
    var usualError = typed2.createError(name2, args, signatures);
    if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection$1(args[0]) && signatures.some((sig) => !sig.params.includes(","))) {
      var err = new TypeError("Function '".concat(name2, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name2, ")'."));
      err.data = usualError.data;
      throw err;
    }
    throw usualError;
  };
  return typed2;
});
function throwNoBignumber(x) {
  throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
}
function throwNoComplex(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
}
function throwNoMatrix() {
  throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
}
function throwNoFraction(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
}
var name$4D = "ResultSet";
var dependencies$4D = [];
var createResultSet = /* @__PURE__ */ factory(name$4D, dependencies$4D, () => {
  function ResultSet2(entries3) {
    if (!(this instanceof ResultSet2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.entries = entries3 || [];
  }
  ResultSet2.prototype.type = "ResultSet";
  ResultSet2.prototype.isResultSet = true;
  ResultSet2.prototype.valueOf = function() {
    return this.entries;
  };
  ResultSet2.prototype.toString = function() {
    return "[" + this.entries.join(", ") + "]";
  };
  ResultSet2.prototype.toJSON = function() {
    return {
      mathjs: "ResultSet",
      entries: this.entries
    };
  };
  ResultSet2.fromJSON = function(json) {
    return new ResultSet2(json.entries);
  };
  return ResultSet2;
}, {
  isClass: true
});
var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10$1 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
  precision: 20,
  rounding: 4,
  modulo: 1,
  toExpNeg: -7,
  toExpPos: 21,
  minE: -EXP_LIMIT,
  maxE: EXP_LIMIT,
  crypto: false
}, inexact, quadrant, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10$1.length - 1, PI_PRECISION = PI.length - 1, P$1 = { toStringTag: tag };
P$1.absoluteValue = P$1.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0)
    x.s = 1;
  return finalise(x);
};
P$1.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P$1.clampedTo = P$1.clamp = function(min3, max3) {
  var k, x = this, Ctor = x.constructor;
  min3 = new Ctor(min3);
  max3 = new Ctor(max3);
  if (!min3.s || !max3.s)
    return new Ctor(NaN);
  if (min3.gt(max3))
    throw Error(invalidArgument + max3);
  k = x.cmp(min3);
  return k < 0 ? min3 : x.cmp(max3) > 0 ? max3 : new Ctor(x);
};
P$1.comparedTo = P$1.cmp = function(y) {
  var i2, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x.e !== y.e)
    return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i2 = 0, j = xdL < ydL ? xdL : ydL; i2 < j; ++i2) {
    if (xd[i2] !== yd[i2])
      return xd[i2] > yd[i2] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P$1.cosine = P$1.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d)
    return new Ctor(NaN);
  if (!x.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P$1.cubeRoot = P$1.cbrt = function() {
  var e2, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e2 = x.e;
    if (s = (e2 - n.length + 1) % 3)
      n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e2 = mathfloor((e2 + 1) / 3) - (e2 % 3 == (e2 < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e2;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e2;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e2 = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide$1(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e2 + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e2 + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e2, Ctor.rounding, m);
};
P$1.decimalPlaces = P$1.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w)
      for (; w % 10 == 0; w /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P$1.dividedBy = P$1.div = function(y) {
  return divide$1(this, new this.constructor(y));
};
P$1.dividedToIntegerBy = P$1.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide$1(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P$1.equals = P$1.eq = function(y) {
  return this.cmp(y) === 0;
};
P$1.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P$1.greaterThan = P$1.gt = function(y) {
  return this.cmp(y) > 0;
};
P$1.greaterThanOrEqualTo = P$1.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P$1.hyperbolicCosine = P$1.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite())
    return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero())
    return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i2 = k, d8 = new Ctor(8);
  for (; i2--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P$1.hyperbolicSine = P$1.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P$1.hyperbolicTangent = P$1.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(x.s);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide$1(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P$1.inverseCosine = P$1.acos = function() {
  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return halfPi.minus(x);
};
P$1.inverseHyperbolicCosine = P$1.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1))
    return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P$1.inverseHyperbolicSine = P$1.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P$1.inverseHyperbolicTangent = P$1.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.e >= 0)
    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1)
    return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide$1(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P$1.inverseSine = P$1.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero())
    return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P$1.inverseTangent = P$1.atan = function() {
  var i2, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i2 = k; i2; --i2)
    x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (; i2 !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== void 0)
      for (i2 = j; r.d[i2] === t.d[i2] && i2--; )
        ;
  }
  if (k)
    r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P$1.isFinite = function() {
  return !!this.d;
};
P$1.isInteger = P$1.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P$1.isNaN = function() {
  return !this.s;
};
P$1.isNegative = P$1.isNeg = function() {
  return this.s < 0;
};
P$1.isPositive = P$1.isPos = function() {
  return this.s > 0;
};
P$1.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P$1.lessThan = P$1.lt = function(y) {
  return this.cmp(y) < 0;
};
P$1.lessThanOrEqualTo = P$1.lte = function(y) {
  return this.cmp(y) < 1;
};
P$1.logarithm = P$1.log = function(base2) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg2 = this, Ctor = arg2.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base2 == null) {
    base2 = new Ctor(10);
    isBase10 = true;
  } else {
    base2 = new Ctor(base2);
    d = base2.d;
    if (base2.s < 0 || !d || !d[0] || base2.eq(1))
      return new Ctor(NaN);
    isBase10 = base2.eq(10);
  }
  d = arg2.d;
  if (arg2.s < 0 || !d || !d[0] || arg2.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg2.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0; )
        k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg2, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base2, sd);
  r = divide$1(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg2, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base2, sd);
      r = divide$1(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P$1.minus = P$1.sub = function(y) {
  var d, e2, i2, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (x.d)
      y.s = -y.s;
    else
      y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y.s = -y.s;
    else if (xd[0])
      y = new Ctor(x);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e2 = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e2;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e2 = xe;
      len = xd.length;
    }
    i2 = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i2) {
      k = i2;
      d.length = 1;
    }
    d.reverse();
    for (i2 = k; i2--; )
      d.push(0);
    d.reverse();
  } else {
    i2 = xd.length;
    len = yd.length;
    xLTy = i2 < len;
    if (xLTy)
      len = i2;
    for (i2 = 0; i2 < len; i2++) {
      if (xd[i2] != yd[i2]) {
        xLTy = xd[i2] < yd[i2];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i2 = yd.length - len; i2 > 0; --i2)
    xd[len++] = 0;
  for (i2 = yd.length; i2 > k; ) {
    if (xd[--i2] < yd[i2]) {
      for (j = i2; j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i2] += BASE;
    }
    xd[i2] -= yd[i2];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e2;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e2);
  return external ? finalise(y, pr, rm) : y;
};
P$1.modulo = P$1.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0])
    return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide$1(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide$1(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P$1.naturalExponential = P$1.exp = function() {
  return naturalExponential(this);
};
P$1.naturalLogarithm = P$1.ln = function() {
  return naturalLogarithm(this);
};
P$1.negated = P$1.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P$1.plus = P$1.add = function(y) {
  var carry, d, e2, i2, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (!x.d)
      y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor(x.e / LOG_BASE);
  e2 = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i2 = k - e2;
  if (i2) {
    if (i2 < 0) {
      d = xd;
      i2 = -i2;
      len = yd.length;
    } else {
      d = yd;
      e2 = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i2 > len) {
      i2 = len;
      d.length = 1;
    }
    d.reverse();
    for (; i2--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i2 = yd.length;
  if (len - i2 < 0) {
    i2 = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i2; ) {
    carry = (xd[--i2] = xd[i2] + yd[i2] + carry) / BASE | 0;
    xd[i2] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e2;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e2);
  return external ? finalise(y, pr, rm) : y;
};
P$1.precision = P$1.sd = function(z) {
  var k, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
    throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k)
      k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P$1.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P$1.sine = P$1.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P$1.squareRoot = P$1.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e2 = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e2) % 2 == 0)
      n += "0";
    s = Math.sqrt(n);
    e2 = mathfloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
    if (s == 1 / 0) {
      n = "5e" + e2;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e2;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e2 = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide$1(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e2 + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e2 + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e2, Ctor.rounding, m);
};
P$1.tangent = P$1.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide$1(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P$1.times = P$1.mul = function(y) {
  var carry, e2, i2, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e2 = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i2 = rL; i2--; )
    r.push(0);
  for (i2 = ydL; --i2 >= 0; ) {
    carry = 0;
    for (k = xdL + i2; k > i2; ) {
      t = r[k] + yd[i2] * xd[k - i2 - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (; !r[--rL]; )
    r.pop();
  if (carry)
    ++e2;
  else
    r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e2);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P$1.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P$1.toDecimalPlaces = P$1.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P$1.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P$1.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P$1.toFraction = function(maxD) {
  var d, d0, d1, d2, e2, k, n, n0, n12, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd)
    return new Ctor(x);
  n12 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e2 = d.e = getPrecision(xd) - x.e - 1;
  k = e2 % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e2 > 0 ? d : n12;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n12))
      throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e2 > 0 ? d : n12 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e2 = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q = divide$1(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d2;
    d2 = n12;
    n12 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide$1(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n12));
  d0 = d0.plus(d2.times(d1));
  n0.s = n12.s = x.s;
  r = divide$1(n12, d1, e2, 1).minus(x).abs().cmp(divide$1(n0, d0, e2, 1).minus(x).abs()) < 1 ? [n12, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P$1.toHexadecimal = P$1.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P$1.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d)
      return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d)
      return y.s ? x : y;
    if (!y.d) {
      if (y.s)
        y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide$1(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P$1.toNumber = function() {
  return +this;
};
P$1.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P$1.toPower = P$1.pow = function(y) {
  var e2, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0])
    return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1))
    return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1))
    return finalise(x, pr, rm);
  e2 = mathfloor(y.e / LOG_BASE);
  if (e2 >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e2 < y.d.length - 1)
      return new Ctor(NaN);
    if ((y.d[e2] & 1) == 0)
      s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e2 = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e2 > Ctor.maxE + 1 || e2 < Ctor.minE - 1)
    return new Ctor(e2 > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e2 + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e2 = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e2 + k)), e2), e2 + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P$1.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P$1.toSignificantDigits = P$1.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P$1.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P$1.truncated = P$1.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P$1.valueOf = P$1.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
function digitsToString(d) {
  var i2, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i2 = 1; i2 < indexOfLastWord; i2++) {
      ws = d[i2] + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w = d[i2];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; )
    w /= 10;
  return str + w;
}
function checkInt32(i2, min3, max3) {
  if (i2 !== ~~i2 || i2 < min3 || i2 > max3) {
    throw Error(invalidArgument + i2);
  }
}
function checkRoundingDigits(d, i2, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0]; k >= 10; k /= 10)
    --i2;
  if (--i2 < 0) {
    i2 += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i2 + 1) / LOG_BASE);
    i2 %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i2);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i2 < 3) {
      if (i2 == 0)
        rd = rd / 100 | 0;
      else if (i2 == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i2 - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i2 < 4) {
      if (i2 == 0)
        rd = rd / 1e3 | 0;
      else if (i2 == 1)
        rd = rd / 100 | 0;
      else if (i2 == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i2 - 3) - 1;
    }
  }
  return r;
}
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i2 = 0, strL = str.length;
  for (; i2 < strL; ) {
    for (arrL = arr.length; arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i2++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, len, y;
  if (x.isZero())
    return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i2 = k; i2--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
var divide$1 = function() {
  function multiplyInteger(x, k, base2) {
    var temp, carry = 0, i2 = x.length;
    for (x = x.slice(); i2--; ) {
      temp = x[i2] * k + carry;
      x[i2] = temp % base2 | 0;
      carry = temp / base2 | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  function compare2(a, b, aL, bL) {
    var i2, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i2 = r = 0; i2 < aL; i2++) {
        if (a[i2] != b[i2]) {
          r = a[i2] > b[i2] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract2(a, b, aL, base2) {
    var i2 = 0;
    for (; aL--; ) {
      a[aL] -= i2;
      i2 = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i2 * base2 + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; )
      a.shift();
  }
  return function(x, y, pr, rm, dp, base2) {
    var cmp, e2, i2, k, logBase, more, prod2, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
      );
    }
    if (base2) {
      logBase = 1;
      e2 = x.e - y.e;
    } else {
      base2 = BASE;
      logBase = LOG_BASE;
      e2 = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign2);
    qd = q.d = [];
    for (i2 = 0; yd[i2] == (xd[i2] || 0); i2++)
      ;
    if (yd[i2] > (xd[i2] || 0))
      e2--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i2 = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (; (i2 < xL || k) && sd--; i2++) {
          t = k * base2 + (xd[i2] || 0);
          qd[i2] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i2 < xL;
      } else {
        k = base2 / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base2);
          xd = multiplyInteger(xd, k, base2);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base2 / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare2(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base2 + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base2)
                k = base2 - 1;
              prod2 = multiplyInteger(yd, k, base2);
              prodL = prod2.length;
              remL = rem.length;
              cmp = compare2(prod2, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract2(prod2, yL < prodL ? yz : yd, prodL, base2);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod2 = yd.slice();
            }
            prodL = prod2.length;
            if (prodL < remL)
              prod2.unshift(0);
            subtract2(rem, prod2, remL, base2);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare2(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract2(rem, yL < remL ? yz : yd, remL, base2);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i2++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e2;
      inexact = more;
    } else {
      for (i2 = 1, k = qd[0]; k >= 10; k /= 10)
        i2++;
      q.e = i2 + e2 * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x, sd, rm, isTruncated) {
  var digits2, i2, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out:
    if (sd != null) {
      xd = x.d;
      if (!xd)
        return x;
      for (digits2 = 1, k = xd[0]; k >= 10; k /= 10)
        digits2++;
      i2 = sd - digits2;
      if (i2 < 0) {
        i2 += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits2 - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i2 + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (; k++ <= xdi; )
              xd.push(0);
            w = rd = 0;
            digits2 = 1;
            i2 %= LOG_BASE;
            j = i2 - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];
          for (digits2 = 1; k >= 10; k /= 10)
            digits2++;
          i2 %= LOG_BASE;
          j = i2 - LOG_BASE + digits2;
          rd = j < 0 ? 0 : w / mathpow(10, digits2 - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits2 - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i2 > 0 ? j > 0 ? w / mathpow(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i2 == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i2);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits2 - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (; ; ) {
          if (xdi == 0) {
            for (i2 = 1, j = xd[0]; j >= 10; j /= 10)
              i2++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10)
              k++;
            if (i2 != k) {
              x.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i2 = xd.length; xd[--i2] === 0; )
        xd.pop();
    }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite())
    return nonFiniteToString(x);
  var k, e2 = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e2 < 0) {
    str = "0." + getZeroString(-e2 - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e2 >= len) {
    str += getZeroString(e2 + 1 - len);
    if (sd && (k = sd - e2 - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e2 + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e2 + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return str;
}
function getBase10Exponent(digits2, e2) {
  var w = digits2[0];
  for (e2 *= LOG_BASE; w >= 10; w /= 10)
    e2++;
  return e2;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10$1), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits2) {
  var w = digits2.length - 1, len = w * LOG_BASE + 1;
  w = digits2[w];
  if (w) {
    for (; w % 10 == 0; w /= 10)
      len--;
    for (w = digits2[0]; w >= 10; w /= 10)
      len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (; k--; )
    zs += "0";
  return zs;
}
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k))
        isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, ltgt) {
  var y, x = new Ctor(args[0]), i2 = 0;
  for (; ++i2 < args.length; ) {
    y = new Ctor(args[i2]);
    if (!y.s) {
      x = y;
      break;
    } else if (x[ltgt](y)) {
      x = y;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i2 = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum2 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = finalise(pow2.times(x), wpr, 1);
    denominator = denominator.times(++i2);
    t = sum2.plus(divide$1(pow2, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j = k;
      while (j--)
        sum2 = finalise(sum2.times(sum2), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow2 = t = new Ctor(1);
          i2 = 0;
          rep++;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
  }
}
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e2, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e2 = x.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e2 = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e2++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e2 + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum2 = numerator = x = divide$1(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum2.plus(divide$1(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e2 !== 0)
        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e2 + ""));
      sum2 = divide$1(sum2, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide$1(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str) {
  var e2, i2, len;
  if ((e2 = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i2 = str.search(/e/i)) > 0) {
    if (e2 < 0)
      e2 = i2;
    e2 += +str.slice(i2 + 1);
    str = str.substring(0, i2);
  } else if (e2 < 0) {
    e2 = str.length;
  }
  for (i2 = 0; str.charCodeAt(i2) === 48; i2++)
    ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i2, len);
  if (str) {
    len -= i2;
    x.e = e2 = e2 - i2 - 1;
    x.d = [];
    i2 = (e2 + 1) % LOG_BASE;
    if (e2 < 0)
      i2 += LOG_BASE;
    if (i2 < len) {
      if (i2)
        x.d.push(+str.slice(0, i2));
      for (len -= LOG_BASE; i2 < len; )
        x.d.push(+str.slice(i2, i2 += LOG_BASE));
      str = str.slice(i2);
      i2 = LOG_BASE - str.length;
    } else {
      i2 -= len;
    }
    for (; i2--; )
      str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str) {
  var base2, Ctor, divisor, i2, isFloat, len, p2, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str))
      return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base2 = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base2 = 2;
  } else if (isOctal.test(str)) {
    base2 = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i2 = str.search(/p/i);
  if (i2 > 0) {
    p2 = +str.slice(i2 + 1);
    str = str.substring(2, i2);
  } else {
    str = str.slice(2);
  }
  i2 = str.indexOf(".");
  isFloat = i2 >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i2 = len - i2;
    divisor = intPow(Ctor, new Ctor(base2), i2, i2 * 2);
  }
  xd = convertBase(str, base2, BASE);
  xe = xd.length - 1;
  for (i2 = xe; xd[i2] === 0; --i2)
    xd.pop();
  if (i2 < 0)
    return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat)
    x = divide$1(x, divisor, len * 4);
  if (p2)
    x = x.times(Math.abs(p2) < 54 ? mathpow(2, p2) : Decimal.pow(2, p2));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (; ; ) {
    t = divide$1(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide$1(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
function tinyPow(b, e2) {
  var n = b;
  while (--e2)
    n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg2 = x.s < 0, pi2 = getPi(Ctor, Ctor.precision, 1), halfPi = pi2.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg2 ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi2);
  if (t.isZero()) {
    quadrant = isNeg2 ? 3 : 2;
  } else {
    x = x.minus(t.times(pi2));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg2 ? 2 : 3 : isNeg2 ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg2 ? 1 : 4 : isNeg2 ? 3 : 2;
  }
  return x.minus(pi2).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base2, e2, i2, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i2 = str.indexOf(".");
    if (isExp) {
      base2 = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base2 = baseOut;
    }
    if (i2 >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i2;
      y.d = convertBase(finiteToString(y), 10, base2);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base2);
    e2 = len = xd.length;
    for (; xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i2 < 0) {
        e2--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e2;
        x = divide$1(x, y, sd, rm, 0, base2);
        xd = x.d;
        e2 = x.e;
        roundUp = inexact;
      }
      i2 = xd[sd];
      k = base2 / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i2 !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i2 > k || i2 === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base2 - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e2;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len)
        ;
      for (i2 = 0, str = ""; i2 < len; i2++)
        str += NUMERALS.charAt(xd[i2]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i2 = baseOut == 16 ? 4 : 3;
            for (--len; len % i2; len++)
              str += "0";
            xd = convertBase(str, base2, baseOut);
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i2 = 1, str = "1."; i2 < len; i2++)
              str += NUMERALS.charAt(xd[i2]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e2 < 0 ? "p" : "p+") + e2;
      } else if (e2 < 0) {
        for (; ++e2; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e2 > len)
          for (e2 -= len; e2--; )
            str += "0";
        else if (e2 < len)
          str = str.slice(0, e2) + "." + str.slice(e2);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs$1(x) {
  return new this(x).abs();
}
function acos$1(x) {
  return new this(x).acos();
}
function acosh$1(x) {
  return new this(x).acosh();
}
function add$1(x, y) {
  return new this(x).plus(y);
}
function asin$1(x) {
  return new this(x).asin();
}
function asinh$1(x) {
  return new this(x).asinh();
}
function atan$1(x) {
  return new this(x).atan();
}
function atanh$1(x) {
  return new this(x).atanh();
}
function atan2$1(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide$1(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide$1(y, x, wpr, 1));
  }
  return r;
}
function cbrt$1(x) {
  return new this(x).cbrt();
}
function ceil$1(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function clamp(x, min3, max3) {
  return new this(x).clamp(min3, max3);
}
function config2(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i2, p2, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i2 = 0; i2 < ps.length; i2 += 3) {
    if (p2 = ps[i2], useDefaults)
      this[p2] = DEFAULTS[p2];
    if ((v = obj[p2]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i2 + 1] && v <= ps[i2 + 2])
        this[p2] = v;
      else
        throw Error(invalidArgument + p2 + ": " + v);
    }
  }
  if (p2 = "crypto", useDefaults)
    this[p2] = DEFAULTS[p2];
  if ((v = obj[p2]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p2] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p2] = false;
      }
    } else {
      throw Error(invalidArgument + p2 + ": " + v);
    }
  }
  return this;
}
function cos$1(x) {
  return new this(x).cos();
}
function cosh$1(x) {
  return new this(x).cosh();
}
function clone$1(obj) {
  var i2, p2, ps;
  function Decimal2(v) {
    var e2, i3, t, x = this;
    if (!(x instanceof Decimal2))
      return new Decimal2(v);
    x.constructor = Decimal2;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal2.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal2.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e2 = 0, i3 = v; i3 >= 10; i3 /= 10)
          e2++;
        if (external) {
          if (e2 > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e2 < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e2;
            x.d = [v];
          }
        } else {
          x.e = e2;
          x.d = [v];
        }
        return;
      } else if (v * 0 !== 0) {
        if (!v)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    } else if (t !== "string") {
      throw Error(invalidArgument + v);
    }
    if ((i3 = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      if (i3 === 43)
        v = v.slice(1);
      x.s = 1;
    }
    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }
  Decimal2.prototype = P$1;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config2;
  Decimal2.clone = clone$1;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs$1;
  Decimal2.acos = acos$1;
  Decimal2.acosh = acosh$1;
  Decimal2.add = add$1;
  Decimal2.asin = asin$1;
  Decimal2.asinh = asinh$1;
  Decimal2.atan = atan$1;
  Decimal2.atanh = atanh$1;
  Decimal2.atan2 = atan2$1;
  Decimal2.cbrt = cbrt$1;
  Decimal2.ceil = ceil$1;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos$1;
  Decimal2.cosh = cosh$1;
  Decimal2.div = div;
  Decimal2.exp = exp$1;
  Decimal2.floor = floor$1;
  Decimal2.hypot = hypot$1;
  Decimal2.ln = ln;
  Decimal2.log = log$1;
  Decimal2.log10 = log10$1;
  Decimal2.log2 = log2$1;
  Decimal2.max = max$1;
  Decimal2.min = min$1;
  Decimal2.mod = mod$1;
  Decimal2.mul = mul;
  Decimal2.pow = pow$1;
  Decimal2.random = random$1;
  Decimal2.round = round$1;
  Decimal2.sign = sign$1;
  Decimal2.sin = sin$1;
  Decimal2.sinh = sinh$1;
  Decimal2.sqrt = sqrt$1;
  Decimal2.sub = sub;
  Decimal2.sum = sum$1;
  Decimal2.tan = tan$1;
  Decimal2.tanh = tanh$1;
  Decimal2.trunc = trunc;
  if (obj === void 0)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i2 = 0; i2 < ps.length; )
        if (!obj.hasOwnProperty(p2 = ps[i2++]))
          obj[p2] = this[p2];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
function div(x, y) {
  return new this(x).div(y);
}
function exp$1(x) {
  return new this(x).exp();
}
function floor$1(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot$1() {
  var i2, n, t = new this(0);
  external = false;
  for (i2 = 0; i2 < arguments.length; ) {
    n = new this(arguments[i2++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x) {
  return new this(x).ln();
}
function log$1(x, y) {
  return new this(x).log(y);
}
function log2$1(x) {
  return new this(x).log(2);
}
function log10$1(x) {
  return new this(x).log(10);
}
function max$1() {
  return maxOrMin(this, arguments, "lt");
}
function min$1() {
  return maxOrMin(this, arguments, "gt");
}
function mod$1(x, y) {
  return new this(x).mod(y);
}
function mul(x, y) {
  return new this(x).mul(y);
}
function pow$1(x, y) {
  return new this(x).pow(y);
}
function random$1(sd) {
  var d, e2, k, n, i2 = 0, r = new this(1), rd = [];
  if (sd === void 0)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i2 < k; )
      rd[i2++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (; i2 < k; ) {
      n = d[i2];
      if (n >= 429e7) {
        d[i2] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i2++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (; i2 < k; ) {
      n = d[i2] + (d[i2 + 1] << 8) + (d[i2 + 2] << 16) + ((d[i2 + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i2);
      } else {
        rd.push(n % 1e7);
        i2 += 4;
      }
    }
    i2 = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i2];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i2] = (k / n | 0) * n;
  }
  for (; rd[i2] === 0; i2--)
    rd.pop();
  if (i2 < 0) {
    e2 = 0;
    rd = [0];
  } else {
    e2 = -1;
    for (; rd[0] === 0; e2 -= LOG_BASE)
      rd.shift();
    for (k = 1, n = rd[0]; n >= 10; n /= 10)
      k++;
    if (k < LOG_BASE)
      e2 -= LOG_BASE - k;
  }
  r.e = e2;
  r.d = rd;
  return r;
}
function round$1(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign$1(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin$1(x) {
  return new this(x).sin();
}
function sinh$1(x) {
  return new this(x).sinh();
}
function sqrt$1(x) {
  return new this(x).sqrt();
}
function sub(x, y) {
  return new this(x).sub(y);
}
function sum$1() {
  var i2 = 0, args = arguments, x = new this(args[i2]);
  external = false;
  for (; x.s && ++i2 < args.length; )
    x = x.plus(args[i2]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
function tan$1(x) {
  return new this(x).tan();
}
function tanh$1(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
P$1[Symbol.for("nodejs.util.inspect.custom")] = P$1.toString;
P$1[Symbol.toStringTag] = "Decimal";
var Decimal = P$1.constructor = clone$1(DEFAULTS);
LN10$1 = new Decimal(LN10$1);
PI = new Decimal(PI);
var name$4C = "BigNumber";
var dependencies$4C = ["?on", "config"];
var createBigNumberClass = /* @__PURE__ */ factory(name$4C, dependencies$4C, (_ref) => {
  var {
    on: on2,
    config: config3
  } = _ref;
  var BigNumber2 = Decimal.clone({
    precision: config3.precision,
    modulo: Decimal.EUCLID
  });
  BigNumber2.prototype = Object.create(BigNumber2.prototype);
  BigNumber2.prototype.type = "BigNumber";
  BigNumber2.prototype.isBigNumber = true;
  BigNumber2.prototype.toJSON = function() {
    return {
      mathjs: "BigNumber",
      value: this.toString()
    };
  };
  BigNumber2.fromJSON = function(json) {
    return new BigNumber2(json.value);
  };
  if (on2) {
    on2("config", function(curr, prev) {
      if (curr.precision !== prev.precision) {
        BigNumber2.config({
          precision: curr.precision
        });
      }
    });
  }
  return BigNumber2;
}, {
  isClass: true
});
var complex$1 = { exports: {} };
/**
 * @license Complex.js v2.1.1 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
(function(module, exports) {
  (function(root) {
    var cosh2 = Math.cosh || function(x) {
      return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
    };
    var sinh2 = Math.sinh || function(x) {
      return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
    };
    var cosm1 = function(x) {
      var b = Math.PI / 4;
      if (-b > x || x > b) {
        return Math.cos(x) - 1;
      }
      var xx = x * x;
      return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
    };
    var hypot2 = function(x, y) {
      var a = Math.abs(x);
      var b = Math.abs(y);
      if (a < 3e3 && b < 3e3) {
        return Math.sqrt(a * a + b * b);
      }
      if (a < b) {
        a = b;
        b = x / y;
      } else {
        b = y / x;
      }
      return a * Math.sqrt(1 + b * b);
    };
    var parser_exit = function() {
      throw SyntaxError("Invalid Param");
    };
    function logHypot(a, b) {
      var _a = Math.abs(a);
      var _b = Math.abs(b);
      if (a === 0) {
        return Math.log(_b);
      }
      if (b === 0) {
        return Math.log(_a);
      }
      if (_a < 3e3 && _b < 3e3) {
        return Math.log(a * a + b * b) * 0.5;
      }
      a = a / 2;
      b = b / 2;
      return 0.5 * Math.log(a * a + b * b) + Math.LN2;
    }
    var parse2 = function(a, b) {
      var z = { "re": 0, "im": 0 };
      if (a === void 0 || a === null) {
        z["re"] = z["im"] = 0;
      } else if (b !== void 0) {
        z["re"] = a;
        z["im"] = b;
      } else
        switch (typeof a) {
          case "object":
            if ("im" in a && "re" in a) {
              z["re"] = a["re"];
              z["im"] = a["im"];
            } else if ("abs" in a && "arg" in a) {
              if (!Number.isFinite(a["abs"]) && Number.isFinite(a["arg"])) {
                return Complex2["INFINITY"];
              }
              z["re"] = a["abs"] * Math.cos(a["arg"]);
              z["im"] = a["abs"] * Math.sin(a["arg"]);
            } else if ("r" in a && "phi" in a) {
              if (!Number.isFinite(a["r"]) && Number.isFinite(a["phi"])) {
                return Complex2["INFINITY"];
              }
              z["re"] = a["r"] * Math.cos(a["phi"]);
              z["im"] = a["r"] * Math.sin(a["phi"]);
            } else if (a.length === 2) {
              z["re"] = a[0];
              z["im"] = a[1];
            } else {
              parser_exit();
            }
            break;
          case "string":
            z["im"] = z["re"] = 0;
            var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
            var plus = 1;
            var minus = 0;
            if (tokens === null) {
              parser_exit();
            }
            for (var i2 = 0; i2 < tokens.length; i2++) {
              var c = tokens[i2];
              if (c === " " || c === "	" || c === "\n")
                ;
              else if (c === "+") {
                plus++;
              } else if (c === "-") {
                minus++;
              } else if (c === "i" || c === "I") {
                if (plus + minus === 0) {
                  parser_exit();
                }
                if (tokens[i2 + 1] !== " " && !isNaN(tokens[i2 + 1])) {
                  z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i2 + 1]);
                  i2++;
                } else {
                  z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                }
                plus = minus = 0;
              } else {
                if (plus + minus === 0 || isNaN(c)) {
                  parser_exit();
                }
                if (tokens[i2 + 1] === "i" || tokens[i2 + 1] === "I") {
                  z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
                  i2++;
                } else {
                  z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
                }
                plus = minus = 0;
              }
            }
            if (plus + minus > 0) {
              parser_exit();
            }
            break;
          case "number":
            z["im"] = 0;
            z["re"] = a;
            break;
          default:
            parser_exit();
        }
      if (isNaN(z["re"]) || isNaN(z["im"]))
        ;
      return z;
    };
    function Complex2(a, b) {
      if (!(this instanceof Complex2)) {
        return new Complex2(a, b);
      }
      var z = parse2(a, b);
      this["re"] = z["re"];
      this["im"] = z["im"];
    }
    Complex2.prototype = {
      "re": 0,
      "im": 0,
      "sign": function() {
        var abs2 = this["abs"]();
        return new Complex2(
          this["re"] / abs2,
          this["im"] / abs2
        );
      },
      "add": function(a, b) {
        var z = new Complex2(a, b);
        if (this["isInfinite"]() && z["isInfinite"]()) {
          return Complex2["NAN"];
        }
        if (this["isInfinite"]() || z["isInfinite"]()) {
          return Complex2["INFINITY"];
        }
        return new Complex2(
          this["re"] + z["re"],
          this["im"] + z["im"]
        );
      },
      "sub": function(a, b) {
        var z = new Complex2(a, b);
        if (this["isInfinite"]() && z["isInfinite"]()) {
          return Complex2["NAN"];
        }
        if (this["isInfinite"]() || z["isInfinite"]()) {
          return Complex2["INFINITY"];
        }
        return new Complex2(
          this["re"] - z["re"],
          this["im"] - z["im"]
        );
      },
      "mul": function(a, b) {
        var z = new Complex2(a, b);
        if (this["isInfinite"]() && z["isZero"]() || this["isZero"]() && z["isInfinite"]()) {
          return Complex2["NAN"];
        }
        if (this["isInfinite"]() || z["isInfinite"]()) {
          return Complex2["INFINITY"];
        }
        if (z["im"] === 0 && this["im"] === 0) {
          return new Complex2(this["re"] * z["re"], 0);
        }
        return new Complex2(
          this["re"] * z["re"] - this["im"] * z["im"],
          this["re"] * z["im"] + this["im"] * z["re"]
        );
      },
      "div": function(a, b) {
        var z = new Complex2(a, b);
        if (this["isZero"]() && z["isZero"]() || this["isInfinite"]() && z["isInfinite"]()) {
          return Complex2["NAN"];
        }
        if (this["isInfinite"]() || z["isZero"]()) {
          return Complex2["INFINITY"];
        }
        if (this["isZero"]() || z["isInfinite"]()) {
          return Complex2["ZERO"];
        }
        a = this["re"];
        b = this["im"];
        var c = z["re"];
        var d = z["im"];
        var t, x;
        if (0 === d) {
          return new Complex2(a / c, b / c);
        }
        if (Math.abs(c) < Math.abs(d)) {
          x = c / d;
          t = c * x + d;
          return new Complex2(
            (a * x + b) / t,
            (b * x - a) / t
          );
        } else {
          x = d / c;
          t = d * x + c;
          return new Complex2(
            (a + b * x) / t,
            (b - a * x) / t
          );
        }
      },
      "pow": function(a, b) {
        var z = new Complex2(a, b);
        a = this["re"];
        b = this["im"];
        if (z["isZero"]()) {
          return Complex2["ONE"];
        }
        if (z["im"] === 0) {
          if (b === 0 && a > 0) {
            return new Complex2(Math.pow(a, z["re"]), 0);
          } else if (a === 0) {
            switch ((z["re"] % 4 + 4) % 4) {
              case 0:
                return new Complex2(Math.pow(b, z["re"]), 0);
              case 1:
                return new Complex2(0, Math.pow(b, z["re"]));
              case 2:
                return new Complex2(-Math.pow(b, z["re"]), 0);
              case 3:
                return new Complex2(0, -Math.pow(b, z["re"]));
            }
          }
        }
        if (a === 0 && b === 0 && z["re"] > 0 && z["im"] >= 0) {
          return Complex2["ZERO"];
        }
        var arg2 = Math.atan2(b, a);
        var loh = logHypot(a, b);
        a = Math.exp(z["re"] * loh - z["im"] * arg2);
        b = z["im"] * loh + z["re"] * arg2;
        return new Complex2(
          a * Math.cos(b),
          a * Math.sin(b)
        );
      },
      "sqrt": function() {
        var a = this["re"];
        var b = this["im"];
        var r = this["abs"]();
        var re2, im2;
        if (a >= 0) {
          if (b === 0) {
            return new Complex2(Math.sqrt(a), 0);
          }
          re2 = 0.5 * Math.sqrt(2 * (r + a));
        } else {
          re2 = Math.abs(b) / Math.sqrt(2 * (r - a));
        }
        if (a <= 0) {
          im2 = 0.5 * Math.sqrt(2 * (r - a));
        } else {
          im2 = Math.abs(b) / Math.sqrt(2 * (r + a));
        }
        return new Complex2(re2, b < 0 ? -im2 : im2);
      },
      "exp": function() {
        var tmp = Math.exp(this["re"]);
        if (this["im"] === 0)
          ;
        return new Complex2(
          tmp * Math.cos(this["im"]),
          tmp * Math.sin(this["im"])
        );
      },
      "expm1": function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex2(
          Math.expm1(a) * Math.cos(b) + cosm1(b),
          Math.exp(a) * Math.sin(b)
        );
      },
      "log": function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex2(
          logHypot(a, b),
          Math.atan2(b, a)
        );
      },
      "abs": function() {
        return hypot2(this["re"], this["im"]);
      },
      "arg": function() {
        return Math.atan2(this["im"], this["re"]);
      },
      "sin": function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex2(
          Math.sin(a) * cosh2(b),
          Math.cos(a) * sinh2(b)
        );
      },
      "cos": function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex2(
          Math.cos(a) * cosh2(b),
          -Math.sin(a) * sinh2(b)
        );
      },
      "tan": function() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = Math.cos(a) + cosh2(b);
        return new Complex2(
          Math.sin(a) / d,
          sinh2(b) / d
        );
      },
      "cot": function() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = Math.cos(a) - cosh2(b);
        return new Complex2(
          -Math.sin(a) / d,
          sinh2(b) / d
        );
      },
      "sec": function() {
        var a = this["re"];
        var b = this["im"];
        var d = 0.5 * cosh2(2 * b) + 0.5 * Math.cos(2 * a);
        return new Complex2(
          Math.cos(a) * cosh2(b) / d,
          Math.sin(a) * sinh2(b) / d
        );
      },
      "csc": function() {
        var a = this["re"];
        var b = this["im"];
        var d = 0.5 * cosh2(2 * b) - 0.5 * Math.cos(2 * a);
        return new Complex2(
          Math.sin(a) * cosh2(b) / d,
          -Math.cos(a) * sinh2(b) / d
        );
      },
      "asin": function() {
        var a = this["re"];
        var b = this["im"];
        var t1 = new Complex2(
          b * b - a * a + 1,
          -2 * a * b
        )["sqrt"]();
        var t2 = new Complex2(
          t1["re"] - b,
          t1["im"] + a
        )["log"]();
        return new Complex2(t2["im"], -t2["re"]);
      },
      "acos": function() {
        var a = this["re"];
        var b = this["im"];
        var t1 = new Complex2(
          b * b - a * a + 1,
          -2 * a * b
        )["sqrt"]();
        var t2 = new Complex2(
          t1["re"] - b,
          t1["im"] + a
        )["log"]();
        return new Complex2(Math.PI / 2 - t2["im"], t2["re"]);
      },
      "atan": function() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0) {
          if (b === 1) {
            return new Complex2(0, Infinity);
          }
          if (b === -1) {
            return new Complex2(0, -Infinity);
          }
        }
        var d = a * a + (1 - b) * (1 - b);
        var t1 = new Complex2(
          (1 - b * b - a * a) / d,
          -2 * a / d
        ).log();
        return new Complex2(-0.5 * t1["im"], 0.5 * t1["re"]);
      },
      "acot": function() {
        var a = this["re"];
        var b = this["im"];
        if (b === 0) {
          return new Complex2(Math.atan2(1, a), 0);
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex2(
          a / d,
          -b / d
        ).atan() : new Complex2(
          a !== 0 ? a / 0 : 0,
          b !== 0 ? -b / 0 : 0
        ).atan();
      },
      "asec": function() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0 && b === 0) {
          return new Complex2(0, Infinity);
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex2(
          a / d,
          -b / d
        ).acos() : new Complex2(
          a !== 0 ? a / 0 : 0,
          b !== 0 ? -b / 0 : 0
        ).acos();
      },
      "acsc": function() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0 && b === 0) {
          return new Complex2(Math.PI / 2, Infinity);
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex2(
          a / d,
          -b / d
        ).asin() : new Complex2(
          a !== 0 ? a / 0 : 0,
          b !== 0 ? -b / 0 : 0
        ).asin();
      },
      "sinh": function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex2(
          sinh2(a) * Math.cos(b),
          cosh2(a) * Math.sin(b)
        );
      },
      "cosh": function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex2(
          cosh2(a) * Math.cos(b),
          sinh2(a) * Math.sin(b)
        );
      },
      "tanh": function() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = cosh2(a) + Math.cos(b);
        return new Complex2(
          sinh2(a) / d,
          Math.sin(b) / d
        );
      },
      "coth": function() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = cosh2(a) - Math.cos(b);
        return new Complex2(
          sinh2(a) / d,
          -Math.sin(b) / d
        );
      },
      "csch": function() {
        var a = this["re"];
        var b = this["im"];
        var d = Math.cos(2 * b) - cosh2(2 * a);
        return new Complex2(
          -2 * sinh2(a) * Math.cos(b) / d,
          2 * cosh2(a) * Math.sin(b) / d
        );
      },
      "sech": function() {
        var a = this["re"];
        var b = this["im"];
        var d = Math.cos(2 * b) + cosh2(2 * a);
        return new Complex2(
          2 * cosh2(a) * Math.cos(b) / d,
          -2 * sinh2(a) * Math.sin(b) / d
        );
      },
      "asinh": function() {
        var tmp = this["im"];
        this["im"] = -this["re"];
        this["re"] = tmp;
        var res = this["asin"]();
        this["re"] = -this["im"];
        this["im"] = tmp;
        tmp = res["re"];
        res["re"] = -res["im"];
        res["im"] = tmp;
        return res;
      },
      "acosh": function() {
        var res = this["acos"]();
        if (res["im"] <= 0) {
          var tmp = res["re"];
          res["re"] = -res["im"];
          res["im"] = tmp;
        } else {
          var tmp = res["im"];
          res["im"] = -res["re"];
          res["re"] = tmp;
        }
        return res;
      },
      "atanh": function() {
        var a = this["re"];
        var b = this["im"];
        var noIM = a > 1 && b === 0;
        var oneMinus = 1 - a;
        var onePlus = 1 + a;
        var d = oneMinus * oneMinus + b * b;
        var x = d !== 0 ? new Complex2(
          (onePlus * oneMinus - b * b) / d,
          (b * oneMinus + onePlus * b) / d
        ) : new Complex2(
          a !== -1 ? a / 0 : 0,
          b !== 0 ? b / 0 : 0
        );
        var temp = x["re"];
        x["re"] = logHypot(x["re"], x["im"]) / 2;
        x["im"] = Math.atan2(x["im"], temp) / 2;
        if (noIM) {
          x["im"] = -x["im"];
        }
        return x;
      },
      "acoth": function() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0 && b === 0) {
          return new Complex2(0, Math.PI / 2);
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex2(
          a / d,
          -b / d
        ).atanh() : new Complex2(
          a !== 0 ? a / 0 : 0,
          b !== 0 ? -b / 0 : 0
        ).atanh();
      },
      "acsch": function() {
        var a = this["re"];
        var b = this["im"];
        if (b === 0) {
          return new Complex2(
            a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity,
            0
          );
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex2(
          a / d,
          -b / d
        ).asinh() : new Complex2(
          a !== 0 ? a / 0 : 0,
          b !== 0 ? -b / 0 : 0
        ).asinh();
      },
      "asech": function() {
        var a = this["re"];
        var b = this["im"];
        if (this["isZero"]()) {
          return Complex2["INFINITY"];
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex2(
          a / d,
          -b / d
        ).acosh() : new Complex2(
          a !== 0 ? a / 0 : 0,
          b !== 0 ? -b / 0 : 0
        ).acosh();
      },
      "inverse": function() {
        if (this["isZero"]()) {
          return Complex2["INFINITY"];
        }
        if (this["isInfinite"]()) {
          return Complex2["ZERO"];
        }
        var a = this["re"];
        var b = this["im"];
        var d = a * a + b * b;
        return new Complex2(a / d, -b / d);
      },
      "conjugate": function() {
        return new Complex2(this["re"], -this["im"]);
      },
      "neg": function() {
        return new Complex2(-this["re"], -this["im"]);
      },
      "ceil": function(places) {
        places = Math.pow(10, places || 0);
        return new Complex2(
          Math.ceil(this["re"] * places) / places,
          Math.ceil(this["im"] * places) / places
        );
      },
      "floor": function(places) {
        places = Math.pow(10, places || 0);
        return new Complex2(
          Math.floor(this["re"] * places) / places,
          Math.floor(this["im"] * places) / places
        );
      },
      "round": function(places) {
        places = Math.pow(10, places || 0);
        return new Complex2(
          Math.round(this["re"] * places) / places,
          Math.round(this["im"] * places) / places
        );
      },
      "equals": function(a, b) {
        var z = new Complex2(a, b);
        return Math.abs(z["re"] - this["re"]) <= Complex2["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex2["EPSILON"];
      },
      "clone": function() {
        return new Complex2(this["re"], this["im"]);
      },
      "toString": function() {
        var a = this["re"];
        var b = this["im"];
        var ret = "";
        if (this["isNaN"]()) {
          return "NaN";
        }
        if (this["isInfinite"]()) {
          return "Infinity";
        }
        if (Math.abs(a) < Complex2["EPSILON"]) {
          a = 0;
        }
        if (Math.abs(b) < Complex2["EPSILON"]) {
          b = 0;
        }
        if (b === 0) {
          return ret + a;
        }
        if (a !== 0) {
          ret += a;
          ret += " ";
          if (b < 0) {
            b = -b;
            ret += "-";
          } else {
            ret += "+";
          }
          ret += " ";
        } else if (b < 0) {
          b = -b;
          ret += "-";
        }
        if (1 !== b) {
          ret += b;
        }
        return ret + "i";
      },
      "toVector": function() {
        return [this["re"], this["im"]];
      },
      "valueOf": function() {
        if (this["im"] === 0) {
          return this["re"];
        }
        return null;
      },
      "isNaN": function() {
        return isNaN(this["re"]) || isNaN(this["im"]);
      },
      "isZero": function() {
        return this["im"] === 0 && this["re"] === 0;
      },
      "isFinite": function() {
        return isFinite(this["re"]) && isFinite(this["im"]);
      },
      "isInfinite": function() {
        return !(this["isNaN"]() || this["isFinite"]());
      }
    };
    Complex2["ZERO"] = new Complex2(0, 0);
    Complex2["ONE"] = new Complex2(1, 0);
    Complex2["I"] = new Complex2(0, 1);
    Complex2["PI"] = new Complex2(Math.PI, 0);
    Complex2["E"] = new Complex2(Math.E, 0);
    Complex2["INFINITY"] = new Complex2(Infinity, Infinity);
    Complex2["NAN"] = new Complex2(NaN, NaN);
    Complex2["EPSILON"] = 1e-15;
    {
      Object.defineProperty(Complex2, "__esModule", { "value": true });
      Complex2["default"] = Complex2;
      Complex2["Complex"] = Complex2;
      module["exports"] = Complex2;
    }
  })();
})(complex$1);
var Complex$1 = /* @__PURE__ */ getDefaultExportFromCjs(complex$1.exports);
var name$4B = "Complex";
var dependencies$4B = [];
var createComplexClass = /* @__PURE__ */ factory(name$4B, dependencies$4B, () => {
  Object.defineProperty(Complex$1, "name", {
    value: "Complex"
  });
  Complex$1.prototype.constructor = Complex$1;
  Complex$1.prototype.type = "Complex";
  Complex$1.prototype.isComplex = true;
  Complex$1.prototype.toJSON = function() {
    return {
      mathjs: "Complex",
      re: this.re,
      im: this.im
    };
  };
  Complex$1.prototype.toPolar = function() {
    return {
      r: this.abs(),
      phi: this.arg()
    };
  };
  Complex$1.prototype.format = function(options) {
    var str = "";
    var im2 = this.im;
    var re2 = this.re;
    var strRe = format$3(this.re, options);
    var strIm = format$3(this.im, options);
    var precision = isNumber(options) ? options : options ? options.precision : null;
    if (precision !== null) {
      var epsilon = Math.pow(10, -precision);
      if (Math.abs(re2 / im2) < epsilon) {
        re2 = 0;
      }
      if (Math.abs(im2 / re2) < epsilon) {
        im2 = 0;
      }
    }
    if (im2 === 0) {
      str = strRe;
    } else if (re2 === 0) {
      if (im2 === 1) {
        str = "i";
      } else if (im2 === -1) {
        str = "-i";
      } else {
        str = strIm + "i";
      }
    } else {
      if (im2 < 0) {
        if (im2 === -1) {
          str = strRe + " - i";
        } else {
          str = strRe + " - " + strIm.substring(1) + "i";
        }
      } else {
        if (im2 === 1) {
          str = strRe + " + i";
        } else {
          str = strRe + " + " + strIm + "i";
        }
      }
    }
    return str;
  };
  Complex$1.fromPolar = function(args) {
    switch (arguments.length) {
      case 1: {
        var arg2 = arguments[0];
        if (typeof arg2 === "object") {
          return Complex$1(arg2);
        } else {
          throw new TypeError("Input has to be an object with r and phi keys.");
        }
      }
      case 2: {
        var r = arguments[0];
        var phi2 = arguments[1];
        if (isNumber(r)) {
          if (isUnit(phi2) && phi2.hasBase("ANGLE")) {
            phi2 = phi2.toNumber("rad");
          }
          if (isNumber(phi2)) {
            return new Complex$1({
              r,
              phi: phi2
            });
          }
          throw new TypeError("Phi is not a number nor an angle unit.");
        } else {
          throw new TypeError("Radius r is not a number.");
        }
      }
      default:
        throw new SyntaxError("Wrong number of arguments in function fromPolar");
    }
  };
  Complex$1.prototype.valueOf = Complex$1.prototype.toString;
  Complex$1.fromJSON = function(json) {
    return new Complex$1(json);
  };
  Complex$1.compare = function(a, b) {
    if (a.re > b.re) {
      return 1;
    }
    if (a.re < b.re) {
      return -1;
    }
    if (a.im > b.im) {
      return 1;
    }
    if (a.im < b.im) {
      return -1;
    }
    return 0;
  };
  return Complex$1;
}, {
  isClass: true
});
var fraction$1 = { exports: {} };
/**
 * @license Fraction.js v4.2.0 05/03/2022
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
(function(module, exports) {
  (function(root) {
    var MAX_CYCLE_LEN = 2e3;
    var P2 = {
      "s": 1,
      "n": 0,
      "d": 1
    };
    function assign2(n, s) {
      if (isNaN(n = parseInt(n, 10))) {
        throw Fraction2["InvalidParameter"];
      }
      return n * s;
    }
    function newFraction(n, d) {
      if (d === 0) {
        throw Fraction2["DivisionByZero"];
      }
      var f = Object.create(Fraction2.prototype);
      f["s"] = n < 0 ? -1 : 1;
      n = n < 0 ? -n : n;
      var a = gcd2(n, d);
      f["n"] = n / a;
      f["d"] = d / a;
      return f;
    }
    function factorize(num) {
      var factors = {};
      var n = num;
      var i2 = 2;
      var s = 4;
      while (s <= n) {
        while (n % i2 === 0) {
          n /= i2;
          factors[i2] = (factors[i2] || 0) + 1;
        }
        s += 1 + 2 * i2++;
      }
      if (n !== num) {
        if (n > 1)
          factors[n] = (factors[n] || 0) + 1;
      } else {
        factors[num] = (factors[num] || 0) + 1;
      }
      return factors;
    }
    var parse2 = function(p1, p2) {
      var n = 0, d = 1, s = 1;
      var v = 0, w = 0, x = 0, y = 1, z = 1;
      var A = 0, B = 1;
      var C = 1, D = 1;
      var N = 1e7;
      var M;
      if (p1 === void 0 || p1 === null)
        ;
      else if (p2 !== void 0) {
        n = p1;
        d = p2;
        s = n * d;
        if (n % 1 !== 0 || d % 1 !== 0) {
          throw Fraction2["NonIntegerParameter"];
        }
      } else
        switch (typeof p1) {
          case "object": {
            if ("d" in p1 && "n" in p1) {
              n = p1["n"];
              d = p1["d"];
              if ("s" in p1)
                n *= p1["s"];
            } else if (0 in p1) {
              n = p1[0];
              if (1 in p1)
                d = p1[1];
            } else {
              throw Fraction2["InvalidParameter"];
            }
            s = n * d;
            break;
          }
          case "number": {
            if (p1 < 0) {
              s = p1;
              p1 = -p1;
            }
            if (p1 % 1 === 0) {
              n = p1;
            } else if (p1 > 0) {
              if (p1 >= 1) {
                z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                p1 /= z;
              }
              while (B <= N && D <= N) {
                M = (A + C) / (B + D);
                if (p1 === M) {
                  if (B + D <= N) {
                    n = A + C;
                    d = B + D;
                  } else if (D > B) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                  break;
                } else {
                  if (p1 > M) {
                    A += C;
                    B += D;
                  } else {
                    C += A;
                    D += B;
                  }
                  if (B > N) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                }
              }
              n *= z;
            } else if (isNaN(p1) || isNaN(p2)) {
              d = n = NaN;
            }
            break;
          }
          case "string": {
            B = p1.match(/\d+|./g);
            if (B === null)
              throw Fraction2["InvalidParameter"];
            if (B[A] === "-") {
              s = -1;
              A++;
            } else if (B[A] === "+") {
              A++;
            }
            if (B.length === A + 1) {
              w = assign2(B[A++], s);
            } else if (B[A + 1] === "." || B[A] === ".") {
              if (B[A] !== ".") {
                v = assign2(B[A++], s);
              }
              A++;
              if (A + 1 === B.length || B[A + 1] === "(" && B[A + 3] === ")" || B[A + 1] === "'" && B[A + 3] === "'") {
                w = assign2(B[A], s);
                y = Math.pow(10, B[A].length);
                A++;
              }
              if (B[A] === "(" && B[A + 2] === ")" || B[A] === "'" && B[A + 2] === "'") {
                x = assign2(B[A + 1], s);
                z = Math.pow(10, B[A + 1].length) - 1;
                A += 3;
              }
            } else if (B[A + 1] === "/" || B[A + 1] === ":") {
              w = assign2(B[A], s);
              y = assign2(B[A + 2], 1);
              A += 3;
            } else if (B[A + 3] === "/" && B[A + 1] === " ") {
              v = assign2(B[A], s);
              w = assign2(B[A + 2], s);
              y = assign2(B[A + 4], 1);
              A += 5;
            }
            if (B.length <= A) {
              d = y * z;
              s = n = x + d * v + z * w;
              break;
            }
          }
          default:
            throw Fraction2["InvalidParameter"];
        }
      if (d === 0) {
        throw Fraction2["DivisionByZero"];
      }
      P2["s"] = s < 0 ? -1 : 1;
      P2["n"] = Math.abs(n);
      P2["d"] = Math.abs(d);
    };
    function modpow(b, e2, m) {
      var r = 1;
      for (; e2 > 0; b = b * b % m, e2 >>= 1) {
        if (e2 & 1) {
          r = r * b % m;
        }
      }
      return r;
    }
    function cycleLen(n, d) {
      for (; d % 2 === 0; d /= 2) {
      }
      for (; d % 5 === 0; d /= 5) {
      }
      if (d === 1)
        return 0;
      var rem = 10 % d;
      var t = 1;
      for (; rem !== 1; t++) {
        rem = rem * 10 % d;
        if (t > MAX_CYCLE_LEN)
          return 0;
      }
      return t;
    }
    function cycleStart(n, d, len) {
      var rem1 = 1;
      var rem2 = modpow(10, len, d);
      for (var t = 0; t < 300; t++) {
        if (rem1 === rem2)
          return t;
        rem1 = rem1 * 10 % d;
        rem2 = rem2 * 10 % d;
      }
      return 0;
    }
    function gcd2(a, b) {
      if (!a)
        return b;
      if (!b)
        return a;
      while (1) {
        a %= b;
        if (!a)
          return b;
        b %= a;
        if (!b)
          return a;
      }
    }
    function Fraction2(a, b) {
      parse2(a, b);
      if (this instanceof Fraction2) {
        a = gcd2(P2["d"], P2["n"]);
        this["s"] = P2["s"];
        this["n"] = P2["n"] / a;
        this["d"] = P2["d"] / a;
      } else {
        return newFraction(P2["s"] * P2["n"], P2["d"]);
      }
    }
    Fraction2["DivisionByZero"] = new Error("Division by Zero");
    Fraction2["InvalidParameter"] = new Error("Invalid argument");
    Fraction2["NonIntegerParameter"] = new Error("Parameters must be integer");
    Fraction2.prototype = {
      "s": 1,
      "n": 0,
      "d": 1,
      "abs": function() {
        return newFraction(this["n"], this["d"]);
      },
      "neg": function() {
        return newFraction(-this["s"] * this["n"], this["d"]);
      },
      "add": function(a, b) {
        parse2(a, b);
        return newFraction(
          this["s"] * this["n"] * P2["d"] + P2["s"] * this["d"] * P2["n"],
          this["d"] * P2["d"]
        );
      },
      "sub": function(a, b) {
        parse2(a, b);
        return newFraction(
          this["s"] * this["n"] * P2["d"] - P2["s"] * this["d"] * P2["n"],
          this["d"] * P2["d"]
        );
      },
      "mul": function(a, b) {
        parse2(a, b);
        return newFraction(
          this["s"] * P2["s"] * this["n"] * P2["n"],
          this["d"] * P2["d"]
        );
      },
      "div": function(a, b) {
        parse2(a, b);
        return newFraction(
          this["s"] * P2["s"] * this["n"] * P2["d"],
          this["d"] * P2["n"]
        );
      },
      "clone": function() {
        return newFraction(this["s"] * this["n"], this["d"]);
      },
      "mod": function(a, b) {
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction2(NaN);
        }
        if (a === void 0) {
          return newFraction(this["s"] * this["n"] % this["d"], 1);
        }
        parse2(a, b);
        if (0 === P2["n"] && 0 === this["d"]) {
          throw Fraction2["DivisionByZero"];
        }
        return newFraction(
          this["s"] * (P2["d"] * this["n"]) % (P2["n"] * this["d"]),
          P2["d"] * this["d"]
        );
      },
      "gcd": function(a, b) {
        parse2(a, b);
        return newFraction(gcd2(P2["n"], this["n"]) * gcd2(P2["d"], this["d"]), P2["d"] * this["d"]);
      },
      "lcm": function(a, b) {
        parse2(a, b);
        if (P2["n"] === 0 && this["n"] === 0) {
          return newFraction(0, 1);
        }
        return newFraction(P2["n"] * this["n"], gcd2(P2["n"], this["n"]) * gcd2(P2["d"], this["d"]));
      },
      "ceil": function(places) {
        places = Math.pow(10, places || 0);
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction2(NaN);
        }
        return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
      },
      "floor": function(places) {
        places = Math.pow(10, places || 0);
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction2(NaN);
        }
        return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
      },
      "round": function(places) {
        places = Math.pow(10, places || 0);
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction2(NaN);
        }
        return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
      },
      "inverse": function() {
        return newFraction(this["s"] * this["d"], this["n"]);
      },
      "pow": function(a, b) {
        parse2(a, b);
        if (P2["d"] === 1) {
          if (P2["s"] < 0) {
            return newFraction(Math.pow(this["s"] * this["d"], P2["n"]), Math.pow(this["n"], P2["n"]));
          } else {
            return newFraction(Math.pow(this["s"] * this["n"], P2["n"]), Math.pow(this["d"], P2["n"]));
          }
        }
        if (this["s"] < 0)
          return null;
        var N = factorize(this["n"]);
        var D = factorize(this["d"]);
        var n = 1;
        var d = 1;
        for (var k in N) {
          if (k === "1")
            continue;
          if (k === "0") {
            n = 0;
            break;
          }
          N[k] *= P2["n"];
          if (N[k] % P2["d"] === 0) {
            N[k] /= P2["d"];
          } else
            return null;
          n *= Math.pow(k, N[k]);
        }
        for (var k in D) {
          if (k === "1")
            continue;
          D[k] *= P2["n"];
          if (D[k] % P2["d"] === 0) {
            D[k] /= P2["d"];
          } else
            return null;
          d *= Math.pow(k, D[k]);
        }
        if (P2["s"] < 0) {
          return newFraction(d, n);
        }
        return newFraction(n, d);
      },
      "equals": function(a, b) {
        parse2(a, b);
        return this["s"] * this["n"] * P2["d"] === P2["s"] * P2["n"] * this["d"];
      },
      "compare": function(a, b) {
        parse2(a, b);
        var t = this["s"] * this["n"] * P2["d"] - P2["s"] * P2["n"] * this["d"];
        return (0 < t) - (t < 0);
      },
      "simplify": function(eps) {
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return this;
        }
        eps = eps || 1e-3;
        var thisABS = this["abs"]();
        var cont = thisABS["toContinued"]();
        for (var i2 = 1; i2 < cont.length; i2++) {
          var s = newFraction(cont[i2 - 1], 1);
          for (var k = i2 - 2; k >= 0; k--) {
            s = s["inverse"]()["add"](cont[k]);
          }
          if (s["sub"](thisABS)["abs"]().valueOf() < eps) {
            return s["mul"](this["s"]);
          }
        }
        return this;
      },
      "divisible": function(a, b) {
        parse2(a, b);
        return !(!(P2["n"] * this["d"]) || this["n"] * P2["d"] % (P2["n"] * this["d"]));
      },
      "valueOf": function() {
        return this["s"] * this["n"] / this["d"];
      },
      "toFraction": function(excludeWhole) {
        var whole, str = "";
        var n = this["n"];
        var d = this["d"];
        if (this["s"] < 0) {
          str += "-";
        }
        if (d === 1) {
          str += n;
        } else {
          if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
            str += whole;
            str += " ";
            n %= d;
          }
          str += n;
          str += "/";
          str += d;
        }
        return str;
      },
      "toLatex": function(excludeWhole) {
        var whole, str = "";
        var n = this["n"];
        var d = this["d"];
        if (this["s"] < 0) {
          str += "-";
        }
        if (d === 1) {
          str += n;
        } else {
          if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
            str += whole;
            n %= d;
          }
          str += "\\frac{";
          str += n;
          str += "}{";
          str += d;
          str += "}";
        }
        return str;
      },
      "toContinued": function() {
        var t;
        var a = this["n"];
        var b = this["d"];
        var res = [];
        if (isNaN(a) || isNaN(b)) {
          return res;
        }
        do {
          res.push(Math.floor(a / b));
          t = a % b;
          a = b;
          b = t;
        } while (a !== 1);
        return res;
      },
      "toString": function(dec) {
        var N = this["n"];
        var D = this["d"];
        if (isNaN(N) || isNaN(D)) {
          return "NaN";
        }
        dec = dec || 15;
        var cycLen = cycleLen(N, D);
        var cycOff = cycleStart(N, D, cycLen);
        var str = this["s"] < 0 ? "-" : "";
        str += N / D | 0;
        N %= D;
        N *= 10;
        if (N)
          str += ".";
        if (cycLen) {
          for (var i2 = cycOff; i2--; ) {
            str += N / D | 0;
            N %= D;
            N *= 10;
          }
          str += "(";
          for (var i2 = cycLen; i2--; ) {
            str += N / D | 0;
            N %= D;
            N *= 10;
          }
          str += ")";
        } else {
          for (var i2 = dec; N && i2--; ) {
            str += N / D | 0;
            N %= D;
            N *= 10;
          }
        }
        return str;
      }
    };
    {
      Object.defineProperty(Fraction2, "__esModule", { "value": true });
      Fraction2["default"] = Fraction2;
      Fraction2["Fraction"] = Fraction2;
      module["exports"] = Fraction2;
    }
  })();
})(fraction$1);
var Fraction$1 = /* @__PURE__ */ getDefaultExportFromCjs(fraction$1.exports);
var name$4A = "Fraction";
var dependencies$4A = [];
var createFractionClass = /* @__PURE__ */ factory(name$4A, dependencies$4A, () => {
  Object.defineProperty(Fraction$1, "name", {
    value: "Fraction"
  });
  Fraction$1.prototype.constructor = Fraction$1;
  Fraction$1.prototype.type = "Fraction";
  Fraction$1.prototype.isFraction = true;
  Fraction$1.prototype.toJSON = function() {
    return {
      mathjs: "Fraction",
      n: this.s * this.n,
      d: this.d
    };
  };
  Fraction$1.fromJSON = function(json) {
    return new Fraction$1(json);
  };
  return Fraction$1;
}, {
  isClass: true
});
var name$4z = "Range";
var dependencies$4z = [];
var createRangeClass = /* @__PURE__ */ factory(name$4z, dependencies$4z, () => {
  function Range2(start2, end, step) {
    if (!(this instanceof Range2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    var hasStart = start2 !== null && start2 !== void 0;
    var hasEnd = end !== null && end !== void 0;
    var hasStep = step !== null && step !== void 0;
    if (hasStart) {
      if (isBigNumber(start2)) {
        start2 = start2.toNumber();
      } else if (typeof start2 !== "number") {
        throw new TypeError("Parameter start must be a number");
      }
    }
    if (hasEnd) {
      if (isBigNumber(end)) {
        end = end.toNumber();
      } else if (typeof end !== "number") {
        throw new TypeError("Parameter end must be a number");
      }
    }
    if (hasStep) {
      if (isBigNumber(step)) {
        step = step.toNumber();
      } else if (typeof step !== "number") {
        throw new TypeError("Parameter step must be a number");
      }
    }
    this.start = hasStart ? parseFloat(start2) : 0;
    this.end = hasEnd ? parseFloat(end) : 0;
    this.step = hasStep ? parseFloat(step) : 1;
  }
  Range2.prototype.type = "Range";
  Range2.prototype.isRange = true;
  Range2.parse = function(str) {
    if (typeof str !== "string") {
      return null;
    }
    var args = str.split(":");
    var nums = args.map(function(arg2) {
      return parseFloat(arg2);
    });
    var invalid = nums.some(function(num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }
    switch (nums.length) {
      case 2:
        return new Range2(nums[0], nums[1]);
      case 3:
        return new Range2(nums[0], nums[2], nums[1]);
      default:
        return null;
    }
  };
  Range2.prototype.clone = function() {
    return new Range2(this.start, this.end, this.step);
  };
  Range2.prototype.size = function() {
    var len = 0;
    var start2 = this.start;
    var step = this.step;
    var end = this.end;
    var diff2 = end - start2;
    if (sign$2(step) === sign$2(diff2)) {
      len = Math.ceil(diff2 / step);
    } else if (diff2 === 0) {
      len = 0;
    }
    if (isNaN(len)) {
      len = 0;
    }
    return [len];
  };
  Range2.prototype.min = function() {
    var size2 = this.size()[0];
    if (size2 > 0) {
      if (this.step > 0) {
        return this.start;
      } else {
        return this.start + (size2 - 1) * this.step;
      }
    } else {
      return void 0;
    }
  };
  Range2.prototype.max = function() {
    var size2 = this.size()[0];
    if (size2 > 0) {
      if (this.step > 0) {
        return this.start + (size2 - 1) * this.step;
      } else {
        return this.start;
      }
    } else {
      return void 0;
    }
  };
  Range2.prototype.forEach = function(callback) {
    var x = this.start;
    var step = this.step;
    var end = this.end;
    var i2 = 0;
    if (step > 0) {
      while (x < end) {
        callback(x, [i2], this);
        x += step;
        i2++;
      }
    } else if (step < 0) {
      while (x > end) {
        callback(x, [i2], this);
        x += step;
        i2++;
      }
    }
  };
  Range2.prototype.map = function(callback) {
    var array = [];
    this.forEach(function(value, index2, obj) {
      array[index2[0]] = callback(value, index2, obj);
    });
    return array;
  };
  Range2.prototype.toArray = function() {
    var array = [];
    this.forEach(function(value, index2) {
      array[index2[0]] = value;
    });
    return array;
  };
  Range2.prototype.valueOf = function() {
    return this.toArray();
  };
  Range2.prototype.format = function(options) {
    var str = format$3(this.start, options);
    if (this.step !== 1) {
      str += ":" + format$3(this.step, options);
    }
    str += ":" + format$3(this.end, options);
    return str;
  };
  Range2.prototype.toString = function() {
    return this.format();
  };
  Range2.prototype.toJSON = function() {
    return {
      mathjs: "Range",
      start: this.start,
      end: this.end,
      step: this.step
    };
  };
  Range2.fromJSON = function(json) {
    return new Range2(json.start, json.end, json.step);
  };
  return Range2;
}, {
  isClass: true
});
var name$4y = "Matrix";
var dependencies$4y = [];
var createMatrixClass = /* @__PURE__ */ factory(name$4y, dependencies$4y, () => {
  function Matrix2() {
    if (!(this instanceof Matrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
  }
  Matrix2.prototype.type = "Matrix";
  Matrix2.prototype.isMatrix = true;
  Matrix2.prototype.storage = function() {
    throw new Error("Cannot invoke storage on a Matrix interface");
  };
  Matrix2.prototype.datatype = function() {
    throw new Error("Cannot invoke datatype on a Matrix interface");
  };
  Matrix2.prototype.create = function(data, datatype) {
    throw new Error("Cannot invoke create on a Matrix interface");
  };
  Matrix2.prototype.subset = function(index2, replacement, defaultValue) {
    throw new Error("Cannot invoke subset on a Matrix interface");
  };
  Matrix2.prototype.get = function(index2) {
    throw new Error("Cannot invoke get on a Matrix interface");
  };
  Matrix2.prototype.set = function(index2, value, defaultValue) {
    throw new Error("Cannot invoke set on a Matrix interface");
  };
  Matrix2.prototype.resize = function(size2, defaultValue) {
    throw new Error("Cannot invoke resize on a Matrix interface");
  };
  Matrix2.prototype.reshape = function(size2, defaultValue) {
    throw new Error("Cannot invoke reshape on a Matrix interface");
  };
  Matrix2.prototype.clone = function() {
    throw new Error("Cannot invoke clone on a Matrix interface");
  };
  Matrix2.prototype.size = function() {
    throw new Error("Cannot invoke size on a Matrix interface");
  };
  Matrix2.prototype.map = function(callback, skipZeros) {
    throw new Error("Cannot invoke map on a Matrix interface");
  };
  Matrix2.prototype.forEach = function(callback) {
    throw new Error("Cannot invoke forEach on a Matrix interface");
  };
  Matrix2.prototype[Symbol.iterator] = function() {
    throw new Error("Cannot iterate a Matrix interface");
  };
  Matrix2.prototype.toArray = function() {
    throw new Error("Cannot invoke toArray on a Matrix interface");
  };
  Matrix2.prototype.valueOf = function() {
    throw new Error("Cannot invoke valueOf on a Matrix interface");
  };
  Matrix2.prototype.format = function(options) {
    throw new Error("Cannot invoke format on a Matrix interface");
  };
  Matrix2.prototype.toString = function() {
    throw new Error("Cannot invoke toString on a Matrix interface");
  };
  return Matrix2;
}, {
  isClass: true
});
function lruQueue(limit) {
  var size2 = 0;
  var base2 = 1;
  var queue2 = /* @__PURE__ */ Object.create(null);
  var map3 = /* @__PURE__ */ Object.create(null);
  var index2 = 0;
  var del = function del2(id) {
    var oldIndex = map3[id];
    if (!oldIndex)
      return;
    delete queue2[oldIndex];
    delete map3[id];
    --size2;
    if (base2 !== oldIndex)
      return;
    if (!size2) {
      index2 = 0;
      base2 = 1;
      return;
    }
    while (!hasOwnProperty.call(queue2, ++base2)) {
      continue;
    }
  };
  limit = Math.abs(limit);
  return {
    hit: function hit(id) {
      var oldIndex = map3[id];
      var nuIndex = ++index2;
      queue2[nuIndex] = id;
      map3[id] = nuIndex;
      if (!oldIndex) {
        ++size2;
        if (size2 <= limit)
          return void 0;
        id = queue2[base2];
        del(id);
        return id;
      }
      delete queue2[oldIndex];
      if (base2 !== oldIndex)
        return void 0;
      while (!hasOwnProperty.call(queue2, ++base2)) {
        continue;
      }
      return void 0;
    },
    delete: del,
    clear: function clear3() {
      size2 = index2 = 0;
      base2 = 1;
      queue2 = /* @__PURE__ */ Object.create(null);
      map3 = /* @__PURE__ */ Object.create(null);
    }
  };
}
function memoize(fn) {
  var {
    hasher: hasher2,
    limit
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  limit = limit == null ? Number.POSITIVE_INFINITY : limit;
  hasher2 = hasher2 == null ? JSON.stringify : hasher2;
  return function memoize2() {
    if (typeof memoize2.cache !== "object") {
      memoize2.cache = {
        values: /* @__PURE__ */ new Map(),
        lru: lruQueue(limit || Number.POSITIVE_INFINITY)
      };
    }
    var args = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      args[i2] = arguments[i2];
    }
    var hash2 = hasher2(args);
    if (memoize2.cache.values.has(hash2)) {
      memoize2.cache.lru.hit(hash2);
      return memoize2.cache.values.get(hash2);
    }
    var newVal = fn.apply(fn, args);
    memoize2.cache.values.set(hash2, newVal);
    memoize2.cache.values.delete(memoize2.cache.lru.hit(hash2));
    return newVal;
  };
}
function maxArgumentCount(fn) {
  return Object.keys(fn.signatures || {}).reduce(function(args, signature) {
    var count3 = (signature.match(/,/g) || []).length + 1;
    return Math.max(args, count3);
  }, -1);
}
var name$4x = "DenseMatrix";
var dependencies$4x = ["Matrix"];
var createDenseMatrixClass = /* @__PURE__ */ factory(name$4x, dependencies$4x, (_ref) => {
  var {
    Matrix: Matrix2
  } = _ref;
  function DenseMatrix2(data, datatype) {
    if (!(this instanceof DenseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      if (data.type === "DenseMatrix") {
        this._data = clone$2(data._data);
        this._size = clone$2(data._size);
        this._datatype = datatype || data._datatype;
      } else {
        this._data = data.toArray();
        this._size = data.size();
        this._datatype = datatype || data._datatype;
      }
    } else if (data && isArray$1(data.data) && isArray$1(data.size)) {
      this._data = data.data;
      this._size = data.size;
      validate(this._data, this._size);
      this._datatype = datatype || data.datatype;
    } else if (isArray$1(data)) {
      this._data = preprocess(data);
      this._size = arraySize(this._data);
      validate(this._data, this._size);
      this._datatype = datatype;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf$1(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
    }
  }
  DenseMatrix2.prototype = new Matrix2();
  DenseMatrix2.prototype.createDenseMatrix = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  Object.defineProperty(DenseMatrix2, "name", {
    value: "DenseMatrix"
  });
  DenseMatrix2.prototype.constructor = DenseMatrix2;
  DenseMatrix2.prototype.type = "DenseMatrix";
  DenseMatrix2.prototype.isDenseMatrix = true;
  DenseMatrix2.prototype.getDataType = function() {
    return getArrayDataType(this._data, typeOf$1);
  };
  DenseMatrix2.prototype.storage = function() {
    return "dense";
  };
  DenseMatrix2.prototype.datatype = function() {
    return this._datatype;
  };
  DenseMatrix2.prototype.create = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
    switch (arguments.length) {
      case 1:
        return _get(this, index2);
      case 2:
      case 3:
        return _set(this, index2, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  DenseMatrix2.prototype.get = function(index2) {
    if (!isArray$1(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    for (var x = 0; x < index2.length; x++) {
      validateIndex(index2[x], this._size[x]);
    }
    var data = this._data;
    for (var i2 = 0, ii = index2.length; i2 < ii; i2++) {
      var indexI = index2[i2];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    return data;
  };
  DenseMatrix2.prototype.set = function(index2, value, defaultValue) {
    if (!isArray$1(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length < this._size.length) {
      throw new DimensionError(index2.length, this._size.length, "<");
    }
    var i2, ii, indexI;
    var size2 = index2.map(function(i3) {
      return i3 + 1;
    });
    _fit(this, size2, defaultValue);
    var data = this._data;
    for (i2 = 0, ii = index2.length - 1; i2 < ii; i2++) {
      indexI = index2[i2];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    indexI = index2[index2.length - 1];
    validateIndex(indexI, data.length);
    data[indexI] = value;
    return this;
  };
  function _get(matrix2, index2) {
    if (!isIndex(index2)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = index2.isScalar();
    if (isScalar) {
      return matrix2.get(index2.min());
    } else {
      var size2 = index2.size();
      if (size2.length !== matrix2._size.length) {
        throw new DimensionError(size2.length, matrix2._size.length);
      }
      var min3 = index2.min();
      var max3 = index2.max();
      for (var i2 = 0, ii = matrix2._size.length; i2 < ii; i2++) {
        validateIndex(min3[i2], matrix2._size[i2]);
        validateIndex(max3[i2], matrix2._size[i2]);
      }
      return new DenseMatrix2(_getSubmatrix(matrix2._data, index2, size2.length, 0), matrix2._datatype);
    }
  }
  function _getSubmatrix(data, index2, dims, dim) {
    var last3 = dim === dims - 1;
    var range2 = index2.dimension(dim);
    if (last3) {
      return range2.map(function(i2) {
        validateIndex(i2, data.length);
        return data[i2];
      }).valueOf();
    } else {
      return range2.map(function(i2) {
        validateIndex(i2, data.length);
        var child = data[i2];
        return _getSubmatrix(child, index2, dims, dim + 1);
      }).valueOf();
    }
  }
  function _set(matrix2, index2, submatrix, defaultValue) {
    if (!index2 || index2.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index2.size();
    var isScalar = index2.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.valueOf();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix2.set(index2.min(), submatrix, defaultValue);
    } else {
      if (iSize.length < matrix2._size.length) {
        throw new DimensionError(iSize.length, matrix2._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i2 = 0;
        var outer = 0;
        while (iSize[i2] === 1 && sSize[i2] === 1) {
          i2++;
        }
        while (iSize[i2] === 1) {
          outer++;
          i2++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      var size2 = index2.max().map(function(i3) {
        return i3 + 1;
      });
      _fit(matrix2, size2, defaultValue);
      var dims = iSize.length;
      var dim = 0;
      _setSubmatrix(matrix2._data, index2, submatrix, dims, dim);
    }
    return matrix2;
  }
  function _setSubmatrix(data, index2, submatrix, dims, dim) {
    var last3 = dim === dims - 1;
    var range2 = index2.dimension(dim);
    if (last3) {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        data[dataIndex] = submatrix[subIndex[0]];
      });
    } else {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        _setSubmatrix(data[dataIndex], index2, submatrix[subIndex[0]], dims, dim + 1);
      });
    }
  }
  DenseMatrix2.prototype.resize = function(size2, defaultValue, copy2) {
    if (!isCollection$1(size2)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size2.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    var m = copy2 ? this.clone() : this;
    return _resize2(m, sizeArray, defaultValue);
  };
  function _resize2(matrix2, size2, defaultValue) {
    if (size2.length === 0) {
      var v = matrix2._data;
      while (isArray$1(v)) {
        v = v[0];
      }
      return v;
    }
    matrix2._size = size2.slice(0);
    matrix2._data = resize$1(matrix2._data, matrix2._size, defaultValue);
    return matrix2;
  }
  DenseMatrix2.prototype.reshape = function(size2, copy2) {
    var m = copy2 ? this.clone() : this;
    m._data = reshape$1(m._data, size2);
    var currentLength = m._size.reduce((length, size3) => length * size3);
    m._size = processSizesWildcard(size2, currentLength);
    return m;
  };
  function _fit(matrix2, size2, defaultValue) {
    var newSize = matrix2._size.slice(0);
    var changed = false;
    while (newSize.length < size2.length) {
      newSize.push(0);
      changed = true;
    }
    for (var i2 = 0, ii = size2.length; i2 < ii; i2++) {
      if (size2[i2] > newSize[i2]) {
        newSize[i2] = size2[i2];
        changed = true;
      }
    }
    if (changed) {
      _resize2(matrix2, newSize, defaultValue);
    }
  }
  DenseMatrix2.prototype.clone = function() {
    var m = new DenseMatrix2({
      data: clone$2(this._data),
      size: clone$2(this._size),
      datatype: this._datatype
    });
    return m;
  };
  DenseMatrix2.prototype.size = function() {
    return this._size.slice(0);
  };
  DenseMatrix2.prototype.map = function(callback) {
    var me = this;
    var args = maxArgumentCount(callback);
    var recurse = function recurse2(value, index2) {
      if (isArray$1(value)) {
        return value.map(function(child, i2) {
          return recurse2(child, index2.concat(i2));
        });
      } else {
        if (args === 1) {
          return callback(value);
        } else if (args === 2) {
          return callback(value, index2);
        } else {
          return callback(value, index2, me);
        }
      }
    };
    var data = recurse(this._data, []);
    var datatype = this._datatype !== void 0 ? getArrayDataType(data, typeOf$1) : void 0;
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.forEach = function(callback) {
    var me = this;
    var recurse = function recurse2(value, index2) {
      if (isArray$1(value)) {
        value.forEach(function(child, i2) {
          recurse2(child, index2.concat(i2));
        });
      } else {
        callback(value, index2, me);
      }
    };
    recurse(this._data, []);
  };
  DenseMatrix2.prototype[Symbol.iterator] = function* () {
    var recurse = function* recurse2(value, index2) {
      if (isArray$1(value)) {
        for (var i2 = 0; i2 < value.length; i2++) {
          yield* recurse2(value[i2], index2.concat(i2));
        }
      } else {
        yield {
          value,
          index: index2
        };
      }
    };
    yield* recurse(this._data, []);
  };
  DenseMatrix2.prototype.rows = function() {
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    for (var row2 of data) {
      result.push(new DenseMatrix2([row2], this._datatype));
    }
    return result;
  };
  DenseMatrix2.prototype.columns = function() {
    var _this = this;
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    var _loop = function _loop2(i3) {
      var col = data.map((row2) => [row2[i3]]);
      result.push(new DenseMatrix2(col, _this._datatype));
    };
    for (var i2 = 0; i2 < s[1]; i2++) {
      _loop(i2);
    }
    return result;
  };
  DenseMatrix2.prototype.toArray = function() {
    return clone$2(this._data);
  };
  DenseMatrix2.prototype.valueOf = function() {
    return this._data;
  };
  DenseMatrix2.prototype.format = function(options) {
    return format$1(this._data, options);
  };
  DenseMatrix2.prototype.toString = function() {
    return format$1(this._data);
  };
  DenseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "DenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  DenseMatrix2.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger$1(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var data = [];
    for (var i2 = 0; i2 < n; i2++) {
      data[i2] = this._data[i2 + kSub][i2 + kSuper];
    }
    return new DenseMatrix2({
      data,
      size: [n],
      datatype: this._datatype
    });
  };
  DenseMatrix2.diagonal = function(size2, value, k, defaultValue) {
    if (!isArray$1(size2)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size2.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size2 = size2.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger$1(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger$1(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size2[0];
    var columns = size2[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray$1(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i2) {
        return value[i2];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i2) {
        return value.get([i2]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    if (!defaultValue) {
      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
    }
    var data = [];
    if (size2.length > 0) {
      data = resize$1(data, size2, defaultValue);
      for (var d = 0; d < n; d++) {
        data[d + kSub][d + kSuper] = _value(d);
      }
    }
    return new DenseMatrix2({
      data,
      size: [rows, columns]
    });
  };
  DenseMatrix2.fromJSON = function(json) {
    return new DenseMatrix2(json);
  };
  DenseMatrix2.prototype.swapRows = function(i2, j) {
    if (!isNumber(i2) || !isInteger$1(i2) || !isNumber(j) || !isInteger$1(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[0]);
    DenseMatrix2._swapRows(i2, j, this._data);
    return this;
  };
  DenseMatrix2._swapRows = function(i2, j, data) {
    var vi = data[i2];
    data[i2] = data[j];
    data[j] = vi;
  };
  function preprocess(data) {
    for (var i2 = 0, ii = data.length; i2 < ii; i2++) {
      var elem = data[i2];
      if (isArray$1(elem)) {
        data[i2] = preprocess(elem);
      } else if (elem && elem.isMatrix === true) {
        data[i2] = preprocess(elem.valueOf());
      }
    }
    return data;
  }
  return DenseMatrix2;
}, {
  isClass: true
});
var name$4w = "clone";
var dependencies$4w = ["typed"];
var createClone = /* @__PURE__ */ factory(name$4w, dependencies$4w, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4w, {
    any: clone$2
  });
});
function _switch$1(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i2, j;
  var ret = [];
  for (j = 0; j < J; j++) {
    var tmp = [];
    for (i2 = 0; i2 < I; i2++) {
      tmp.push(mat[i2][j]);
    }
    ret.push(tmp);
  }
  return ret;
}
function containsCollections(array) {
  for (var i2 = 0; i2 < array.length; i2++) {
    if (isCollection$1(array[i2])) {
      return true;
    }
  }
  return false;
}
function deepForEach(array, callback) {
  if (isMatrix(array)) {
    array = array.valueOf();
  }
  for (var i2 = 0, ii = array.length; i2 < ii; i2++) {
    var value = array[i2];
    if (Array.isArray(value)) {
      deepForEach(value, callback);
    } else {
      callback(value);
    }
  }
}
function deepMap(array, callback, skipZeros) {
  if (array && typeof array.map === "function") {
    return array.map(function(x) {
      return deepMap(x, callback);
    });
  } else {
    return callback(array);
  }
}
function reduce$1(mat, dim, callback) {
  var size2 = Array.isArray(mat) ? arraySize(mat) : mat.size();
  if (dim < 0 || dim >= size2.length) {
    throw new IndexError(dim, size2.length);
  }
  if (isMatrix(mat)) {
    return mat.create(_reduce(mat.valueOf(), dim, callback));
  } else {
    return _reduce(mat, dim, callback);
  }
}
function _reduce(mat, dim, callback) {
  var i2, ret, val, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      val = mat[0];
      for (i2 = 1; i2 < mat.length; i2++) {
        val = callback(val, mat[i2]);
      }
      return val;
    } else {
      tran = _switch$1(mat);
      ret = [];
      for (i2 = 0; i2 < tran.length; i2++) {
        ret[i2] = _reduce(tran[i2], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i2 = 0; i2 < mat.length; i2++) {
      ret[i2] = _reduce(mat[i2], dim - 1, callback);
    }
    return ret;
  }
}
function scatter(a, j, w, x, u, mark, cindex, f, inverse, update8, value) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var k, k0, k1, i2;
  if (x) {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      i2 = aindex[k];
      if (w[i2] !== mark) {
        w[i2] = mark;
        cindex.push(i2);
        if (update8) {
          x[i2] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
          u[i2] = mark;
        } else {
          x[i2] = avalues[k];
        }
      } else {
        x[i2] = inverse ? f(avalues[k], x[i2]) : f(x[i2], avalues[k]);
        u[i2] = mark;
      }
    }
  } else {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      i2 = aindex[k];
      if (w[i2] !== mark) {
        w[i2] = mark;
        cindex.push(i2);
      } else {
        u[i2] = mark;
      }
    }
  }
}
var name$4v = "isInteger";
var dependencies$4v = ["typed"];
var createIsInteger = /* @__PURE__ */ factory(name$4v, dependencies$4v, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4v, {
    number: isInteger$1,
    BigNumber: function BigNumber2(x) {
      return x.isInt();
    },
    Fraction: function Fraction2(x) {
      return x.d === 1 && isFinite(x.n);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var n1$4 = "number";
var n2$2 = "number, number";
function absNumber(a) {
  return Math.abs(a);
}
absNumber.signature = n1$4;
function addNumber(a, b) {
  return a + b;
}
addNumber.signature = n2$2;
function multiplyNumber(a, b) {
  return a * b;
}
multiplyNumber.signature = n2$2;
function unaryMinusNumber(x) {
  return -x;
}
unaryMinusNumber.signature = n1$4;
function unaryPlusNumber(x) {
  return x;
}
unaryPlusNumber.signature = n1$4;
function cbrtNumber(x) {
  return cbrt$2(x);
}
cbrtNumber.signature = n1$4;
function cubeNumber(x) {
  return x * x * x;
}
cubeNumber.signature = n1$4;
function expNumber(x) {
  return Math.exp(x);
}
expNumber.signature = n1$4;
function expm1Number(x) {
  return expm1$1(x);
}
expm1Number.signature = n1$4;
function gcdNumber(a, b) {
  if (!isInteger$1(a) || !isInteger$1(b)) {
    throw new Error("Parameters in function gcd must be integer numbers");
  }
  var r;
  while (b !== 0) {
    r = a % b;
    a = b;
    b = r;
  }
  return a < 0 ? -a : a;
}
gcdNumber.signature = n2$2;
function lcmNumber(a, b) {
  if (!isInteger$1(a) || !isInteger$1(b)) {
    throw new Error("Parameters in function lcm must be integer numbers");
  }
  if (a === 0 || b === 0) {
    return 0;
  }
  var t;
  var prod2 = a * b;
  while (b !== 0) {
    t = b;
    b = a % t;
    a = t;
  }
  return Math.abs(prod2 / a);
}
lcmNumber.signature = n2$2;
function logNumber(x, y) {
  if (y) {
    return Math.log(x) / Math.log(y);
  }
  return Math.log(x);
}
function log10Number(x) {
  return log10$2(x);
}
log10Number.signature = n1$4;
function log2Number(x) {
  return log2$2(x);
}
log2Number.signature = n1$4;
function modNumber(x, y) {
  if (y > 0) {
    return x - y * Math.floor(x / y);
  } else if (y === 0) {
    return x;
  } else {
    throw new Error("Cannot calculate mod for a negative divisor");
  }
}
modNumber.signature = n2$2;
function nthRootNumber(a) {
  var root = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  var inv2 = root < 0;
  if (inv2) {
    root = -root;
  }
  if (root === 0) {
    throw new Error("Root must be non-zero");
  }
  if (a < 0 && Math.abs(root) % 2 !== 1) {
    throw new Error("Root must be odd when a is negative.");
  }
  if (a === 0) {
    return inv2 ? Infinity : 0;
  }
  if (!isFinite(a)) {
    return inv2 ? 0 : a;
  }
  var x = Math.pow(Math.abs(a), 1 / root);
  x = a < 0 ? -x : x;
  return inv2 ? 1 / x : x;
}
function signNumber(x) {
  return sign$2(x);
}
signNumber.signature = n1$4;
function squareNumber(x) {
  return x * x;
}
squareNumber.signature = n1$4;
function xgcdNumber(a, b) {
  var t;
  var q;
  var r;
  var x = 0;
  var lastx = 1;
  var y = 1;
  var lasty = 0;
  if (!isInteger$1(a) || !isInteger$1(b)) {
    throw new Error("Parameters in function xgcd must be integer numbers");
  }
  while (b) {
    q = Math.floor(a / b);
    r = a - q * b;
    t = x;
    x = lastx - q * x;
    lastx = t;
    t = y;
    y = lasty - q * y;
    lasty = t;
    a = b;
    b = r;
  }
  var res;
  if (a < 0) {
    res = [-a, -lastx, -lasty];
  } else {
    res = [a, a ? lastx : 0, lasty];
  }
  return res;
}
xgcdNumber.signature = n2$2;
function powNumber(x, y) {
  if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
    return 0;
  }
  return Math.pow(x, y);
}
powNumber.signature = n2$2;
function roundNumber(value) {
  var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!isInteger$1(decimals) || decimals < 0 || decimals > 15) {
    throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");
  }
  return parseFloat(toFixed$1(value, decimals));
}
var n1$3 = "number";
var n2$1 = "number, number";
function bitAndNumber(x, y) {
  if (!isInteger$1(x) || !isInteger$1(y)) {
    throw new Error("Integers expected in function bitAnd");
  }
  return x & y;
}
bitAndNumber.signature = n2$1;
function bitNotNumber(x) {
  if (!isInteger$1(x)) {
    throw new Error("Integer expected in function bitNot");
  }
  return ~x;
}
bitNotNumber.signature = n1$3;
function bitOrNumber(x, y) {
  if (!isInteger$1(x) || !isInteger$1(y)) {
    throw new Error("Integers expected in function bitOr");
  }
  return x | y;
}
bitOrNumber.signature = n2$1;
function bitXorNumber(x, y) {
  if (!isInteger$1(x) || !isInteger$1(y)) {
    throw new Error("Integers expected in function bitXor");
  }
  return x ^ y;
}
bitXorNumber.signature = n2$1;
function leftShiftNumber(x, y) {
  if (!isInteger$1(x) || !isInteger$1(y)) {
    throw new Error("Integers expected in function leftShift");
  }
  return x << y;
}
leftShiftNumber.signature = n2$1;
function rightArithShiftNumber(x, y) {
  if (!isInteger$1(x) || !isInteger$1(y)) {
    throw new Error("Integers expected in function rightArithShift");
  }
  return x >> y;
}
rightArithShiftNumber.signature = n2$1;
function rightLogShiftNumber(x, y) {
  if (!isInteger$1(x) || !isInteger$1(y)) {
    throw new Error("Integers expected in function rightLogShift");
  }
  return x >>> y;
}
rightLogShiftNumber.signature = n2$1;
function product(i2, n) {
  if (n < i2) {
    return 1;
  }
  if (n === i2) {
    return n;
  }
  var half = n + i2 >> 1;
  return product(i2, half) * product(half + 1, n);
}
function combinationsNumber(n, k) {
  if (!isInteger$1(n) || n < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (!isInteger$1(k) || k < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (k > n) {
    throw new TypeError("k must be less than or equal to n");
  }
  var nMinusk = n - k;
  var answer = 1;
  var firstnumerator = k < nMinusk ? nMinusk + 1 : k + 1;
  var nextdivisor = 2;
  var lastdivisor = k < nMinusk ? k : nMinusk;
  for (var nextnumerator = firstnumerator; nextnumerator <= n; ++nextnumerator) {
    answer *= nextnumerator;
    while (nextdivisor <= lastdivisor && answer % nextdivisor === 0) {
      answer /= nextdivisor;
      ++nextdivisor;
    }
  }
  if (nextdivisor <= lastdivisor) {
    answer /= product(nextdivisor, lastdivisor);
  }
  return answer;
}
combinationsNumber.signature = "number, number";
var pi$1 = Math.PI;
var tau$1 = 2 * Math.PI;
var e$1 = Math.E;
var phi$1 = 1.618033988749895;
var n1$2 = "number";
var n2 = "number, number";
function notNumber(x) {
  return !x;
}
notNumber.signature = n1$2;
function orNumber(x, y) {
  return !!(x || y);
}
orNumber.signature = n2;
function xorNumber(x, y) {
  return !!x !== !!y;
}
xorNumber.signature = n2;
function andNumber(x, y) {
  return !!(x && y);
}
andNumber.signature = n2;
function gammaNumber(n) {
  var x;
  if (isInteger$1(n)) {
    if (n <= 0) {
      return isFinite(n) ? Infinity : NaN;
    }
    if (n > 171) {
      return Infinity;
    }
    return product(1, n - 1);
  }
  if (n < 0.5) {
    return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
  }
  if (n >= 171.35) {
    return Infinity;
  }
  if (n > 85) {
    var twoN = n * n;
    var threeN = twoN * n;
    var fourN = threeN * n;
    var fiveN = fourN * n;
    return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
  }
  --n;
  x = gammaP[0];
  for (var i2 = 1; i2 < gammaP.length; ++i2) {
    x += gammaP[i2] / (n + i2);
  }
  var t = n + gammaG + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
}
gammaNumber.signature = "number";
var gammaG = 4.7421875;
var gammaP = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22];
var lnSqrt2PI = 0.9189385332046728;
var lgammaG = 5;
var lgammaN = 7;
var lgammaSeries = [1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -5395239384953e-18];
function lgammaNumber(n) {
  if (n < 0)
    return NaN;
  if (n === 0)
    return Infinity;
  if (!isFinite(n))
    return n;
  if (n < 0.5) {
    return Math.log(Math.PI / Math.sin(Math.PI * n)) - lgammaNumber(1 - n);
  }
  n = n - 1;
  var base2 = n + lgammaG + 0.5;
  var sum2 = lgammaSeries[0];
  for (var i2 = lgammaN - 1; i2 >= 1; i2--) {
    sum2 += lgammaSeries[i2] / (n + i2);
  }
  return lnSqrt2PI + (n + 0.5) * Math.log(base2) - base2 + Math.log(sum2);
}
lgammaNumber.signature = "number";
var n1$1 = "number";
function acoshNumber(x) {
  return acosh$2(x);
}
acoshNumber.signature = n1$1;
function acotNumber(x) {
  return Math.atan(1 / x);
}
acotNumber.signature = n1$1;
function acothNumber(x) {
  return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;
}
acothNumber.signature = n1$1;
function acscNumber(x) {
  return Math.asin(1 / x);
}
acscNumber.signature = n1$1;
function acschNumber(x) {
  var xInv = 1 / x;
  return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
}
acschNumber.signature = n1$1;
function asecNumber(x) {
  return Math.acos(1 / x);
}
asecNumber.signature = n1$1;
function asechNumber(x) {
  var xInv = 1 / x;
  var ret = Math.sqrt(xInv * xInv - 1);
  return Math.log(ret + xInv);
}
asechNumber.signature = n1$1;
function asinhNumber(x) {
  return asinh$2(x);
}
asinhNumber.signature = n1$1;
function atanhNumber(x) {
  return atanh$2(x);
}
atanhNumber.signature = n1$1;
function cotNumber(x) {
  return 1 / Math.tan(x);
}
cotNumber.signature = n1$1;
function cothNumber(x) {
  var e2 = Math.exp(2 * x);
  return (e2 + 1) / (e2 - 1);
}
cothNumber.signature = n1$1;
function cscNumber(x) {
  return 1 / Math.sin(x);
}
cscNumber.signature = n1$1;
function cschNumber(x) {
  if (x === 0) {
    return Number.POSITIVE_INFINITY;
  } else {
    return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign$2(x);
  }
}
cschNumber.signature = n1$1;
function secNumber(x) {
  return 1 / Math.cos(x);
}
secNumber.signature = n1$1;
function sechNumber(x) {
  return 2 / (Math.exp(x) + Math.exp(-x));
}
sechNumber.signature = n1$1;
function sinhNumber(x) {
  return sinh$2(x);
}
sinhNumber.signature = n1$1;
var n1 = "number";
function isNegativeNumber(x) {
  return x < 0;
}
isNegativeNumber.signature = n1;
function isPositiveNumber(x) {
  return x > 0;
}
isPositiveNumber.signature = n1;
function isZeroNumber(x) {
  return x === 0;
}
isZeroNumber.signature = n1;
function isNaNNumber(x) {
  return Number.isNaN(x);
}
isNaNNumber.signature = n1;
var name$4u = "isNegative";
var dependencies$4u = ["typed"];
var createIsNegative = /* @__PURE__ */ factory(name$4u, dependencies$4u, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4u, {
    number: isNegativeNumber,
    BigNumber: function BigNumber2(x) {
      return x.isNeg() && !x.isZero() && !x.isNaN();
    },
    Fraction: function Fraction2(x) {
      return x.s < 0;
    },
    Unit: typed2.referToSelf((self2) => (x) => typed2.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4t = "isNumeric";
var dependencies$4t = ["typed"];
var createIsNumeric = /* @__PURE__ */ factory(name$4t, dependencies$4t, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4t, {
    "number | BigNumber | Fraction | boolean": () => true,
    "Complex | Unit | string | null | undefined | Node": () => false,
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4s = "hasNumericValue";
var dependencies$4s = ["typed", "isNumeric"];
var createHasNumericValue = /* @__PURE__ */ factory(name$4s, dependencies$4s, (_ref) => {
  var {
    typed: typed2,
    isNumeric: isNumeric2
  } = _ref;
  return typed2(name$4s, {
    boolean: () => true,
    string: function string2(x) {
      return x.trim().length > 0 && !isNaN(Number(x));
    },
    any: function any(x) {
      return isNumeric2(x);
    }
  });
});
var name$4r = "isPositive";
var dependencies$4r = ["typed"];
var createIsPositive = /* @__PURE__ */ factory(name$4r, dependencies$4r, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4r, {
    number: isPositiveNumber,
    BigNumber: function BigNumber2(x) {
      return !x.isNeg() && !x.isZero() && !x.isNaN();
    },
    Fraction: function Fraction2(x) {
      return x.s > 0 && x.n > 0;
    },
    Unit: typed2.referToSelf((self2) => (x) => typed2.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4q = "isZero";
var dependencies$4q = ["typed"];
var createIsZero = /* @__PURE__ */ factory(name$4q, dependencies$4q, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4q, {
    number: isZeroNumber,
    BigNumber: function BigNumber2(x) {
      return x.isZero();
    },
    Complex: function Complex2(x) {
      return x.re === 0 && x.im === 0;
    },
    Fraction: function Fraction2(x) {
      return x.d === 1 && x.n === 0;
    },
    Unit: typed2.referToSelf((self2) => (x) => typed2.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4p = "isNaN";
var dependencies$4p = ["typed"];
var createIsNaN = /* @__PURE__ */ factory(name$4p, dependencies$4p, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4p, {
    number: isNaNNumber,
    BigNumber: function BigNumber2(x) {
      return x.isNaN();
    },
    Fraction: function Fraction2(x) {
      return false;
    },
    Complex: function Complex2(x) {
      return x.isNaN();
    },
    Unit: function Unit2(x) {
      return Number.isNaN(x.value);
    },
    "Array | Matrix": function ArrayMatrix(x) {
      return deepMap(x, Number.isNaN);
    }
  });
});
var name$4o = "typeOf";
var dependencies$4o = ["typed"];
var createTypeOf = /* @__PURE__ */ factory(name$4o, dependencies$4o, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4o, {
    any: typeOf$1
  });
});
function nearlyEqual(x, y, epsilon) {
  if (epsilon === null || epsilon === void 0) {
    return x.eq(y);
  }
  if (x.eq(y)) {
    return true;
  }
  if (x.isNaN() || y.isNaN()) {
    return false;
  }
  if (x.isFinite() && y.isFinite()) {
    var diff2 = x.minus(y).abs();
    if (diff2.isZero()) {
      return true;
    } else {
      var max3 = x.constructor.max(x.abs(), y.abs());
      return diff2.lte(max3.times(epsilon));
    }
  }
  return false;
}
function complexEquals(x, y, epsilon) {
  return nearlyEqual$1(x.re, y.re, epsilon) && nearlyEqual$1(x.im, y.im, epsilon);
}
var createCompareUnits = /* @__PURE__ */ factory("compareUnits", ["typed"], (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return {
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => {
      if (!x.equalBase(y)) {
        throw new Error("Cannot compare units with different base");
      }
      return typed2.find(self2, [x.valueType(), y.valueType()])(x.value, y.value);
    })
  };
});
var name$4n = "equalScalar";
var dependencies$4n = ["typed", "config"];
var createEqualScalar = /* @__PURE__ */ factory(name$4n, dependencies$4n, (_ref) => {
  var {
    typed: typed2,
    config: config3
  } = _ref;
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name$4n, {
    "boolean, boolean": function booleanBoolean(x, y) {
      return x === y;
    },
    "number, number": function numberNumber(x, y) {
      return nearlyEqual$1(x, y, config3.epsilon);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.eq(y) || nearlyEqual(x, y, config3.epsilon);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.equals(y);
    },
    "Complex, Complex": function ComplexComplex(x, y) {
      return complexEquals(x, y, config3.epsilon);
    }
  }, compareUnits);
});
factory(name$4n, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config3
  } = _ref2;
  return typed2(name$4n, {
    "number, number": function numberNumber(x, y) {
      return nearlyEqual$1(x, y, config3.epsilon);
    }
  });
});
var name$4m = "SparseMatrix";
var dependencies$4m = ["typed", "equalScalar", "Matrix"];
var createSparseMatrixClass = /* @__PURE__ */ factory(name$4m, dependencies$4m, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2,
    Matrix: Matrix2
  } = _ref;
  function SparseMatrix2(data, datatype) {
    if (!(this instanceof SparseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      _createFromMatrix(this, data, datatype);
    } else if (data && isArray$1(data.index) && isArray$1(data.ptr) && isArray$1(data.size)) {
      this._values = data.values;
      this._index = data.index;
      this._ptr = data.ptr;
      this._size = data.size;
      this._datatype = datatype || data.datatype;
    } else if (isArray$1(data)) {
      _createFromArray(this, data, datatype);
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf$1(data) + ")");
    } else {
      this._values = [];
      this._index = [];
      this._ptr = [0];
      this._size = [0, 0];
      this._datatype = datatype;
    }
  }
  function _createFromMatrix(matrix2, source, datatype) {
    if (source.type === "SparseMatrix") {
      matrix2._values = source._values ? clone$2(source._values) : void 0;
      matrix2._index = clone$2(source._index);
      matrix2._ptr = clone$2(source._ptr);
      matrix2._size = clone$2(source._size);
      matrix2._datatype = datatype || source._datatype;
    } else {
      _createFromArray(matrix2, source.valueOf(), datatype || source._datatype);
    }
  }
  function _createFromArray(matrix2, data, datatype) {
    matrix2._values = [];
    matrix2._index = [];
    matrix2._ptr = [];
    matrix2._datatype = datatype;
    var rows = data.length;
    var columns = 0;
    var eq = equalScalar2;
    var zero2 = 0;
    if (isString(datatype)) {
      eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
      zero2 = typed2.convert(0, datatype);
    }
    if (rows > 0) {
      var j = 0;
      do {
        matrix2._ptr.push(matrix2._index.length);
        for (var i2 = 0; i2 < rows; i2++) {
          var row2 = data[i2];
          if (isArray$1(row2)) {
            if (j === 0 && columns < row2.length) {
              columns = row2.length;
            }
            if (j < row2.length) {
              var v = row2[j];
              if (!eq(v, zero2)) {
                matrix2._values.push(v);
                matrix2._index.push(i2);
              }
            }
          } else {
            if (j === 0 && columns < 1) {
              columns = 1;
            }
            if (!eq(row2, zero2)) {
              matrix2._values.push(row2);
              matrix2._index.push(i2);
            }
          }
        }
        j++;
      } while (j < columns);
    }
    matrix2._ptr.push(matrix2._index.length);
    matrix2._size = [rows, columns];
  }
  SparseMatrix2.prototype = new Matrix2();
  SparseMatrix2.prototype.createSparseMatrix = function(data, datatype) {
    return new SparseMatrix2(data, datatype);
  };
  Object.defineProperty(SparseMatrix2, "name", {
    value: "SparseMatrix"
  });
  SparseMatrix2.prototype.constructor = SparseMatrix2;
  SparseMatrix2.prototype.type = "SparseMatrix";
  SparseMatrix2.prototype.isSparseMatrix = true;
  SparseMatrix2.prototype.getDataType = function() {
    return getArrayDataType(this._values, typeOf$1);
  };
  SparseMatrix2.prototype.storage = function() {
    return "sparse";
  };
  SparseMatrix2.prototype.datatype = function() {
    return this._datatype;
  };
  SparseMatrix2.prototype.create = function(data, datatype) {
    return new SparseMatrix2(data, datatype);
  };
  SparseMatrix2.prototype.density = function() {
    var rows = this._size[0];
    var columns = this._size[1];
    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
  };
  SparseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
    if (!this._values) {
      throw new Error("Cannot invoke subset on a Pattern only matrix");
    }
    switch (arguments.length) {
      case 1:
        return _getsubset(this, index2);
      case 2:
      case 3:
        return _setsubset(this, index2, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  function _getsubset(matrix2, idx) {
    if (!isIndex(idx)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = idx.isScalar();
    if (isScalar) {
      return matrix2.get(idx.min());
    }
    var size2 = idx.size();
    if (size2.length !== matrix2._size.length) {
      throw new DimensionError(size2.length, matrix2._size.length);
    }
    var i2, ii, k, kk;
    var min3 = idx.min();
    var max3 = idx.max();
    for (i2 = 0, ii = matrix2._size.length; i2 < ii; i2++) {
      validateIndex(min3[i2], matrix2._size[i2]);
      validateIndex(max3[i2], matrix2._size[i2]);
    }
    var mvalues = matrix2._values;
    var mindex = matrix2._index;
    var mptr = matrix2._ptr;
    var rows = idx.dimension(0);
    var columns = idx.dimension(1);
    var w = [];
    var pv = [];
    rows.forEach(function(i3, r) {
      pv[i3] = r[0];
      w[i3] = true;
    });
    var values2 = mvalues ? [] : void 0;
    var index2 = [];
    var ptr = [];
    columns.forEach(function(j) {
      ptr.push(index2.length);
      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
        i2 = mindex[k];
        if (w[i2] === true) {
          index2.push(pv[i2]);
          if (values2) {
            values2.push(mvalues[k]);
          }
        }
      }
    });
    ptr.push(index2.length);
    return new SparseMatrix2({
      values: values2,
      index: index2,
      ptr,
      size: size2,
      datatype: matrix2._datatype
    });
  }
  function _setsubset(matrix2, index2, submatrix, defaultValue) {
    if (!index2 || index2.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index2.size();
    var isScalar = index2.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.toArray();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix2.set(index2.min(), submatrix, defaultValue);
    } else {
      if (iSize.length !== 1 && iSize.length !== 2) {
        throw new DimensionError(iSize.length, matrix2._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i2 = 0;
        var outer = 0;
        while (iSize[i2] === 1 && sSize[i2] === 1) {
          i2++;
        }
        while (iSize[i2] === 1) {
          outer++;
          i2++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      if (iSize.length === 1) {
        var range2 = index2.dimension(0);
        range2.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          matrix2.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
        });
      } else {
        var firstDimensionRange = index2.dimension(0);
        var secondDimensionRange = index2.dimension(1);
        firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
          validateIndex(firstDataIndex);
          secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
            validateIndex(secondDataIndex);
            matrix2.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
          });
        });
      }
    }
    return matrix2;
  }
  SparseMatrix2.prototype.get = function(index2) {
    if (!isArray$1(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke get on a Pattern only matrix");
    }
    var i2 = index2[0];
    var j = index2[1];
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[1]);
    var k = _getValueIndex(i2, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i2) {
      return this._values[k];
    }
    return 0;
  };
  SparseMatrix2.prototype.set = function(index2, v, defaultValue) {
    if (!isArray$1(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke set on a Pattern only matrix");
    }
    var i2 = index2[0];
    var j = index2[1];
    var rows = this._size[0];
    var columns = this._size[1];
    var eq = equalScalar2;
    var zero2 = 0;
    if (isString(this._datatype)) {
      eq = typed2.find(equalScalar2, [this._datatype, this._datatype]) || equalScalar2;
      zero2 = typed2.convert(0, this._datatype);
    }
    if (i2 > rows - 1 || j > columns - 1) {
      _resize2(this, Math.max(i2 + 1, rows), Math.max(j + 1, columns), defaultValue);
      rows = this._size[0];
      columns = this._size[1];
    }
    validateIndex(i2, rows);
    validateIndex(j, columns);
    var k = _getValueIndex(i2, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i2) {
      if (!eq(v, zero2)) {
        this._values[k] = v;
      } else {
        _remove(k, j, this._values, this._index, this._ptr);
      }
    } else {
      _insert(k, i2, j, v, this._values, this._index, this._ptr);
    }
    return this;
  };
  function _getValueIndex(i2, top, bottom, index2) {
    if (bottom - top === 0) {
      return bottom;
    }
    for (var r = top; r < bottom; r++) {
      if (index2[r] === i2) {
        return r;
      }
    }
    return top;
  }
  function _remove(k, j, values2, index2, ptr) {
    values2.splice(k, 1);
    index2.splice(k, 1);
    for (var x = j + 1; x < ptr.length; x++) {
      ptr[x]--;
    }
  }
  function _insert(k, i2, j, v, values2, index2, ptr) {
    values2.splice(k, 0, v);
    index2.splice(k, 0, i2);
    for (var x = j + 1; x < ptr.length; x++) {
      ptr[x]++;
    }
  }
  SparseMatrix2.prototype.resize = function(size2, defaultValue, copy2) {
    if (!isCollection$1(size2)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size2.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    if (sizeArray.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    sizeArray.forEach(function(value) {
      if (!isNumber(value) || !isInteger$1(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format$1(sizeArray) + ")");
      }
    });
    var m = copy2 ? this.clone() : this;
    return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
  };
  function _resize2(matrix2, rows, columns, defaultValue) {
    var value = defaultValue || 0;
    var eq = equalScalar2;
    var zero2 = 0;
    if (isString(matrix2._datatype)) {
      eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
      zero2 = typed2.convert(0, matrix2._datatype);
      value = typed2.convert(value, matrix2._datatype);
    }
    var ins = !eq(value, zero2);
    var r = matrix2._size[0];
    var c = matrix2._size[1];
    var i2, j, k;
    if (columns > c) {
      for (j = c; j < columns; j++) {
        matrix2._ptr[j] = matrix2._values.length;
        if (ins) {
          for (i2 = 0; i2 < r; i2++) {
            matrix2._values.push(value);
            matrix2._index.push(i2);
          }
        }
      }
      matrix2._ptr[columns] = matrix2._values.length;
    } else if (columns < c) {
      matrix2._ptr.splice(columns + 1, c - columns);
      matrix2._values.splice(matrix2._ptr[columns], matrix2._values.length);
      matrix2._index.splice(matrix2._ptr[columns], matrix2._index.length);
    }
    c = columns;
    if (rows > r) {
      if (ins) {
        var n = 0;
        for (j = 0; j < c; j++) {
          matrix2._ptr[j] = matrix2._ptr[j] + n;
          k = matrix2._ptr[j + 1] + n;
          var p2 = 0;
          for (i2 = r; i2 < rows; i2++, p2++) {
            matrix2._values.splice(k + p2, 0, value);
            matrix2._index.splice(k + p2, 0, i2);
            n++;
          }
        }
        matrix2._ptr[c] = matrix2._values.length;
      }
    } else if (rows < r) {
      var d = 0;
      for (j = 0; j < c; j++) {
        matrix2._ptr[j] = matrix2._ptr[j] - d;
        var k0 = matrix2._ptr[j];
        var k1 = matrix2._ptr[j + 1] - d;
        for (k = k0; k < k1; k++) {
          i2 = matrix2._index[k];
          if (i2 > rows - 1) {
            matrix2._values.splice(k, 1);
            matrix2._index.splice(k, 1);
            d++;
          }
        }
      }
      matrix2._ptr[j] = matrix2._values.length;
    }
    matrix2._size[0] = rows;
    matrix2._size[1] = columns;
    return matrix2;
  }
  SparseMatrix2.prototype.reshape = function(sizes, copy2) {
    if (!isArray$1(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length !== 2) {
      throw new Error("Sparse matrices can only be reshaped in two dimensions");
    }
    sizes.forEach(function(value) {
      if (!isNumber(value) || !isInteger$1(value) || value <= -2 || value === 0) {
        throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format$1(sizes) + ")");
      }
    });
    var currentLength = this._size[0] * this._size[1];
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = sizes[0] * sizes[1];
    if (currentLength !== newLength) {
      throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
    }
    var m = copy2 ? this.clone() : this;
    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
      return m;
    }
    var colIndex = [];
    for (var i2 = 0; i2 < m._ptr.length; i2++) {
      for (var j = 0; j < m._ptr[i2 + 1] - m._ptr[i2]; j++) {
        colIndex.push(i2);
      }
    }
    var values2 = m._values.slice();
    var rowIndex = m._index.slice();
    for (var _i = 0; _i < m._index.length; _i++) {
      var r1 = rowIndex[_i];
      var c1 = colIndex[_i];
      var flat = r1 * m._size[1] + c1;
      colIndex[_i] = flat % sizes[1];
      rowIndex[_i] = Math.floor(flat / sizes[1]);
    }
    m._values.length = 0;
    m._index.length = 0;
    m._ptr.length = sizes[1] + 1;
    m._size = sizes.slice();
    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
      m._ptr[_i2] = 0;
    }
    for (var h2 = 0; h2 < values2.length; h2++) {
      var _i3 = rowIndex[h2];
      var _j = colIndex[h2];
      var v = values2[h2];
      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
    }
    return m;
  };
  SparseMatrix2.prototype.clone = function() {
    var m = new SparseMatrix2({
      values: this._values ? clone$2(this._values) : void 0,
      index: clone$2(this._index),
      ptr: clone$2(this._ptr),
      size: clone$2(this._size),
      datatype: this._datatype
    });
    return m;
  };
  SparseMatrix2.prototype.size = function() {
    return this._size.slice(0);
  };
  SparseMatrix2.prototype.map = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke map on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    var args = maxArgumentCount(callback);
    var invoke = function invoke2(v, i2, j) {
      if (args === 1)
        return callback(v);
      if (args === 2)
        return callback(v, [i2, j]);
      return callback(v, [i2, j], me);
    };
    return _map2(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
  };
  function _map2(matrix2, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
    var values2 = [];
    var index2 = [];
    var ptr = [];
    var eq = equalScalar2;
    var zero2 = 0;
    if (isString(matrix2._datatype)) {
      eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
      zero2 = typed2.convert(0, matrix2._datatype);
    }
    var invoke = function invoke2(v, x, y) {
      v = callback(v, x, y);
      if (!eq(v, zero2)) {
        values2.push(v);
        index2.push(x);
      }
    };
    for (var j = minColumn; j <= maxColumn; j++) {
      ptr.push(values2.length);
      var k0 = matrix2._ptr[j];
      var k1 = matrix2._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0; k < k1; k++) {
          var i2 = matrix2._index[k];
          if (i2 >= minRow && i2 <= maxRow) {
            invoke(matrix2._values[k], i2 - minRow, j - minColumn);
          }
        }
      } else {
        var _values = {};
        for (var _k = k0; _k < k1; _k++) {
          var _i4 = matrix2._index[_k];
          _values[_i4] = matrix2._values[_k];
        }
        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
          var value = _i5 in _values ? _values[_i5] : 0;
          invoke(value, _i5 - minRow, j - minColumn);
        }
      }
    }
    ptr.push(values2.length);
    return new SparseMatrix2({
      values: values2,
      index: index2,
      ptr,
      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
    });
  }
  SparseMatrix2.prototype.forEach = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke forEach on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0; k < k1; k++) {
          var i2 = this._index[k];
          callback(this._values[k], [i2, j], me);
        }
      } else {
        var values2 = {};
        for (var _k2 = k0; _k2 < k1; _k2++) {
          var _i6 = this._index[_k2];
          values2[_i6] = this._values[_k2];
        }
        for (var _i7 = 0; _i7 < rows; _i7++) {
          var value = _i7 in values2 ? values2[_i7] : 0;
          callback(value, [_i7, j], me);
        }
      }
    }
  };
  SparseMatrix2.prototype[Symbol.iterator] = function* () {
    if (!this._values) {
      throw new Error("Cannot iterate a Pattern only matrix");
    }
    var columns = this._size[1];
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        var i2 = this._index[k];
        yield {
          value: this._values[k],
          index: [i2, j]
        };
      }
    }
  };
  SparseMatrix2.prototype.toArray = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, true);
  };
  SparseMatrix2.prototype.valueOf = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, false);
  };
  function _toArray(values2, index2, ptr, size2, copy2) {
    var rows = size2[0];
    var columns = size2[1];
    var a = [];
    var i2, j;
    for (i2 = 0; i2 < rows; i2++) {
      a[i2] = [];
      for (j = 0; j < columns; j++) {
        a[i2][j] = 0;
      }
    }
    for (j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        i2 = index2[k];
        a[i2][j] = values2 ? copy2 ? clone$2(values2[k]) : values2[k] : 1;
      }
    }
    return a;
  }
  SparseMatrix2.prototype.format = function(options) {
    var rows = this._size[0];
    var columns = this._size[1];
    var density = this.density();
    var str = "Sparse Matrix [" + format$1(rows, options) + " x " + format$1(columns, options) + "] density: " + format$1(density, options) + "\n";
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        var i2 = this._index[k];
        str += "\n    (" + format$1(i2, options) + ", " + format$1(j, options) + ") ==> " + (this._values ? format$1(this._values[k], options) : "X");
      }
    }
    return str;
  };
  SparseMatrix2.prototype.toString = function() {
    return format$1(this.toArray());
  };
  SparseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "SparseMatrix",
      values: this._values,
      index: this._index,
      ptr: this._ptr,
      size: this._size,
      datatype: this._datatype
    };
  };
  SparseMatrix2.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger$1(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var values2 = [];
    var index2 = [];
    var ptr = [];
    ptr[0] = 0;
    for (var j = kSuper; j < columns && values2.length < n; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var x = k0; x < k1; x++) {
        var i2 = this._index[x];
        if (i2 === j - kSuper + kSub) {
          values2.push(this._values[x]);
          index2[values2.length - 1] = i2 - kSub;
          break;
        }
      }
    }
    ptr.push(values2.length);
    return new SparseMatrix2({
      values: values2,
      index: index2,
      ptr,
      size: [n, 1]
    });
  };
  SparseMatrix2.fromJSON = function(json) {
    return new SparseMatrix2(json);
  };
  SparseMatrix2.diagonal = function(size2, value, k, defaultValue, datatype) {
    if (!isArray$1(size2)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size2.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size2 = size2.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger$1(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger$1(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var eq = equalScalar2;
    var zero2 = 0;
    if (isString(datatype)) {
      eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
      zero2 = typed2.convert(0, datatype);
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size2[0];
    var columns = size2[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray$1(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i3) {
        return value[i3];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i3) {
        return value.get([i3]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    var values2 = [];
    var index2 = [];
    var ptr = [];
    for (var j = 0; j < columns; j++) {
      ptr.push(values2.length);
      var i2 = j - kSuper;
      if (i2 >= 0 && i2 < n) {
        var v = _value(i2);
        if (!eq(v, zero2)) {
          index2.push(i2 + kSub);
          values2.push(v);
        }
      }
    }
    ptr.push(values2.length);
    return new SparseMatrix2({
      values: values2,
      index: index2,
      ptr,
      size: [rows, columns]
    });
  };
  SparseMatrix2.prototype.swapRows = function(i2, j) {
    if (!isNumber(i2) || !isInteger$1(i2) || !isNumber(j) || !isInteger$1(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[0]);
    SparseMatrix2._swapRows(i2, j, this._size[1], this._values, this._index, this._ptr);
    return this;
  };
  SparseMatrix2._forEachRow = function(j, values2, index2, ptr, callback) {
    var k0 = ptr[j];
    var k1 = ptr[j + 1];
    for (var k = k0; k < k1; k++) {
      callback(index2[k], values2[k]);
    }
  };
  SparseMatrix2._swapRows = function(x, y, columns, values2, index2, ptr) {
    for (var j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      var kx = _getValueIndex(x, k0, k1, index2);
      var ky = _getValueIndex(y, k0, k1, index2);
      if (kx < k1 && ky < k1 && index2[kx] === x && index2[ky] === y) {
        if (values2) {
          var v = values2[kx];
          values2[kx] = values2[ky];
          values2[ky] = v;
        }
        continue;
      }
      if (kx < k1 && index2[kx] === x && (ky >= k1 || index2[ky] !== y)) {
        var vx = values2 ? values2[kx] : void 0;
        index2.splice(ky, 0, y);
        if (values2) {
          values2.splice(ky, 0, vx);
        }
        index2.splice(ky <= kx ? kx + 1 : kx, 1);
        if (values2) {
          values2.splice(ky <= kx ? kx + 1 : kx, 1);
        }
        continue;
      }
      if (ky < k1 && index2[ky] === y && (kx >= k1 || index2[kx] !== x)) {
        var vy = values2 ? values2[ky] : void 0;
        index2.splice(kx, 0, x);
        if (values2) {
          values2.splice(kx, 0, vy);
        }
        index2.splice(kx <= ky ? ky + 1 : ky, 1);
        if (values2) {
          values2.splice(kx <= ky ? ky + 1 : ky, 1);
        }
      }
    }
  };
  return SparseMatrix2;
}, {
  isClass: true
});
var name$4l = "number";
var dependencies$4l = ["typed"];
function getNonDecimalNumberParts(input) {
  var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
  if (nonDecimalWithRadixMatch) {
    var radix = {
      "0b": 2,
      "0o": 8,
      "0x": 16
    }[nonDecimalWithRadixMatch[1]];
    var integerPart = nonDecimalWithRadixMatch[2];
    var fractionalPart = nonDecimalWithRadixMatch[3];
    return {
      input,
      radix,
      integerPart,
      fractionalPart
    };
  } else {
    return null;
  }
}
function makeNumberFromNonDecimalParts(parts) {
  var n = parseInt(parts.integerPart, parts.radix);
  var f = 0;
  for (var i2 = 0; i2 < parts.fractionalPart.length; i2++) {
    var digitValue = parseInt(parts.fractionalPart[i2], parts.radix);
    f += digitValue / Math.pow(parts.radix, i2 + 1);
  }
  var result = n + f;
  if (isNaN(result)) {
    throw new SyntaxError('String "' + parts.input + '" is no valid number');
  }
  return result;
}
var createNumber = /* @__PURE__ */ factory(name$4l, dependencies$4l, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var number2 = typed2("number", {
    "": function _() {
      return 0;
    },
    number: function number3(x) {
      return x;
    },
    string: function string2(x) {
      if (x === "NaN")
        return NaN;
      var nonDecimalNumberParts = getNonDecimalNumberParts(x);
      if (nonDecimalNumberParts) {
        return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
      }
      var size2 = 0;
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        size2 = Number(wordSizeSuffixMatch[2]);
        x = wordSizeSuffixMatch[1];
      }
      var num = Number(x);
      if (isNaN(num)) {
        throw new SyntaxError('String "' + x + '" is no valid number');
      }
      if (wordSizeSuffixMatch) {
        if (num > 2 ** size2 - 1) {
          throw new SyntaxError('String "'.concat(x, '" is out of range'));
        }
        if (num >= 2 ** (size2 - 1)) {
          num = num - 2 ** size2;
        }
      }
      return num;
    },
    BigNumber: function BigNumber2(x) {
      return x.toNumber();
    },
    Fraction: function Fraction2(x) {
      return x.valueOf();
    },
    Unit: function Unit2(x) {
      throw new Error("Second argument with valueless unit expected");
    },
    null: function _null2(x) {
      return 0;
    },
    "Unit, string | Unit": function UnitStringUnit(unit2, valuelessUnit) {
      return unit2.toNumber(valuelessUnit);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
  number2.fromJSON = function(json) {
    return parseFloat(json.value);
  };
  return number2;
});
var name$4k = "string";
var dependencies$4k = ["typed"];
var createString = /* @__PURE__ */ factory(name$4k, dependencies$4k, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4k, {
    "": function _() {
      return "";
    },
    number: format$3,
    null: function _null2(x) {
      return "null";
    },
    boolean: function boolean2(x) {
      return x + "";
    },
    string: function string2(x) {
      return x;
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2)),
    any: function any(x) {
      return String(x);
    }
  });
});
var name$4j = "boolean";
var dependencies$4j = ["typed"];
var createBoolean = /* @__PURE__ */ factory(name$4j, dependencies$4j, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4j, {
    "": function _() {
      return false;
    },
    boolean: function boolean2(x) {
      return x;
    },
    number: function number2(x) {
      return !!x;
    },
    null: function _null2(x) {
      return false;
    },
    BigNumber: function BigNumber2(x) {
      return !x.isZero();
    },
    string: function string2(x) {
      var lcase = x.toLowerCase();
      if (lcase === "true") {
        return true;
      } else if (lcase === "false") {
        return false;
      }
      var num = Number(x);
      if (x !== "" && !isNaN(num)) {
        return !!num;
      }
      throw new Error('Cannot convert "' + x + '" to a boolean');
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4i = "bignumber";
var dependencies$4i = ["typed", "BigNumber"];
var createBignumber = /* @__PURE__ */ factory(name$4i, dependencies$4i, (_ref) => {
  var {
    typed: typed2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2("bignumber", {
    "": function _() {
      return new BigNumber2(0);
    },
    number: function number2(x) {
      return new BigNumber2(x + "");
    },
    string: function string2(x) {
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        var size2 = wordSizeSuffixMatch[2];
        var n = BigNumber2(wordSizeSuffixMatch[1]);
        var twoPowSize = new BigNumber2(2).pow(Number(size2));
        if (n.gt(twoPowSize.sub(1))) {
          throw new SyntaxError('String "'.concat(x, '" is out of range'));
        }
        var twoPowSizeSubOne = new BigNumber2(2).pow(Number(size2) - 1);
        if (n.gte(twoPowSizeSubOne)) {
          return n.sub(twoPowSize);
        } else {
          return n;
        }
      }
      return new BigNumber2(x);
    },
    BigNumber: function BigNumber3(x) {
      return x;
    },
    Fraction: function Fraction2(x) {
      return new BigNumber2(x.n).div(x.d).times(x.s);
    },
    null: function _null2(x) {
      return new BigNumber2(0);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4h = "complex";
var dependencies$4h = ["typed", "Complex"];
var createComplex = /* @__PURE__ */ factory(name$4h, dependencies$4h, (_ref) => {
  var {
    typed: typed2,
    Complex: Complex2
  } = _ref;
  return typed2("complex", {
    "": function _() {
      return Complex2.ZERO;
    },
    number: function number2(x) {
      return new Complex2(x, 0);
    },
    "number, number": function numberNumber(re2, im2) {
      return new Complex2(re2, im2);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(re2, im2) {
      return new Complex2(re2.toNumber(), im2.toNumber());
    },
    Fraction: function Fraction2(x) {
      return new Complex2(x.valueOf(), 0);
    },
    Complex: function Complex3(x) {
      return x.clone();
    },
    string: function string2(x) {
      return Complex2(x);
    },
    null: function _null2(x) {
      return Complex2(0);
    },
    Object: function Object2(x) {
      if ("re" in x && "im" in x) {
        return new Complex2(x.re, x.im);
      }
      if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
        return new Complex2(x);
      }
      throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4g = "fraction";
var dependencies$4g = ["typed", "Fraction"];
var createFraction = /* @__PURE__ */ factory(name$4g, dependencies$4g, (_ref) => {
  var {
    typed: typed2,
    Fraction: Fraction2
  } = _ref;
  return typed2("fraction", {
    number: function number2(x) {
      if (!isFinite(x) || isNaN(x)) {
        throw new Error(x + " cannot be represented as a fraction");
      }
      return new Fraction2(x);
    },
    string: function string2(x) {
      return new Fraction2(x);
    },
    "number, number": function numberNumber(numerator, denominator) {
      return new Fraction2(numerator, denominator);
    },
    null: function _null2(x) {
      return new Fraction2(0);
    },
    BigNumber: function BigNumber2(x) {
      return new Fraction2(x.toString());
    },
    Fraction: function Fraction3(x) {
      return x;
    },
    Object: function Object2(x) {
      return new Fraction2(x);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4f = "matrix";
var dependencies$4f = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
var createMatrix = /* @__PURE__ */ factory(name$4f, dependencies$4f, (_ref) => {
  var {
    typed: typed2,
    Matrix: Matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name$4f, {
    "": function _() {
      return _create([]);
    },
    string: function string2(format2) {
      return _create([], format2);
    },
    "string, string": function stringString(format2, datatype) {
      return _create([], format2, datatype);
    },
    Array: function Array2(data) {
      return _create(data);
    },
    Matrix: function Matrix3(data) {
      return _create(data, data.storage());
    },
    "Array | Matrix, string": _create,
    "Array | Matrix, string, string": _create
  });
  function _create(data, format2, datatype) {
    if (format2 === "dense" || format2 === "default" || format2 === void 0) {
      return new DenseMatrix2(data, datatype);
    }
    if (format2 === "sparse") {
      return new SparseMatrix2(data, datatype);
    }
    throw new TypeError("Unknown matrix type " + JSON.stringify(format2) + ".");
  }
});
var name$4e = "matrixFromFunction";
var dependencies$4e = ["typed", "matrix", "isZero"];
var createMatrixFromFunction = /* @__PURE__ */ factory(name$4e, dependencies$4e, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    isZero: isZero2
  } = _ref;
  return typed2(name$4e, {
    "Array | Matrix, function, string, string": function ArrayMatrixFunctionStringString(size2, fn, format2, datatype) {
      return _create(size2, fn, format2, datatype);
    },
    "Array | Matrix, function, string": function ArrayMatrixFunctionString(size2, fn, format2) {
      return _create(size2, fn, format2);
    },
    "Matrix, function": function MatrixFunction(size2, fn) {
      return _create(size2, fn, "dense");
    },
    "Array, function": function ArrayFunction(size2, fn) {
      return _create(size2, fn, "dense").toArray();
    },
    "Array | Matrix, string, function": function ArrayMatrixStringFunction(size2, format2, fn) {
      return _create(size2, fn, format2);
    },
    "Array | Matrix, string, string, function": function ArrayMatrixStringStringFunction(size2, format2, datatype, fn) {
      return _create(size2, fn, format2, datatype);
    }
  });
  function _create(size2, fn, format2, datatype) {
    var m;
    if (datatype !== void 0) {
      m = matrix2(format2, datatype);
    } else {
      m = matrix2(format2);
    }
    m.resize(size2);
    m.forEach(function(_, index2) {
      var val = fn(index2);
      if (isZero2(val))
        return;
      m.set(index2, val);
    });
    return m;
  }
});
var name$4d = "matrixFromRows";
var dependencies$4d = ["typed", "matrix", "flatten", "size"];
var createMatrixFromRows = /* @__PURE__ */ factory(name$4d, dependencies$4d, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    flatten: flatten4,
    size: size2
  } = _ref;
  return typed2(name$4d, {
    "...Array": function Array2(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix2(arr) {
      return matrix2(_createArray(arr.map((m) => m.toArray())));
    }
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one row is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var row2 of arr) {
      var rowLength = checkVectorTypeAndReturnLength(row2);
      if (rowLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (rowLength | 0));
      }
      result.push(flatten4(row2));
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size2(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});
var name$4c = "matrixFromColumns";
var dependencies$4c = ["typed", "matrix", "flatten", "size"];
var createMatrixFromColumns = /* @__PURE__ */ factory(name$4c, dependencies$4c, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    flatten: flatten4,
    size: size2
  } = _ref;
  return typed2(name$4c, {
    "...Array": function Array2(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix2(arr) {
      return matrix2(_createArray(arr.map((m) => m.toArray())));
    }
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one column is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var i2 = 0; i2 < N; i2++) {
      result[i2] = [];
    }
    for (var col of arr) {
      var colLength = checkVectorTypeAndReturnLength(col);
      if (colLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (colLength | 0));
      }
      var f = flatten4(col);
      for (var _i = 0; _i < N; _i++) {
        result[_i].push(f[_i]);
      }
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size2(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});
var name$4b = "splitUnit";
var dependencies$4b = ["typed"];
var createSplitUnit = /* @__PURE__ */ factory(name$4b, dependencies$4b, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4b, {
    "Unit, Array": function UnitArray(unit2, parts) {
      return unit2.splitUnit(parts);
    }
  });
});
var name$4a = "unaryMinus";
var dependencies$4a = ["typed"];
var createUnaryMinus = /* @__PURE__ */ factory(name$4a, dependencies$4a, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4a, {
    number: unaryMinusNumber,
    "Complex | BigNumber | Fraction": (x) => x.neg(),
    Unit: typed2.referToSelf((self2) => (x) => {
      var res = x.clone();
      res.value = typed2.find(self2, res.valueType())(x.value);
      return res;
    }),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$49 = "unaryPlus";
var dependencies$49 = ["typed", "config", "BigNumber"];
var createUnaryPlus = /* @__PURE__ */ factory(name$49, dependencies$49, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    BigNumber: BigNumber2
  } = _ref;
  return typed2(name$49, {
    number: unaryPlusNumber,
    Complex: function Complex2(x) {
      return x;
    },
    BigNumber: function BigNumber3(x) {
      return x;
    },
    Fraction: function Fraction2(x) {
      return x;
    },
    Unit: function Unit2(x) {
      return x.clone();
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2)),
    "boolean | string": function booleanString(x) {
      return config3.number === "BigNumber" ? new BigNumber2(+x) : +x;
    }
  });
});
var name$48 = "abs";
var dependencies$48 = ["typed"];
var createAbs = /* @__PURE__ */ factory(name$48, dependencies$48, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$48, {
    number: absNumber,
    "Complex | BigNumber | Fraction | Unit": (x) => x.abs(),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$47 = "apply";
var dependencies$47 = ["typed", "isInteger"];
var createApply = /* @__PURE__ */ factory(name$47, dependencies$47, (_ref) => {
  var {
    typed: typed2,
    isInteger: isInteger2
  } = _ref;
  return typed2(name$47, {
    "Array | Matrix, number | BigNumber, function": function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {
      if (!isInteger2(dim)) {
        throw new TypeError("Integer number expected for dimension");
      }
      var size2 = Array.isArray(mat) ? arraySize(mat) : mat.size();
      if (dim < 0 || dim >= size2.length) {
        throw new IndexError(dim, size2.length);
      }
      if (isMatrix(mat)) {
        return mat.create(_apply(mat.valueOf(), dim, callback));
      } else {
        return _apply(mat, dim, callback);
      }
    }
  });
});
function _apply(mat, dim, callback) {
  var i2, ret, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      return callback(mat);
    } else {
      tran = _switch(mat);
      ret = [];
      for (i2 = 0; i2 < tran.length; i2++) {
        ret[i2] = _apply(tran[i2], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i2 = 0; i2 < mat.length; i2++) {
      ret[i2] = _apply(mat[i2], dim - 1, callback);
    }
    return ret;
  }
}
function _switch(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i2, j;
  var ret = [];
  for (j = 0; j < J; j++) {
    var tmp = [];
    for (i2 = 0; i2 < I; i2++) {
      tmp.push(mat[i2][j]);
    }
    ret.push(tmp);
  }
  return ret;
}
var name$46 = "addScalar";
var dependencies$46 = ["typed"];
var createAddScalar = /* @__PURE__ */ factory(name$46, dependencies$46, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$46, {
    "number, number": addNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.add(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.plus(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.add(y);
    },
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => {
      if (x.value === null || x.value === void 0) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null || y.value === void 0) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y))
        throw new Error("Units do not match");
      var res = x.clone();
      res.value = typed2.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  });
});
var name$45 = "cbrt";
var dependencies$45 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
var createCbrt = /* @__PURE__ */ factory(name$45, dependencies$45, (_ref) => {
  var {
    config: config3,
    typed: typed2,
    isNegative: isNegative2,
    unaryMinus: unaryMinus2,
    matrix: matrix2,
    Complex: Complex2,
    BigNumber: BigNumber2,
    Fraction: Fraction2
  } = _ref;
  return typed2(name$45, {
    number: cbrtNumber,
    Complex: _cbrtComplex,
    "Complex, boolean": _cbrtComplex,
    BigNumber: function BigNumber3(x) {
      return x.cbrt();
    },
    Unit: _cbrtUnit
  });
  function _cbrtComplex(x, allRoots) {
    var arg3 = x.arg() / 3;
    var abs2 = x.abs();
    var principal = new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3).exp());
    if (allRoots) {
      var all = [principal, new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3 + Math.PI * 2 / 3).exp()), new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3 - Math.PI * 2 / 3).exp())];
      return config3.matrix === "Array" ? all : matrix2(all);
    } else {
      return principal;
    }
  }
  function _cbrtUnit(x) {
    if (x.value && isComplex(x.value)) {
      var result = x.clone();
      result.value = 1;
      result = result.pow(1 / 3);
      result.value = _cbrtComplex(x.value);
      return result;
    } else {
      var negate = isNegative2(x.value);
      if (negate) {
        x.value = unaryMinus2(x.value);
      }
      var third;
      if (isBigNumber(x.value)) {
        third = new BigNumber2(1).div(3);
      } else if (isFraction(x.value)) {
        third = new Fraction2(1, 3);
      } else {
        third = 1 / 3;
      }
      var _result = x.pow(third);
      if (negate) {
        _result.value = unaryMinus2(_result.value);
      }
      return _result;
    }
  }
});
var name$44 = "matAlgo11xS0s";
var dependencies$44 = ["typed", "equalScalar"];
var createMatAlgo11xS0s = /* @__PURE__ */ factory(name$44, dependencies$44, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo11xS0s(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero2 = 0;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var i2 = aindex[k];
        var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
        if (!eq(v, zero2)) {
          cindex.push(i2);
          cvalues.push(v);
        }
      }
    }
    cptr[columns] = cindex.length;
    return s.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$43 = "matAlgo12xSfs";
var dependencies$43 = ["typed", "DenseMatrix"];
var createMatAlgo12xSfs = /* @__PURE__ */ factory(name$43, dependencies$43, (_ref) => {
  var {
    typed: typed2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo12xSfs(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i2 = 0; i2 < rows; i2++) {
        if (j === 0) {
          cdata[i2] = [];
        }
        if (w[i2] === mark) {
          cdata[i2][j] = inverse ? cf(b, x[i2]) : cf(x[i2], b);
        } else {
          cdata[i2][j] = inverse ? cf(b, 0) : cf(0, b);
        }
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$42 = "matAlgo14xDs";
var dependencies$42 = ["typed"];
var createMatAlgo14xDs = /* @__PURE__ */ factory(name$42, dependencies$42, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function matAlgo14xDs(a, b, callback, inverse) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
    return a.createDenseMatrix({
      data: cdata,
      size: clone$2(asize),
      datatype: dt
    });
  };
  function _iterate(f, level, s, n, av, bv, inverse) {
    var cv = [];
    if (level === s.length - 1) {
      for (var i2 = 0; i2 < n; i2++) {
        cv[i2] = inverse ? f(bv, av[i2]) : f(av[i2], bv);
      }
    } else {
      for (var j = 0; j < n; j++) {
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
      }
    }
    return cv;
  }
});
var name$41 = "ceil";
var dependencies$41 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createCeilNumber = /* @__PURE__ */ factory(name$41, ["typed", "config", "round"], (_ref) => {
  var {
    typed: typed2,
    config: config3,
    round: round2
  } = _ref;
  return typed2(name$41, {
    number: function number2(x) {
      if (nearlyEqual$1(x, round2(x), config3.epsilon)) {
        return round2(x);
      } else {
        return Math.ceil(x);
      }
    },
    "number, number": function numberNumber(x, n) {
      if (nearlyEqual$1(x, round2(x, n), config3.epsilon)) {
        return round2(x, n);
      } else {
        var [number2, exponent] = "".concat(x, "e").split("e");
        var result = Math.ceil(Number("".concat(number2, "e").concat(Number(exponent) + n)));
        [number2, exponent] = "".concat(result, "e").split("e");
        return Number("".concat(number2, "e").concat(Number(exponent) - n));
      }
    }
  });
});
var createCeil = /* @__PURE__ */ factory(name$41, dependencies$41, (_ref2) => {
  var {
    typed: typed2,
    config: config3,
    round: round2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref2;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var ceilNumber = createCeilNumber({
    typed: typed2,
    config: config3,
    round: round2
  });
  return typed2("ceil", {
    number: ceilNumber.signatures.number,
    "number,number": ceilNumber.signatures["number,number"],
    Complex: function Complex2(x) {
      return x.ceil();
    },
    "Complex, number": function ComplexNumber(x, n) {
      return x.ceil(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x, n) {
      return x.ceil(n.toNumber());
    },
    BigNumber: function BigNumber2(x) {
      if (nearlyEqual(x, round2(x), config3.epsilon)) {
        return round2(x);
      } else {
        return x.ceil();
      }
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
      if (nearlyEqual(x, round2(x, n), config3.epsilon)) {
        return round2(x, n);
      } else {
        return x.toDecimalPlaces(n.toNumber(), Decimal.ROUND_CEIL);
      }
    },
    Fraction: function Fraction2(x) {
      return x.ceil();
    },
    "Fraction, number": function FractionNumber(x, n) {
      return x.ceil(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x, n) {
      return x.ceil(n.toNumber());
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => {
      return deepMap(x, self2);
    }),
    "Array, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i2) => self2(i2, n));
    }),
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0))
        return zeros2(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs(y, x, self2, true);
      }
      return matAlgo12xSfs(y, x, self2, true);
    })
  });
});
var name$40 = "cube";
var dependencies$40 = ["typed"];
var createCube = /* @__PURE__ */ factory(name$40, dependencies$40, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$40, {
    number: cubeNumber,
    Complex: function Complex2(x) {
      return x.mul(x).mul(x);
    },
    BigNumber: function BigNumber2(x) {
      return x.times(x).times(x);
    },
    Fraction: function Fraction2(x) {
      return x.pow(3);
    },
    Unit: function Unit2(x) {
      return x.pow(3);
    }
  });
});
var name$3$ = "exp";
var dependencies$3$ = ["typed"];
var createExp = /* @__PURE__ */ factory(name$3$, dependencies$3$, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3$, {
    number: expNumber,
    Complex: function Complex2(x) {
      return x.exp();
    },
    BigNumber: function BigNumber2(x) {
      return x.exp();
    }
  });
});
var name$3_ = "expm1";
var dependencies$3_ = ["typed", "Complex"];
var createExpm1 = /* @__PURE__ */ factory(name$3_, dependencies$3_, (_ref) => {
  var {
    typed: typed2,
    Complex: _Complex
  } = _ref;
  return typed2(name$3_, {
    number: expm1Number,
    Complex: function Complex2(x) {
      var r = Math.exp(x.re);
      return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
    },
    BigNumber: function BigNumber2(x) {
      return x.exp().minus(1);
    }
  });
});
var name$3Z = "fix";
var dependencies$3Z = ["typed", "Complex", "matrix", "ceil", "floor", "equalScalar", "zeros", "DenseMatrix"];
var createFixNumber = /* @__PURE__ */ factory(name$3Z, ["typed", "ceil", "floor"], (_ref) => {
  var {
    typed: typed2,
    ceil: ceil2,
    floor: floor2
  } = _ref;
  return typed2(name$3Z, {
    number: function number2(x) {
      return x > 0 ? floor2(x) : ceil2(x);
    },
    "number, number": function numberNumber(x, n) {
      return x > 0 ? floor2(x, n) : ceil2(x, n);
    }
  });
});
var createFix = /* @__PURE__ */ factory(name$3Z, dependencies$3Z, (_ref2) => {
  var {
    typed: typed2,
    Complex: _Complex,
    matrix: matrix2,
    ceil: ceil2,
    floor: floor2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref2;
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var fixNumber = createFixNumber({
    typed: typed2,
    ceil: ceil2,
    floor: floor2
  });
  return typed2("fix", {
    number: fixNumber.signatures.number,
    "number, number | BigNumber": fixNumber.signatures["number,number"],
    Complex: function Complex2(x) {
      return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
    },
    "Complex, number": function ComplexNumber(x, n) {
      return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
    },
    "Complex, BigNumber": function ComplexBigNumber(x, bn) {
      var n = bn.toNumber();
      return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
    },
    BigNumber: function BigNumber2(x) {
      return x.isNegative() ? ceil2(x) : floor2(x);
    },
    "BigNumber, number | BigNumber": function BigNumberNumberBigNumber(x, n) {
      return x.isNegative() ? ceil2(x, n) : floor2(x, n);
    },
    Fraction: function Fraction2(x) {
      return x.s < 0 ? x.ceil() : x.floor();
    },
    "Fraction, number | BigNumber": function FractionNumberBigNumber(x, n) {
      return x.s < 0 ? ceil2(x, n) : floor2(x, n);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => {
      return deepMap(x, self2);
    }),
    "Array | Matrix, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i2) => self2(i2, n));
    }),
    "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0))
        return zeros2(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs(y, x, self2, true);
      }
      return matAlgo12xSfs(y, x, self2, true);
    })
  });
});
var name$3Y = "floor";
var dependencies$3Y = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createFloorNumber = /* @__PURE__ */ factory(name$3Y, ["typed", "config", "round"], (_ref) => {
  var {
    typed: typed2,
    config: config3,
    round: round2
  } = _ref;
  return typed2(name$3Y, {
    number: function number2(x) {
      if (nearlyEqual$1(x, round2(x), config3.epsilon)) {
        return round2(x);
      } else {
        return Math.floor(x);
      }
    },
    "number, number": function numberNumber(x, n) {
      if (nearlyEqual$1(x, round2(x, n), config3.epsilon)) {
        return round2(x, n);
      } else {
        var [number2, exponent] = "".concat(x, "e").split("e");
        var result = Math.floor(Number("".concat(number2, "e").concat(Number(exponent) + n)));
        [number2, exponent] = "".concat(result, "e").split("e");
        return Number("".concat(number2, "e").concat(Number(exponent) - n));
      }
    }
  });
});
var createFloor = /* @__PURE__ */ factory(name$3Y, dependencies$3Y, (_ref2) => {
  var {
    typed: typed2,
    config: config3,
    round: round2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref2;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var floorNumber = createFloorNumber({
    typed: typed2,
    config: config3,
    round: round2
  });
  return typed2("floor", {
    number: floorNumber.signatures.number,
    "number,number": floorNumber.signatures["number,number"],
    Complex: function Complex2(x) {
      return x.floor();
    },
    "Complex, number": function ComplexNumber(x, n) {
      return x.floor(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x, n) {
      return x.floor(n.toNumber());
    },
    BigNumber: function BigNumber2(x) {
      if (nearlyEqual(x, round2(x), config3.epsilon)) {
        return round2(x);
      } else {
        return x.floor();
      }
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
      if (nearlyEqual(x, round2(x, n), config3.epsilon)) {
        return round2(x, n);
      } else {
        return x.toDecimalPlaces(n.toNumber(), Decimal.ROUND_FLOOR);
      }
    },
    Fraction: function Fraction2(x) {
      return x.floor();
    },
    "Fraction, number": function FractionNumber(x, n) {
      return x.floor(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x, n) {
      return x.floor(n.toNumber());
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => {
      return deepMap(x, self2);
    }),
    "Array, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i2) => self2(i2, n));
    }),
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0))
        return zeros2(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs(y, x, self2, true);
      }
      return matAlgo12xSfs(y, x, self2, true);
    })
  });
});
var name$3X = "matAlgo01xDSid";
var dependencies$3X = ["typed"];
var createMatAlgo01xDSid = /* @__PURE__ */ factory(name$3X, dependencies$3X, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt = typeof adt === "string" && adt === bdt ? adt : void 0;
    var cf = dt ? typed2.find(callback, [dt, dt]) : callback;
    var i2, j;
    var cdata = [];
    for (i2 = 0; i2 < rows; i2++) {
      cdata[i2] = [];
    }
    var x = [];
    var w = [];
    for (j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        x[i2] = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
        w[i2] = mark;
      }
      for (i2 = 0; i2 < rows; i2++) {
        if (w[i2] === mark) {
          cdata[i2][j] = x[i2];
        } else {
          cdata[i2][j] = adata[i2][j];
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$3W = "matAlgo04xSidSid";
var dependencies$3W = ["typed", "equalScalar"];
var createMatAlgo04xSidSid = /* @__PURE__ */ factory(name$3W, dependencies$3W, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo04xSidSid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero2 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var xa = avalues && bvalues ? [] : void 0;
    var xb = avalues && bvalues ? [] : void 0;
    var wa = [];
    var wb = [];
    var i2, j, k, k0, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        cindex.push(i2);
        wa[i2] = mark;
        if (xa) {
          xa[i2] = avalues[k];
        }
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        if (wa[i2] === mark) {
          if (xa) {
            var v = cf(xa[i2], bvalues[k]);
            if (!eq(v, zero2)) {
              xa[i2] = v;
            } else {
              wa[i2] = null;
            }
          }
        } else {
          cindex.push(i2);
          wb[i2] = mark;
          if (xb) {
            xb[i2] = bvalues[k];
          }
        }
      }
      if (xa && xb) {
        k = cptr[j];
        while (k < cindex.length) {
          i2 = cindex[k];
          if (wa[i2] === mark) {
            cvalues[k] = xa[i2];
            k++;
          } else if (wb[i2] === mark) {
            cvalues[k] = xb[i2];
            k++;
          } else {
            cindex.splice(k, 1);
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$3V = "matAlgo10xSids";
var dependencies$3V = ["typed", "DenseMatrix"];
var createMatAlgo10xSids = /* @__PURE__ */ factory(name$3V, dependencies$3V, (_ref) => {
  var {
    typed: typed2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo10xSids(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i2 = 0; i2 < rows; i2++) {
        if (j === 0) {
          cdata[i2] = [];
        }
        if (w[i2] === mark) {
          cdata[i2][j] = inverse ? cf(b, x[i2]) : cf(x[i2], b);
        } else {
          cdata[i2][j] = b;
        }
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$3U = "matAlgo13xDD";
var dependencies$3U = ["typed"];
var createMatAlgo13xDD = /* @__PURE__ */ factory(name$3U, dependencies$3U, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function matAlgo13xDD(a, b, callback) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var csize = [];
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    for (var s = 0; s < asize.length; s++) {
      if (asize[s] !== bsize[s]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      csize[s] = asize[s];
    }
    var dt;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
    return a.createDenseMatrix({
      data: cdata,
      size: csize,
      datatype: dt
    });
  };
  function _iterate(f, level, s, n, av, bv) {
    var cv = [];
    if (level === s.length - 1) {
      for (var i2 = 0; i2 < n; i2++) {
        cv[i2] = f(av[i2], bv[i2]);
      }
    } else {
      for (var j = 0; j < n; j++) {
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
      }
    }
    return cv;
  }
});
var name$3T = "matrixAlgorithmSuite";
var dependencies$3T = ["typed", "matrix"];
var createMatrixAlgorithmSuite = /* @__PURE__ */ factory(name$3T, dependencies$3T, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  var matAlgo13xDD = createMatAlgo13xDD({
    typed: typed2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  return function matrixAlgorithmSuite(options) {
    var elop = options.elop;
    var SD = options.SD || options.DS;
    var matrixSignatures;
    if (elop) {
      matrixSignatures = {
        "DenseMatrix, DenseMatrix": (x, y) => matAlgo13xDD(x, y, elop),
        "Array, Array": (x, y) => matAlgo13xDD(matrix2(x), matrix2(y), elop).valueOf(),
        "Array, DenseMatrix": (x, y) => matAlgo13xDD(matrix2(x), y, elop),
        "DenseMatrix, Array": (x, y) => matAlgo13xDD(x, matrix2(y), elop)
      };
      if (options.SS) {
        matrixSignatures["SparseMatrix, SparseMatrix"] = (x, y) => options.SS(x, y, elop, false);
      }
      if (options.DS) {
        matrixSignatures["DenseMatrix, SparseMatrix"] = (x, y) => options.DS(x, y, elop, false);
        matrixSignatures["Array, SparseMatrix"] = (x, y) => options.DS(matrix2(x), y, elop, false);
      }
      if (SD) {
        matrixSignatures["SparseMatrix, DenseMatrix"] = (x, y) => SD(y, x, elop, true);
        matrixSignatures["SparseMatrix, Array"] = (x, y) => SD(matrix2(y), x, elop, true);
      }
    } else {
      matrixSignatures = {
        "DenseMatrix, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(x, y, self2);
        }),
        "Array, Array": typed2.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(matrix2(x), matrix2(y), self2).valueOf();
        }),
        "Array, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(matrix2(x), y, self2);
        }),
        "DenseMatrix, Array": typed2.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(x, matrix2(y), self2);
        })
      };
      if (options.SS) {
        matrixSignatures["SparseMatrix, SparseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return options.SS(x, y, self2, false);
        });
      }
      if (options.DS) {
        matrixSignatures["DenseMatrix, SparseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return options.DS(x, y, self2, false);
        });
        matrixSignatures["Array, SparseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return options.DS(matrix2(x), y, self2, false);
        });
      }
      if (SD) {
        matrixSignatures["SparseMatrix, DenseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return SD(y, x, self2, true);
        });
        matrixSignatures["SparseMatrix, Array"] = typed2.referToSelf((self2) => (x, y) => {
          return SD(matrix2(y), x, self2, true);
        });
      }
    }
    var scalar = options.scalar || "any";
    var Ds = options.Ds || options.Ss;
    if (Ds) {
      if (elop) {
        matrixSignatures["DenseMatrix," + scalar] = (x, y) => matAlgo14xDs(x, y, elop, false);
        matrixSignatures[scalar + ", DenseMatrix"] = (x, y) => matAlgo14xDs(y, x, elop, true);
        matrixSignatures["Array," + scalar] = (x, y) => matAlgo14xDs(matrix2(x), y, elop, false).valueOf();
        matrixSignatures[scalar + ", Array"] = (x, y) => matAlgo14xDs(matrix2(y), x, elop, true).valueOf();
      } else {
        matrixSignatures["DenseMatrix," + scalar] = typed2.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(x, y, self2, false);
        });
        matrixSignatures[scalar + ", DenseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(y, x, self2, true);
        });
        matrixSignatures["Array," + scalar] = typed2.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(matrix2(x), y, self2, false).valueOf();
        });
        matrixSignatures[scalar + ", Array"] = typed2.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
        });
      }
    }
    var sS = options.sS !== void 0 ? options.sS : options.Ss;
    if (elop) {
      if (options.Ss) {
        matrixSignatures["SparseMatrix," + scalar] = (x, y) => options.Ss(x, y, elop, false);
      }
      if (sS) {
        matrixSignatures[scalar + ", SparseMatrix"] = (x, y) => sS(y, x, elop, true);
      }
    } else {
      if (options.Ss) {
        matrixSignatures["SparseMatrix," + scalar] = typed2.referToSelf((self2) => (x, y) => {
          return options.Ss(x, y, self2, false);
        });
      }
      if (sS) {
        matrixSignatures[scalar + ", SparseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return sS(y, x, self2, true);
        });
      }
    }
    if (elop && elop.signatures) {
      extend(matrixSignatures, elop.signatures);
    }
    return matrixSignatures;
  };
});
var name$3S = "gcd";
var dependencies$3S = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix"];
var createGcd = /* @__PURE__ */ factory(name$3S, dependencies$3S, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var gcdTypes = "number | BigNumber | Fraction | Matrix | Array";
  var gcdManySignature = {};
  gcdManySignature["".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes)] = typed2.referToSelf((self2) => (a, b, args) => {
    var res = self2(a, b);
    for (var i2 = 0; i2 < args.length; i2++) {
      res = self2(res, args[i2]);
    }
    return res;
  });
  return typed2(name$3S, {
    "number, number": gcdNumber,
    "BigNumber, BigNumber": _gcdBigNumber,
    "Fraction, Fraction": (x, y) => x.gcd(y)
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }), gcdManySignature);
  function _gcdBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var zero2 = new BigNumber2(0);
    while (!b.isZero()) {
      var r = a.mod(b);
      a = b;
      b = r;
    }
    return a.lt(zero2) ? a.neg() : a;
  }
});
var name$3R = "matAlgo02xDS0";
var dependencies$3R = ["typed", "equalScalar"];
var createMatAlgo02xDS0 = /* @__PURE__ */ factory(name$3R, dependencies$3R, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero2 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        var i2 = bindex[k];
        var cij = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
        if (!eq(cij, zero2)) {
          cindex.push(i2);
          cvalues.push(cij);
        }
      }
    }
    cptr[columns] = cindex.length;
    return sparseMatrix.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$3Q = "matAlgo06xS0S0";
var dependencies$3Q = ["typed", "equalScalar"];
var createMatAlgo06xS0S0 = /* @__PURE__ */ factory(name$3Q, dependencies$3Q, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo06xS0S0(a, b, callback) {
    var avalues = a._values;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero2 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : void 0;
    var w = [];
    var u = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      scatter(a, j, w, x, u, mark, cindex, cf);
      scatter(b, j, w, x, u, mark, cindex, cf);
      if (x) {
        var k = cptr[j];
        while (k < cindex.length) {
          var i2 = cindex[k];
          if (u[i2] === mark) {
            var v = x[i2];
            if (!eq(v, zero2)) {
              cvalues.push(v);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          } else {
            cindex.splice(k, 1);
          }
        }
      } else {
        var p2 = cptr[j];
        while (p2 < cindex.length) {
          var r = cindex[p2];
          if (u[r] !== mark) {
            cindex.splice(p2, 1);
          } else {
            p2++;
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$3P = "lcm";
var dependencies$3P = ["typed", "matrix", "equalScalar"];
var createLcm = /* @__PURE__ */ factory(name$3P, dependencies$3P, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var lcmTypes = "number | BigNumber | Fraction | Matrix | Array";
  var lcmManySignature = {};
  lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed2.referToSelf((self2) => (a, b, args) => {
    var res = self2(a, b);
    for (var i2 = 0; i2 < args.length; i2++) {
      res = self2(res, args[i2]);
    }
    return res;
  });
  return typed2(name$3P, {
    "number, number": lcmNumber,
    "BigNumber, BigNumber": _lcmBigNumber,
    "Fraction, Fraction": (x, y) => x.lcm(y)
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }), lcmManySignature);
  function _lcmBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a.isZero()) {
      return a;
    }
    if (b.isZero()) {
      return b;
    }
    var prod2 = a.times(b);
    while (!b.isZero()) {
      var t = b;
      b = a.mod(t);
      a = t;
    }
    return prod2.div(a).abs();
  }
});
var name$3O = "log10";
var dependencies$3O = ["typed", "config", "Complex"];
var createLog10 = /* @__PURE__ */ factory(name$3O, dependencies$3O, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: _Complex
  } = _ref;
  return typed2(name$3O, {
    number: function number2(x) {
      if (x >= 0 || config3.predictable) {
        return log10Number(x);
      } else {
        return new _Complex(x, 0).log().div(Math.LN10);
      }
    },
    Complex: function Complex2(x) {
      return new _Complex(x).log().div(Math.LN10);
    },
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config3.predictable) {
        return x.log();
      } else {
        return new _Complex(x.toNumber(), 0).log().div(Math.LN10);
      }
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3N = "log2";
var dependencies$3N = ["typed", "config", "Complex"];
var createLog2 = /* @__PURE__ */ factory(name$3N, dependencies$3N, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2
  } = _ref;
  return typed2(name$3N, {
    number: function number2(x) {
      if (x >= 0 || config3.predictable) {
        return log2Number(x);
      } else {
        return _log2Complex(new Complex2(x, 0));
      }
    },
    Complex: _log2Complex,
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config3.predictable) {
        return x.log(2);
      } else {
        return _log2Complex(new Complex2(x.toNumber(), 0));
      }
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
  function _log2Complex(x) {
    var newX = Math.sqrt(x.re * x.re + x.im * x.im);
    return new Complex2(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
  }
});
var name$3M = "matAlgo03xDSf";
var dependencies$3M = ["typed"];
var createMatAlgo03xDSf = /* @__PURE__ */ factory(name$3M, dependencies$3M, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function matAlgo03xDSf(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype;
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero2 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      zero2 = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    for (var z = 0; z < rows; z++) {
      cdata[z] = [];
    }
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        var i2 = bindex[k];
        x[i2] = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
        w[i2] = mark;
      }
      for (var y = 0; y < rows; y++) {
        if (w[y] === mark) {
          cdata[y][j] = x[y];
        } else {
          cdata[y][j] = inverse ? cf(zero2, adata[y][j]) : cf(adata[y][j], zero2);
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$3L = "matAlgo05xSfSf";
var dependencies$3L = ["typed", "equalScalar"];
var createMatAlgo05xSfSf = /* @__PURE__ */ factory(name$3L, dependencies$3L, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo05xSfSf(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero2 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var xa = cvalues ? [] : void 0;
    var xb = cvalues ? [] : void 0;
    var wa = [];
    var wb = [];
    var i2, j, k, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
        i2 = aindex[k];
        cindex.push(i2);
        wa[i2] = mark;
        if (xa) {
          xa[i2] = avalues[k];
        }
      }
      for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
        i2 = bindex[k];
        if (wa[i2] !== mark) {
          cindex.push(i2);
        }
        wb[i2] = mark;
        if (xb) {
          xb[i2] = bvalues[k];
        }
      }
      if (cvalues) {
        k = cptr[j];
        while (k < cindex.length) {
          i2 = cindex[k];
          var wai = wa[i2];
          var wbi = wb[i2];
          if (wai === mark || wbi === mark) {
            var va = wai === mark ? xa[i2] : zero2;
            var vb = wbi === mark ? xb[i2] : zero2;
            var vc = cf(va, vb);
            if (!eq(vc, zero2)) {
              cvalues.push(vc);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$3K = "mod";
var dependencies$3K = ["typed", "matrix", "equalScalar", "DenseMatrix"];
var createMod = /* @__PURE__ */ factory(name$3K, dependencies$3K, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$3K, {
    "number, number": modNumber,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      if (y.isNeg()) {
        throw new Error("Cannot calculate mod for a negative divisor");
      }
      return y.isZero() ? x : x.mod(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      if (y.compare(0) < 0) {
        throw new Error("Cannot calculate mod for a negative divisor");
      }
      return x.compare(0) >= 0 ? x.mod(y) : x.mod(y).add(y).mod(y);
    }
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});
var name$3J = "multiplyScalar";
var dependencies$3J = ["typed"];
var createMultiplyScalar = /* @__PURE__ */ factory(name$3J, dependencies$3J, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("multiplyScalar", {
    "number, number": multiplyNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.mul(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.times(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.mul(y);
    },
    "number | Fraction | BigNumber | Complex, Unit": (x, y) => y.multiply(x),
    "Unit, number | Fraction | BigNumber | Complex | Unit": (x, y) => x.multiply(y)
  });
});
var name$3I = "multiply";
var dependencies$3I = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
var createMultiply = /* @__PURE__ */ factory(name$3I, dependencies$3I, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    equalScalar: equalScalar2,
    dot: dot2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  function _validateMatrixDimensions(size1, size2) {
    switch (size1.length) {
      case 1:
        switch (size2.length) {
          case 1:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
            }
            break;
          case 2:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      case 2:
        switch (size2.length) {
          case 1:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
            }
            break;
          case 2:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      default:
        throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
    }
  }
  function _multiplyVectorVector(a, b, n) {
    if (n === 0) {
      throw new Error("Cannot multiply two empty vectors");
    }
    return dot2(a, b);
  }
  function _multiplyVectorMatrix(a, b) {
    if (b.storage() !== "dense") {
      throw new Error("Support for SparseMatrix not implemented");
    }
    return _multiplyVectorDenseMatrix(a, b);
  }
  function _multiplyVectorDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var alength = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var j = 0; j < bcolumns; j++) {
      var sum2 = mf(adata[0], bdata[0][j]);
      for (var i2 = 1; i2 < alength; i2++) {
        sum2 = af(sum2, mf(adata[i2], bdata[i2][j]));
      }
      c[j] = sum2;
    }
    return a.createDenseMatrix({
      data: c,
      size: [bcolumns],
      datatype: dt
    });
  }
  var _multiplyMatrixVector = typed2("_multiplyMatrixVector", {
    "DenseMatrix, any": _multiplyDenseMatrixVector,
    "SparseMatrix, any": _multiplySparseMatrixVector
  });
  var _multiplyMatrixMatrix = typed2("_multiplyMatrixMatrix", {
    "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
    "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
    "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
    "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
  });
  function _multiplyDenseMatrixVector(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = asize[0];
    var acolumns = asize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var i2 = 0; i2 < arows; i2++) {
      var row2 = adata[i2];
      var sum2 = mf(row2[0], bdata[0]);
      for (var j = 1; j < acolumns; j++) {
        sum2 = af(sum2, mf(row2[j], bdata[j]));
      }
      c[i2] = sum2;
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows],
      datatype: dt
    });
  }
  function _multiplyDenseMatrixDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var arows = asize[0];
    var acolumns = asize[1];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var i2 = 0; i2 < arows; i2++) {
      var row2 = adata[i2];
      c[i2] = [];
      for (var j = 0; j < bcolumns; j++) {
        var sum2 = mf(row2[0], bdata[0][j]);
        for (var x = 1; x < acolumns; x++) {
          sum2 = af(sum2, mf(row2[x], bdata[x][j]));
        }
        c[i2][j] = sum2;
      }
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows, bcolumns],
      datatype: dt
    });
  }
  function _multiplyDenseMatrixSparseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (!bvalues) {
      throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
    }
    var arows = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero2 = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = b.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var kb0 = bptr[jb];
      var kb1 = bptr[jb + 1];
      if (kb1 > kb0) {
        var last3 = 0;
        for (var i2 = 0; i2 < arows; i2++) {
          var mark = i2 + 1;
          var cij = void 0;
          for (var kb = kb0; kb < kb1; kb++) {
            var ib = bindex[kb];
            if (last3 !== mark) {
              cij = mf(adata[i2][ib], bvalues[kb]);
              last3 = mark;
            } else {
              cij = af(cij, mf(adata[i2][ib], bvalues[kb]));
            }
          }
          if (last3 === mark && !eq(cij, zero2)) {
            cindex.push(i2);
            cvalues.push(cij);
          }
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixVector(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = a._size[0];
    var brows = b._size[0];
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero2 = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
    }
    var x = [];
    var w = [];
    cptr[0] = 0;
    for (var ib = 0; ib < brows; ib++) {
      var vbi = bdata[ib];
      if (!eq(vbi, zero2)) {
        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
          var ia = aindex[ka];
          if (!w[ia]) {
            w[ia] = true;
            cindex.push(ia);
            x[ia] = mf(vbi, avalues[ka]);
          } else {
            x[ia] = af(x[ia], mf(vbi, avalues[ka]));
          }
        }
      }
    }
    for (var p1 = cindex.length, p2 = 0; p2 < p1; p2++) {
      var ic = cindex[p2];
      cvalues[p2] = x[ic];
    }
    cptr[1] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, 1],
      datatype: dt
    });
  }
  function _multiplySparseMatrixDenseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype;
    var arows = a._size[0];
    var brows = b._size[0];
    var bcolumns = b._size[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero2 = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    var x = [];
    var w = [];
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (var ib = 0; ib < brows; ib++) {
        var vbij = bdata[ib][jb];
        if (!eq(vbij, zero2)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            var ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(vbij, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbij, avalues[ka]));
            }
          }
        }
      }
      for (var p0 = cptr[jb], p1 = cindex.length, p2 = p0; p2 < p1; p2++) {
        var ic = cindex[p2];
        cvalues[p2] = x[ic];
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixSparseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bdt = b._datatype;
    var arows = a._size[0];
    var bcolumns = b._size[1];
    var values2 = avalues && bvalues;
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var cvalues = values2 ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: dt
    });
    var x = values2 ? [] : void 0;
    var w = [];
    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
        ib = bindex[kb];
        if (values2) {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(bvalues[kb], avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
            }
          }
        } else {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
            }
          }
        }
      }
      if (values2) {
        for (var p0 = cptr[jb], p1 = cindex.length, p2 = p0; p2 < p1; p2++) {
          var ic = cindex[p2];
          cvalues[p2] = x[ic];
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  return typed2(name$3I, multiplyScalar2, {
    "Array, Array": typed2.referTo("Matrix, Matrix", (selfMM) => (x, y) => {
      _validateMatrixDimensions(arraySize(x), arraySize(y));
      var m = selfMM(matrix2(x), matrix2(y));
      return isMatrix(m) ? m.valueOf() : m;
    }),
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      var xsize = x.size();
      var ysize = y.size();
      _validateMatrixDimensions(xsize, ysize);
      if (xsize.length === 1) {
        if (ysize.length === 1) {
          return _multiplyVectorVector(x, y, xsize[0]);
        }
        return _multiplyVectorMatrix(x, y);
      }
      if (ysize.length === 1) {
        return _multiplyMatrixVector(x, y);
      }
      return _multiplyMatrixMatrix(x, y);
    },
    "Matrix, Array": typed2.referTo("Matrix,Matrix", (selfMM) => (x, y) => selfMM(x, matrix2(y))),
    "Array, Matrix": typed2.referToSelf((self2) => (x, y) => {
      return self2(matrix2(x, y.storage()), y);
    }),
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return matAlgo11xS0s(x, y, multiplyScalar2, false);
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return matAlgo14xDs(x, y, multiplyScalar2, false);
    },
    "any, SparseMatrix": function anySparseMatrix(x, y) {
      return matAlgo11xS0s(y, x, multiplyScalar2, true);
    },
    "any, DenseMatrix": function anyDenseMatrix(x, y) {
      return matAlgo14xDs(y, x, multiplyScalar2, true);
    },
    "Array, any": function ArrayAny(x, y) {
      return matAlgo14xDs(matrix2(x), y, multiplyScalar2, false).valueOf();
    },
    "any, Array": function anyArray(x, y) {
      return matAlgo14xDs(matrix2(y), x, multiplyScalar2, true).valueOf();
    },
    "any, any": multiplyScalar2,
    "any, any, ...any": typed2.referToSelf((self2) => (x, y, rest2) => {
      var result = self2(x, y);
      for (var i2 = 0; i2 < rest2.length; i2++) {
        result = self2(result, rest2[i2]);
      }
      return result;
    })
  });
});
var name$3H = "nthRoot";
var dependencies$3H = ["typed", "matrix", "equalScalar", "BigNumber"];
var createNthRoot = /* @__PURE__ */ factory(name$3H, dependencies$3H, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    BigNumber: _BigNumber
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  function complexErr() {
    throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
  }
  return typed2(name$3H, {
    number: nthRootNumber,
    "number, number": nthRootNumber,
    BigNumber: (x) => _bigNthRoot(x, new _BigNumber(2)),
    "BigNumber, BigNumber": _bigNthRoot,
    Complex: complexErr,
    "Complex, number": complexErr,
    Array: typed2.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(matrix2(x), 2).valueOf()),
    DenseMatrix: typed2.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(x, 2)),
    SparseMatrix: typed2.referTo("SparseMatrix,number", (selfSn) => (x) => selfSn(x, 2)),
    "SparseMatrix, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo06xS0S0(x, y, self2);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "DenseMatrix, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo01xDSid(x, y, self2, false);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "Array, SparseMatrix": typed2.referTo("DenseMatrix,SparseMatrix", (selfDS) => (x, y) => selfDS(matrix2(x), y)),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo11xS0s(y, x, self2, true);
      } else {
        throw new Error("Root must be non-zero");
      }
    })
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: false
  }));
  function _bigNthRoot(a, root) {
    var precision = _BigNumber.precision;
    var Big = _BigNumber.clone({
      precision: precision + 2
    });
    var zero2 = new _BigNumber(0);
    var one = new Big(1);
    var inv2 = root.isNegative();
    if (inv2) {
      root = root.neg();
    }
    if (root.isZero()) {
      throw new Error("Root must be non-zero");
    }
    if (a.isNegative() && !root.abs().mod(2).equals(1)) {
      throw new Error("Root must be odd when a is negative.");
    }
    if (a.isZero()) {
      return inv2 ? new Big(Infinity) : 0;
    }
    if (!a.isFinite()) {
      return inv2 ? zero2 : a;
    }
    var x = a.abs().pow(one.div(root));
    x = a.isNeg() ? x.neg() : x;
    return new _BigNumber((inv2 ? one.div(x) : x).toPrecision(precision));
  }
});
var name$3G = "sign";
var dependencies$3G = ["typed", "BigNumber", "Fraction", "complex"];
var createSign = /* @__PURE__ */ factory(name$3G, dependencies$3G, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber,
    complex: complex2,
    Fraction: _Fraction
  } = _ref;
  return typed2(name$3G, {
    number: signNumber,
    Complex: function Complex2(x) {
      return x.im === 0 ? complex2(signNumber(x.re)) : x.sign();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(x.cmp(0));
    },
    Fraction: function Fraction2(x) {
      return new _Fraction(x.s, 1);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2)),
    Unit: typed2.referToSelf((self2) => (x) => {
      if (!x._isDerived() && x.units[0].unit.offset !== 0) {
        throw new TypeError("sign is ambiguous for units with offset");
      }
      return typed2.find(self2, x.valueType())(x.value);
    })
  });
});
var name$3F = "sqrt";
var dependencies$3F = ["config", "typed", "Complex"];
var createSqrt = /* @__PURE__ */ factory(name$3F, dependencies$3F, (_ref) => {
  var {
    config: config3,
    typed: typed2,
    Complex: Complex2
  } = _ref;
  return typed2("sqrt", {
    number: _sqrtNumber,
    Complex: function Complex3(x) {
      return x.sqrt();
    },
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config3.predictable) {
        return x.sqrt();
      } else {
        return _sqrtNumber(x.toNumber());
      }
    },
    Unit: function Unit2(x) {
      return x.pow(0.5);
    }
  });
  function _sqrtNumber(x) {
    if (isNaN(x)) {
      return NaN;
    } else if (x >= 0 || config3.predictable) {
      return Math.sqrt(x);
    } else {
      return new Complex2(x, 0).sqrt();
    }
  }
});
var name$3E = "square";
var dependencies$3E = ["typed"];
var createSquare = /* @__PURE__ */ factory(name$3E, dependencies$3E, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3E, {
    number: squareNumber,
    Complex: function Complex2(x) {
      return x.mul(x);
    },
    BigNumber: function BigNumber2(x) {
      return x.times(x);
    },
    Fraction: function Fraction2(x) {
      return x.mul(x);
    },
    Unit: function Unit2(x) {
      return x.pow(2);
    }
  });
});
var name$3D = "subtract";
var dependencies$3D = ["typed", "matrix", "equalScalar", "addScalar", "unaryMinus", "DenseMatrix"];
var createSubtract = /* @__PURE__ */ factory(name$3D, dependencies$3D, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    addScalar: addScalar2,
    unaryMinus: unaryMinus2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$3D, {
    "number, number": (x, y) => x - y,
    "Complex, Complex": (x, y) => x.sub(y),
    "BigNumber, BigNumber": (x, y) => x.minus(y),
    "Fraction, Fraction": (x, y) => x.sub(y),
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => {
      if (x.value === null) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y)) {
        throw new Error("Units do not match");
      }
      var res = x.clone();
      res.value = typed2.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo01xDSid,
    SD: matAlgo03xDSf,
    Ss: matAlgo12xSfs,
    sS: matAlgo10xSids
  }));
});
var name$3C = "xgcd";
var dependencies$3C = ["typed", "config", "matrix", "BigNumber"];
var createXgcd = /* @__PURE__ */ factory(name$3C, dependencies$3C, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2(name$3C, {
    "number, number": function numberNumber(a, b) {
      var res = xgcdNumber(a, b);
      return config3.matrix === "Array" ? res : matrix2(res);
    },
    "BigNumber, BigNumber": _xgcdBigNumber
  });
  function _xgcdBigNumber(a, b) {
    var t;
    var q;
    var r;
    var zero2 = new BigNumber2(0);
    var one = new BigNumber2(1);
    var x = zero2;
    var lastx = one;
    var y = one;
    var lasty = zero2;
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (!b.isZero()) {
      q = a.div(b).floor();
      r = a.mod(b);
      t = x;
      x = lastx.minus(q.times(x));
      lastx = t;
      t = y;
      y = lasty.minus(q.times(y));
      lasty = t;
      a = b;
      b = r;
    }
    var res;
    if (a.lt(zero2)) {
      res = [a.neg(), lastx.neg(), lasty.neg()];
    } else {
      res = [a, !a.isZero() ? lastx : 0, lasty];
    }
    return config3.matrix === "Array" ? res : matrix2(res);
  }
});
var name$3B = "invmod";
var dependencies$3B = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"];
var createInvmod = /* @__PURE__ */ factory(name$3B, dependencies$3B, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    BigNumber: BigNumber2,
    xgcd: xgcd2,
    equal: equal2,
    smaller: smaller2,
    mod: mod2,
    add: add2,
    isInteger: isInteger2
  } = _ref;
  return typed2(name$3B, {
    "number, number": invmod2,
    "BigNumber, BigNumber": invmod2
  });
  function invmod2(a, b) {
    if (!isInteger2(a) || !isInteger2(b))
      throw new Error("Parameters in function invmod must be integer numbers");
    a = mod2(a, b);
    if (equal2(b, 0))
      throw new Error("Divisor must be non zero");
    var res = xgcd2(a, b);
    res = res.valueOf();
    var [gcd2, inv2] = res;
    if (!equal2(gcd2, BigNumber2(1)))
      return NaN;
    inv2 = mod2(inv2, b);
    if (smaller2(inv2, BigNumber2(0)))
      inv2 = add2(inv2, b);
    return inv2;
  }
});
var name$3A = "matAlgo09xS0Sf";
var dependencies$3A = ["typed", "equalScalar"];
var createMatAlgo09xS0Sf = /* @__PURE__ */ factory(name$3A, dependencies$3A, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo09xS0Sf(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero2 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : void 0;
    var w = [];
    var i2, j, k, k0, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      if (x) {
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i2 = bindex[k];
          w[i2] = mark;
          x[i2] = bvalues[k];
        }
      }
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        if (x) {
          var vb = w[i2] === mark ? x[i2] : zero2;
          var vc = cf(avalues[k], vb);
          if (!eq(vc, zero2)) {
            cindex.push(i2);
            cvalues.push(vc);
          }
        } else {
          cindex.push(i2);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$3z = "dotMultiply";
var dependencies$3z = ["typed", "matrix", "equalScalar", "multiplyScalar"];
var createDotMultiply = /* @__PURE__ */ factory(name$3z, dependencies$3z, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    multiplyScalar: multiplyScalar2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$3z, matrixAlgorithmSuite({
    elop: multiplyScalar2,
    SS: matAlgo09xS0Sf,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});
function bitAndBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitAnd");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.eq(-1) || x.eq(y)) {
    return x;
  }
  if (y.isZero() || x.eq(-1)) {
    return y;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      if (x.isNegative() === y.isNegative()) {
        return x;
      }
      return new BigNumber2(0);
    }
    if (!x.isFinite()) {
      if (y.isNegative()) {
        return x;
      }
      if (x.isNegative()) {
        return new BigNumber2(0);
      }
      return y;
    }
    if (!y.isFinite()) {
      if (x.isNegative()) {
        return y;
      }
      if (y.isNegative()) {
        return new BigNumber2(0);
      }
      return x;
    }
  }
  return bitwise(x, y, function(a, b) {
    return a & b;
  });
}
function bitNotBigNumber(x) {
  if (x.isFinite() && !x.isInteger()) {
    throw new Error("Integer expected in function bitNot");
  }
  var BigNumber2 = x.constructor;
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  var result = x.plus(new BigNumber2(1));
  result.s = -result.s || null;
  BigNumber2.config({
    precision: prevPrec
  });
  return result;
}
function bitOrBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitOr");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  var negOne = new BigNumber2(-1);
  if (x.isZero() || y.eq(negOne) || x.eq(y)) {
    return y;
  }
  if (y.isZero() || x.eq(negOne)) {
    return x;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
      return negOne;
    }
    if (x.isNegative() && y.isNegative()) {
      return x.isFinite() ? x : y;
    }
    return x.isFinite() ? y : x;
  }
  return bitwise(x, y, function(a, b) {
    return a | b;
  });
}
function bitwise(x, y, func) {
  var BigNumber2 = x.constructor;
  var xBits, yBits;
  var xSign = +(x.s < 0);
  var ySign = +(y.s < 0);
  if (xSign) {
    xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
    for (var i2 = 0; i2 < xBits.length; ++i2) {
      xBits[i2] ^= 1;
    }
  } else {
    xBits = decCoefficientToBinaryString(x);
  }
  if (ySign) {
    yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
    for (var _i = 0; _i < yBits.length; ++_i) {
      yBits[_i] ^= 1;
    }
  } else {
    yBits = decCoefficientToBinaryString(y);
  }
  var minBits, maxBits, minSign;
  if (xBits.length <= yBits.length) {
    minBits = xBits;
    maxBits = yBits;
    minSign = xSign;
  } else {
    minBits = yBits;
    maxBits = xBits;
    minSign = ySign;
  }
  var shortLen = minBits.length;
  var longLen = maxBits.length;
  var expFuncVal = func(xSign, ySign) ^ 1;
  var outVal = new BigNumber2(expFuncVal ^ 1);
  var twoPower = new BigNumber2(1);
  var two = new BigNumber2(2);
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  while (shortLen > 0) {
    if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  while (longLen > 0) {
    if (func(minSign, maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  BigNumber2.config({
    precision: prevPrec
  });
  if (expFuncVal === 0) {
    outVal.s = -outVal.s;
  }
  return outVal;
}
function decCoefficientToBinaryString(x) {
  var a = x.d;
  var r = a[0] + "";
  for (var i2 = 1; i2 < a.length; ++i2) {
    var s = a[i2] + "";
    for (var z = 7 - s.length; z--; ) {
      s = "0" + s;
    }
    r += s;
  }
  var j = r.length;
  while (r.charAt(j) === "0") {
    j--;
  }
  var xe = x.e;
  var str = r.slice(0, j + 1 || 1);
  var strL = str.length;
  if (xe > 0) {
    if (++xe > strL) {
      xe -= strL;
      while (xe--) {
        str += "0";
      }
    } else if (xe < strL) {
      str = str.slice(0, xe) + "." + str.slice(xe);
    }
  }
  var arr = [0];
  for (var _i2 = 0; _i2 < str.length; ) {
    var arrL = arr.length;
    while (arrL--) {
      arr[arrL] *= 10;
    }
    arr[0] += parseInt(str.charAt(_i2++));
    for (var _j = 0; _j < arr.length; ++_j) {
      if (arr[_j] > 1) {
        if (arr[_j + 1] === null || arr[_j + 1] === void 0) {
          arr[_j + 1] = 0;
        }
        arr[_j + 1] += arr[_j] >> 1;
        arr[_j] &= 1;
      }
    }
  }
  return arr.reverse();
}
function bitXor$1(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitXor");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero()) {
    return y;
  }
  if (y.isZero()) {
    return x;
  }
  if (x.eq(y)) {
    return new BigNumber2(0);
  }
  var negOne = new BigNumber2(-1);
  if (x.eq(negOne)) {
    return bitNotBigNumber(y);
  }
  if (y.eq(negOne)) {
    return bitNotBigNumber(x);
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      return negOne;
    }
    return new BigNumber2(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
  }
  return bitwise(x, y, function(a, b) {
    return a ^ b;
  });
}
function leftShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function leftShift");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!x.isFinite() && !y.isFinite()) {
    return new BigNumber2(NaN);
  }
  if (y.lt(55)) {
    return x.times(Math.pow(2, y.toNumber()) + "");
  }
  return x.times(new BigNumber2(2).pow(y));
}
function rightArithShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function rightArithShift");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!y.isFinite()) {
    if (x.isNegative()) {
      return new BigNumber2(-1);
    }
    if (!x.isFinite()) {
      return new BigNumber2(NaN);
    }
    return new BigNumber2(0);
  }
  if (y.lt(55)) {
    return x.div(Math.pow(2, y.toNumber()) + "").floor();
  }
  return x.div(new BigNumber2(2).pow(y)).floor();
}
var name$3y = "bitAnd";
var dependencies$3y = ["typed", "matrix", "equalScalar"];
var createBitAnd = /* @__PURE__ */ factory(name$3y, dependencies$3y, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$3y, {
    "number, number": bitAndNumber,
    "BigNumber, BigNumber": bitAndBigNumber
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});
var name$3x = "bitNot";
var dependencies$3x = ["typed"];
var createBitNot = /* @__PURE__ */ factory(name$3x, dependencies$3x, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3x, {
    number: bitNotNumber,
    BigNumber: bitNotBigNumber,
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3w = "bitOr";
var dependencies$3w = ["typed", "matrix", "equalScalar", "DenseMatrix"];
var createBitOr = /* @__PURE__ */ factory(name$3w, dependencies$3w, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$3w, {
    "number, number": bitOrNumber,
    "BigNumber, BigNumber": bitOrBigNumber
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }));
});
var name$3v = "matAlgo07xSSf";
var dependencies$3v = ["typed", "DenseMatrix"];
var createMatAlgo07xSSf = /* @__PURE__ */ factory(name$3v, dependencies$3v, (_ref) => {
  var {
    typed: typed2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo07xSSf(a, b, callback) {
    var asize = a._size;
    var adt = a._datatype;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero2 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      zero2 = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var i2, j;
    var cdata = [];
    for (i2 = 0; i2 < rows; i2++) {
      cdata[i2] = [];
    }
    var xa = [];
    var xb = [];
    var wa = [];
    var wb = [];
    for (j = 0; j < columns; j++) {
      var mark = j + 1;
      _scatter(a, j, wa, xa, mark);
      _scatter(b, j, wb, xb, mark);
      for (i2 = 0; i2 < rows; i2++) {
        var va = wa[i2] === mark ? xa[i2] : zero2;
        var vb = wb[i2] === mark ? xb[i2] : zero2;
        cdata[i2][j] = cf(va, vb);
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
  function _scatter(m, j, w, x, mark) {
    var values2 = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
      var i2 = index2[k];
      w[i2] = mark;
      x[i2] = values2[k];
    }
  }
});
var name$3u = "bitXor";
var dependencies$3u = ["typed", "matrix", "DenseMatrix"];
var createBitXor = /* @__PURE__ */ factory(name$3u, dependencies$3u, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$3u, {
    "number, number": bitXorNumber,
    "BigNumber, BigNumber": bitXor$1
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var name$3t = "arg";
var dependencies$3t = ["typed"];
var createArg = /* @__PURE__ */ factory(name$3t, dependencies$3t, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3t, {
    number: function number2(x) {
      return Math.atan2(0, x);
    },
    BigNumber: function BigNumber2(x) {
      return x.constructor.atan2(0, x);
    },
    Complex: function Complex2(x) {
      return x.arg();
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3s = "conj";
var dependencies$3s = ["typed"];
var createConj = /* @__PURE__ */ factory(name$3s, dependencies$3s, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3s, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.conjugate(),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3r = "im";
var dependencies$3r = ["typed"];
var createIm = /* @__PURE__ */ factory(name$3r, dependencies$3r, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3r, {
    number: () => 0,
    "BigNumber | Fraction": (x) => x.mul(0),
    Complex: (x) => x.im,
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3q = "re";
var dependencies$3q = ["typed"];
var createRe = /* @__PURE__ */ factory(name$3q, dependencies$3q, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3q, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.re,
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3p = "not";
var dependencies$3p = ["typed"];
var createNot = /* @__PURE__ */ factory(name$3p, dependencies$3p, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3p, {
    "null | undefined": () => true,
    number: notNumber,
    Complex: function Complex2(x) {
      return x.re === 0 && x.im === 0;
    },
    BigNumber: function BigNumber2(x) {
      return x.isZero() || x.isNaN();
    },
    Unit: typed2.referToSelf((self2) => (x) => typed2.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3o = "or";
var dependencies$3o = ["typed", "matrix", "equalScalar", "DenseMatrix"];
var createOr = /* @__PURE__ */ factory(name$3o, dependencies$3o, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$3o, {
    "number, number": orNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
    },
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var name$3n = "xor";
var dependencies$3n = ["typed", "matrix", "DenseMatrix"];
var createXor = /* @__PURE__ */ factory(name$3n, dependencies$3n, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$3n, {
    "number, number": xorNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
    },
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var name$3m = "concat";
var dependencies$3m = ["typed", "matrix", "isInteger"];
var createConcat = /* @__PURE__ */ factory(name$3m, dependencies$3m, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger2
  } = _ref;
  return typed2(name$3m, {
    "...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumber(args) {
      var i2;
      var len = args.length;
      var dim = -1;
      var prevDim;
      var asMatrix = false;
      var matrices = [];
      for (i2 = 0; i2 < len; i2++) {
        var arg2 = args[i2];
        if (isMatrix(arg2)) {
          asMatrix = true;
        }
        if (isNumber(arg2) || isBigNumber(arg2)) {
          if (i2 !== len - 1) {
            throw new Error("Dimension must be specified as last argument");
          }
          prevDim = dim;
          dim = arg2.valueOf();
          if (!isInteger2(dim)) {
            throw new TypeError("Integer number expected for dimension");
          }
          if (dim < 0 || i2 > 0 && dim > prevDim) {
            throw new IndexError(dim, prevDim + 1);
          }
        } else {
          var m = clone$2(arg2).valueOf();
          var size2 = arraySize(m);
          matrices[i2] = m;
          prevDim = dim;
          dim = size2.length - 1;
          if (i2 > 0 && dim !== prevDim) {
            throw new DimensionError(prevDim + 1, dim + 1);
          }
        }
      }
      if (matrices.length === 0) {
        throw new SyntaxError("At least one matrix expected");
      }
      var res = matrices.shift();
      while (matrices.length) {
        res = _concat(res, matrices.shift(), dim, 0);
      }
      return asMatrix ? matrix2(res) : res;
    },
    "...string": function string2(args) {
      return args.join("");
    }
  });
});
function _concat(a, b, concatDim, dim) {
  if (dim < concatDim) {
    if (a.length !== b.length) {
      throw new DimensionError(a.length, b.length);
    }
    var c = [];
    for (var i2 = 0; i2 < a.length; i2++) {
      c[i2] = _concat(a[i2], b[i2], concatDim, dim + 1);
    }
    return c;
  } else {
    return a.concat(b);
  }
}
var name$3l = "column";
var dependencies$3l = ["typed", "Index", "matrix", "range"];
var createColumn = /* @__PURE__ */ factory(name$3l, dependencies$3l, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  return typed2(name$3l, {
    "Matrix, number": _column,
    "Array, number": function ArrayNumber(value, column2) {
      return _column(matrix2(clone$2(value)), column2).valueOf();
    }
  });
  function _column(value, column2) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(column2, value.size()[1]);
    var rowRange = range2(0, value.size()[0]);
    var index2 = new Index2(rowRange, column2);
    return value.subset(index2);
  }
});
var name$3k = "count";
var dependencies$3k = ["typed", "size", "prod"];
var createCount = /* @__PURE__ */ factory(name$3k, dependencies$3k, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    prod: prod2
  } = _ref;
  return typed2(name$3k, {
    string: function string2(x) {
      return x.length;
    },
    "Matrix | Array": function MatrixArray(x) {
      return prod2(size2(x));
    }
  });
});
var name$3j = "cross";
var dependencies$3j = ["typed", "matrix", "subtract", "multiply"];
var createCross = /* @__PURE__ */ factory(name$3j, dependencies$3j, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    multiply: multiply2
  } = _ref;
  return typed2(name$3j, {
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      return matrix2(_cross(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return matrix2(_cross(x.toArray(), y));
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return matrix2(_cross(x, y.toArray()));
    },
    "Array, Array": _cross
  });
  function _cross(x, y) {
    var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
    x = squeeze$1(x);
    y = squeeze$1(y);
    var xSize = arraySize(x);
    var ySize = arraySize(y);
    if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
      throw new RangeError("Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
    }
    var product2 = [subtract2(multiply2(x[1], y[2]), multiply2(x[2], y[1])), subtract2(multiply2(x[2], y[0]), multiply2(x[0], y[2])), subtract2(multiply2(x[0], y[1]), multiply2(x[1], y[0]))];
    if (highestDimension > 1) {
      return [product2];
    } else {
      return product2;
    }
  }
});
var name$3i = "diag";
var dependencies$3i = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
var createDiag = /* @__PURE__ */ factory(name$3i, dependencies$3i, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name$3i, {
    Array: function Array2(x) {
      return _diag(x, 0, arraySize(x), null);
    },
    "Array, number": function ArrayNumber(x, k) {
      return _diag(x, k, arraySize(x), null);
    },
    "Array, BigNumber": function ArrayBigNumber(x, k) {
      return _diag(x, k.toNumber(), arraySize(x), null);
    },
    "Array, string": function ArrayString(x, format2) {
      return _diag(x, 0, arraySize(x), format2);
    },
    "Array, number, string": function ArrayNumberString(x, k, format2) {
      return _diag(x, k, arraySize(x), format2);
    },
    "Array, BigNumber, string": function ArrayBigNumberString(x, k, format2) {
      return _diag(x, k.toNumber(), arraySize(x), format2);
    },
    Matrix: function Matrix2(x) {
      return _diag(x, 0, x.size(), x.storage());
    },
    "Matrix, number": function MatrixNumber(x, k) {
      return _diag(x, k, x.size(), x.storage());
    },
    "Matrix, BigNumber": function MatrixBigNumber(x, k) {
      return _diag(x, k.toNumber(), x.size(), x.storage());
    },
    "Matrix, string": function MatrixString(x, format2) {
      return _diag(x, 0, x.size(), format2);
    },
    "Matrix, number, string": function MatrixNumberString(x, k, format2) {
      return _diag(x, k, x.size(), format2);
    },
    "Matrix, BigNumber, string": function MatrixBigNumberString(x, k, format2) {
      return _diag(x, k.toNumber(), x.size(), format2);
    }
  });
  function _diag(x, k, size2, format2) {
    if (!isInteger$1(k)) {
      throw new TypeError("Second parameter in function diag must be an integer");
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    switch (size2.length) {
      case 1:
        return _createDiagonalMatrix(x, k, format2, size2[0], kSub, kSuper);
      case 2:
        return _getDiagonal(x, k, format2, size2, kSub, kSuper);
    }
    throw new RangeError("Matrix for function diag must be 2 dimensional");
  }
  function _createDiagonalMatrix(x, k, format2, l, kSub, kSuper) {
    var ms = [l + kSub, l + kSuper];
    if (format2 && format2 !== "sparse" && format2 !== "dense") {
      throw new TypeError("Unknown matrix type ".concat(format2, '"'));
    }
    var m = format2 === "sparse" ? SparseMatrix2.diagonal(ms, x, k) : DenseMatrix2.diagonal(ms, x, k);
    return format2 !== null ? m : m.valueOf();
  }
  function _getDiagonal(x, k, format2, s, kSub, kSuper) {
    if (isMatrix(x)) {
      var dm = x.diagonal(k);
      if (format2 !== null) {
        if (format2 !== dm.storage()) {
          return matrix2(dm, format2);
        }
        return dm;
      }
      return dm.valueOf();
    }
    var n = Math.min(s[0] - kSub, s[1] - kSuper);
    var vector = [];
    for (var i2 = 0; i2 < n; i2++) {
      vector[i2] = x[i2 + kSub][i2 + kSuper];
    }
    return format2 !== null ? matrix2(vector) : vector;
  }
});
var name$3h = "filter";
var dependencies$3h = ["typed"];
var createFilter = /* @__PURE__ */ factory(name$3h, dependencies$3h, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("filter", {
    "Array, function": _filterCallback,
    "Matrix, function": function MatrixFunction(x, test) {
      return x.create(_filterCallback(x.toArray(), test));
    },
    "Array, RegExp": filterRegExp,
    "Matrix, RegExp": function MatrixRegExp(x, test) {
      return x.create(filterRegExp(x.toArray(), test));
    }
  });
});
function _filterCallback(x, callback) {
  var args = maxArgumentCount(callback);
  return filter$1(x, function(value, index2, array) {
    if (args === 1) {
      return callback(value);
    } else if (args === 2) {
      return callback(value, [index2]);
    } else {
      return callback(value, [index2], array);
    }
  });
}
var name$3g = "flatten";
var dependencies$3g = ["typed", "matrix"];
var createFlatten = /* @__PURE__ */ factory(name$3g, dependencies$3g, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return typed2(name$3g, {
    Array: function Array2(x) {
      return flatten$1(clone$2(x));
    },
    Matrix: function Matrix2(x) {
      var flat = flatten$1(clone$2(x.toArray()));
      return matrix2(flat);
    }
  });
});
var name$3f = "forEach";
var dependencies$3f = ["typed"];
var createForEach = /* @__PURE__ */ factory(name$3f, dependencies$3f, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3f, {
    "Array, function": _forEach,
    "Matrix, function": function MatrixFunction(x, callback) {
      return x.forEach(callback);
    }
  });
});
function _forEach(array, callback) {
  var args = maxArgumentCount(callback);
  var recurse = function recurse2(value, index2) {
    if (Array.isArray(value)) {
      forEach$1(value, function(child, i2) {
        recurse2(child, index2.concat(i2));
      });
    } else {
      if (args === 1) {
        callback(value);
      } else if (args === 2) {
        callback(value, index2);
      } else {
        callback(value, index2, array);
      }
    }
  };
  recurse(array, []);
}
var name$3e = "getMatrixDataType";
var dependencies$3e = ["typed"];
var createGetMatrixDataType = /* @__PURE__ */ factory(name$3e, dependencies$3e, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3e, {
    Array: function Array2(x) {
      return getArrayDataType(x, typeOf$1);
    },
    Matrix: function Matrix2(x) {
      return x.getDataType();
    }
  });
});
var name$3d = "identity";
var dependencies$3d = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
var createIdentity = /* @__PURE__ */ factory(name$3d, dependencies$3d, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name$3d, {
    "": function _() {
      return config3.matrix === "Matrix" ? matrix2([]) : [];
    },
    string: function string2(format2) {
      return matrix2(format2);
    },
    "number | BigNumber": function numberBigNumber(rows) {
      return _identity(rows, rows, config3.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, string": function numberBigNumberString(rows, format2) {
      return _identity(rows, rows, format2);
    },
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
      return _identity(rows, cols, config3.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format2) {
      return _identity(rows, cols, format2);
    },
    Array: function Array2(size2) {
      return _identityVector(size2);
    },
    "Array, string": function ArrayString(size2, format2) {
      return _identityVector(size2, format2);
    },
    Matrix: function Matrix2(size2) {
      return _identityVector(size2.valueOf(), size2.storage());
    },
    "Matrix, string": function MatrixString(size2, format2) {
      return _identityVector(size2.valueOf(), format2);
    }
  });
  function _identityVector(size2, format2) {
    switch (size2.length) {
      case 0:
        return format2 ? matrix2(format2) : [];
      case 1:
        return _identity(size2[0], size2[0], format2);
      case 2:
        return _identity(size2[0], size2[1], format2);
      default:
        throw new Error("Vector containing two values expected");
    }
  }
  function _identity(rows, cols, format2) {
    var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber2 : null;
    if (isBigNumber(rows))
      rows = rows.toNumber();
    if (isBigNumber(cols))
      cols = cols.toNumber();
    if (!isInteger$1(rows) || rows < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    if (!isInteger$1(cols) || cols < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    var one = Big ? new BigNumber2(1) : 1;
    var defaultValue = Big ? new Big(0) : 0;
    var size2 = [rows, cols];
    if (format2) {
      if (format2 === "sparse") {
        return SparseMatrix2.diagonal(size2, one, 0, defaultValue);
      }
      if (format2 === "dense") {
        return DenseMatrix2.diagonal(size2, one, 0, defaultValue);
      }
      throw new TypeError('Unknown matrix type "'.concat(format2, '"'));
    }
    var res = resize$1([], size2, defaultValue);
    var minimum = rows < cols ? rows : cols;
    for (var d = 0; d < minimum; d++) {
      res[d][d] = one;
    }
    return res;
  }
});
var name$3c = "kron";
var dependencies$3c = ["typed", "matrix", "multiplyScalar"];
var createKron = /* @__PURE__ */ factory(name$3c, dependencies$3c, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    multiplyScalar: multiplyScalar2
  } = _ref;
  return typed2(name$3c, {
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      return matrix2(_kron(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return matrix2(_kron(x.toArray(), y));
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return matrix2(_kron(x, y.toArray()));
    },
    "Array, Array": _kron
  });
  function _kron(a, b) {
    if (arraySize(a).length === 1) {
      a = [a];
    }
    if (arraySize(b).length === 1) {
      b = [b];
    }
    if (arraySize(a).length > 2 || arraySize(b).length > 2) {
      throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(a.length) + ", y = " + JSON.stringify(b.length) + ")");
    }
    var t = [];
    var r = [];
    return a.map(function(a2) {
      return b.map(function(b2) {
        r = [];
        t.push(r);
        return a2.map(function(y) {
          return b2.map(function(x) {
            return r.push(multiplyScalar2(y, x));
          });
        });
      });
    }) && t;
  }
});
var name$3b = "map";
var dependencies$3b = ["typed"];
var createMap = /* @__PURE__ */ factory(name$3b, dependencies$3b, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3b, {
    "Array, function": _map$1,
    "Matrix, function": function MatrixFunction(x, callback) {
      return x.map(callback);
    }
  });
});
function _map$1(array, callback) {
  var args = maxArgumentCount(callback);
  var recurse = function recurse2(value, index2) {
    if (Array.isArray(value)) {
      return value.map(function(child, i2) {
        return recurse2(child, index2.concat(i2));
      });
    } else {
      try {
        if (args === 1) {
          return callback(value);
        } else if (args === 2) {
          return callback(value, index2);
        } else {
          return callback(value, index2, array);
        }
      } catch (err) {
        if (err instanceof TypeError && "data" in err && err.data.category === "wrongType") {
          var newmsg = "map attempted to call '".concat(err.data.fn, "(").concat(value);
          var indexString = JSON.stringify(index2);
          if (args === 2) {
            newmsg += "," + indexString;
          } else if (args !== 1) {
            newmsg += ",".concat(indexString, ",").concat(array);
          }
          newmsg += ")' but argument ".concat(err.data.index + 1, " of type ");
          newmsg += "".concat(err.data.actual, " does not match expected type ");
          newmsg += err.data.expected.join(" or ");
          throw new TypeError(newmsg);
        }
        throw err;
      }
    }
  };
  return recurse(array, []);
}
var name$3a = "diff";
var dependencies$3a = ["typed", "matrix", "subtract", "number"];
var createDiff = /* @__PURE__ */ factory(name$3a, dependencies$3a, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number2
  } = _ref;
  return typed2(name$3a, {
    "Array | Matrix": function ArrayMatrix(arr) {
      if (isMatrix(arr)) {
        return matrix2(_diff(arr.toArray()));
      } else {
        return _diff(arr);
      }
    },
    "Array | Matrix, number": function ArrayMatrixNumber(arr, dim) {
      if (!isInteger$1(dim))
        throw new RangeError("Dimension must be a whole number");
      if (isMatrix(arr)) {
        return matrix2(_recursive(arr.toArray(), dim));
      } else {
        return _recursive(arr, dim);
      }
    },
    "Array, BigNumber": typed2.referTo("Array,number", (selfAn) => (arr, dim) => selfAn(arr, number2(dim))),
    "Matrix, BigNumber": typed2.referTo("Matrix,number", (selfMn) => (arr, dim) => selfMn(arr, number2(dim)))
  });
  function _recursive(arr, dim) {
    if (isMatrix(arr)) {
      arr = arr.toArray();
    }
    if (!Array.isArray(arr)) {
      throw RangeError("Array/Matrix does not have that many dimensions");
    }
    if (dim > 0) {
      var result = [];
      arr.forEach((element) => {
        result.push(_recursive(element, dim - 1));
      });
      return result;
    } else if (dim === 0) {
      return _diff(arr);
    } else {
      throw RangeError("Cannot have negative dimension");
    }
  }
  function _diff(arr) {
    var result = [];
    var size2 = arr.length;
    for (var i2 = 1; i2 < size2; i2++) {
      result.push(_ElementDiff(arr[i2 - 1], arr[i2]));
    }
    return result;
  }
  function _ElementDiff(obj1, obj2) {
    if (isMatrix(obj1))
      obj1 = obj1.toArray();
    if (isMatrix(obj2))
      obj2 = obj2.toArray();
    var obj1IsArray = Array.isArray(obj1);
    var obj2IsArray = Array.isArray(obj2);
    if (obj1IsArray && obj2IsArray) {
      return _ArrayDiff(obj1, obj2);
    }
    if (!obj1IsArray && !obj2IsArray) {
      return subtract2(obj2, obj1);
    }
    throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
  }
  function _ArrayDiff(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      throw RangeError("Not all sub-arrays have the same length");
    }
    var result = [];
    var size2 = arr1.length;
    for (var i2 = 0; i2 < size2; i2++) {
      result.push(_ElementDiff(arr1[i2], arr2[i2]));
    }
    return result;
  }
});
var name$39 = "ones";
var dependencies$39 = ["typed", "config", "matrix", "BigNumber"];
var createOnes = /* @__PURE__ */ factory(name$39, dependencies$39, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2("ones", {
    "": function _() {
      return config3.matrix === "Array" ? _ones([]) : _ones([], "default");
    },
    "...number | BigNumber | string": function numberBigNumberString(size2) {
      var last3 = size2[size2.length - 1];
      if (typeof last3 === "string") {
        var format2 = size2.pop();
        return _ones(size2, format2);
      } else if (config3.matrix === "Array") {
        return _ones(size2);
      } else {
        return _ones(size2, "default");
      }
    },
    Array: _ones,
    Matrix: function Matrix2(size2) {
      var format2 = size2.storage();
      return _ones(size2.valueOf(), format2);
    },
    "Array | Matrix, string": function ArrayMatrixString(size2, format2) {
      return _ones(size2.valueOf(), format2);
    }
  });
  function _ones(size2, format2) {
    var hasBigNumbers = _normalize(size2);
    var defaultValue = hasBigNumbers ? new BigNumber2(1) : 1;
    _validate2(size2);
    if (format2) {
      var m = matrix2(format2);
      if (size2.length > 0) {
        return m.resize(size2, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size2.length > 0) {
        return resize$1(arr, size2, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size2) {
    var hasBigNumbers = false;
    size2.forEach(function(value, index2, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index2] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate2(size2) {
    size2.forEach(function(value) {
      if (typeof value !== "number" || !isInteger$1(value) || value < 0) {
        throw new Error("Parameters in function ones must be positive integers");
      }
    });
  }
});
function noBignumber() {
  throw new Error('No "bignumber" implementation available');
}
function noFraction() {
  throw new Error('No "fraction" implementation available');
}
function noMatrix() {
  throw new Error('No "matrix" implementation available');
}
var name$38 = "range";
var dependencies$38 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq"];
var createRange = /* @__PURE__ */ factory(name$38, dependencies$38, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    bignumber: bignumber2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2,
    largerEq: largerEq2
  } = _ref;
  return typed2(name$38, {
    string: _strRange,
    "string, boolean": _strRange,
    "number, number": function numberNumber(start2, end) {
      return _out(_rangeEx(start2, end, 1));
    },
    "number, number, number": function numberNumberNumber(start2, end, step) {
      return _out(_rangeEx(start2, end, step));
    },
    "number, number, boolean": function numberNumberBoolean(start2, end, includeEnd) {
      return includeEnd ? _out(_rangeInc(start2, end, 1)) : _out(_rangeEx(start2, end, 1));
    },
    "number, number, number, boolean": function numberNumberNumberBoolean(start2, end, step, includeEnd) {
      return includeEnd ? _out(_rangeInc(start2, end, step)) : _out(_rangeEx(start2, end, step));
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(start2, end) {
      var BigNumber2 = start2.constructor;
      return _out(_bigRangeEx(start2, end, new BigNumber2(1)));
    },
    "BigNumber, BigNumber, BigNumber": function BigNumberBigNumberBigNumber(start2, end, step) {
      return _out(_bigRangeEx(start2, end, step));
    },
    "BigNumber, BigNumber, boolean": function BigNumberBigNumberBoolean(start2, end, includeEnd) {
      var BigNumber2 = start2.constructor;
      return includeEnd ? _out(_bigRangeInc(start2, end, new BigNumber2(1))) : _out(_bigRangeEx(start2, end, new BigNumber2(1)));
    },
    "BigNumber, BigNumber, BigNumber, boolean": function BigNumberBigNumberBigNumberBoolean(start2, end, step, includeEnd) {
      return includeEnd ? _out(_bigRangeInc(start2, end, step)) : _out(_bigRangeEx(start2, end, step));
    }
  });
  function _out(arr) {
    if (config3.matrix === "Matrix") {
      return matrix2 ? matrix2(arr) : noMatrix();
    }
    return arr;
  }
  function _strRange(str, includeEnd) {
    var r = _parse(str);
    if (!r) {
      throw new SyntaxError('String "' + str + '" is no valid range');
    }
    var fn;
    if (config3.number === "BigNumber") {
      if (bignumber2 === void 0) {
        noBignumber();
      }
      fn = includeEnd ? _bigRangeInc : _bigRangeEx;
      return _out(fn(bignumber2(r.start), bignumber2(r.end), bignumber2(r.step)));
    } else {
      fn = includeEnd ? _rangeInc : _rangeEx;
      return _out(fn(r.start, r.end, r.step));
    }
  }
  function _rangeEx(start2, end, step) {
    var array = [];
    var x = start2;
    if (step > 0) {
      while (smaller2(x, end)) {
        array.push(x);
        x += step;
      }
    } else if (step < 0) {
      while (larger2(x, end)) {
        array.push(x);
        x += step;
      }
    }
    return array;
  }
  function _rangeInc(start2, end, step) {
    var array = [];
    var x = start2;
    if (step > 0) {
      while (smallerEq2(x, end)) {
        array.push(x);
        x += step;
      }
    } else if (step < 0) {
      while (largerEq2(x, end)) {
        array.push(x);
        x += step;
      }
    }
    return array;
  }
  function _bigRangeEx(start2, end, step) {
    var zero2 = bignumber2(0);
    var array = [];
    var x = start2;
    if (step.gt(zero2)) {
      while (smaller2(x, end)) {
        array.push(x);
        x = x.plus(step);
      }
    } else if (step.lt(zero2)) {
      while (larger2(x, end)) {
        array.push(x);
        x = x.plus(step);
      }
    }
    return array;
  }
  function _bigRangeInc(start2, end, step) {
    var zero2 = bignumber2(0);
    var array = [];
    var x = start2;
    if (step.gt(zero2)) {
      while (smallerEq2(x, end)) {
        array.push(x);
        x = x.plus(step);
      }
    } else if (step.lt(zero2)) {
      while (largerEq2(x, end)) {
        array.push(x);
        x = x.plus(step);
      }
    }
    return array;
  }
  function _parse(str) {
    var args = str.split(":");
    var nums = args.map(function(arg2) {
      return Number(arg2);
    });
    var invalid = nums.some(function(num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }
    switch (nums.length) {
      case 2:
        return {
          start: nums[0],
          end: nums[1],
          step: 1
        };
      case 3:
        return {
          start: nums[0],
          end: nums[2],
          step: nums[1]
        };
      default:
        return null;
    }
  }
});
var name$37 = "reshape";
var dependencies$37 = ["typed", "isInteger", "matrix"];
var createReshape = /* @__PURE__ */ factory(name$37, dependencies$37, (_ref) => {
  var {
    typed: typed2,
    isInteger: isInteger2
  } = _ref;
  return typed2(name$37, {
    "Matrix, Array": function MatrixArray(x, sizes) {
      return x.reshape(sizes);
    },
    "Array, Array": function ArrayArray(x, sizes) {
      sizes.forEach(function(size2) {
        if (!isInteger2(size2)) {
          throw new TypeError("Invalid size for dimension: " + size2);
        }
      });
      return reshape$1(x, sizes);
    }
  });
});
function ArgumentsError(fn, count3, min3, max3) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.fn = fn;
  this.count = count3;
  this.min = min3;
  this.max = max3;
  this.message = "Wrong number of arguments in function " + fn + " (" + count3 + " provided, " + min3 + (max3 !== void 0 && max3 !== null ? "-" + max3 : "") + " expected)";
  this.stack = new Error().stack;
}
ArgumentsError.prototype = new Error();
ArgumentsError.prototype.constructor = Error;
ArgumentsError.prototype.name = "ArgumentsError";
ArgumentsError.prototype.isArgumentsError = true;
var name$36 = "resize";
var dependencies$36 = ["config", "matrix"];
var createResize = /* @__PURE__ */ factory(name$36, dependencies$36, (_ref) => {
  var {
    config: config3,
    matrix: matrix2
  } = _ref;
  return function resize2(x, size2, defaultValue) {
    if (arguments.length !== 2 && arguments.length !== 3) {
      throw new ArgumentsError("resize", arguments.length, 2, 3);
    }
    if (isMatrix(size2)) {
      size2 = size2.valueOf();
    }
    if (isBigNumber(size2[0])) {
      size2 = size2.map(function(value) {
        return !isBigNumber(value) ? value : value.toNumber();
      });
    }
    if (isMatrix(x)) {
      return x.resize(size2, defaultValue, true);
    }
    if (typeof x === "string") {
      return _resizeString(x, size2, defaultValue);
    }
    var asMatrix = Array.isArray(x) ? false : config3.matrix !== "Array";
    if (size2.length === 0) {
      while (Array.isArray(x)) {
        x = x[0];
      }
      return clone$2(x);
    } else {
      if (!Array.isArray(x)) {
        x = [x];
      }
      x = clone$2(x);
      var res = resize$1(x, size2, defaultValue);
      return asMatrix ? matrix2(res) : res;
    }
  };
  function _resizeString(str, size2, defaultChar) {
    if (defaultChar !== void 0) {
      if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
        throw new TypeError("Single character expected as defaultValue");
      }
    } else {
      defaultChar = " ";
    }
    if (size2.length !== 1) {
      throw new DimensionError(size2.length, 1);
    }
    var len = size2[0];
    if (typeof len !== "number" || !isInteger$1(len)) {
      throw new TypeError("Invalid size, must contain positive integers (size: " + format$1(size2) + ")");
    }
    if (str.length > len) {
      return str.substring(0, len);
    } else if (str.length < len) {
      var res = str;
      for (var i2 = 0, ii = len - str.length; i2 < ii; i2++) {
        res += defaultChar;
      }
      return res;
    } else {
      return str;
    }
  }
});
var name$35 = "rotate";
var dependencies$35 = ["typed", "multiply", "rotationMatrix"];
var createRotate = /* @__PURE__ */ factory(name$35, dependencies$35, (_ref) => {
  var {
    typed: typed2,
    multiply: multiply2,
    rotationMatrix: rotationMatrix2
  } = _ref;
  return typed2(name$35, {
    "Array , number | BigNumber | Complex | Unit": function ArrayNumberBigNumberComplexUnit(w, theta) {
      _validateSize(w, 2);
      var matrixRes = multiply2(rotationMatrix2(theta), w);
      return matrixRes.toArray();
    },
    "Matrix , number | BigNumber | Complex | Unit": function MatrixNumberBigNumberComplexUnit(w, theta) {
      _validateSize(w, 2);
      return multiply2(rotationMatrix2(theta), w);
    },
    "Array, number | BigNumber | Complex | Unit, Array | Matrix": function ArrayNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
      _validateSize(w, 3);
      var matrixRes = multiply2(rotationMatrix2(theta, v), w);
      return matrixRes;
    },
    "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function MatrixNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
      _validateSize(w, 3);
      return multiply2(rotationMatrix2(theta, v), w);
    }
  });
  function _validateSize(v, expectedSize) {
    var actualSize = Array.isArray(v) ? arraySize(v) : v.size();
    if (actualSize.length > 2) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize.length === 2 && actualSize[1] !== 1) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize[0] !== expectedSize) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
  }
});
var name$34 = "rotationMatrix";
var dependencies$34 = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
var createRotationMatrix = /* @__PURE__ */ factory(name$34, dependencies$34, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    multiplyScalar: multiplyScalar2,
    addScalar: addScalar2,
    unaryMinus: unaryMinus2,
    norm: norm2,
    BigNumber: BigNumber2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    cos: cos2,
    sin: sin2
  } = _ref;
  return typed2(name$34, {
    "": function _() {
      return config3.matrix === "Matrix" ? matrix2([]) : [];
    },
    string: function string2(format2) {
      return matrix2(format2);
    },
    "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(theta) {
      return _rotationMatrix2x2(theta, config3.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber | Complex | Unit, string": function numberBigNumberComplexUnitString(theta, format2) {
      return _rotationMatrix2x2(theta, format2);
    },
    "number | BigNumber | Complex | Unit, Array": function numberBigNumberComplexUnitArray(theta, v) {
      var matrixV = matrix2(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, void 0);
    },
    "number | BigNumber | Complex | Unit, Matrix": function numberBigNumberComplexUnitMatrix(theta, v) {
      _validateVector(v);
      var storageType = v.storage() || (config3.matrix === "Matrix" ? "dense" : void 0);
      return _rotationMatrix3x3(theta, v, storageType);
    },
    "number | BigNumber | Complex | Unit, Array, string": function numberBigNumberComplexUnitArrayString(theta, v, format2) {
      var matrixV = matrix2(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, format2);
    },
    "number | BigNumber | Complex | Unit, Matrix, string": function numberBigNumberComplexUnitMatrixString(theta, v, format2) {
      _validateVector(v);
      return _rotationMatrix3x3(theta, v, format2);
    }
  });
  function _rotationMatrix2x2(theta, format2) {
    var Big = isBigNumber(theta);
    var minusOne = Big ? new BigNumber2(-1) : -1;
    var cosTheta = cos2(theta);
    var sinTheta = sin2(theta);
    var data = [[cosTheta, multiplyScalar2(minusOne, sinTheta)], [sinTheta, cosTheta]];
    return _convertToFormat(data, format2);
  }
  function _validateVector(v) {
    var size2 = v.size();
    if (size2.length < 1 || size2[0] !== 3) {
      throw new RangeError("Vector must be of dimensions 1x3");
    }
  }
  function _mul(array) {
    return array.reduce((p2, curr) => multiplyScalar2(p2, curr));
  }
  function _convertToFormat(data, format2) {
    if (format2) {
      if (format2 === "sparse") {
        return new SparseMatrix2(data);
      }
      if (format2 === "dense") {
        return new DenseMatrix2(data);
      }
      throw new TypeError('Unknown matrix type "'.concat(format2, '"'));
    }
    return data;
  }
  function _rotationMatrix3x3(theta, v, format2) {
    var normV = norm2(v);
    if (normV === 0) {
      throw new RangeError("Rotation around zero vector");
    }
    var Big = isBigNumber(theta) ? BigNumber2 : null;
    var one = Big ? new Big(1) : 1;
    var minusOne = Big ? new Big(-1) : -1;
    var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
    var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
    var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
    var c = cos2(theta);
    var oneMinusC = addScalar2(one, unaryMinus2(c));
    var s = sin2(theta);
    var r11 = addScalar2(c, _mul([vx, vx, oneMinusC]));
    var r12 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
    var r13 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
    var r21 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
    var r22 = addScalar2(c, _mul([vy, vy, oneMinusC]));
    var r23 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
    var r31 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
    var r32 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
    var r33 = addScalar2(c, _mul([vz, vz, oneMinusC]));
    var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
    return _convertToFormat(data, format2);
  }
});
var name$33 = "row";
var dependencies$33 = ["typed", "Index", "matrix", "range"];
var createRow = /* @__PURE__ */ factory(name$33, dependencies$33, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  return typed2(name$33, {
    "Matrix, number": _row,
    "Array, number": function ArrayNumber(value, row2) {
      return _row(matrix2(clone$2(value)), row2).valueOf();
    }
  });
  function _row(value, row2) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(row2, value.size()[0]);
    var columnRange = range2(0, value.size()[1]);
    var index2 = new Index2(row2, columnRange);
    return value.subset(index2);
  }
});
var name$32 = "size";
var dependencies$32 = ["typed", "config", "?matrix"];
var createSize = /* @__PURE__ */ factory(name$32, dependencies$32, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2
  } = _ref;
  return typed2(name$32, {
    Matrix: function Matrix2(x) {
      return x.create(x.size());
    },
    Array: arraySize,
    string: function string2(x) {
      return config3.matrix === "Array" ? [x.length] : matrix2([x.length]);
    },
    "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x) {
      return config3.matrix === "Array" ? [] : matrix2 ? matrix2([]) : noMatrix();
    }
  });
});
var name$31 = "squeeze";
var dependencies$31 = ["typed", "matrix"];
var createSqueeze = /* @__PURE__ */ factory(name$31, dependencies$31, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return typed2(name$31, {
    Array: function Array2(x) {
      return squeeze$1(clone$2(x));
    },
    Matrix: function Matrix2(x) {
      var res = squeeze$1(x.toArray());
      return Array.isArray(res) ? matrix2(res) : res;
    },
    any: function any(x) {
      return clone$2(x);
    }
  });
});
var name$30 = "subset";
var dependencies$30 = ["typed", "matrix"];
var createSubset = /* @__PURE__ */ factory(name$30, dependencies$30, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return typed2(name$30, {
    "Array, Index": function ArrayIndex(value, index2) {
      var m = matrix2(value);
      var subset2 = m.subset(index2);
      return index2.isScalar() ? subset2 : subset2.valueOf();
    },
    "Matrix, Index": function MatrixIndex(value, index2) {
      return value.subset(index2);
    },
    "Object, Index": _getObjectProperty,
    "string, Index": _getSubstring,
    "Array, Index, any": function ArrayIndexAny(value, index2, replacement) {
      return matrix2(clone$2(value)).subset(index2, replacement, void 0).valueOf();
    },
    "Array, Index, any, any": function ArrayIndexAnyAny(value, index2, replacement, defaultValue) {
      return matrix2(clone$2(value)).subset(index2, replacement, defaultValue).valueOf();
    },
    "Matrix, Index, any": function MatrixIndexAny(value, index2, replacement) {
      return value.clone().subset(index2, replacement);
    },
    "Matrix, Index, any, any": function MatrixIndexAnyAny(value, index2, replacement, defaultValue) {
      return value.clone().subset(index2, replacement, defaultValue);
    },
    "string, Index, string": _setSubstring,
    "string, Index, string, string": _setSubstring,
    "Object, Index, any": _setObjectProperty
  });
});
function _getSubstring(str, index2) {
  if (!isIndex(index2)) {
    throw new TypeError("Index expected");
  }
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size().length, 1);
  }
  var strLen = str.length;
  validateIndex(index2.min()[0], strLen);
  validateIndex(index2.max()[0], strLen);
  var range2 = index2.dimension(0);
  var substr = "";
  range2.forEach(function(v) {
    substr += str.charAt(v);
  });
  return substr;
}
function _setSubstring(str, index2, replacement, defaultValue) {
  if (!index2 || index2.isIndex !== true) {
    throw new TypeError("Index expected");
  }
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size().length, 1);
  }
  if (defaultValue !== void 0) {
    if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
      throw new TypeError("Single character expected as defaultValue");
    }
  } else {
    defaultValue = " ";
  }
  var range2 = index2.dimension(0);
  var len = range2.size()[0];
  if (len !== replacement.length) {
    throw new DimensionError(range2.size()[0], replacement.length);
  }
  var strLen = str.length;
  validateIndex(index2.min()[0]);
  validateIndex(index2.max()[0]);
  var chars = [];
  for (var i2 = 0; i2 < strLen; i2++) {
    chars[i2] = str.charAt(i2);
  }
  range2.forEach(function(v, i3) {
    chars[v] = replacement.charAt(i3[0]);
  });
  if (chars.length > strLen) {
    for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
      if (!chars[_i]) {
        chars[_i] = defaultValue;
      }
    }
  }
  return chars.join("");
}
function _getObjectProperty(object, index2) {
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size(), 1);
  }
  var key = index2.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  return getSafeProperty(object, key);
}
function _setObjectProperty(object, index2, replacement) {
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size(), 1);
  }
  var key = index2.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  var updated = clone$2(object);
  setSafeProperty(updated, key, replacement);
  return updated;
}
var name$2$ = "transpose";
var dependencies$2$ = ["typed", "matrix"];
var createTranspose = /* @__PURE__ */ factory(name$2$, dependencies$2$, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return typed2(name$2$, {
    Array: (x) => transposeMatrix(matrix2(x)).valueOf(),
    Matrix: transposeMatrix,
    any: clone$2
  });
  function transposeMatrix(x) {
    var size2 = x.size();
    var c;
    switch (size2.length) {
      case 1:
        c = x.clone();
        break;
      case 2:
        {
          var rows = size2[0];
          var columns = size2[1];
          if (columns === 0) {
            throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format$1(size2) + ")");
          }
          switch (x.storage()) {
            case "dense":
              c = _denseTranspose(x, rows, columns);
              break;
            case "sparse":
              c = _sparseTranspose(x, rows, columns);
              break;
          }
        }
        break;
      default:
        throw new RangeError("Matrix must be a vector or two dimensional (size: " + format$1(size2) + ")");
    }
    return c;
  }
  function _denseTranspose(m, rows, columns) {
    var data = m._data;
    var transposed = [];
    var transposedRow;
    for (var j = 0; j < columns; j++) {
      transposedRow = transposed[j] = [];
      for (var i2 = 0; i2 < rows; i2++) {
        transposedRow[i2] = clone$2(data[i2][j]);
      }
    }
    return m.createDenseMatrix({
      data: transposed,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
  function _sparseTranspose(m, rows, columns) {
    var values2 = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var cvalues = values2 ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var w = [];
    for (var x = 0; x < rows; x++) {
      w[x] = 0;
    }
    var p2, l, j;
    for (p2 = 0, l = index2.length; p2 < l; p2++) {
      w[index2[p2]]++;
    }
    var sum2 = 0;
    for (var i2 = 0; i2 < rows; i2++) {
      cptr.push(sum2);
      sum2 += w[i2];
      w[i2] = cptr[i2];
    }
    cptr.push(sum2);
    for (j = 0; j < columns; j++) {
      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
        var q = w[index2[k]]++;
        cindex[q] = j;
        if (values2) {
          cvalues[q] = clone$2(values2[k]);
        }
      }
    }
    return m.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
});
var name$2_ = "ctranspose";
var dependencies$2_ = ["typed", "transpose", "conj"];
var createCtranspose = /* @__PURE__ */ factory(name$2_, dependencies$2_, (_ref) => {
  var {
    typed: typed2,
    transpose: transpose2,
    conj: conj2
  } = _ref;
  return typed2(name$2_, {
    any: function any(x) {
      return conj2(transpose2(x));
    }
  });
});
var name$2Z = "zeros";
var dependencies$2Z = ["typed", "config", "matrix", "BigNumber"];
var createZeros = /* @__PURE__ */ factory(name$2Z, dependencies$2Z, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2(name$2Z, {
    "": function _() {
      return config3.matrix === "Array" ? _zeros([]) : _zeros([], "default");
    },
    "...number | BigNumber | string": function numberBigNumberString(size2) {
      var last3 = size2[size2.length - 1];
      if (typeof last3 === "string") {
        var format2 = size2.pop();
        return _zeros(size2, format2);
      } else if (config3.matrix === "Array") {
        return _zeros(size2);
      } else {
        return _zeros(size2, "default");
      }
    },
    Array: _zeros,
    Matrix: function Matrix2(size2) {
      var format2 = size2.storage();
      return _zeros(size2.valueOf(), format2);
    },
    "Array | Matrix, string": function ArrayMatrixString(size2, format2) {
      return _zeros(size2.valueOf(), format2);
    }
  });
  function _zeros(size2, format2) {
    var hasBigNumbers = _normalize(size2);
    var defaultValue = hasBigNumbers ? new BigNumber2(0) : 0;
    _validate2(size2);
    if (format2) {
      var m = matrix2(format2);
      if (size2.length > 0) {
        return m.resize(size2, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size2.length > 0) {
        return resize$1(arr, size2, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size2) {
    var hasBigNumbers = false;
    size2.forEach(function(value, index2, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index2] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate2(size2) {
    size2.forEach(function(value) {
      if (typeof value !== "number" || !isInteger$1(value) || value < 0) {
        throw new Error("Parameters in function zeros must be positive integers");
      }
    });
  }
});
var name$2Y = "fft";
var dependencies$2Y = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i"];
var createFft = /* @__PURE__ */ factory(name$2Y, dependencies$2Y, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    exp: exp2,
    tau: tau2,
    i: I
  } = _ref;
  return typed2(name$2Y, {
    Array: _ndFft,
    Matrix: function Matrix2(matrix3) {
      return matrix3.create(_ndFft(matrix3.toArray()));
    }
  });
  function _ndFft(arr) {
    var size2 = arraySize(arr);
    if (size2.length === 1)
      return _fft(arr, size2[0]);
    return _1dFft(arr.map((slice3) => _ndFft(slice3, size2.slice(1))), 0);
  }
  function _1dFft(arr, dim) {
    var size2 = arraySize(arr);
    if (dim !== 0)
      return new Array(size2[0]).fill(0).map((_, i2) => _1dFft(arr[i2], dim - 1));
    if (size2.length === 1)
      return _fft(arr);
    function _transpose(arr2) {
      var size3 = arraySize(arr2);
      return new Array(size3[1]).fill(0).map((_, j) => new Array(size3[0]).fill(0).map((_2, i2) => arr2[i2][j]));
    }
    return _transpose(_1dFft(_transpose(arr), 1));
  }
  function _fft(arr) {
    var len = arr.length;
    if (len === 1)
      return [arr[0]];
    if (len % 2 === 0) {
      var ret = [..._fft(arr.filter((_, i2) => i2 % 2 === 0)), ..._fft(arr.filter((_, i2) => i2 % 2 === 1))];
      for (var k = 0; k < len / 2; k++) {
        var p2 = ret[k];
        var q = multiplyScalar2(ret[k + len / 2], exp2(multiplyScalar2(multiplyScalar2(tau2, I), divideScalar2(-k, len))));
        ret[k] = addScalar2(p2, q);
        ret[k + len / 2] = addScalar2(p2, multiplyScalar2(-1, q));
      }
      return ret;
    }
    throw new Error("Can only calculate FFT of power-of-two size");
  }
});
var name$2X = "ifft";
var dependencies$2X = ["typed", "fft", "dotDivide", "conj"];
var createIfft = /* @__PURE__ */ factory(name$2X, dependencies$2X, (_ref) => {
  var {
    typed: typed2,
    fft: fft2,
    dotDivide: dotDivide2,
    conj: conj2
  } = _ref;
  return typed2(name$2X, {
    "Array | Matrix": function ArrayMatrix(arr) {
      var size2 = isMatrix(arr) ? arr.size() : arraySize(arr);
      return dotDivide2(conj2(fft2(conj2(arr))), size2.reduce((acc, curr) => acc * curr, 1));
    }
  });
});
var name$2W = "erf";
var dependencies$2W = ["typed"];
var createErf = /* @__PURE__ */ factory(name$2W, dependencies$2W, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("name", {
    number: function number2(x) {
      var y = Math.abs(x);
      if (y >= MAX_NUM) {
        return sign$2(x);
      }
      if (y <= THRESH) {
        return sign$2(x) * erf1(y);
      }
      if (y <= 4) {
        return sign$2(x) * (1 - erfc2(y));
      }
      return sign$2(x) * (1 - erfc3(y));
    },
    "Array | Matrix": typed2.referToSelf((self2) => (n) => deepMap(n, self2))
  });
  function erf1(y) {
    var ysq = y * y;
    var xnum = P[0][4] * ysq;
    var xden = ysq;
    var i2;
    for (i2 = 0; i2 < 3; i2 += 1) {
      xnum = (xnum + P[0][i2]) * ysq;
      xden = (xden + Q[0][i2]) * ysq;
    }
    return y * (xnum + P[0][3]) / (xden + Q[0][3]);
  }
  function erfc2(y) {
    var xnum = P[1][8] * y;
    var xden = y;
    var i2;
    for (i2 = 0; i2 < 7; i2 += 1) {
      xnum = (xnum + P[1][i2]) * y;
      xden = (xden + Q[1][i2]) * y;
    }
    var result = (xnum + P[1][7]) / (xden + Q[1][7]);
    var ysq = parseInt(y * 16) / 16;
    var del = (y - ysq) * (y + ysq);
    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
  }
  function erfc3(y) {
    var ysq = 1 / (y * y);
    var xnum = P[2][5] * ysq;
    var xden = ysq;
    var i2;
    for (i2 = 0; i2 < 4; i2 += 1) {
      xnum = (xnum + P[2][i2]) * ysq;
      xden = (xden + Q[2][i2]) * ysq;
    }
    var result = ysq * (xnum + P[2][4]) / (xden + Q[2][4]);
    result = (SQRPI - result) / y;
    ysq = parseInt(y * 16) / 16;
    var del = (y - ysq) * (y + ysq);
    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
  }
});
var THRESH = 0.46875;
var SQRPI = 0.5641895835477563;
var P = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 21531153547440383e-24], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 6587491615298378e-19, 0.016315387137302097]];
var Q = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]];
var MAX_NUM = Math.pow(2, 53);
var name$2V = "mode";
var dependencies$2V = ["typed", "isNaN", "isNumeric"];
var createMode = /* @__PURE__ */ factory(name$2V, dependencies$2V, (_ref) => {
  var {
    typed: typed2,
    isNaN: isNaN2,
    isNumeric: isNumeric2
  } = _ref;
  return typed2(name$2V, {
    "Array | Matrix": _mode,
    "...": function _(args) {
      return _mode(args);
    }
  });
  function _mode(values2) {
    values2 = flatten$1(values2.valueOf());
    var num = values2.length;
    if (num === 0) {
      throw new Error("Cannot calculate mode of an empty array");
    }
    var count3 = {};
    var mode2 = [];
    var max3 = 0;
    for (var i2 = 0; i2 < values2.length; i2++) {
      var value = values2[i2];
      if (isNumeric2(value) && isNaN2(value)) {
        throw new Error("Cannot calculate mode of an array containing NaN values");
      }
      if (!(value in count3)) {
        count3[value] = 0;
      }
      count3[value]++;
      if (count3[value] === max3) {
        mode2.push(value);
      } else if (count3[value] > max3) {
        max3 = count3[value];
        mode2 = [value];
      }
    }
    return mode2;
  }
});
function improveErrorMessage(err, fnName, value) {
  var details;
  if (String(err).indexOf("Unexpected type") !== -1) {
    details = arguments.length > 2 ? " (type: " + typeOf$1(value) + ", value: " + JSON.stringify(value) + ")" : " (type: " + err.data.actual + ")";
    return new TypeError("Cannot calculate " + fnName + ", unexpected type of argument" + details);
  }
  if (String(err).indexOf("complex numbers") !== -1) {
    details = arguments.length > 2 ? " (type: " + typeOf$1(value) + ", value: " + JSON.stringify(value) + ")" : "";
    return new TypeError("Cannot calculate " + fnName + ", no ordering relation is defined for complex numbers" + details);
  }
  return err;
}
var name$2U = "prod";
var dependencies$2U = ["typed", "config", "multiplyScalar", "numeric"];
var createProd = /* @__PURE__ */ factory(name$2U, dependencies$2U, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    multiplyScalar: multiplyScalar2,
    numeric: numeric3
  } = _ref;
  return typed2(name$2U, {
    "Array | Matrix": _prod,
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      throw new Error("prod(A, dim) is not yet supported");
    },
    "...": function _(args) {
      return _prod(args);
    }
  });
  function _prod(array) {
    var prod2;
    deepForEach(array, function(value) {
      try {
        prod2 = prod2 === void 0 ? value : multiplyScalar2(prod2, value);
      } catch (err) {
        throw improveErrorMessage(err, "prod", value);
      }
    });
    if (typeof prod2 === "string") {
      prod2 = numeric3(prod2, config3.number);
    }
    if (prod2 === void 0) {
      throw new Error("Cannot calculate prod of an empty array");
    }
    return prod2;
  }
});
var name$2T = "format";
var dependencies$2T = ["typed"];
var createFormat = /* @__PURE__ */ factory(name$2T, dependencies$2T, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$2T, {
    any: format$1,
    "any, Object | function | number": format$1
  });
});
var name$2S = "bin";
var dependencies$2S = ["typed", "format"];
var createBin = factory(name$2S, dependencies$2S, (_ref) => {
  var {
    typed: typed2,
    format: format2
  } = _ref;
  return typed2(name$2S, {
    "number | BigNumber": function numberBigNumber(n) {
      return format2(n, {
        notation: "bin"
      });
    },
    "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
      return format2(n, {
        notation: "bin",
        wordSize
      });
    }
  });
});
var name$2R = "oct";
var dependencies$2R = ["typed", "format"];
var createOct = factory(name$2R, dependencies$2R, (_ref) => {
  var {
    typed: typed2,
    format: format2
  } = _ref;
  return typed2(name$2R, {
    "number | BigNumber": function numberBigNumber(n) {
      return format2(n, {
        notation: "oct"
      });
    },
    "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
      return format2(n, {
        notation: "oct",
        wordSize
      });
    }
  });
});
var name$2Q = "hex";
var dependencies$2Q = ["typed", "format"];
var createHex = factory(name$2Q, dependencies$2Q, (_ref) => {
  var {
    typed: typed2,
    format: format2
  } = _ref;
  return typed2(name$2Q, {
    "number | BigNumber": function numberBigNumber(n) {
      return format2(n, {
        notation: "hex"
      });
    },
    "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
      return format2(n, {
        notation: "hex",
        wordSize
      });
    }
  });
});
var name$2P = "print";
var dependencies$2P = ["typed"];
var createPrint = /* @__PURE__ */ factory(name$2P, dependencies$2P, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$2P, {
    "string, Object | Array": _print,
    "string, Object | Array, number | Object": _print
  });
});
function _print(template, values2, options) {
  return template.replace(/\$([\w.]+)/g, function(original, key) {
    var keys2 = key.split(".");
    var value = values2[keys2.shift()];
    while (keys2.length && value !== void 0) {
      var k = keys2.shift();
      value = k ? value[k] : value + ".";
    }
    if (value !== void 0) {
      if (!isString(value)) {
        return format$1(value, options);
      } else {
        return value;
      }
    }
    return original;
  });
}
var name$2O = "to";
var dependencies$2O = ["typed", "matrix"];
var createTo = /* @__PURE__ */ factory(name$2O, dependencies$2O, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$2O, {
    "Unit, Unit | string": (x, unit2) => x.to(unit2)
  }, matrixAlgorithmSuite({
    Ds: true
  }));
});
var name$2N = "isPrime";
var dependencies$2N = ["typed"];
var createIsPrime = /* @__PURE__ */ factory(name$2N, dependencies$2N, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$2N, {
    number: function number2(x) {
      if (x * 0 !== 0) {
        return false;
      }
      if (x <= 3) {
        return x > 1;
      }
      if (x % 2 === 0 || x % 3 === 0) {
        return false;
      }
      for (var i2 = 5; i2 * i2 <= x; i2 += 6) {
        if (x % i2 === 0 || x % (i2 + 2) === 0) {
          return false;
        }
      }
      return true;
    },
    BigNumber: function BigNumber2(n) {
      if (n.toNumber() * 0 !== 0) {
        return false;
      }
      if (n.lte(3))
        return n.gt(1);
      if (n.mod(2).eq(0) || n.mod(3).eq(0))
        return false;
      if (n.lt(Math.pow(2, 32))) {
        var x = n.toNumber();
        for (var i2 = 5; i2 * i2 <= x; i2 += 6) {
          if (x % i2 === 0 || x % (i2 + 2) === 0) {
            return false;
          }
        }
        return true;
      }
      function modPow(base2, exponent, modulus) {
        var accumulator = 1;
        while (!exponent.eq(0)) {
          if (exponent.mod(2).eq(0)) {
            exponent = exponent.div(2);
            base2 = base2.mul(base2).mod(modulus);
          } else {
            exponent = exponent.sub(1);
            accumulator = base2.mul(accumulator).mod(modulus);
          }
        }
        return accumulator;
      }
      var Decimal2 = n.constructor.clone({
        precision: n.toFixed(0).length * 2
      });
      n = new Decimal2(n);
      var r = 0;
      var d = n.sub(1);
      while (d.mod(2).eq(0)) {
        d = d.div(2);
        r += 1;
      }
      var bases = null;
      if (n.lt("3317044064679887385961981")) {
        bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter((x2) => x2 < n);
      } else {
        var max3 = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
        bases = [];
        for (var _i = 2; _i <= max3; _i += 1) {
          bases.push(max3);
        }
      }
      for (var _i2 = 0; _i2 < bases.length; _i2 += 1) {
        var a = bases[_i2];
        var adn = modPow(n.sub(n).add(a), d, n);
        if (!adn.eq(1)) {
          for (var _i3 = 0, _x = adn; !_x.eq(n.sub(1)); _i3 += 1, _x = _x.mul(_x).mod(n)) {
            if (_i3 === r - 1) {
              return false;
            }
          }
        }
      }
      return true;
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$2M = "numeric";
var dependencies$2M = ["number", "?bignumber", "?fraction"];
var createNumeric = /* @__PURE__ */ factory(name$2M, dependencies$2M, (_ref) => {
  var {
    number: _number,
    bignumber: bignumber2,
    fraction: fraction2
  } = _ref;
  var validInputTypes = {
    string: true,
    number: true,
    BigNumber: true,
    Fraction: true
  };
  var validOutputTypes = {
    number: (x) => _number(x),
    BigNumber: bignumber2 ? (x) => bignumber2(x) : noBignumber,
    Fraction: fraction2 ? (x) => fraction2(x) : noFraction
  };
  return function numeric3(value) {
    var outputType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "number";
    var check = arguments.length > 2 ? arguments[2] : void 0;
    if (check !== void 0) {
      throw new SyntaxError("numeric() takes one or two arguments");
    }
    var inputType = typeOf$1(value);
    if (!(inputType in validInputTypes)) {
      throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
    }
    if (!(outputType in validOutputTypes)) {
      throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
    }
    if (outputType === inputType) {
      return value;
    } else {
      return validOutputTypes[outputType](value);
    }
  };
});
var name$2L = "divideScalar";
var dependencies$2L = ["typed", "numeric"];
var createDivideScalar = /* @__PURE__ */ factory(name$2L, dependencies$2L, (_ref) => {
  var {
    typed: typed2,
    numeric: numeric3
  } = _ref;
  return typed2(name$2L, {
    "number, number": function numberNumber(x, y) {
      return x / y;
    },
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.div(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.div(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.div(y);
    },
    "Unit, number | Complex | Fraction | BigNumber | Unit": (x, y) => x.divide(y),
    "number | Fraction | Complex | BigNumber, Unit": (x, y) => y.divideInto(x)
  });
});
var name$2K = "pow";
var dependencies$2K = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
var createPow = /* @__PURE__ */ factory(name$2K, dependencies$2K, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    identity: identity2,
    multiply: multiply2,
    matrix: matrix2,
    inv: inv2,
    number: number2,
    fraction: fraction2,
    Complex: Complex2
  } = _ref;
  return typed2(name$2K, {
    "number, number": _pow,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.pow(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      if (y.isInteger() || x >= 0 || config3.predictable) {
        return x.pow(y);
      } else {
        return new Complex2(x.toNumber(), 0).pow(y.toNumber(), 0);
      }
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      var result = x.pow(y);
      if (result != null) {
        return result;
      }
      if (config3.predictable) {
        throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
      } else {
        return _pow(x.valueOf(), y.valueOf());
      }
    },
    "Array, number": _powArray,
    "Array, BigNumber": function ArrayBigNumber(x, y) {
      return _powArray(x, y.toNumber());
    },
    "Matrix, number": _powMatrix,
    "Matrix, BigNumber": function MatrixBigNumber(x, y) {
      return _powMatrix(x, y.toNumber());
    },
    "Unit, number | BigNumber": function UnitNumberBigNumber(x, y) {
      return x.pow(y);
    }
  });
  function _pow(x, y) {
    if (config3.predictable && !isInteger$1(y) && x < 0) {
      try {
        var yFrac = fraction2(y);
        var yNum = number2(yFrac);
        if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
          if (yFrac.d % 2 === 1) {
            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
          }
        }
      } catch (ex) {
      }
    }
    if (config3.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
      return NaN;
    }
    if (isInteger$1(y) || x >= 0 || config3.predictable) {
      return powNumber(x, y);
    } else {
      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
        return 0;
      }
      return new Complex2(x, 0).pow(y, 0);
    }
  }
  function _powArray(x, y) {
    if (!isInteger$1(y)) {
      throw new TypeError("For A^b, b must be an integer (value is " + y + ")");
    }
    var s = arraySize(x);
    if (s.length !== 2) {
      throw new Error("For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)");
    }
    if (s[0] !== s[1]) {
      throw new Error("For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")");
    }
    if (y < 0) {
      try {
        return _powArray(inv2(x), -y);
      } catch (error) {
        if (error.message === "Cannot calculate inverse, determinant is zero") {
          throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y + ")");
        }
        throw error;
      }
    }
    var res = identity2(s[0]).valueOf();
    var px = x;
    while (y >= 1) {
      if ((y & 1) === 1) {
        res = multiply2(px, res);
      }
      y >>= 1;
      px = multiply2(px, px);
    }
    return res;
  }
  function _powMatrix(x, y) {
    return matrix2(_powArray(x.valueOf(), y));
  }
});
var NO_INT = "Number of decimals in function round must be an integer";
var name$2J = "round";
var dependencies$2J = ["typed", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
var createRound = /* @__PURE__ */ factory(name$2J, dependencies$2J, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  return typed2(name$2J, {
    number: roundNumber,
    "number, number": roundNumber,
    "number, BigNumber": function numberBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return new BigNumber2(x).toDecimalPlaces(n.toNumber());
    },
    Complex: function Complex2(x) {
      return x.round();
    },
    "Complex, number": function ComplexNumber(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      var _n = n.toNumber();
      return x.round(_n);
    },
    BigNumber: function BigNumber3(x) {
      return x.toDecimalPlaces(0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return x.toDecimalPlaces(n.toNumber());
    },
    Fraction: function Fraction2(x) {
      return x.round();
    },
    "Fraction, number": function FractionNumber(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return x.round(n.toNumber());
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2)),
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(x, y, self2, false);
    }),
    "Array, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix2(x), y, self2, false).valueOf();
    }),
    "number | Complex | BigNumber | Fraction, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo12xSfs(y, x, self2, true);
    }),
    "number | Complex | BigNumber | Fraction, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    }),
    "number | Complex | BigNumber | Fraction, Array": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
    })
  });
});
var name$2I = "log";
var dependencies$2I = ["config", "typed", "divideScalar", "Complex"];
var createLog = /* @__PURE__ */ factory(name$2I, dependencies$2I, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    divideScalar: divideScalar2,
    Complex: Complex2
  } = _ref;
  return typed2(name$2I, {
    number: function number2(x) {
      if (x >= 0 || config3.predictable) {
        return logNumber(x);
      } else {
        return new Complex2(x, 0).log();
      }
    },
    Complex: function Complex3(x) {
      return x.log();
    },
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config3.predictable) {
        return x.ln();
      } else {
        return new Complex2(x.toNumber(), 0).log();
      }
    },
    "any, any": typed2.referToSelf((self2) => (x, base2) => {
      return divideScalar2(self2(x), self2(base2));
    })
  });
});
var name$2H = "log1p";
var dependencies$2H = ["typed", "config", "divideScalar", "log", "Complex"];
var createLog1p = /* @__PURE__ */ factory(name$2H, dependencies$2H, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    divideScalar: divideScalar2,
    log: log3,
    Complex: Complex2
  } = _ref;
  return typed2(name$2H, {
    number: function number2(x) {
      if (x >= -1 || config3.predictable) {
        return log1p$1(x);
      } else {
        return _log1pComplex(new Complex2(x, 0));
      }
    },
    Complex: _log1pComplex,
    BigNumber: function BigNumber2(x) {
      var y = x.plus(1);
      if (!y.isNegative() || config3.predictable) {
        return y.ln();
      } else {
        return _log1pComplex(new Complex2(x.toNumber(), 0));
      }
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2)),
    "any, any": typed2.referToSelf((self2) => (x, base2) => {
      return divideScalar2(self2(x), log3(base2));
    })
  });
  function _log1pComplex(x) {
    var xRe1p = x.re + 1;
    return new Complex2(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
  }
});
var name$2G = "nthRoots";
var dependencies$2G = ["config", "typed", "divideScalar", "Complex"];
var createNthRoots = /* @__PURE__ */ factory(name$2G, dependencies$2G, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    divideScalar: divideScalar2,
    Complex: Complex2
  } = _ref;
  var _calculateExactResult = [function realPos(val) {
    return new Complex2(val, 0);
  }, function imagPos(val) {
    return new Complex2(0, val);
  }, function realNeg(val) {
    return new Complex2(-val, 0);
  }, function imagNeg(val) {
    return new Complex2(0, -val);
  }];
  function _nthComplexRoots(a, root) {
    if (root < 0)
      throw new Error("Root must be greater than zero");
    if (root === 0)
      throw new Error("Root must be non-zero");
    if (root % 1 !== 0)
      throw new Error("Root must be an integer");
    if (a === 0 || a.abs() === 0)
      return [new Complex2(0, 0)];
    var aIsNumeric = typeof a === "number";
    var offset;
    if (aIsNumeric || a.re === 0 || a.im === 0) {
      if (aIsNumeric) {
        offset = 2 * +(a < 0);
      } else if (a.im === 0) {
        offset = 2 * +(a.re < 0);
      } else {
        offset = 2 * +(a.im < 0) + 1;
      }
    }
    var arg2 = a.arg();
    var abs2 = a.abs();
    var roots = [];
    var r = Math.pow(abs2, 1 / root);
    for (var k = 0; k < root; k++) {
      var halfPiFactor = (offset + 4 * k) / root;
      if (halfPiFactor === Math.round(halfPiFactor)) {
        roots.push(_calculateExactResult[halfPiFactor % 4](r));
        continue;
      }
      roots.push(new Complex2({
        r,
        phi: (arg2 + 2 * Math.PI * k) / root
      }));
    }
    return roots;
  }
  return typed2(name$2G, {
    Complex: function Complex3(x) {
      return _nthComplexRoots(x, 2);
    },
    "Complex, number": _nthComplexRoots
  });
});
var name$2F = "dotPow";
var dependencies$2F = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix"];
var createDotPow = /* @__PURE__ */ factory(name$2F, dependencies$2F, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2,
    matrix: matrix2,
    pow: pow2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var powScalarSignatures = {};
  for (var signature in pow2.signatures) {
    if (Object.prototype.hasOwnProperty.call(pow2.signatures, signature)) {
      if (!signature.includes("Matrix") && !signature.includes("Array")) {
        powScalarSignatures[signature] = pow2.signatures[signature];
      }
    }
  }
  var powScalar = typed2(powScalarSignatures);
  return typed2(name$2F, matrixAlgorithmSuite({
    elop: powScalar,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});
var name$2E = "dotDivide";
var dependencies$2E = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix"];
var createDotDivide = /* @__PURE__ */ factory(name$2E, dependencies$2E, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    divideScalar: divideScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$2E, matrixAlgorithmSuite({
    elop: divideScalar2,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});
function createSolveValidation(_ref) {
  var {
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function solveValidation(m, b, copy2) {
    var mSize = m.size();
    if (mSize.length !== 2) {
      throw new RangeError("Matrix must be two dimensional (size: " + format$1(mSize) + ")");
    }
    var rows = mSize[0];
    var columns = mSize[1];
    if (rows !== columns) {
      throw new RangeError("Matrix must be square (size: " + format$1(mSize) + ")");
    }
    var data = [];
    if (isMatrix(b)) {
      var bSize = b.size();
      var bdata = b._data;
      if (bSize.length === 1) {
        if (bSize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var i2 = 0; i2 < rows; i2++) {
          data[i2] = [bdata[i2]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1],
          datatype: b._datatype
        });
      }
      if (bSize.length === 2) {
        if (bSize[0] !== rows || bSize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        if (isDenseMatrix(b)) {
          if (copy2) {
            data = [];
            for (var _i = 0; _i < rows; _i++) {
              data[_i] = [bdata[_i][0]];
            }
            return new DenseMatrix2({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
          return b;
        }
        if (isSparseMatrix(b)) {
          for (var _i2 = 0; _i2 < rows; _i2++) {
            data[_i2] = [0];
          }
          var values2 = b._values;
          var index2 = b._index;
          var ptr = b._ptr;
          for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
            var _i3 = index2[k];
            data[_i3][0] = values2[k];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
    if (isArray$1(b)) {
      var bsize = arraySize(b);
      if (bsize.length === 1) {
        if (bsize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i4 = 0; _i4 < rows; _i4++) {
          data[_i4] = [b[_i4]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      if (bsize.length === 2) {
        if (bsize[0] !== rows || bsize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i5 = 0; _i5 < rows; _i5++) {
          data[_i5] = [b[_i5][0]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
  };
}
var name$2D = "lsolve";
var dependencies$2D = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
var createLsolve = /* @__PURE__ */ factory(name$2D, dependencies$2D, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtract: subtract2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name$2D, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var r = _denseForwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = 0; j < columns; j++) {
      var bj = bdata[j][0] || 0;
      var xj = void 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar2(bj, vjj);
        for (var i2 = j + 1; i2 < rows; i2++) {
          bdata[i2] = [subtract2(bdata[i2][0] || 0, multiplyScalar2(xj, mdata[i2][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values2 = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = 0; j < columns; j++) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = firstIndex; k < lastIndex; k++) {
          var i2 = index2[k];
          if (i2 === j) {
            vjj = values2[k];
          } else if (i2 > j) {
            jValues.push(values2[k]);
            jIndices.push(i2);
          }
        }
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar2(bj, vjj);
        for (var _k = 0, l = jIndices.length; _k < l; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtract2(bdata[_i][0] || 0, multiplyScalar2(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
});
var name$2C = "usolve";
var dependencies$2C = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
var createUsolve = /* @__PURE__ */ factory(name$2C, dependencies$2C, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtract: subtract2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name$2C, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var r = _denseBackwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = columns - 1; j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      var xj = void 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar2(bj, vjj);
        for (var i2 = j - 1; i2 >= 0; i2--) {
          bdata[i2] = [subtract2(bdata[i2][0] || 0, multiplyScalar2(xj, mdata[i2][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values2 = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = columns - 1; j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = lastIndex - 1; k >= firstIndex; k--) {
          var i2 = index2[k];
          if (i2 === j) {
            vjj = values2[k];
          } else if (i2 < j) {
            jValues.push(values2[k]);
            jIndices.push(i2);
          }
        }
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar2(bj, vjj);
        for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtract2(bdata[_i][0], multiplyScalar2(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
});
var name$2B = "lsolveAll";
var dependencies$2B = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
var createLsolveAll = /* @__PURE__ */ factory(name$2B, dependencies$2B, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtract: subtract2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name$2B, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var R = _denseForwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseForwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i2 = 0; i2 < columns; i2++) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        if (!equalScalar2(M[i2][i2], 0)) {
          b[i2] = divideScalar2(b[i2], M[i2][i2]);
          for (var j = i2 + 1; j < columns; j++) {
            b[j] = subtract2(b[j], multiplyScalar2(b[i2], M[j][i2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j = i2 + 1; _j < columns; _j++) {
            bNew[_j] = subtract2(bNew[_j], M[_j][i2]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
  function _sparseForwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values2 = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    for (var i2 = 0; i2 < columns; i2++) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i2];
        var lastIndex = ptr[i2 + 1];
        var Mii = 0;
        for (var j = firstIndex; j < lastIndex; j++) {
          var J = index2[j];
          if (J === i2) {
            Mii = values2[j];
          } else if (J > i2) {
            iValues.push(values2[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar2(Mii, 0)) {
          b[i2] = divideScalar2(b[i2], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtract2(b[_J], multiplyScalar2(b[i2], iValues[_j2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtract2(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
});
var name$2A = "usolveAll";
var dependencies$2A = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtract", "equalScalar", "DenseMatrix"];
var createUsolveAll = /* @__PURE__ */ factory(name$2A, dependencies$2A, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtract: subtract2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name$2A, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var R = _denseBackwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseBackwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i2 = columns - 1; i2 >= 0; i2--) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        if (!equalScalar2(M[i2][i2], 0)) {
          b[i2] = divideScalar2(b[i2], M[i2][i2]);
          for (var j = i2 - 1; j >= 0; j--) {
            b[j] = subtract2(b[j], multiplyScalar2(b[i2], M[j][i2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j = i2 - 1; _j >= 0; _j--) {
            bNew[_j] = subtract2(bNew[_j], M[_j][i2]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
  function _sparseBackwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values2 = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    for (var i2 = columns - 1; i2 >= 0; i2--) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i2];
        var lastIndex = ptr[i2 + 1];
        var Mii = 0;
        for (var j = lastIndex - 1; j >= firstIndex; j--) {
          var J = index2[j];
          if (J === i2) {
            Mii = values2[j];
          } else if (J < i2) {
            iValues.push(values2[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar2(Mii, 0)) {
          b[i2] = divideScalar2(b[i2], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtract2(b[_J], multiplyScalar2(b[i2], iValues[_j2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtract2(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
});
var name$2z = "matAlgo08xS0Sid";
var dependencies$2z = ["typed", "equalScalar"];
var createMatAlgo08xS0Sid = /* @__PURE__ */ factory(name$2z, dependencies$2z, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo08xS0Sid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype;
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!avalues || !bvalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrices");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero2 = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero2 = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var x = [];
    var w = [];
    var k, k0, k1, i2;
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        w[i2] = mark;
        x[i2] = avalues[k];
        cindex.push(i2);
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        if (w[i2] === mark) {
          x[i2] = cf(x[i2], bvalues[k]);
        }
      }
      k = cptr[j];
      while (k < cindex.length) {
        i2 = cindex[k];
        var v = x[i2];
        if (!eq(v, zero2)) {
          cvalues.push(v);
          k++;
        } else {
          cindex.splice(k, 1);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var createUseMatrixForArrayScalar = /* @__PURE__ */ factory("useMatrixForArrayScalar", ["typed", "matrix"], (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return {
    "Array, number": typed2.referTo("DenseMatrix, number", (selfDn) => (x, y) => selfDn(matrix2(x), y).valueOf()),
    "Array, BigNumber": typed2.referTo("DenseMatrix, BigNumber", (selfDB) => (x, y) => selfDB(matrix2(x), y).valueOf()),
    "number, Array": typed2.referTo("number, DenseMatrix", (selfnD) => (x, y) => selfnD(x, matrix2(y)).valueOf()),
    "BigNumber, Array": typed2.referTo("BigNumber, DenseMatrix", (selfBD) => (x, y) => selfBD(x, matrix2(y)).valueOf())
  };
});
var name$2y = "leftShift";
var dependencies$2y = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createLeftShift = /* @__PURE__ */ factory(name$2y, dependencies$2y, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$2y, {
    "number, number": leftShiftNumber,
    "BigNumber, BigNumber": leftShiftBigNumber,
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});
var name$2x = "rightArithShift";
var dependencies$2x = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createRightArithShift = /* @__PURE__ */ factory(name$2x, dependencies$2x, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$2x, {
    "number, number": rightArithShiftNumber,
    "BigNumber, BigNumber": rightArithShiftBigNumber,
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});
var name$2w = "rightLogShift";
var dependencies$2w = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createRightLogShift = /* @__PURE__ */ factory(name$2w, dependencies$2w, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$2w, {
    "number, number": rightLogShiftNumber,
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});
var name$2v = "and";
var dependencies$2v = ["typed", "matrix", "equalScalar", "zeros", "not"];
var createAnd = /* @__PURE__ */ factory(name$2v, dependencies$2v, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    not: not2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$2v, {
    "number, number": andNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
    },
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0)),
    "SparseMatrix, any": typed2.referToSelf((self2) => (x, y) => {
      if (not2(y)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, any": typed2.referToSelf((self2) => (x, y) => {
      if (not2(y)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "any, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (not2(x)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo11xS0s(y, x, self2, true);
    }),
    "any, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (not2(x)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    }),
    "Array, any": typed2.referToSelf((self2) => (x, y) => {
      return self2(matrix2(x), y).valueOf();
    }),
    "any, Array": typed2.referToSelf((self2) => (x, y) => {
      return self2(x, matrix2(y)).valueOf();
    })
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0
  }));
});
var name$2u = "compare";
var dependencies$2u = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix"];
var createCompare = /* @__PURE__ */ factory(name$2u, dependencies$2u, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    equalScalar: equalScalar2,
    matrix: matrix2,
    BigNumber: BigNumber2,
    Fraction: Fraction2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name$2u, createCompareNumber({
    typed: typed2,
    config: config3
  }), {
    "boolean, boolean": function booleanBoolean(x, y) {
      return x === y ? 0 : x > y ? 1 : -1;
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return nearlyEqual(x, y, config3.epsilon) ? new BigNumber2(0) : new BigNumber2(x.cmp(y));
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return new Fraction2(x.compare(y));
    },
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createCompareNumber = /* @__PURE__ */ factory(name$2u, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config3
  } = _ref2;
  return typed2(name$2u, {
    "number, number": function numberNumber(x, y) {
      return nearlyEqual$1(x, y, config3.epsilon) ? 0 : x > y ? 1 : -1;
    }
  });
});
var naturalSort = function naturalSort2(a, b) {
  var re2 = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, sre = /(^[ ]*|[ ]*$)/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, i2 = function(s) {
    return naturalSort2.insensitive && ("" + s).toLowerCase() || "" + s;
  }, x = i2(a).replace(sre, "") || "", y = i2(b).replace(sre, "") || "", xN = x.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), yN = y.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), xD = parseInt(x.match(hre), 16) || xN.length !== 1 && x.match(dre) && Date.parse(x), yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null, oFxNcL, oFyNcL;
  if (yD) {
    if (xD < yD) {
      return -1;
    } else if (xD > yD) {
      return 1;
    }
  }
  for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
    oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
    oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
    if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
      return isNaN(oFxNcL) ? 1 : -1;
    } else if (typeof oFxNcL !== typeof oFyNcL) {
      oFxNcL += "";
      oFyNcL += "";
    }
    if (oFxNcL < oFyNcL) {
      return -1;
    }
    if (oFxNcL > oFyNcL) {
      return 1;
    }
  }
  return 0;
};
var name$2t = "compareNatural";
var dependencies$2t = ["typed", "compare"];
var createCompareNatural = /* @__PURE__ */ factory(name$2t, dependencies$2t, (_ref) => {
  var {
    typed: typed2,
    compare: compare2
  } = _ref;
  var compareBooleans = compare2.signatures["boolean,boolean"];
  return typed2(name$2t, {
    "any, any": _compareNatural
  });
  function _compareNatural(x, y) {
    var typeX = typeOf$1(x);
    var typeY = typeOf$1(y);
    var c;
    if ((typeX === "number" || typeX === "BigNumber" || typeX === "Fraction") && (typeY === "number" || typeY === "BigNumber" || typeY === "Fraction")) {
      c = compare2(x, y);
      if (c.toString() !== "0") {
        return c > 0 ? 1 : -1;
      } else {
        return naturalSort(typeX, typeY);
      }
    }
    var matTypes = ["Array", "DenseMatrix", "SparseMatrix"];
    if (matTypes.includes(typeX) || matTypes.includes(typeY)) {
      c = compareMatricesAndArrays(_compareNatural, x, y);
      if (c !== 0) {
        return c;
      } else {
        return naturalSort(typeX, typeY);
      }
    }
    if (typeX !== typeY) {
      return naturalSort(typeX, typeY);
    }
    if (typeX === "Complex") {
      return compareComplexNumbers(x, y);
    }
    if (typeX === "Unit") {
      if (x.equalBase(y)) {
        return _compareNatural(x.value, y.value);
      }
      return compareArrays(_compareNatural, x.formatUnits(), y.formatUnits());
    }
    if (typeX === "boolean") {
      return compareBooleans(x, y);
    }
    if (typeX === "string") {
      return naturalSort(x, y);
    }
    if (typeX === "Object") {
      return compareObjects(_compareNatural, x, y);
    }
    if (typeX === "null") {
      return 0;
    }
    if (typeX === "undefined") {
      return 0;
    }
    throw new TypeError('Unsupported type of value "' + typeX + '"');
  }
  function compareMatricesAndArrays(compareNatural2, x, y) {
    if (isSparseMatrix(x) && isSparseMatrix(y)) {
      return compareArrays(compareNatural2, x.toJSON().values, y.toJSON().values);
    }
    if (isSparseMatrix(x)) {
      return compareMatricesAndArrays(compareNatural2, x.toArray(), y);
    }
    if (isSparseMatrix(y)) {
      return compareMatricesAndArrays(compareNatural2, x, y.toArray());
    }
    if (isDenseMatrix(x)) {
      return compareMatricesAndArrays(compareNatural2, x.toJSON().data, y);
    }
    if (isDenseMatrix(y)) {
      return compareMatricesAndArrays(compareNatural2, x, y.toJSON().data);
    }
    if (!Array.isArray(x)) {
      return compareMatricesAndArrays(compareNatural2, [x], y);
    }
    if (!Array.isArray(y)) {
      return compareMatricesAndArrays(compareNatural2, x, [y]);
    }
    return compareArrays(compareNatural2, x, y);
  }
  function compareArrays(compareNatural2, x, y) {
    for (var i2 = 0, ii = Math.min(x.length, y.length); i2 < ii; i2++) {
      var v = compareNatural2(x[i2], y[i2]);
      if (v !== 0) {
        return v;
      }
    }
    if (x.length > y.length) {
      return 1;
    }
    if (x.length < y.length) {
      return -1;
    }
    return 0;
  }
  function compareObjects(compareNatural2, x, y) {
    var keysX = Object.keys(x);
    var keysY = Object.keys(y);
    keysX.sort(naturalSort);
    keysY.sort(naturalSort);
    var c = compareArrays(compareNatural2, keysX, keysY);
    if (c !== 0) {
      return c;
    }
    for (var i2 = 0; i2 < keysX.length; i2++) {
      var v = compareNatural2(x[keysX[i2]], y[keysY[i2]]);
      if (v !== 0) {
        return v;
      }
    }
    return 0;
  }
});
function compareComplexNumbers(x, y) {
  if (x.re > y.re) {
    return 1;
  }
  if (x.re < y.re) {
    return -1;
  }
  if (x.im > y.im) {
    return 1;
  }
  if (x.im < y.im) {
    return -1;
  }
  return 0;
}
var name$2s = "compareText";
var dependencies$2s = ["typed", "matrix"];
compareText$1.signature = "any, any";
var createCompareText = /* @__PURE__ */ factory(name$2s, dependencies$2s, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$2s, compareText$1, matrixAlgorithmSuite({
    elop: compareText$1,
    Ds: true
  }));
});
var name$2r = "equal";
var dependencies$2r = ["typed", "matrix", "equalScalar", "DenseMatrix"];
var createEqual = /* @__PURE__ */ factory(name$2r, dependencies$2r, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$2r, createEqualNumber({
    typed: typed2,
    equalScalar: equalScalar2
  }), matrixAlgorithmSuite({
    elop: equalScalar2,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createEqualNumber = factory(name$2r, ["typed", "equalScalar"], (_ref2) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref2;
  return typed2(name$2r, {
    "any, any": function anyAny(x, y) {
      if (x === null) {
        return y === null;
      }
      if (y === null) {
        return x === null;
      }
      if (x === void 0) {
        return y === void 0;
      }
      if (y === void 0) {
        return x === void 0;
      }
      return equalScalar2(x, y);
    }
  });
});
var name$2q = "equalText";
var dependencies$2q = ["typed", "compareText", "isZero"];
var createEqualText = /* @__PURE__ */ factory(name$2q, dependencies$2q, (_ref) => {
  var {
    typed: typed2,
    compareText: compareText2,
    isZero: isZero2
  } = _ref;
  return typed2(name$2q, {
    "any, any": function anyAny(x, y) {
      return isZero2(compareText2(x, y));
    }
  });
});
var name$2p = "smaller";
var dependencies$2p = ["typed", "config", "matrix", "DenseMatrix"];
var createSmaller = /* @__PURE__ */ factory(name$2p, dependencies$2p, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name$2p, createSmallerNumber({
    typed: typed2,
    config: config3
  }), {
    "boolean, boolean": (x, y) => x < y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.lt(y) && !nearlyEqual(x, y, config3.epsilon);
    },
    "Fraction, Fraction": (x, y) => x.compare(y) === -1,
    "Complex, Complex": function ComplexComplex(x, y) {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createSmallerNumber = /* @__PURE__ */ factory(name$2p, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config3
  } = _ref2;
  return typed2(name$2p, {
    "number, number": function numberNumber(x, y) {
      return x < y && !nearlyEqual$1(x, y, config3.epsilon);
    }
  });
});
var name$2o = "smallerEq";
var dependencies$2o = ["typed", "config", "matrix", "DenseMatrix"];
var createSmallerEq = /* @__PURE__ */ factory(name$2o, dependencies$2o, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name$2o, createSmallerEqNumber({
    typed: typed2,
    config: config3
  }), {
    "boolean, boolean": (x, y) => x <= y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.lte(y) || nearlyEqual(x, y, config3.epsilon);
    },
    "Fraction, Fraction": (x, y) => x.compare(y) !== 1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createSmallerEqNumber = /* @__PURE__ */ factory(name$2o, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config3
  } = _ref2;
  return typed2(name$2o, {
    "number, number": function numberNumber(x, y) {
      return x <= y || nearlyEqual$1(x, y, config3.epsilon);
    }
  });
});
var name$2n = "larger";
var dependencies$2n = ["typed", "config", "matrix", "DenseMatrix"];
var createLarger = /* @__PURE__ */ factory(name$2n, dependencies$2n, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name$2n, createLargerNumber({
    typed: typed2,
    config: config3
  }), {
    "boolean, boolean": (x, y) => x > y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.gt(y) && !nearlyEqual(x, y, config3.epsilon);
    },
    "Fraction, Fraction": (x, y) => x.compare(y) === 1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createLargerNumber = /* @__PURE__ */ factory(name$2n, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config3
  } = _ref2;
  return typed2(name$2n, {
    "number, number": function numberNumber(x, y) {
      return x > y && !nearlyEqual$1(x, y, config3.epsilon);
    }
  });
});
var name$2m = "largerEq";
var dependencies$2m = ["typed", "config", "matrix", "DenseMatrix"];
var createLargerEq = /* @__PURE__ */ factory(name$2m, dependencies$2m, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name$2m, createLargerEqNumber({
    typed: typed2,
    config: config3
  }), {
    "boolean, boolean": (x, y) => x >= y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.gte(y) || nearlyEqual(x, y, config3.epsilon);
    },
    "Fraction, Fraction": (x, y) => x.compare(y) !== -1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createLargerEqNumber = /* @__PURE__ */ factory(name$2m, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config3
  } = _ref2;
  return typed2(name$2m, {
    "number, number": function numberNumber(x, y) {
      return x >= y || nearlyEqual$1(x, y, config3.epsilon);
    }
  });
});
var name$2l = "deepEqual";
var dependencies$2l = ["typed", "equal"];
var createDeepEqual = /* @__PURE__ */ factory(name$2l, dependencies$2l, (_ref) => {
  var {
    typed: typed2,
    equal: equal2
  } = _ref;
  return typed2(name$2l, {
    "any, any": function anyAny(x, y) {
      return _deepEqual(x.valueOf(), y.valueOf());
    }
  });
  function _deepEqual(x, y) {
    if (Array.isArray(x)) {
      if (Array.isArray(y)) {
        var len = x.length;
        if (len !== y.length) {
          return false;
        }
        for (var i2 = 0; i2 < len; i2++) {
          if (!_deepEqual(x[i2], y[i2])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    } else {
      if (Array.isArray(y)) {
        return false;
      } else {
        return equal2(x, y);
      }
    }
  }
});
var name$2k = "unequal";
var dependencies$2k = ["typed", "config", "equalScalar", "matrix", "DenseMatrix"];
var createUnequal = /* @__PURE__ */ factory(name$2k, dependencies$2k, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    equalScalar: equalScalar2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$2k, createUnequalNumber({
    typed: typed2,
    equalScalar: equalScalar2
  }), matrixAlgorithmSuite({
    elop: _unequal,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
  function _unequal(x, y) {
    return !equalScalar2(x, y);
  }
});
var createUnequalNumber = factory(name$2k, ["typed", "equalScalar"], (_ref2) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref2;
  return typed2(name$2k, {
    "any, any": function anyAny(x, y) {
      if (x === null) {
        return y !== null;
      }
      if (y === null) {
        return x !== null;
      }
      if (x === void 0) {
        return y !== void 0;
      }
      if (y === void 0) {
        return x !== void 0;
      }
      return !equalScalar2(x, y);
    }
  });
});
var name$2j = "partitionSelect";
var dependencies$2j = ["typed", "isNumeric", "isNaN", "compare"];
var createPartitionSelect = /* @__PURE__ */ factory(name$2j, dependencies$2j, (_ref) => {
  var {
    typed: typed2,
    isNumeric: isNumeric2,
    isNaN: isNaN2,
    compare: compare2
  } = _ref;
  var asc = compare2;
  var desc = (a, b) => -compare2(a, b);
  return typed2(name$2j, {
    "Array | Matrix, number": function ArrayMatrixNumber(x, k) {
      return _partitionSelect(x, k, asc);
    },
    "Array | Matrix, number, string": function ArrayMatrixNumberString(x, k, compare3) {
      if (compare3 === "asc") {
        return _partitionSelect(x, k, asc);
      } else if (compare3 === "desc") {
        return _partitionSelect(x, k, desc);
      } else {
        throw new Error('Compare string must be "asc" or "desc"');
      }
    },
    "Array | Matrix, number, function": _partitionSelect
  });
  function _partitionSelect(x, k, compare3) {
    if (!isInteger$1(k) || k < 0) {
      throw new Error("k must be a non-negative integer");
    }
    if (isMatrix(x)) {
      var size2 = x.size();
      if (size2.length > 1) {
        throw new Error("Only one dimensional matrices supported");
      }
      return quickSelect(x.valueOf(), k, compare3);
    }
    if (Array.isArray(x)) {
      return quickSelect(x, k, compare3);
    }
  }
  function quickSelect(arr, k, compare3) {
    if (k >= arr.length) {
      throw new Error("k out of bounds");
    }
    for (var i2 = 0; i2 < arr.length; i2++) {
      if (isNumeric2(arr[i2]) && isNaN2(arr[i2])) {
        return arr[i2];
      }
    }
    var from = 0;
    var to2 = arr.length - 1;
    while (from < to2) {
      var r = from;
      var w = to2;
      var pivot = arr[Math.floor(Math.random() * (to2 - from + 1)) + from];
      while (r < w) {
        if (compare3(arr[r], pivot) >= 0) {
          var tmp = arr[w];
          arr[w] = arr[r];
          arr[r] = tmp;
          --w;
        } else {
          ++r;
        }
      }
      if (compare3(arr[r], pivot) > 0) {
        --r;
      }
      if (k <= r) {
        to2 = r;
      } else {
        from = r + 1;
      }
    }
    return arr[k];
  }
});
var name$2i = "sort";
var dependencies$2i = ["typed", "matrix", "compare", "compareNatural"];
var createSort = /* @__PURE__ */ factory(name$2i, dependencies$2i, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    compare: compare2,
    compareNatural: compareNatural2
  } = _ref;
  var compareAsc = compare2;
  var compareDesc = (a, b) => -compare2(a, b);
  return typed2(name$2i, {
    Array: function Array2(x) {
      _arrayIsVector(x);
      return x.sort(compareAsc);
    },
    Matrix: function Matrix2(x) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(compareAsc), x.storage());
    },
    "Array, function": function ArrayFunction(x, _comparator2) {
      _arrayIsVector(x);
      return x.sort(_comparator2);
    },
    "Matrix, function": function MatrixFunction(x, _comparator2) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(_comparator2), x.storage());
    },
    "Array, string": function ArrayString(x, order) {
      _arrayIsVector(x);
      return x.sort(_comparator(order));
    },
    "Matrix, string": function MatrixString(x, order) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(_comparator(order)), x.storage());
    }
  });
  function _comparator(order) {
    if (order === "asc") {
      return compareAsc;
    } else if (order === "desc") {
      return compareDesc;
    } else if (order === "natural") {
      return compareNatural2;
    } else {
      throw new Error('String "asc", "desc", or "natural" expected');
    }
  }
  function _arrayIsVector(array) {
    if (arraySize(array).length !== 1) {
      throw new Error("One dimensional array expected");
    }
  }
  function _matrixIsVector(matrix3) {
    if (matrix3.size().length !== 1) {
      throw new Error("One dimensional matrix expected");
    }
  }
});
var name$2h = "max";
var dependencies$2h = ["typed", "config", "numeric", "larger"];
var createMax = /* @__PURE__ */ factory(name$2h, dependencies$2h, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    numeric: numeric3,
    larger: larger2
  } = _ref;
  return typed2(name$2h, {
    "Array | Matrix": _max,
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      return reduce$1(array, dim.valueOf(), _largest);
    },
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function max");
      }
      return _max(args);
    }
  });
  function _largest(x, y) {
    try {
      return larger2(x, y) ? x : y;
    } catch (err) {
      throw improveErrorMessage(err, "max", y);
    }
  }
  function _max(array) {
    var res;
    deepForEach(array, function(value) {
      try {
        if (isNaN(value) && typeof value === "number") {
          res = NaN;
        } else if (res === void 0 || larger2(value, res)) {
          res = value;
        }
      } catch (err) {
        throw improveErrorMessage(err, "max", value);
      }
    });
    if (res === void 0) {
      throw new Error("Cannot calculate max of an empty array");
    }
    if (typeof res === "string") {
      res = numeric3(res, config3.number);
    }
    return res;
  }
});
var name$2g = "min";
var dependencies$2g = ["typed", "config", "numeric", "smaller"];
var createMin = /* @__PURE__ */ factory(name$2g, dependencies$2g, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    numeric: numeric3,
    smaller: smaller2
  } = _ref;
  return typed2(name$2g, {
    "Array | Matrix": _min,
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      return reduce$1(array, dim.valueOf(), _smallest);
    },
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function min");
      }
      return _min(args);
    }
  });
  function _smallest(x, y) {
    try {
      return smaller2(x, y) ? x : y;
    } catch (err) {
      throw improveErrorMessage(err, "min", y);
    }
  }
  function _min(array) {
    var min3;
    deepForEach(array, function(value) {
      try {
        if (isNaN(value) && typeof value === "number") {
          min3 = NaN;
        } else if (min3 === void 0 || smaller2(value, min3)) {
          min3 = value;
        }
      } catch (err) {
        throw improveErrorMessage(err, "min", value);
      }
    });
    if (min3 === void 0) {
      throw new Error("Cannot calculate min of an empty array");
    }
    if (typeof min3 === "string") {
      min3 = numeric3(min3, config3.number);
    }
    return min3;
  }
});
var name$2f = "ImmutableDenseMatrix";
var dependencies$2f = ["smaller", "DenseMatrix"];
var createImmutableDenseMatrixClass = /* @__PURE__ */ factory(name$2f, dependencies$2f, (_ref) => {
  var {
    smaller: smaller2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  function ImmutableDenseMatrix2(data, datatype) {
    if (!(this instanceof ImmutableDenseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data) || isArray$1(data)) {
      var matrix2 = new DenseMatrix2(data, datatype);
      this._data = matrix2._data;
      this._size = matrix2._size;
      this._datatype = matrix2._datatype;
      this._min = null;
      this._max = null;
    } else if (data && isArray$1(data.data) && isArray$1(data.size)) {
      this._data = data.data;
      this._size = data.size;
      this._datatype = data.datatype;
      this._min = typeof data.min !== "undefined" ? data.min : null;
      this._max = typeof data.max !== "undefined" ? data.max : null;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf$1(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
      this._min = null;
      this._max = null;
    }
  }
  ImmutableDenseMatrix2.prototype = new DenseMatrix2();
  ImmutableDenseMatrix2.prototype.type = "ImmutableDenseMatrix";
  ImmutableDenseMatrix2.prototype.isImmutableDenseMatrix = true;
  ImmutableDenseMatrix2.prototype.subset = function(index2) {
    switch (arguments.length) {
      case 1: {
        var m = DenseMatrix2.prototype.subset.call(this, index2);
        if (isMatrix(m)) {
          return new ImmutableDenseMatrix2({
            data: m._data,
            size: m._size,
            datatype: m._datatype
          });
        }
        return m;
      }
      case 2:
      case 3:
        throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  ImmutableDenseMatrix2.prototype.set = function() {
    throw new Error("Cannot invoke set on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.resize = function() {
    throw new Error("Cannot invoke resize on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.reshape = function() {
    throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.clone = function() {
    return new ImmutableDenseMatrix2({
      data: clone$2(this._data),
      size: clone$2(this._size),
      datatype: this._datatype
    });
  };
  ImmutableDenseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "ImmutableDenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  ImmutableDenseMatrix2.fromJSON = function(json) {
    return new ImmutableDenseMatrix2(json);
  };
  ImmutableDenseMatrix2.prototype.swapRows = function() {
    throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.min = function() {
    if (this._min === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller2(v, m)) {
          m = v;
        }
      });
      this._min = m !== null ? m : void 0;
    }
    return this._min;
  };
  ImmutableDenseMatrix2.prototype.max = function() {
    if (this._max === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller2(m, v)) {
          m = v;
        }
      });
      this._max = m !== null ? m : void 0;
    }
    return this._max;
  };
  return ImmutableDenseMatrix2;
}, {
  isClass: true
});
var name$2e = "Index";
var dependencies$2e = ["ImmutableDenseMatrix"];
var createIndexClass = /* @__PURE__ */ factory(name$2e, dependencies$2e, (_ref) => {
  var {
    ImmutableDenseMatrix: ImmutableDenseMatrix2
  } = _ref;
  function Index2(ranges) {
    if (!(this instanceof Index2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._dimensions = [];
    this._isScalar = true;
    for (var i2 = 0, ii = arguments.length; i2 < ii; i2++) {
      var arg2 = arguments[i2];
      if (isRange(arg2)) {
        this._dimensions.push(arg2);
        this._isScalar = false;
      } else if (Array.isArray(arg2) || isMatrix(arg2)) {
        var m = _createImmutableMatrix(arg2.valueOf());
        this._dimensions.push(m);
        var size2 = m.size();
        if (size2.length !== 1 || size2[0] !== 1) {
          this._isScalar = false;
        }
      } else if (typeof arg2 === "number") {
        this._dimensions.push(_createImmutableMatrix([arg2]));
      } else if (typeof arg2 === "string") {
        this._dimensions.push(arg2);
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      }
    }
  }
  Index2.prototype.type = "Index";
  Index2.prototype.isIndex = true;
  function _createImmutableMatrix(arg2) {
    for (var i2 = 0, l = arg2.length; i2 < l; i2++) {
      if (typeof arg2[i2] !== "number" || !isInteger$1(arg2[i2])) {
        throw new TypeError("Index parameters must be positive integer numbers");
      }
    }
    return new ImmutableDenseMatrix2(arg2);
  }
  Index2.prototype.clone = function() {
    var index2 = new Index2();
    index2._dimensions = clone$2(this._dimensions);
    index2._isScalar = this._isScalar;
    return index2;
  };
  Index2.create = function(ranges) {
    var index2 = new Index2();
    Index2.apply(index2, ranges);
    return index2;
  };
  Index2.prototype.size = function() {
    var size2 = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var d = this._dimensions[i2];
      size2[i2] = typeof d === "string" ? 1 : d.size()[0];
    }
    return size2;
  };
  Index2.prototype.max = function() {
    var values2 = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var range2 = this._dimensions[i2];
      values2[i2] = typeof range2 === "string" ? range2 : range2.max();
    }
    return values2;
  };
  Index2.prototype.min = function() {
    var values2 = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var range2 = this._dimensions[i2];
      values2[i2] = typeof range2 === "string" ? range2 : range2.min();
    }
    return values2;
  };
  Index2.prototype.forEach = function(callback) {
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      callback(this._dimensions[i2], i2, this);
    }
  };
  Index2.prototype.dimension = function(dim) {
    return this._dimensions[dim] || null;
  };
  Index2.prototype.isObjectProperty = function() {
    return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
  };
  Index2.prototype.getObjectProperty = function() {
    return this.isObjectProperty() ? this._dimensions[0] : null;
  };
  Index2.prototype.isScalar = function() {
    return this._isScalar;
  };
  Index2.prototype.toArray = function() {
    var array = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var dimension = this._dimensions[i2];
      array.push(typeof dimension === "string" ? dimension : dimension.toArray());
    }
    return array;
  };
  Index2.prototype.valueOf = Index2.prototype.toArray;
  Index2.prototype.toString = function() {
    var strings = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var dimension = this._dimensions[i2];
      if (typeof dimension === "string") {
        strings.push(JSON.stringify(dimension));
      } else {
        strings.push(dimension.toString());
      }
    }
    return "[" + strings.join(", ") + "]";
  };
  Index2.prototype.toJSON = function() {
    return {
      mathjs: "Index",
      dimensions: this._dimensions
    };
  };
  Index2.fromJSON = function(json) {
    return Index2.create(json.dimensions);
  };
  return Index2;
}, {
  isClass: true
});
var name$2d = "FibonacciHeap";
var dependencies$2d = ["smaller", "larger"];
var createFibonacciHeapClass = /* @__PURE__ */ factory(name$2d, dependencies$2d, (_ref) => {
  var {
    smaller: smaller2,
    larger: larger2
  } = _ref;
  var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
  function FibonacciHeap2() {
    if (!(this instanceof FibonacciHeap2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._minimum = null;
    this._size = 0;
  }
  FibonacciHeap2.prototype.type = "FibonacciHeap";
  FibonacciHeap2.prototype.isFibonacciHeap = true;
  FibonacciHeap2.prototype.insert = function(key, value) {
    var node = {
      key,
      value,
      degree: 0
    };
    if (this._minimum) {
      var minimum = this._minimum;
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      if (smaller2(key, minimum.key)) {
        this._minimum = node;
      }
    } else {
      node.left = node;
      node.right = node;
      this._minimum = node;
    }
    this._size++;
    return node;
  };
  FibonacciHeap2.prototype.size = function() {
    return this._size;
  };
  FibonacciHeap2.prototype.clear = function() {
    this._minimum = null;
    this._size = 0;
  };
  FibonacciHeap2.prototype.isEmpty = function() {
    return this._size === 0;
  };
  FibonacciHeap2.prototype.extractMinimum = function() {
    var node = this._minimum;
    if (node === null) {
      return node;
    }
    var minimum = this._minimum;
    var numberOfChildren = node.degree;
    var x = node.child;
    while (numberOfChildren > 0) {
      var tempRight = x.right;
      x.left.right = x.right;
      x.right.left = x.left;
      x.left = minimum;
      x.right = minimum.right;
      minimum.right = x;
      x.right.left = x;
      x.parent = null;
      x = tempRight;
      numberOfChildren--;
    }
    node.left.right = node.right;
    node.right.left = node.left;
    if (node === node.right) {
      minimum = null;
    } else {
      minimum = node.right;
      minimum = _findMinimumNode(minimum, this._size);
    }
    this._size--;
    this._minimum = minimum;
    return node;
  };
  FibonacciHeap2.prototype.remove = function(node) {
    this._minimum = _decreaseKey(this._minimum, node, -1);
    this.extractMinimum();
  };
  function _decreaseKey(minimum, node, key) {
    node.key = key;
    var parent = node.parent;
    if (parent && smaller2(node.key, parent.key)) {
      _cut(minimum, node, parent);
      _cascadingCut(minimum, parent);
    }
    if (smaller2(node.key, minimum.key)) {
      minimum = node;
    }
    return minimum;
  }
  function _cut(minimum, node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    parent.degree--;
    if (parent.child === node) {
      parent.child = node.right;
    }
    if (parent.degree === 0) {
      parent.child = null;
    }
    node.left = minimum;
    node.right = minimum.right;
    minimum.right = node;
    node.right.left = node;
    node.parent = null;
    node.mark = false;
  }
  function _cascadingCut(minimum, node) {
    var parent = node.parent;
    if (!parent) {
      return;
    }
    if (!node.mark) {
      node.mark = true;
    } else {
      _cut(minimum, node, parent);
      _cascadingCut(parent);
    }
  }
  var _linkNodes = function _linkNodes2(node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    node.parent = parent;
    if (!parent.child) {
      parent.child = node;
      node.right = node;
      node.left = node;
    } else {
      node.left = parent.child;
      node.right = parent.child.right;
      parent.child.right = node;
      node.right.left = node;
    }
    parent.degree++;
    node.mark = false;
  };
  function _findMinimumNode(minimum, size2) {
    var arraySize2 = Math.floor(Math.log(size2) * oneOverLogPhi) + 1;
    var array = new Array(arraySize2);
    var numRoots = 0;
    var x = minimum;
    if (x) {
      numRoots++;
      x = x.right;
      while (x !== minimum) {
        numRoots++;
        x = x.right;
      }
    }
    var y;
    while (numRoots > 0) {
      var d = x.degree;
      var next = x.right;
      while (true) {
        y = array[d];
        if (!y) {
          break;
        }
        if (larger2(x.key, y.key)) {
          var temp = y;
          y = x;
          x = temp;
        }
        _linkNodes(y, x);
        array[d] = null;
        d++;
      }
      array[d] = x;
      x = next;
      numRoots--;
    }
    minimum = null;
    for (var i2 = 0; i2 < arraySize2; i2++) {
      y = array[i2];
      if (!y) {
        continue;
      }
      if (minimum) {
        y.left.right = y.right;
        y.right.left = y.left;
        y.left = minimum;
        y.right = minimum.right;
        minimum.right = y;
        y.right.left = y;
        if (smaller2(y.key, minimum.key)) {
          minimum = y;
        }
      } else {
        minimum = y;
      }
    }
    return minimum;
  }
  return FibonacciHeap2;
}, {
  isClass: true
});
var name$2c = "Spa";
var dependencies$2c = ["addScalar", "equalScalar", "FibonacciHeap"];
var createSpaClass = /* @__PURE__ */ factory(name$2c, dependencies$2c, (_ref) => {
  var {
    addScalar: addScalar2,
    equalScalar: equalScalar2,
    FibonacciHeap: FibonacciHeap2
  } = _ref;
  function Spa2() {
    if (!(this instanceof Spa2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._values = [];
    this._heap = new FibonacciHeap2();
  }
  Spa2.prototype.type = "Spa";
  Spa2.prototype.isSpa = true;
  Spa2.prototype.set = function(i2, v) {
    if (!this._values[i2]) {
      var node = this._heap.insert(i2, v);
      this._values[i2] = node;
    } else {
      this._values[i2].value = v;
    }
  };
  Spa2.prototype.get = function(i2) {
    var node = this._values[i2];
    if (node) {
      return node.value;
    }
    return 0;
  };
  Spa2.prototype.accumulate = function(i2, v) {
    var node = this._values[i2];
    if (!node) {
      node = this._heap.insert(i2, v);
      this._values[i2] = node;
    } else {
      node.value = addScalar2(node.value, v);
    }
  };
  Spa2.prototype.forEach = function(from, to2, callback) {
    var heap = this._heap;
    var values2 = this._values;
    var nodes2 = [];
    var node = heap.extractMinimum();
    if (node) {
      nodes2.push(node);
    }
    while (node && node.key <= to2) {
      if (node.key >= from) {
        if (!equalScalar2(node.value, 0)) {
          callback(node.key, node.value, this);
        }
      }
      node = heap.extractMinimum();
      if (node) {
        nodes2.push(node);
      }
    }
    for (var i2 = 0; i2 < nodes2.length; i2++) {
      var n = nodes2[i2];
      node = heap.insert(n.key, n.value);
      values2[node.key] = node;
    }
  };
  Spa2.prototype.swap = function(i2, j) {
    var nodei = this._values[i2];
    var nodej = this._values[j];
    if (!nodei && nodej) {
      nodei = this._heap.insert(i2, nodej.value);
      this._heap.remove(nodej);
      this._values[i2] = nodei;
      this._values[j] = void 0;
    } else if (nodei && !nodej) {
      nodej = this._heap.insert(j, nodei.value);
      this._heap.remove(nodei);
      this._values[j] = nodej;
      this._values[i2] = void 0;
    } else if (nodei && nodej) {
      var v = nodei.value;
      nodei.value = nodej.value;
      nodej.value = v;
    }
  };
  return Spa2;
}, {
  isClass: true
});
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var createBigNumberE = memoize(function(BigNumber2) {
  return new BigNumber2(1).exp();
}, {
  hasher
});
var createBigNumberPhi = memoize(function(BigNumber2) {
  return new BigNumber2(1).plus(new BigNumber2(5).sqrt()).div(2);
}, {
  hasher
});
var createBigNumberPi = memoize(function(BigNumber2) {
  return BigNumber2.acos(-1);
}, {
  hasher
});
var createBigNumberTau = memoize(function(BigNumber2) {
  return createBigNumberPi(BigNumber2).times(2);
}, {
  hasher
});
function hasher(args) {
  return args[0].precision;
}
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var name$2b = "Unit";
var dependencies$2b = ["?on", "config", "addScalar", "subtract", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
var createUnitClass = /* @__PURE__ */ factory(name$2b, dependencies$2b, (_ref) => {
  var {
    on: on2,
    config: config3,
    addScalar: addScalar2,
    subtract: subtract2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    pow: pow2,
    abs: abs2,
    fix: fix2,
    round: round2,
    equal: equal2,
    isNumeric: isNumeric2,
    format: format2,
    number: number2,
    Complex: Complex2,
    BigNumber: _BigNumber,
    Fraction: _Fraction
  } = _ref;
  var toNumber2 = number2;
  function Unit2(value, name2) {
    if (!(this instanceof Unit2)) {
      throw new Error("Constructor must be called with the new operator");
    }
    if (!(value === null || value === void 0 || isNumeric2(value) || isComplex(value))) {
      throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
    }
    if (name2 !== void 0 && (typeof name2 !== "string" || name2 === "")) {
      throw new TypeError("Second parameter in Unit constructor must be a string");
    }
    if (name2 !== void 0) {
      var u = Unit2.parse(name2);
      this.units = u.units;
      this.dimensions = u.dimensions;
    } else {
      this.units = [];
      this.dimensions = [];
      for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
        this.dimensions[i2] = 0;
      }
    }
    this.value = value !== void 0 && value !== null ? this._normalize(value) : null;
    this.fixPrefix = false;
    this.skipAutomaticSimplification = true;
  }
  Object.defineProperty(Unit2, "name", {
    value: "Unit"
  });
  Unit2.prototype.constructor = Unit2;
  Unit2.prototype.type = "Unit";
  Unit2.prototype.isUnit = true;
  var text, index2, c;
  function skipWhitespace() {
    while (c === " " || c === "	") {
      next();
    }
  }
  function isDigitDot(c2) {
    return c2 >= "0" && c2 <= "9" || c2 === ".";
  }
  function isDigit(c2) {
    return c2 >= "0" && c2 <= "9";
  }
  function next() {
    index2++;
    c = text.charAt(index2);
  }
  function revert(oldIndex) {
    index2 = oldIndex;
    c = text.charAt(index2);
  }
  function parseNumber() {
    var number3 = "";
    var oldIndex = index2;
    if (c === "+") {
      next();
    } else if (c === "-") {
      number3 += c;
      next();
    }
    if (!isDigitDot(c)) {
      revert(oldIndex);
      return null;
    }
    if (c === ".") {
      number3 += c;
      next();
      if (!isDigit(c)) {
        revert(oldIndex);
        return null;
      }
    } else {
      while (isDigit(c)) {
        number3 += c;
        next();
      }
      if (c === ".") {
        number3 += c;
        next();
      }
    }
    while (isDigit(c)) {
      number3 += c;
      next();
    }
    if (c === "E" || c === "e") {
      var tentativeNumber = "";
      var tentativeIndex = index2;
      tentativeNumber += c;
      next();
      if (c === "+" || c === "-") {
        tentativeNumber += c;
        next();
      }
      if (!isDigit(c)) {
        revert(tentativeIndex);
        return number3;
      }
      number3 = number3 + tentativeNumber;
      while (isDigit(c)) {
        number3 += c;
        next();
      }
    }
    return number3;
  }
  function parseUnit() {
    var unitName = "";
    while (isDigit(c) || Unit2.isValidAlpha(c)) {
      unitName += c;
      next();
    }
    var firstC = unitName.charAt(0);
    if (Unit2.isValidAlpha(firstC)) {
      return unitName;
    } else {
      return null;
    }
  }
  function parseCharacter(toFind) {
    if (c === toFind) {
      next();
      return toFind;
    } else {
      return null;
    }
  }
  Unit2.parse = function(str, options) {
    options = options || {};
    text = str;
    index2 = -1;
    c = "";
    if (typeof text !== "string") {
      throw new TypeError("Invalid argument in Unit.parse, string expected");
    }
    var unit3 = new Unit2();
    unit3.units = [];
    var powerMultiplierCurrent = 1;
    var expectingUnit = false;
    next();
    skipWhitespace();
    var valueStr = parseNumber();
    var value = null;
    if (valueStr) {
      if (config3.number === "BigNumber") {
        value = new _BigNumber(valueStr);
      } else if (config3.number === "Fraction") {
        try {
          value = new _Fraction(valueStr);
        } catch (err) {
          value = parseFloat(valueStr);
        }
      } else {
        value = parseFloat(valueStr);
      }
      skipWhitespace();
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      }
    }
    var powerMultiplierStack = [];
    var powerMultiplierStackProduct = 1;
    while (true) {
      skipWhitespace();
      while (c === "(") {
        powerMultiplierStack.push(powerMultiplierCurrent);
        powerMultiplierStackProduct *= powerMultiplierCurrent;
        powerMultiplierCurrent = 1;
        next();
        skipWhitespace();
      }
      var uStr = void 0;
      if (c) {
        var oldC = c;
        uStr = parseUnit();
        if (uStr === null) {
          throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index2.toString());
        }
      } else {
        break;
      }
      var res = _findUnit(uStr);
      if (res === null) {
        throw new SyntaxError('Unit "' + uStr + '" not found.');
      }
      var power = powerMultiplierCurrent * powerMultiplierStackProduct;
      skipWhitespace();
      if (parseCharacter("^")) {
        skipWhitespace();
        var p2 = parseNumber();
        if (p2 === null) {
          throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
        }
        power *= p2;
      }
      unit3.units.push({
        unit: res.unit,
        prefix: res.prefix,
        power
      });
      for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
        unit3.dimensions[i2] += (res.unit.dimensions[i2] || 0) * power;
      }
      skipWhitespace();
      while (c === ")") {
        if (powerMultiplierStack.length === 0) {
          throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index2.toString());
        }
        powerMultiplierStackProduct /= powerMultiplierStack.pop();
        next();
        skipWhitespace();
      }
      expectingUnit = false;
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      } else {
        powerMultiplierCurrent = 1;
      }
      if (res.unit.base) {
        var baseDim = res.unit.base.key;
        UNIT_SYSTEMS.auto[baseDim] = {
          unit: res.unit,
          prefix: res.prefix
        };
      }
    }
    skipWhitespace();
    if (c) {
      throw new SyntaxError('Could not parse: "' + str + '"');
    }
    if (expectingUnit) {
      throw new SyntaxError('Trailing characters: "' + str + '"');
    }
    if (powerMultiplierStack.length !== 0) {
      throw new SyntaxError('Unmatched "(" in "' + text + '"');
    }
    if (unit3.units.length === 0 && !options.allowNoUnits) {
      throw new SyntaxError('"' + str + '" contains no units');
    }
    unit3.value = value !== void 0 ? unit3._normalize(value) : null;
    return unit3;
  };
  Unit2.prototype.clone = function() {
    var unit3 = new Unit2();
    unit3.fixPrefix = this.fixPrefix;
    unit3.skipAutomaticSimplification = this.skipAutomaticSimplification;
    unit3.value = clone$2(this.value);
    unit3.dimensions = this.dimensions.slice(0);
    unit3.units = [];
    for (var i2 = 0; i2 < this.units.length; i2++) {
      unit3.units[i2] = {};
      for (var p2 in this.units[i2]) {
        if (hasOwnProperty$2(this.units[i2], p2)) {
          unit3.units[i2][p2] = this.units[i2][p2];
        }
      }
    }
    return unit3;
  };
  Unit2.prototype.valueType = function() {
    return typeOf$1(this.value);
  };
  Unit2.prototype._isDerived = function() {
    if (this.units.length === 0) {
      return false;
    }
    return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
  };
  Unit2.prototype._normalize = function(value) {
    if (value === null || value === void 0 || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit2._getNumberConverter(typeOf$1(value));
    for (var i2 = 0; i2 < this.units.length; i2++) {
      var unitValue = convert(this.units[i2].unit.value);
      var unitPrefixValue = convert(this.units[i2].prefix.value);
      var unitPower = convert(this.units[i2].power);
      res = multiplyScalar2(res, pow2(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  Unit2.prototype._denormalize = function(value, prefixValue) {
    if (value === null || value === void 0 || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit2._getNumberConverter(typeOf$1(value));
    for (var i2 = 0; i2 < this.units.length; i2++) {
      var unitValue = convert(this.units[i2].unit.value);
      var unitPrefixValue = convert(this.units[i2].prefix.value);
      var unitPower = convert(this.units[i2].power);
      res = divideScalar2(res, pow2(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  var _findUnit = memoize((str) => {
    if (hasOwnProperty$2(UNITS, str)) {
      var unit3 = UNITS[str];
      var prefix = unit3.prefixes[""];
      return {
        unit: unit3,
        prefix
      };
    }
    for (var _name in UNITS) {
      if (hasOwnProperty$2(UNITS, _name)) {
        if (endsWith(str, _name)) {
          var _unit = UNITS[_name];
          var prefixLen = str.length - _name.length;
          var prefixName = str.substring(0, prefixLen);
          var _prefix = hasOwnProperty$2(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : void 0;
          if (_prefix !== void 0) {
            return {
              unit: _unit,
              prefix: _prefix
            };
          }
        }
      }
    }
    return null;
  }, {
    hasher: (args) => args[0],
    limit: 100
  });
  Unit2.isValuelessUnit = function(name2) {
    return _findUnit(name2) !== null;
  };
  Unit2.prototype.hasBase = function(base2) {
    if (typeof base2 === "string") {
      base2 = BASE_UNITS[base2];
    }
    if (!base2) {
      return false;
    }
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      if (Math.abs((this.dimensions[i2] || 0) - (base2.dimensions[i2] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;
  };
  Unit2.prototype.equalBase = function(other) {
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      if (Math.abs((this.dimensions[i2] || 0) - (other.dimensions[i2] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;
  };
  Unit2.prototype.equals = function(other) {
    return this.equalBase(other) && equal2(this.value, other.value);
  };
  Unit2.prototype.multiply = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit2(_other);
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) + (other.dimensions[i2] || 0);
    }
    for (var _i = 0; _i < other.units.length; _i++) {
      var inverted = _objectSpread$1({}, other.units[_i]);
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = multiplyScalar2(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit2.prototype.divideInto = function(numerator) {
    return new Unit2(numerator).divide(this);
  };
  Unit2.prototype.divide = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit2(_other);
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) - (other.dimensions[i2] || 0);
    }
    for (var _i2 = 0; _i2 < other.units.length; _i2++) {
      var inverted = _objectSpread$1(_objectSpread$1({}, other.units[_i2]), {}, {
        power: -other.units[_i2].power
      });
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = divideScalar2(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit2.prototype.pow = function(p2) {
    var res = this.clone();
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) * p2;
    }
    for (var _i3 = 0; _i3 < res.units.length; _i3++) {
      res.units[_i3].power *= p2;
    }
    if (res.value !== null) {
      res.value = pow2(res.value, p2);
    } else {
      res.value = null;
    }
    res.skipAutomaticSimplification = false;
    return getNumericIfUnitless(res);
  };
  function getNumericIfUnitless(unit3) {
    if (unit3.equalBase(BASE_UNITS.NONE) && unit3.value !== null && !config3.predictable) {
      return unit3.value;
    } else {
      return unit3;
    }
  }
  Unit2.prototype.abs = function() {
    var ret = this.clone();
    if (ret.value !== null) {
      if (ret._isDerived() || ret.units[0].unit.offset === 0) {
        ret.value = abs2(ret.value);
      } else {
        var convert = ret._numberConverter();
        var unitValue = convert(ret.units[0].unit.value);
        var nominalOffset = convert(ret.units[0].unit.offset);
        var unitOffset = multiplyScalar2(unitValue, nominalOffset);
        ret.value = subtract2(abs2(addScalar2(ret.value, unitOffset)), unitOffset);
      }
    }
    for (var i2 in ret.units) {
      if (ret.units[i2].unit.name === "VA" || ret.units[i2].unit.name === "VAR") {
        ret.units[i2].unit = UNITS.W;
      }
    }
    return ret;
  };
  Unit2.prototype.to = function(valuelessUnit) {
    var value = this.value === null ? this._normalize(1) : this.value;
    var other;
    if (typeof valuelessUnit === "string") {
      other = Unit2.parse(valuelessUnit);
    } else if (isUnit(valuelessUnit)) {
      other = valuelessUnit.clone();
    } else {
      throw new Error("String or Unit expected as parameter");
    }
    if (!this.equalBase(other)) {
      throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
    }
    if (other.value !== null) {
      throw new Error("Cannot convert to a unit with a value");
    }
    if (this.value === null || this._isDerived() || this.units[0].unit.offset === other.units[0].unit.offset) {
      other.value = clone$2(value);
    } else {
      var convert = Unit2._getNumberConverter(typeOf$1(value));
      var thisUnitValue = convert(this.units[0].unit.value);
      var thisNominalOffset = convert(this.units[0].unit.offset);
      var thisUnitOffset = multiplyScalar2(thisUnitValue, thisNominalOffset);
      var otherUnitValue = convert(other.units[0].unit.value);
      var otherNominalOffset = convert(other.units[0].unit.offset);
      var otherUnitOffset = multiplyScalar2(otherUnitValue, otherNominalOffset);
      other.value = subtract2(addScalar2(value, thisUnitOffset), otherUnitOffset);
    }
    other.fixPrefix = true;
    other.skipAutomaticSimplification = true;
    return other;
  };
  Unit2.prototype.toNumber = function(valuelessUnit) {
    return toNumber2(this.toNumeric(valuelessUnit));
  };
  Unit2.prototype.toNumeric = function(valuelessUnit) {
    var other;
    if (valuelessUnit) {
      other = this.to(valuelessUnit);
    } else {
      other = this.clone();
    }
    if (other._isDerived() || other.units.length === 0) {
      return other._denormalize(other.value);
    } else {
      return other._denormalize(other.value, other.units[0].prefix.value);
    }
  };
  Unit2.prototype.toString = function() {
    return this.format();
  };
  Unit2.prototype.toJSON = function() {
    return {
      mathjs: "Unit",
      value: this._denormalize(this.value),
      unit: this.formatUnits(),
      fixPrefix: this.fixPrefix
    };
  };
  Unit2.fromJSON = function(json) {
    var unit3 = new Unit2(json.value, json.unit);
    unit3.fixPrefix = json.fixPrefix || false;
    return unit3;
  };
  Unit2.prototype.valueOf = Unit2.prototype.toString;
  Unit2.prototype.simplify = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    var matchingBase;
    for (var key2 in currentUnitSystem) {
      if (hasOwnProperty$2(currentUnitSystem, key2)) {
        if (ret.hasBase(BASE_UNITS[key2])) {
          matchingBase = key2;
          break;
        }
      }
    }
    if (matchingBase === "NONE") {
      ret.units = [];
    } else {
      var matchingUnit;
      if (matchingBase) {
        if (hasOwnProperty$2(currentUnitSystem, matchingBase)) {
          matchingUnit = currentUnitSystem[matchingBase];
        }
      }
      if (matchingUnit) {
        ret.units = [{
          unit: matchingUnit.unit,
          prefix: matchingUnit.prefix,
          power: 1
        }];
      } else {
        var missingBaseDim = false;
        for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
          var baseDim = BASE_DIMENSIONS[i2];
          if (Math.abs(ret.dimensions[i2] || 0) > 1e-12) {
            if (hasOwnProperty$2(currentUnitSystem, baseDim)) {
              proposedUnitList.push({
                unit: currentUnitSystem[baseDim].unit,
                prefix: currentUnitSystem[baseDim].prefix,
                power: ret.dimensions[i2] || 0
              });
            } else {
              missingBaseDim = true;
            }
          }
        }
        if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
          ret.units = proposedUnitList;
        }
      }
    }
    return ret;
  };
  Unit2.prototype.toSI = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      var baseDim = BASE_DIMENSIONS[i2];
      if (Math.abs(ret.dimensions[i2] || 0) > 1e-12) {
        if (hasOwnProperty$2(UNIT_SYSTEMS.si, baseDim)) {
          proposedUnitList.push({
            unit: UNIT_SYSTEMS.si[baseDim].unit,
            prefix: UNIT_SYSTEMS.si[baseDim].prefix,
            power: ret.dimensions[i2] || 0
          });
        } else {
          throw new Error("Cannot express custom unit " + baseDim + " in SI units");
        }
      }
    }
    ret.units = proposedUnitList;
    ret.fixPrefix = true;
    ret.skipAutomaticSimplification = true;
    return ret;
  };
  Unit2.prototype.formatUnits = function() {
    var strNum = "";
    var strDen = "";
    var nNum = 0;
    var nDen = 0;
    for (var i2 = 0; i2 < this.units.length; i2++) {
      if (this.units[i2].power > 0) {
        nNum++;
        strNum += " " + this.units[i2].prefix.name + this.units[i2].unit.name;
        if (Math.abs(this.units[i2].power - 1) > 1e-15) {
          strNum += "^" + this.units[i2].power;
        }
      } else if (this.units[i2].power < 0) {
        nDen++;
      }
    }
    if (nDen > 0) {
      for (var _i4 = 0; _i4 < this.units.length; _i4++) {
        if (this.units[_i4].power < 0) {
          if (nNum > 0) {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            if (Math.abs(this.units[_i4].power + 1) > 1e-15) {
              strDen += "^" + -this.units[_i4].power;
            }
          } else {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            strDen += "^" + this.units[_i4].power;
          }
        }
      }
    }
    strNum = strNum.substr(1);
    strDen = strDen.substr(1);
    if (nNum > 1 && nDen > 0) {
      strNum = "(" + strNum + ")";
    }
    if (nDen > 1 && nNum > 0) {
      strDen = "(" + strDen + ")";
    }
    var str = strNum;
    if (nNum > 0 && nDen > 0) {
      str += " / ";
    }
    str += strDen;
    return str;
  };
  Unit2.prototype.format = function(options) {
    var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
    var isImaginary = false;
    if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
      isImaginary = Math.abs(simp.value.re) < 1e-14;
    }
    for (var i2 in simp.units) {
      if (hasOwnProperty$2(simp.units, i2)) {
        if (simp.units[i2].unit) {
          if (simp.units[i2].unit.name === "VA" && isImaginary) {
            simp.units[i2].unit = UNITS.VAR;
          } else if (simp.units[i2].unit.name === "VAR" && !isImaginary) {
            simp.units[i2].unit = UNITS.VA;
          }
        }
      }
    }
    if (simp.units.length === 1 && !simp.fixPrefix) {
      if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
        simp.units[0].prefix = simp._bestPrefix();
      }
    }
    var value = simp._denormalize(simp.value);
    var str = simp.value !== null ? format2(value, options || {}) : "";
    var unitStr = simp.formatUnits();
    if (simp.value && isComplex(simp.value)) {
      str = "(" + str + ")";
    }
    if (unitStr.length > 0 && str.length > 0) {
      str += " ";
    }
    str += unitStr;
    return str;
  };
  Unit2.prototype._bestPrefix = function() {
    if (this.units.length !== 1) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    var absValue = this.value !== null ? abs2(this.value) : 0;
    var absUnitValue = abs2(this.units[0].unit.value);
    var bestPrefix = this.units[0].prefix;
    if (absValue === 0) {
      return bestPrefix;
    }
    var power = this.units[0].power;
    var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
    if (bestDiff > -2.200001 && bestDiff < 1.800001)
      return bestPrefix;
    bestDiff = Math.abs(bestDiff);
    var prefixes2 = this.units[0].unit.prefixes;
    for (var p2 in prefixes2) {
      if (hasOwnProperty$2(prefixes2, p2)) {
        var prefix = prefixes2[p2];
        if (prefix.scientific) {
          var diff2 = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
          if (diff2 < bestDiff || diff2 === bestDiff && prefix.name.length < bestPrefix.name.length) {
            bestPrefix = prefix;
            bestDiff = diff2;
          }
        }
      }
    }
    return bestPrefix;
  };
  Unit2.prototype.splitUnit = function(parts) {
    var x = this.clone();
    var ret = [];
    for (var i2 = 0; i2 < parts.length; i2++) {
      x = x.to(parts[i2]);
      if (i2 === parts.length - 1)
        break;
      var xNumeric = x.toNumeric();
      var xRounded = round2(xNumeric);
      var xFixed = void 0;
      var isNearlyEqual = equal2(xRounded, xNumeric);
      if (isNearlyEqual) {
        xFixed = xRounded;
      } else {
        xFixed = fix2(x.toNumeric());
      }
      var y = new Unit2(xFixed, parts[i2].toString());
      ret.push(y);
      x = subtract2(x, y);
    }
    var testSum = 0;
    for (var _i5 = 0; _i5 < ret.length; _i5++) {
      testSum = addScalar2(testSum, ret[_i5].value);
    }
    if (equal2(testSum, this.value)) {
      x.value = 0;
    }
    ret.push(x);
    return ret;
  };
  var PREFIXES = {
    NONE: {
      "": {
        name: "",
        value: 1,
        scientific: true
      }
    },
    SHORT: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 10,
        scientific: false
      },
      h: {
        name: "h",
        value: 100,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.1,
        scientific: false
      },
      c: {
        name: "c",
        value: 0.01,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-3,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-6,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-9,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-12,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-15,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-18,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-21,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-24,
        scientific: true
      }
    },
    LONG: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      deca: {
        name: "deca",
        value: 10,
        scientific: false
      },
      hecto: {
        name: "hecto",
        value: 100,
        scientific: false
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: true
      },
      deci: {
        name: "deci",
        value: 0.1,
        scientific: false
      },
      centi: {
        name: "centi",
        value: 0.01,
        scientific: false
      },
      milli: {
        name: "milli",
        value: 1e-3,
        scientific: true
      },
      micro: {
        name: "micro",
        value: 1e-6,
        scientific: true
      },
      nano: {
        name: "nano",
        value: 1e-9,
        scientific: true
      },
      pico: {
        name: "pico",
        value: 1e-12,
        scientific: true
      },
      femto: {
        name: "femto",
        value: 1e-15,
        scientific: true
      },
      atto: {
        name: "atto",
        value: 1e-18,
        scientific: true
      },
      zepto: {
        name: "zepto",
        value: 1e-21,
        scientific: true
      },
      yocto: {
        name: "yocto",
        value: 1e-24,
        scientific: true
      }
    },
    SQUARED: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 100,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e4,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e6,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e12,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e18,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e24,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e30,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e36,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e42,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e48,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.01,
        scientific: false
      },
      c: {
        name: "c",
        value: 1e-4,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-6,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-12,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-18,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-24,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-30,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-36,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-42,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-48,
        scientific: true
      }
    },
    CUBIC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 1e3,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e6,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e9,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e18,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e27,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e36,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e45,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e54,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e63,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e72,
        scientific: true
      },
      d: {
        name: "d",
        value: 1e-3,
        scientific: false
      },
      c: {
        name: "c",
        value: 1e-6,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-9,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-18,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-27,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-36,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-45,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-54,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-63,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-72,
        scientific: true
      }
    },
    BINARY_SHORT_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: true
      }
    },
    BINARY_SHORT_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      Ki: {
        name: "Ki",
        value: 1024,
        scientific: true
      },
      Mi: {
        name: "Mi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      Gi: {
        name: "Gi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      Ti: {
        name: "Ti",
        value: Math.pow(1024, 4),
        scientific: true
      },
      Pi: {
        name: "Pi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      Ei: {
        name: "Ei",
        value: Math.pow(1024, 6),
        scientific: true
      },
      Zi: {
        name: "Zi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      Yi: {
        name: "Yi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BINARY_LONG_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: true
      }
    },
    BINARY_LONG_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kibi: {
        name: "kibi",
        value: 1024,
        scientific: true
      },
      mebi: {
        name: "mebi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      gibi: {
        name: "gibi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      tebi: {
        name: "tebi",
        value: Math.pow(1024, 4),
        scientific: true
      },
      pebi: {
        name: "pebi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      exi: {
        name: "exi",
        value: Math.pow(1024, 6),
        scientific: true
      },
      zebi: {
        name: "zebi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      yobi: {
        name: "yobi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BTU: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      MM: {
        name: "MM",
        value: 1e6,
        scientific: true
      }
    }
  };
  PREFIXES.SHORTLONG = _extends$1({}, PREFIXES.SHORT, PREFIXES.LONG);
  PREFIXES.BINARY_SHORT = _extends$1({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
  PREFIXES.BINARY_LONG = _extends$1({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
  var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
  var BASE_UNITS = {
    NONE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    MASS: {
      dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    LENGTH: {
      dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
    },
    TIME: {
      dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
    },
    CURRENT: {
      dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
    },
    TEMPERATURE: {
      dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
    },
    LUMINOUS_INTENSITY: {
      dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
    },
    AMOUNT_OF_SUBSTANCE: {
      dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
    },
    FORCE: {
      dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
    },
    SURFACE: {
      dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
    },
    VOLUME: {
      dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
    },
    ENERGY: {
      dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
    },
    POWER: {
      dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
    },
    PRESSURE: {
      dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CHARGE: {
      dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CAPACITANCE: {
      dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_POTENTIAL: {
      dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_RESISTANCE: {
      dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_INDUCTANCE: {
      dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CONDUCTANCE: {
      dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX: {
      dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX_DENSITY: {
      dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
    },
    FREQUENCY: {
      dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
    },
    ANGLE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
    },
    BIT: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
    }
  };
  for (var key in BASE_UNITS) {
    if (hasOwnProperty$2(BASE_UNITS, key)) {
      BASE_UNITS[key].key = key;
    }
  }
  var BASE_UNIT_NONE = {};
  var UNIT_NONE = {
    name: "",
    base: BASE_UNIT_NONE,
    value: 1,
    offset: 0,
    dimensions: BASE_DIMENSIONS.map((x) => 0)
  };
  var UNITS = {
    meter: {
      name: "meter",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    inch: {
      name: "inch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    foot: {
      name: "foot",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yard: {
      name: "yard",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mile: {
      name: "mile",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    link: {
      name: "link",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rod: {
      name: "rod",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.0292,
      offset: 0
    },
    chain: {
      name: "chain",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    angstrom: {
      name: "angstrom",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1e-10,
      offset: 0
    },
    m: {
      name: "m",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    in: {
      name: "in",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    ft: {
      name: "ft",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yd: {
      name: "yd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mi: {
      name: "mi",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    li: {
      name: "li",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rd: {
      name: "rd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.02921,
      offset: 0
    },
    ch: {
      name: "ch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    mil: {
      name: "mil",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 254e-7,
      offset: 0
    },
    m2: {
      name: "m2",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.SQUARED,
      value: 1,
      offset: 0
    },
    sqin: {
      name: "sqin",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 64516e-8,
      offset: 0
    },
    sqft: {
      name: "sqft",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.09290304,
      offset: 0
    },
    sqyd: {
      name: "sqyd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.83612736,
      offset: 0
    },
    sqmi: {
      name: "sqmi",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 2589988110336e-6,
      offset: 0
    },
    sqrd: {
      name: "sqrd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 25.29295,
      offset: 0
    },
    sqch: {
      name: "sqch",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 404.6873,
      offset: 0
    },
    sqmil: {
      name: "sqmil",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 64516e-14,
      offset: 0
    },
    acre: {
      name: "acre",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 4046.86,
      offset: 0
    },
    hectare: {
      name: "hectare",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 1e4,
      offset: 0
    },
    m3: {
      name: "m3",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.CUBIC,
      value: 1,
      offset: 0
    },
    L: {
      name: "L",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    l: {
      name: "l",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    litre: {
      name: "litre",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.LONG,
      value: 1e-3,
      offset: 0
    },
    cuin: {
      name: "cuin",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 16387064e-12,
      offset: 0
    },
    cuft: {
      name: "cuft",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.028316846592,
      offset: 0
    },
    cuyd: {
      name: "cuyd",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.764554857984,
      offset: 0
    },
    teaspoon: {
      name: "teaspoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-6,
      offset: 0
    },
    tablespoon: {
      name: "tablespoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 15e-6,
      offset: 0
    },
    drop: {
      name: "drop",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },
    gtt: {
      name: "gtt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },
    minim: {
      name: "minim",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 6161152e-14,
      offset: 0
    },
    fluiddram: {
      name: "fluiddram",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 36966911e-13,
      offset: 0
    },
    fluidounce: {
      name: "fluidounce",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2957353e-11,
      offset: 0
    },
    gill: {
      name: "gill",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1182941e-10,
      offset: 0
    },
    cc: {
      name: "cc",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1e-6,
      offset: 0
    },
    cup: {
      name: "cup",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2365882e-10,
      offset: 0
    },
    pint: {
      name: "pint",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 4731765e-10,
      offset: 0
    },
    quart: {
      name: "quart",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 9463529e-10,
      offset: 0
    },
    gallon: {
      name: "gallon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 3785412e-9,
      offset: 0
    },
    beerbarrel: {
      name: "beerbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    },
    oilbarrel: {
      name: "oilbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    },
    hogshead: {
      name: "hogshead",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.238481,
      offset: 0
    },
    fldr: {
      name: "fldr",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 36966911e-13,
      offset: 0
    },
    floz: {
      name: "floz",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2957353e-11,
      offset: 0
    },
    gi: {
      name: "gi",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1182941e-10,
      offset: 0
    },
    cp: {
      name: "cp",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2365882e-10,
      offset: 0
    },
    pt: {
      name: "pt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 4731765e-10,
      offset: 0
    },
    qt: {
      name: "qt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 9463529e-10,
      offset: 0
    },
    gal: {
      name: "gal",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 3785412e-9,
      offset: 0
    },
    bbl: {
      name: "bbl",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    },
    obl: {
      name: "obl",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    },
    g: {
      name: "g",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    gram: {
      name: "gram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1e-3,
      offset: 0
    },
    ton: {
      name: "ton",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 907.18474,
      offset: 0
    },
    t: {
      name: "t",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1e3,
      offset: 0
    },
    tonne: {
      name: "tonne",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1e3,
      offset: 0
    },
    grain: {
      name: "grain",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dram: {
      name: "dram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    ounce: {
      name: "ounce",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    poundmass: {
      name: "poundmass",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    hundredweight: {
      name: "hundredweight",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    stick: {
      name: "stick",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.115,
      offset: 0
    },
    stone: {
      name: "stone",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6.35029318,
      offset: 0
    },
    gr: {
      name: "gr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dr: {
      name: "dr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    oz: {
      name: "oz",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    lbm: {
      name: "lbm",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    cwt: {
      name: "cwt",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    s: {
      name: "s",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    min: {
      name: "min",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    h: {
      name: "h",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    second: {
      name: "second",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    sec: {
      name: "sec",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    minute: {
      name: "minute",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    hour: {
      name: "hour",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    day: {
      name: "day",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 86400,
      offset: 0
    },
    week: {
      name: "week",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 7 * 86400,
      offset: 0
    },
    month: {
      name: "month",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 2629800,
      offset: 0
    },
    year: {
      name: "year",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600,
      offset: 0
    },
    decade: {
      name: "decade",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e3,
      offset: 0
    },
    century: {
      name: "century",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e4,
      offset: 0
    },
    millennium: {
      name: "millennium",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e5,
      offset: 0
    },
    hertz: {
      name: "Hertz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    Hz: {
      name: "Hz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    rad: {
      name: "rad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    radian: {
      name: "radian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    deg: {
      name: "deg",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      offset: 0
    },
    degree: {
      name: "degree",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      offset: 0
    },
    grad: {
      name: "grad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      offset: 0
    },
    gradian: {
      name: "gradian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      offset: 0
    },
    cycle: {
      name: "cycle",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      offset: 0
    },
    arcsec: {
      name: "arcsec",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      offset: 0
    },
    arcmin: {
      name: "arcmin",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      offset: 0
    },
    A: {
      name: "A",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    ampere: {
      name: "ampere",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    K: {
      name: "K",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 0
    },
    degC: {
      name: "degC",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 273.15
    },
    degF: {
      name: "degF",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1 / 1.8,
      offset: 459.67
    },
    degR: {
      name: "degR",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1 / 1.8,
      offset: 0
    },
    kelvin: {
      name: "kelvin",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 0
    },
    celsius: {
      name: "celsius",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1,
      offset: 273.15
    },
    fahrenheit: {
      name: "fahrenheit",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1 / 1.8,
      offset: 459.67
    },
    rankine: {
      name: "rankine",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.NONE,
      value: 1 / 1.8,
      offset: 0
    },
    mol: {
      name: "mol",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    mole: {
      name: "mole",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    cd: {
      name: "cd",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    candela: {
      name: "candela",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    N: {
      name: "N",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    newton: {
      name: "newton",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    dyn: {
      name: "dyn",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1e-5,
      offset: 0
    },
    dyne: {
      name: "dyne",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1e-5,
      offset: 0
    },
    lbf: {
      name: "lbf",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    poundforce: {
      name: "poundforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    kip: {
      name: "kip",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 4448.2216,
      offset: 0
    },
    kilogramforce: {
      name: "kilogramforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    J: {
      name: "J",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    joule: {
      name: "joule",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    erg: {
      name: "erg",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.NONE,
      value: 1e-7,
      offset: 0
    },
    Wh: {
      name: "Wh",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 3600,
      offset: 0
    },
    BTU: {
      name: "BTU",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.BTU,
      value: 1055.05585262,
      offset: 0
    },
    eV: {
      name: "eV",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1602176565e-28,
      offset: 0
    },
    electronvolt: {
      name: "electronvolt",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 1602176565e-28,
      offset: 0
    },
    W: {
      name: "W",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    watt: {
      name: "watt",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    hp: {
      name: "hp",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.NONE,
      value: 745.6998715386,
      offset: 0
    },
    VAR: {
      name: "VAR",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: Complex2.I,
      offset: 0
    },
    VA: {
      name: "VA",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    Pa: {
      name: "Pa",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    psi: {
      name: "psi",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 6894.75729276459,
      offset: 0
    },
    atm: {
      name: "atm",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 101325,
      offset: 0
    },
    bar: {
      name: "bar",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORTLONG,
      value: 1e5,
      offset: 0
    },
    torr: {
      name: "torr",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmHg: {
      name: "mmHg",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmH2O: {
      name: "mmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    cmH2O: {
      name: "cmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 98.0665,
      offset: 0
    },
    coulomb: {
      name: "coulomb",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    C: {
      name: "C",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    farad: {
      name: "farad",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    F: {
      name: "F",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    volt: {
      name: "volt",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    V: {
      name: "V",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    ohm: {
      name: "ohm",
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORTLONG,
      value: 1,
      offset: 0
    },
    henry: {
      name: "henry",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    H: {
      name: "H",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    siemens: {
      name: "siemens",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    S: {
      name: "S",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    weber: {
      name: "weber",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    Wb: {
      name: "Wb",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    tesla: {
      name: "tesla",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    T: {
      name: "T",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    b: {
      name: "b",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 1,
      offset: 0
    },
    bits: {
      name: "bits",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 1,
      offset: 0
    },
    B: {
      name: "B",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 8,
      offset: 0
    },
    bytes: {
      name: "bytes",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 8,
      offset: 0
    }
  };
  var ALIASES = {
    meters: "meter",
    inches: "inch",
    feet: "foot",
    yards: "yard",
    miles: "mile",
    links: "link",
    rods: "rod",
    chains: "chain",
    angstroms: "angstrom",
    lt: "l",
    litres: "litre",
    liter: "litre",
    liters: "litre",
    teaspoons: "teaspoon",
    tablespoons: "tablespoon",
    minims: "minim",
    fluiddrams: "fluiddram",
    fluidounces: "fluidounce",
    gills: "gill",
    cups: "cup",
    pints: "pint",
    quarts: "quart",
    gallons: "gallon",
    beerbarrels: "beerbarrel",
    oilbarrels: "oilbarrel",
    hogsheads: "hogshead",
    gtts: "gtt",
    grams: "gram",
    tons: "ton",
    tonnes: "tonne",
    grains: "grain",
    drams: "dram",
    ounces: "ounce",
    poundmasses: "poundmass",
    hundredweights: "hundredweight",
    sticks: "stick",
    lb: "lbm",
    lbs: "lbm",
    kips: "kip",
    kgf: "kilogramforce",
    acres: "acre",
    hectares: "hectare",
    sqfeet: "sqft",
    sqyard: "sqyd",
    sqmile: "sqmi",
    sqmiles: "sqmi",
    mmhg: "mmHg",
    mmh2o: "mmH2O",
    cmh2o: "cmH2O",
    seconds: "second",
    secs: "second",
    minutes: "minute",
    mins: "minute",
    hours: "hour",
    hr: "hour",
    hrs: "hour",
    days: "day",
    weeks: "week",
    months: "month",
    years: "year",
    decades: "decade",
    centuries: "century",
    millennia: "millennium",
    hertz: "hertz",
    radians: "radian",
    degrees: "degree",
    gradians: "gradian",
    cycles: "cycle",
    arcsecond: "arcsec",
    arcseconds: "arcsec",
    arcminute: "arcmin",
    arcminutes: "arcmin",
    BTUs: "BTU",
    watts: "watt",
    joules: "joule",
    amperes: "ampere",
    coulombs: "coulomb",
    volts: "volt",
    ohms: "ohm",
    farads: "farad",
    webers: "weber",
    teslas: "tesla",
    electronvolts: "electronvolt",
    moles: "mole",
    bit: "bits",
    byte: "bytes"
  };
  function calculateAngleValues(config4) {
    if (config4.number === "BigNumber") {
      var pi2 = createBigNumberPi(_BigNumber);
      UNITS.rad.value = new _BigNumber(1);
      UNITS.deg.value = pi2.div(180);
      UNITS.grad.value = pi2.div(200);
      UNITS.cycle.value = pi2.times(2);
      UNITS.arcsec.value = pi2.div(648e3);
      UNITS.arcmin.value = pi2.div(10800);
    } else {
      UNITS.rad.value = 1;
      UNITS.deg.value = Math.PI / 180;
      UNITS.grad.value = Math.PI / 200;
      UNITS.cycle.value = Math.PI * 2;
      UNITS.arcsec.value = Math.PI / 648e3;
      UNITS.arcmin.value = Math.PI / 10800;
    }
    UNITS.radian.value = UNITS.rad.value;
    UNITS.degree.value = UNITS.deg.value;
    UNITS.gradian.value = UNITS.grad.value;
  }
  calculateAngleValues(config3);
  if (on2) {
    on2("config", function(curr, prev) {
      if (curr.number !== prev.number) {
        calculateAngleValues(curr);
      }
    });
  }
  var UNIT_SYSTEMS = {
    si: {
      NONE: {
        unit: UNIT_NONE,
        prefix: PREFIXES.NONE[""]
      },
      LENGTH: {
        unit: UNITS.m,
        prefix: PREFIXES.SHORT[""]
      },
      MASS: {
        unit: UNITS.g,
        prefix: PREFIXES.SHORT.k
      },
      TIME: {
        unit: UNITS.s,
        prefix: PREFIXES.SHORT[""]
      },
      CURRENT: {
        unit: UNITS.A,
        prefix: PREFIXES.SHORT[""]
      },
      TEMPERATURE: {
        unit: UNITS.K,
        prefix: PREFIXES.SHORT[""]
      },
      LUMINOUS_INTENSITY: {
        unit: UNITS.cd,
        prefix: PREFIXES.SHORT[""]
      },
      AMOUNT_OF_SUBSTANCE: {
        unit: UNITS.mol,
        prefix: PREFIXES.SHORT[""]
      },
      ANGLE: {
        unit: UNITS.rad,
        prefix: PREFIXES.SHORT[""]
      },
      BIT: {
        unit: UNITS.bits,
        prefix: PREFIXES.SHORT[""]
      },
      FORCE: {
        unit: UNITS.N,
        prefix: PREFIXES.SHORT[""]
      },
      ENERGY: {
        unit: UNITS.J,
        prefix: PREFIXES.SHORT[""]
      },
      POWER: {
        unit: UNITS.W,
        prefix: PREFIXES.SHORT[""]
      },
      PRESSURE: {
        unit: UNITS.Pa,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CHARGE: {
        unit: UNITS.C,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CAPACITANCE: {
        unit: UNITS.F,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_POTENTIAL: {
        unit: UNITS.V,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_RESISTANCE: {
        unit: UNITS.ohm,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_INDUCTANCE: {
        unit: UNITS.H,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CONDUCTANCE: {
        unit: UNITS.S,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX: {
        unit: UNITS.Wb,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX_DENSITY: {
        unit: UNITS.T,
        prefix: PREFIXES.SHORT[""]
      },
      FREQUENCY: {
        unit: UNITS.Hz,
        prefix: PREFIXES.SHORT[""]
      }
    }
  };
  UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.cgs.LENGTH = {
    unit: UNITS.m,
    prefix: PREFIXES.SHORT.c
  };
  UNIT_SYSTEMS.cgs.MASS = {
    unit: UNITS.g,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.FORCE = {
    unit: UNITS.dyn,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.ENERGY = {
    unit: UNITS.erg,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.us.LENGTH = {
    unit: UNITS.ft,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.MASS = {
    unit: UNITS.lbm,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.TEMPERATURE = {
    unit: UNITS.degF,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.FORCE = {
    unit: UNITS.lbf,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.ENERGY = {
    unit: UNITS.BTU,
    prefix: PREFIXES.BTU[""]
  };
  UNIT_SYSTEMS.us.POWER = {
    unit: UNITS.hp,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.PRESSURE = {
    unit: UNITS.psi,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  var currentUnitSystem = UNIT_SYSTEMS.auto;
  Unit2.setUnitSystem = function(name2) {
    if (hasOwnProperty$2(UNIT_SYSTEMS, name2)) {
      currentUnitSystem = UNIT_SYSTEMS[name2];
    } else {
      throw new Error("Unit system " + name2 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
    }
  };
  Unit2.getUnitSystem = function() {
    for (var _key in UNIT_SYSTEMS) {
      if (hasOwnProperty$2(UNIT_SYSTEMS, _key)) {
        if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
          return _key;
        }
      }
    }
  };
  Unit2.typeConverters = {
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(x + "");
    },
    Fraction: function Fraction2(x) {
      return new _Fraction(x);
    },
    Complex: function Complex3(x) {
      return x;
    },
    number: function number3(x) {
      return x;
    }
  };
  Unit2.prototype._numberConverter = function() {
    var convert = Unit2.typeConverters[this.valueType()];
    if (convert) {
      return convert;
    }
    throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
  };
  Unit2._getNumberConverter = function(type) {
    if (!Unit2.typeConverters[type]) {
      throw new TypeError('Unsupported type "' + type + '"');
    }
    return Unit2.typeConverters[type];
  };
  for (var _key2 in UNITS) {
    if (hasOwnProperty$2(UNITS, _key2)) {
      var unit2 = UNITS[_key2];
      unit2.dimensions = unit2.base.dimensions;
    }
  }
  for (var _name2 in ALIASES) {
    if (hasOwnProperty$2(ALIASES, _name2)) {
      var _unit2 = UNITS[ALIASES[_name2]];
      var alias = {};
      for (var _key3 in _unit2) {
        if (hasOwnProperty$2(_unit2, _key3)) {
          alias[_key3] = _unit2[_key3];
        }
      }
      alias.name = _name2;
      UNITS[_name2] = alias;
    }
  }
  Unit2.isValidAlpha = function isValidAlpha(c2) {
    return /^[a-zA-Z]$/.test(c2);
  };
  function assertUnitNameIsValid(name2) {
    for (var i2 = 0; i2 < name2.length; i2++) {
      c = name2.charAt(i2);
      if (i2 === 0 && !Unit2.isValidAlpha(c)) {
        throw new Error('Invalid unit name (must begin with alpha character): "' + name2 + '"');
      }
      if (i2 > 0 && !(Unit2.isValidAlpha(c) || isDigit(c))) {
        throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name2 + '"');
      }
    }
  }
  Unit2.createUnit = function(obj, options) {
    if (typeof obj !== "object") {
      throw new TypeError("createUnit expects first parameter to be of type 'Object'");
    }
    if (options && options.override) {
      for (var _key4 in obj) {
        if (hasOwnProperty$2(obj, _key4)) {
          Unit2.deleteUnit(_key4);
        }
        if (obj[_key4].aliases) {
          for (var i2 = 0; i2 < obj[_key4].aliases.length; i2++) {
            Unit2.deleteUnit(obj[_key4].aliases[i2]);
          }
        }
      }
    }
    var lastUnit;
    for (var _key5 in obj) {
      if (hasOwnProperty$2(obj, _key5)) {
        lastUnit = Unit2.createUnitSingle(_key5, obj[_key5]);
      }
    }
    return lastUnit;
  };
  Unit2.createUnitSingle = function(name2, obj, options) {
    if (typeof obj === "undefined" || obj === null) {
      obj = {};
    }
    if (typeof name2 !== "string") {
      throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
    }
    if (hasOwnProperty$2(UNITS, name2)) {
      throw new Error('Cannot create unit "' + name2 + '": a unit with that name already exists');
    }
    assertUnitNameIsValid(name2);
    var defUnit = null;
    var aliases = [];
    var offset = 0;
    var definition;
    var prefixes2;
    var baseName;
    if (obj && obj.type === "Unit") {
      defUnit = obj.clone();
    } else if (typeof obj === "string") {
      if (obj !== "") {
        definition = obj;
      }
    } else if (typeof obj === "object") {
      definition = obj.definition;
      prefixes2 = obj.prefixes;
      offset = obj.offset;
      baseName = obj.baseName;
      if (obj.aliases) {
        aliases = obj.aliases.valueOf();
      }
    } else {
      throw new TypeError('Cannot create unit "' + name2 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
    }
    if (aliases) {
      for (var i2 = 0; i2 < aliases.length; i2++) {
        if (hasOwnProperty$2(UNITS, aliases[i2])) {
          throw new Error('Cannot create alias "' + aliases[i2] + '": a unit with that name already exists');
        }
      }
    }
    if (definition && typeof definition === "string" && !defUnit) {
      try {
        defUnit = Unit2.parse(definition, {
          allowNoUnits: true
        });
      } catch (ex) {
        ex.message = 'Could not create unit "' + name2 + '" from "' + definition + '": ' + ex.message;
        throw ex;
      }
    } else if (definition && definition.type === "Unit") {
      defUnit = definition.clone();
    }
    aliases = aliases || [];
    offset = offset || 0;
    if (prefixes2 && prefixes2.toUpperCase) {
      prefixes2 = PREFIXES[prefixes2.toUpperCase()] || PREFIXES.NONE;
    } else {
      prefixes2 = PREFIXES.NONE;
    }
    var newUnit = {};
    if (!defUnit) {
      baseName = baseName || name2 + "_STUFF";
      if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
        throw new Error('Cannot create new base unit "' + name2 + '": a base unit with that name already exists (and cannot be overridden)');
      }
      BASE_DIMENSIONS.push(baseName);
      for (var b in BASE_UNITS) {
        if (hasOwnProperty$2(BASE_UNITS, b)) {
          BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
        }
      }
      var newBaseUnit = {
        dimensions: []
      };
      for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
        newBaseUnit.dimensions[_i6] = 0;
      }
      newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
      newBaseUnit.key = baseName;
      BASE_UNITS[baseName] = newBaseUnit;
      newUnit = {
        name: name2,
        value: 1,
        dimensions: BASE_UNITS[baseName].dimensions.slice(0),
        prefixes: prefixes2,
        offset,
        base: BASE_UNITS[baseName]
      };
      currentUnitSystem[baseName] = {
        unit: newUnit,
        prefix: PREFIXES.NONE[""]
      };
    } else {
      newUnit = {
        name: name2,
        value: defUnit.value,
        dimensions: defUnit.dimensions.slice(0),
        prefixes: prefixes2,
        offset
      };
      var anyMatch = false;
      for (var _i7 in BASE_UNITS) {
        if (hasOwnProperty$2(BASE_UNITS, _i7)) {
          var match = true;
          for (var j = 0; j < BASE_DIMENSIONS.length; j++) {
            if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
              match = false;
              break;
            }
          }
          if (match) {
            anyMatch = true;
            newUnit.base = BASE_UNITS[_i7];
            break;
          }
        }
      }
      if (!anyMatch) {
        baseName = baseName || name2 + "_STUFF";
        var _newBaseUnit = {
          dimensions: defUnit.dimensions.slice(0)
        };
        _newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = _newBaseUnit;
        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE[""]
        };
        newUnit.base = BASE_UNITS[baseName];
      }
    }
    Unit2.UNITS[name2] = newUnit;
    for (var _i8 = 0; _i8 < aliases.length; _i8++) {
      var aliasName = aliases[_i8];
      var _alias = {};
      for (var _key6 in newUnit) {
        if (hasOwnProperty$2(newUnit, _key6)) {
          _alias[_key6] = newUnit[_key6];
        }
      }
      _alias.name = aliasName;
      Unit2.UNITS[aliasName] = _alias;
    }
    delete _findUnit.cache;
    return new Unit2(null, name2);
  };
  Unit2.deleteUnit = function(name2) {
    delete Unit2.UNITS[name2];
  };
  Unit2.PREFIXES = PREFIXES;
  Unit2.BASE_DIMENSIONS = BASE_DIMENSIONS;
  Unit2.BASE_UNITS = BASE_UNITS;
  Unit2.UNIT_SYSTEMS = UNIT_SYSTEMS;
  Unit2.UNITS = UNITS;
  return Unit2;
}, {
  isClass: true
});
var name$2a = "unit";
var dependencies$2a = ["typed", "Unit"];
var createUnitFunction = /* @__PURE__ */ factory(name$2a, dependencies$2a, (_ref) => {
  var {
    typed: typed2,
    Unit: Unit2
  } = _ref;
  return typed2(name$2a, {
    Unit: function Unit3(x) {
      return x.clone();
    },
    string: function string2(x) {
      if (Unit2.isValuelessUnit(x)) {
        return new Unit2(null, x);
      }
      return Unit2.parse(x, {
        allowNoUnits: true
      });
    },
    "number | BigNumber | Fraction | Complex, string": function numberBigNumberFractionComplexString(value, unit2) {
      return new Unit2(value, unit2);
    },
    "number | BigNumber | Fraction": function numberBigNumberFraction(value) {
      return new Unit2(value);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$29 = "sparse";
var dependencies$29 = ["typed", "SparseMatrix"];
var createSparse = /* @__PURE__ */ factory(name$29, dependencies$29, (_ref) => {
  var {
    typed: typed2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name$29, {
    "": function _() {
      return new SparseMatrix2([]);
    },
    string: function string2(datatype) {
      return new SparseMatrix2([], datatype);
    },
    "Array | Matrix": function ArrayMatrix(data) {
      return new SparseMatrix2(data);
    },
    "Array | Matrix, string": function ArrayMatrixString(data, datatype) {
      return new SparseMatrix2(data, datatype);
    }
  });
});
var name$28 = "createUnit";
var dependencies$28 = ["typed", "Unit"];
var createCreateUnit = /* @__PURE__ */ factory(name$28, dependencies$28, (_ref) => {
  var {
    typed: typed2,
    Unit: Unit2
  } = _ref;
  return typed2(name$28, {
    "Object, Object": function ObjectObject(obj, options) {
      return Unit2.createUnit(obj, options);
    },
    Object: function Object2(obj) {
      return Unit2.createUnit(obj, {});
    },
    "string, Unit | string | Object, Object": function stringUnitStringObjectObject(name2, def2, options) {
      var obj = {};
      obj[name2] = def2;
      return Unit2.createUnit(obj, options);
    },
    "string, Unit | string | Object": function stringUnitStringObject(name2, def2) {
      var obj = {};
      obj[name2] = def2;
      return Unit2.createUnit(obj, {});
    },
    string: function string2(name2) {
      var obj = {};
      obj[name2] = {};
      return Unit2.createUnit(obj, {});
    }
  });
});
var name$27 = "acos";
var dependencies$27 = ["typed", "config", "Complex"];
var createAcos = /* @__PURE__ */ factory(name$27, dependencies$27, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2
  } = _ref;
  return typed2(name$27, {
    number: function number2(x) {
      if (x >= -1 && x <= 1 || config3.predictable) {
        return Math.acos(x);
      } else {
        return new Complex2(x, 0).acos();
      }
    },
    Complex: function Complex3(x) {
      return x.acos();
    },
    BigNumber: function BigNumber2(x) {
      return x.acos();
    }
  });
});
var name$26 = "acosh";
var dependencies$26 = ["typed", "config", "Complex"];
var createAcosh = /* @__PURE__ */ factory(name$26, dependencies$26, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2
  } = _ref;
  return typed2(name$26, {
    number: function number2(x) {
      if (x >= 1 || config3.predictable) {
        return acoshNumber(x);
      }
      if (x <= -1) {
        return new Complex2(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
      }
      return new Complex2(x, 0).acosh();
    },
    Complex: function Complex3(x) {
      return x.acosh();
    },
    BigNumber: function BigNumber2(x) {
      return x.acosh();
    }
  });
});
var name$25 = "acot";
var dependencies$25 = ["typed", "BigNumber"];
var createAcot = /* @__PURE__ */ factory(name$25, dependencies$25, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$25, {
    number: acotNumber,
    Complex: function Complex2(x) {
      return x.acot();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).atan();
    }
  });
});
var name$24 = "acoth";
var dependencies$24 = ["typed", "config", "Complex", "BigNumber"];
var createAcoth = /* @__PURE__ */ factory(name$24, dependencies$24, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$24, {
    number: function number2(x) {
      if (x >= 1 || x <= -1 || config3.predictable) {
        return acothNumber(x);
      }
      return new Complex2(x, 0).acoth();
    },
    Complex: function Complex3(x) {
      return x.acoth();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).atanh();
    }
  });
});
var name$23 = "acsc";
var dependencies$23 = ["typed", "config", "Complex", "BigNumber"];
var createAcsc = /* @__PURE__ */ factory(name$23, dependencies$23, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$23, {
    number: function number2(x) {
      if (x <= -1 || x >= 1 || config3.predictable) {
        return acscNumber(x);
      }
      return new Complex2(x, 0).acsc();
    },
    Complex: function Complex3(x) {
      return x.acsc();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).asin();
    }
  });
});
var name$22 = "acsch";
var dependencies$22 = ["typed", "BigNumber"];
var createAcsch = /* @__PURE__ */ factory(name$22, dependencies$22, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$22, {
    number: acschNumber,
    Complex: function Complex2(x) {
      return x.acsch();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).asinh();
    }
  });
});
var name$21 = "asec";
var dependencies$21 = ["typed", "config", "Complex", "BigNumber"];
var createAsec = /* @__PURE__ */ factory(name$21, dependencies$21, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$21, {
    number: function number2(x) {
      if (x <= -1 || x >= 1 || config3.predictable) {
        return asecNumber(x);
      }
      return new Complex2(x, 0).asec();
    },
    Complex: function Complex3(x) {
      return x.asec();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).acos();
    }
  });
});
var name$20 = "asech";
var dependencies$20 = ["typed", "config", "Complex", "BigNumber"];
var createAsech = /* @__PURE__ */ factory(name$20, dependencies$20, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$20, {
    number: function number2(x) {
      if (x <= 1 && x >= -1 || config3.predictable) {
        var xInv = 1 / x;
        if (xInv > 0 || config3.predictable) {
          return asechNumber(x);
        }
        var ret = Math.sqrt(xInv * xInv - 1);
        return new Complex2(Math.log(ret - xInv), Math.PI);
      }
      return new Complex2(x, 0).asech();
    },
    Complex: function Complex3(x) {
      return x.asech();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).acosh();
    }
  });
});
var name$1$ = "asin";
var dependencies$1$ = ["typed", "config", "Complex"];
var createAsin = /* @__PURE__ */ factory(name$1$, dependencies$1$, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2
  } = _ref;
  return typed2(name$1$, {
    number: function number2(x) {
      if (x >= -1 && x <= 1 || config3.predictable) {
        return Math.asin(x);
      } else {
        return new Complex2(x, 0).asin();
      }
    },
    Complex: function Complex3(x) {
      return x.asin();
    },
    BigNumber: function BigNumber2(x) {
      return x.asin();
    }
  });
});
var name$1_ = "asinh";
var dependencies$1_ = ["typed"];
var createAsinh = /* @__PURE__ */ factory(name$1_, dependencies$1_, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("asinh", {
    number: asinhNumber,
    Complex: function Complex2(x) {
      return x.asinh();
    },
    BigNumber: function BigNumber2(x) {
      return x.asinh();
    }
  });
});
var name$1Z = "atan";
var dependencies$1Z = ["typed"];
var createAtan = /* @__PURE__ */ factory(name$1Z, dependencies$1Z, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("atan", {
    number: function number2(x) {
      return Math.atan(x);
    },
    Complex: function Complex2(x) {
      return x.atan();
    },
    BigNumber: function BigNumber2(x) {
      return x.atan();
    }
  });
});
var name$1Y = "atan2";
var dependencies$1Y = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix"];
var createAtan2 = /* @__PURE__ */ factory(name$1Y, dependencies$1Y, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$1Y, {
    "number, number": Math.atan2,
    "BigNumber, BigNumber": (y, x) => BigNumber2.atan2(y, x)
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SS: matAlgo09xS0Sf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});
var name$1X = "atanh";
var dependencies$1X = ["typed", "config", "Complex"];
var createAtanh = /* @__PURE__ */ factory(name$1X, dependencies$1X, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2
  } = _ref;
  return typed2(name$1X, {
    number: function number2(x) {
      if (x <= 1 && x >= -1 || config3.predictable) {
        return atanhNumber(x);
      }
      return new Complex2(x, 0).atanh();
    },
    Complex: function Complex3(x) {
      return x.atanh();
    },
    BigNumber: function BigNumber2(x) {
      return x.atanh();
    }
  });
});
var createTrigUnit = /* @__PURE__ */ factory("trigUnit", ["typed"], (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return {
    Unit: typed2.referToSelf((self2) => (x) => {
      if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
        throw new TypeError("Unit in function cot is no angle");
      }
      return typed2.find(self2, x.valueType())(x.value);
    })
  };
});
var name$1W = "cos";
var dependencies$1W = ["typed"];
var createCos = /* @__PURE__ */ factory(name$1W, dependencies$1W, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name$1W, {
    number: Math.cos,
    "Complex | BigNumber": (x) => x.cos()
  }, trigUnit);
});
var name$1V = "cosh";
var dependencies$1V = ["typed"];
var createCosh = /* @__PURE__ */ factory(name$1V, dependencies$1V, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$1V, {
    number: cosh$2,
    "Complex | BigNumber": (x) => x.cosh()
  });
});
var name$1U = "cot";
var dependencies$1U = ["typed", "BigNumber"];
var createCot = /* @__PURE__ */ factory(name$1U, dependencies$1U, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name$1U, {
    number: cotNumber,
    Complex: (x) => x.cot(),
    BigNumber: (x) => new _BigNumber(1).div(x.tan())
  }, trigUnit);
});
var name$1T = "coth";
var dependencies$1T = ["typed", "BigNumber"];
var createCoth = /* @__PURE__ */ factory(name$1T, dependencies$1T, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$1T, {
    number: cothNumber,
    Complex: (x) => x.coth(),
    BigNumber: (x) => new _BigNumber(1).div(x.tanh())
  });
});
var name$1S = "csc";
var dependencies$1S = ["typed", "BigNumber"];
var createCsc = /* @__PURE__ */ factory(name$1S, dependencies$1S, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name$1S, {
    number: cscNumber,
    Complex: (x) => x.csc(),
    BigNumber: (x) => new _BigNumber(1).div(x.sin())
  }, trigUnit);
});
var name$1R = "csch";
var dependencies$1R = ["typed", "BigNumber"];
var createCsch = /* @__PURE__ */ factory(name$1R, dependencies$1R, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$1R, {
    number: cschNumber,
    Complex: (x) => x.csch(),
    BigNumber: (x) => new _BigNumber(1).div(x.sinh())
  });
});
var name$1Q = "sec";
var dependencies$1Q = ["typed", "BigNumber"];
var createSec = /* @__PURE__ */ factory(name$1Q, dependencies$1Q, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name$1Q, {
    number: secNumber,
    Complex: (x) => x.sec(),
    BigNumber: (x) => new _BigNumber(1).div(x.cos())
  }, trigUnit);
});
var name$1P = "sech";
var dependencies$1P = ["typed", "BigNumber"];
var createSech = /* @__PURE__ */ factory(name$1P, dependencies$1P, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$1P, {
    number: sechNumber,
    Complex: (x) => x.sech(),
    BigNumber: (x) => new _BigNumber(1).div(x.cosh())
  });
});
var name$1O = "sin";
var dependencies$1O = ["typed"];
var createSin = /* @__PURE__ */ factory(name$1O, dependencies$1O, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name$1O, {
    number: Math.sin,
    "Complex | BigNumber": (x) => x.sin()
  }, trigUnit);
});
var name$1N = "sinh";
var dependencies$1N = ["typed"];
var createSinh = /* @__PURE__ */ factory(name$1N, dependencies$1N, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$1N, {
    number: sinhNumber,
    "Complex | BigNumber": (x) => x.sinh()
  });
});
var name$1M = "tan";
var dependencies$1M = ["typed"];
var createTan = /* @__PURE__ */ factory(name$1M, dependencies$1M, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name$1M, {
    number: Math.tan,
    "Complex | BigNumber": (x) => x.tan()
  }, trigUnit);
});
var name$1L = "tanh";
var dependencies$1L = ["typed"];
var createTanh = /* @__PURE__ */ factory(name$1L, dependencies$1L, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("tanh", {
    number: tanh$2,
    "Complex | BigNumber": (x) => x.tanh()
  });
});
var name$1K = "setCartesian";
var dependencies$1K = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetCartesian = /* @__PURE__ */ factory(name$1K, dependencies$1K, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name$1K, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result = [];
      if (subset2(size2(a1), new Index2(0)) !== 0 && subset2(size2(a2), new Index2(0)) !== 0) {
        var b1 = flatten$1(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2);
        var b2 = flatten$1(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2);
        result = [];
        for (var i2 = 0; i2 < b1.length; i2++) {
          for (var j = 0; j < b2.length; j++) {
            result.push([b1[i2], b2[j]]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return result;
      }
      return new DenseMatrix2(result);
    }
  });
});
var name$1J = "setDifference";
var dependencies$1J = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDifference = /* @__PURE__ */ factory(name$1J, dependencies$1J, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name$1J, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result;
      if (subset2(size2(a1), new Index2(0)) === 0) {
        result = [];
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten$1(a1.toArray());
      } else {
        var b1 = identify(flatten$1(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
        var b2 = identify(flatten$1(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
        result = [];
        var inb2;
        for (var i2 = 0; i2 < b1.length; i2++) {
          inb2 = false;
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
              inb2 = true;
              break;
            }
          }
          if (!inb2) {
            result.push(b1[i2]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix2(generalize(result));
    }
  });
});
var name$1I = "setDistinct";
var dependencies$1I = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDistinct = /* @__PURE__ */ factory(name$1I, dependencies$1I, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name$1I, {
    "Array | Matrix": function ArrayMatrix(a) {
      var result;
      if (subset2(size2(a), new Index2(0)) === 0) {
        result = [];
      } else {
        var b = flatten$1(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
        result = [];
        result.push(b[0]);
        for (var i2 = 1; i2 < b.length; i2++) {
          if (compareNatural2(b[i2], b[i2 - 1]) !== 0) {
            result.push(b[i2]);
          }
        }
      }
      if (Array.isArray(a)) {
        return result;
      }
      return new DenseMatrix2(result);
    }
  });
});
var name$1H = "setIntersect";
var dependencies$1H = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetIntersect = /* @__PURE__ */ factory(name$1H, dependencies$1H, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name$1H, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result;
      if (subset2(size2(a1), new Index2(0)) === 0 || subset2(size2(a2), new Index2(0)) === 0) {
        result = [];
      } else {
        var b1 = identify(flatten$1(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
        var b2 = identify(flatten$1(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
        result = [];
        for (var i2 = 0; i2 < b1.length; i2++) {
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
              result.push(b1[i2]);
              break;
            }
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix2(generalize(result));
    }
  });
});
var name$1G = "setIsSubset";
var dependencies$1G = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetIsSubset = /* @__PURE__ */ factory(name$1G, dependencies$1G, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed2(name$1G, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return true;
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return false;
      }
      var b1 = identify(flatten$1(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
      var b2 = identify(flatten$1(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
      var inb2;
      for (var i2 = 0; i2 < b1.length; i2++) {
        inb2 = false;
        for (var j = 0; j < b2.length; j++) {
          if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
            inb2 = true;
            break;
          }
        }
        if (inb2 === false) {
          return false;
        }
      }
      return true;
    }
  });
});
var name$1F = "setMultiplicity";
var dependencies$1F = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetMultiplicity = /* @__PURE__ */ factory(name$1F, dependencies$1F, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed2(name$1F, {
    "number | BigNumber | Fraction | Complex, Array | Matrix": function numberBigNumberFractionComplexArrayMatrix(e2, a) {
      if (subset2(size2(a), new Index2(0)) === 0) {
        return 0;
      }
      var b = flatten$1(Array.isArray(a) ? a : a.toArray());
      var count3 = 0;
      for (var i2 = 0; i2 < b.length; i2++) {
        if (compareNatural2(b[i2], e2) === 0) {
          count3++;
        }
      }
      return count3;
    }
  });
});
var name$1E = "setPowerset";
var dependencies$1E = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetPowerset = /* @__PURE__ */ factory(name$1E, dependencies$1E, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed2(name$1E, {
    "Array | Matrix": function ArrayMatrix(a) {
      if (subset2(size2(a), new Index2(0)) === 0) {
        return [];
      }
      var b = flatten$1(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
      var result = [];
      var number2 = 0;
      while (number2.toString(2).length <= b.length) {
        result.push(_subset(b, number2.toString(2).split("").reverse()));
        number2++;
      }
      return _sort(result);
    }
  });
  function _subset(array, bitarray) {
    var result = [];
    for (var i2 = 0; i2 < bitarray.length; i2++) {
      if (bitarray[i2] === "1") {
        result.push(array[i2]);
      }
    }
    return result;
  }
  function _sort(array) {
    var temp = [];
    for (var i2 = array.length - 1; i2 > 0; i2--) {
      for (var j = 0; j < i2; j++) {
        if (array[j].length > array[j + 1].length) {
          temp = array[j];
          array[j] = array[j + 1];
          array[j + 1] = temp;
        }
      }
    }
    return array;
  }
});
var name$1D = "setSize";
var dependencies$1D = ["typed", "compareNatural"];
var createSetSize = /* @__PURE__ */ factory(name$1D, dependencies$1D, (_ref) => {
  var {
    typed: typed2,
    compareNatural: compareNatural2
  } = _ref;
  return typed2(name$1D, {
    "Array | Matrix": function ArrayMatrix(a) {
      return Array.isArray(a) ? flatten$1(a).length : flatten$1(a.toArray()).length;
    },
    "Array | Matrix, boolean": function ArrayMatrixBoolean(a, unique2) {
      if (unique2 === false || a.length === 0) {
        return Array.isArray(a) ? flatten$1(a).length : flatten$1(a.toArray()).length;
      } else {
        var b = flatten$1(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
        var count3 = 1;
        for (var i2 = 1; i2 < b.length; i2++) {
          if (compareNatural2(b[i2], b[i2 - 1]) !== 0) {
            count3++;
          }
        }
        return count3;
      }
    }
  });
});
var name$1C = "setSymDifference";
var dependencies$1C = ["typed", "size", "concat", "subset", "setDifference", "Index"];
var createSetSymDifference = /* @__PURE__ */ factory(name$1C, dependencies$1C, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    concat: concat3,
    subset: subset2,
    setDifference: setDifference2,
    Index: Index2
  } = _ref;
  return typed2(name$1C, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return flatten$1(a2);
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten$1(a1);
      }
      var b1 = flatten$1(a1);
      var b2 = flatten$1(a2);
      return concat3(setDifference2(b1, b2), setDifference2(b2, b1));
    }
  });
});
var name$1B = "setUnion";
var dependencies$1B = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
var createSetUnion = /* @__PURE__ */ factory(name$1B, dependencies$1B, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    concat: concat3,
    subset: subset2,
    setIntersect: setIntersect2,
    setSymDifference: setSymDifference2,
    Index: Index2
  } = _ref;
  return typed2(name$1B, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return flatten$1(a2);
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten$1(a1);
      }
      var b1 = flatten$1(a1);
      var b2 = flatten$1(a2);
      return concat3(setSymDifference2(b1, b2), setIntersect2(b1, b2));
    }
  });
});
var name$1A = "add";
var dependencies$1A = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix"];
var createAdd = /* @__PURE__ */ factory(name$1A, dependencies$1A, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$1A, {
    "any, any": addScalar2,
    "any, any, ...any": typed2.referToSelf((self2) => (x, y, rest2) => {
      var result = self2(x, y);
      for (var i2 = 0; i2 < rest2.length; i2++) {
        result = self2(result, rest2[i2]);
      }
      return result;
    })
  }, matrixAlgorithmSuite({
    elop: addScalar2,
    DS: matAlgo01xDSid,
    SS: matAlgo04xSidSid,
    Ss: matAlgo10xSids
  }));
});
var name$1z = "hypot";
var dependencies$1z = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"];
var createHypot = /* @__PURE__ */ factory(name$1z, dependencies$1z, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    sqrt: sqrt2,
    smaller: smaller2,
    isPositive: isPositive2
  } = _ref;
  return typed2(name$1z, {
    "... number | BigNumber": _hypot,
    Array: _hypot,
    Matrix: (M) => _hypot(flatten$1(M.toArray()))
  });
  function _hypot(args) {
    var result = 0;
    var largest = 0;
    for (var i2 = 0; i2 < args.length; i2++) {
      if (isComplex(args[i2])) {
        throw new TypeError("Unexpected type of argument to hypot");
      }
      var value = abs2(args[i2]);
      if (smaller2(largest, value)) {
        result = multiplyScalar2(result, multiplyScalar2(divideScalar2(largest, value), divideScalar2(largest, value)));
        result = addScalar2(result, 1);
        largest = value;
      } else {
        result = addScalar2(result, isPositive2(value) ? multiplyScalar2(divideScalar2(value, largest), divideScalar2(value, largest)) : value);
      }
    }
    return multiplyScalar2(largest, sqrt2(result));
  }
});
var name$1y = "norm";
var dependencies$1y = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
var createNorm = /* @__PURE__ */ factory(name$1y, dependencies$1y, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    pow: pow2,
    conj: conj2,
    sqrt: sqrt2,
    multiply: multiply2,
    equalScalar: equalScalar2,
    larger: larger2,
    smaller: smaller2,
    matrix: matrix2,
    ctranspose: ctranspose2,
    eigs: eigs2
  } = _ref;
  return typed2(name$1y, {
    number: Math.abs,
    Complex: function Complex2(x) {
      return x.abs();
    },
    BigNumber: function BigNumber2(x) {
      return x.abs();
    },
    boolean: function boolean2(x) {
      return Math.abs(x);
    },
    Array: function Array2(x) {
      return _norm(matrix2(x), 2);
    },
    Matrix: function Matrix2(x) {
      return _norm(x, 2);
    },
    "Array, number | BigNumber | string": function ArrayNumberBigNumberString(x, p2) {
      return _norm(matrix2(x), p2);
    },
    "Matrix, number | BigNumber | string": function MatrixNumberBigNumberString(x, p2) {
      return _norm(x, p2);
    }
  });
  function _vectorNormPlusInfinity(x) {
    var pinf = 0;
    x.forEach(function(value) {
      var v = abs2(value);
      if (larger2(v, pinf)) {
        pinf = v;
      }
    }, true);
    return pinf;
  }
  function _vectorNormMinusInfinity(x) {
    var ninf;
    x.forEach(function(value) {
      var v = abs2(value);
      if (!ninf || smaller2(v, ninf)) {
        ninf = v;
      }
    }, true);
    return ninf || 0;
  }
  function _vectorNorm(x, p2) {
    if (p2 === Number.POSITIVE_INFINITY || p2 === "inf") {
      return _vectorNormPlusInfinity(x);
    }
    if (p2 === Number.NEGATIVE_INFINITY || p2 === "-inf") {
      return _vectorNormMinusInfinity(x);
    }
    if (p2 === "fro") {
      return _norm(x, 2);
    }
    if (typeof p2 === "number" && !isNaN(p2)) {
      if (!equalScalar2(p2, 0)) {
        var n = 0;
        x.forEach(function(value) {
          n = add2(pow2(abs2(value), p2), n);
        }, true);
        return pow2(n, 1 / p2);
      }
      return Number.POSITIVE_INFINITY;
    }
    throw new Error("Unsupported parameter value");
  }
  function _matrixNormFrobenius(x) {
    var fro = 0;
    x.forEach(function(value, index2) {
      fro = add2(fro, multiply2(value, conj2(value)));
    });
    return abs2(sqrt2(fro));
  }
  function _matrixNormOne(x) {
    var c = [];
    var maxc = 0;
    x.forEach(function(value, index2) {
      var j = index2[1];
      var cj = add2(c[j] || 0, abs2(value));
      if (larger2(cj, maxc)) {
        maxc = cj;
      }
      c[j] = cj;
    }, true);
    return maxc;
  }
  function _matrixNormTwo(x) {
    var sizeX = x.size();
    if (sizeX[0] !== sizeX[1]) {
      throw new RangeError("Invalid matrix dimensions");
    }
    var tx = ctranspose2(x);
    var squaredX = multiply2(tx, x);
    var eigenVals = eigs2(squaredX).values.toArray();
    var rho = eigenVals[eigenVals.length - 1];
    return abs2(sqrt2(rho));
  }
  function _matrixNormInfinity(x) {
    var r = [];
    var maxr = 0;
    x.forEach(function(value, index2) {
      var i2 = index2[0];
      var ri = add2(r[i2] || 0, abs2(value));
      if (larger2(ri, maxr)) {
        maxr = ri;
      }
      r[i2] = ri;
    }, true);
    return maxr;
  }
  function _matrixNorm(x, p2) {
    if (p2 === 1) {
      return _matrixNormOne(x);
    }
    if (p2 === Number.POSITIVE_INFINITY || p2 === "inf") {
      return _matrixNormInfinity(x);
    }
    if (p2 === "fro") {
      return _matrixNormFrobenius(x);
    }
    if (p2 === 2) {
      return _matrixNormTwo(x);
    }
    throw new Error("Unsupported parameter value " + p2);
  }
  function _norm(x, p2) {
    var sizeX = x.size();
    if (sizeX.length === 1) {
      return _vectorNorm(x, p2);
    }
    if (sizeX.length === 2) {
      if (sizeX[0] && sizeX[1]) {
        return _matrixNorm(x, p2);
      } else {
        throw new RangeError("Invalid matrix dimensions");
      }
    }
  }
});
var name$1x = "dot";
var dependencies$1x = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
var createDot = /* @__PURE__ */ factory(name$1x, dependencies$1x, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    conj: conj2,
    size: size2
  } = _ref;
  return typed2(name$1x, {
    "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
    "SparseMatrix, SparseMatrix": _sparseDot
  });
  function _validateDim(x, y) {
    var xSize = _size(x);
    var ySize = _size(y);
    var xLen, yLen;
    if (xSize.length === 1) {
      xLen = xSize[0];
    } else if (xSize.length === 2 && xSize[1] === 1) {
      xLen = xSize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
    }
    if (ySize.length === 1) {
      yLen = ySize[0];
    } else if (ySize.length === 2 && ySize[1] === 1) {
      yLen = ySize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
    }
    if (xLen !== yLen)
      throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
    if (xLen === 0)
      throw new RangeError("Cannot calculate the dot product of empty vectors");
    return xLen;
  }
  function _denseDot(a, b) {
    var N = _validateDim(a, b);
    var adata = isMatrix(a) ? a._data : a;
    var adt = isMatrix(a) ? a._datatype : void 0;
    var bdata = isMatrix(b) ? b._data : b;
    var bdt = isMatrix(b) ? b._datatype : void 0;
    var aIsColumn = _size(a).length === 2;
    var bIsColumn = _size(b).length === 2;
    var add2 = addScalar2;
    var mul2 = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string") {
      var dt = adt;
      add2 = typed2.find(addScalar2, [dt, dt]);
      mul2 = typed2.find(multiplyScalar2, [dt, dt]);
    }
    if (!aIsColumn && !bIsColumn) {
      var c = mul2(conj2(adata[0]), bdata[0]);
      for (var i2 = 1; i2 < N; i2++) {
        c = add2(c, mul2(conj2(adata[i2]), bdata[i2]));
      }
      return c;
    }
    if (!aIsColumn && bIsColumn) {
      var _c = mul2(conj2(adata[0]), bdata[0][0]);
      for (var _i = 1; _i < N; _i++) {
        _c = add2(_c, mul2(conj2(adata[_i]), bdata[_i][0]));
      }
      return _c;
    }
    if (aIsColumn && !bIsColumn) {
      var _c2 = mul2(conj2(adata[0][0]), bdata[0]);
      for (var _i2 = 1; _i2 < N; _i2++) {
        _c2 = add2(_c2, mul2(conj2(adata[_i2][0]), bdata[_i2]));
      }
      return _c2;
    }
    if (aIsColumn && bIsColumn) {
      var _c3 = mul2(conj2(adata[0][0]), bdata[0][0]);
      for (var _i3 = 1; _i3 < N; _i3++) {
        _c3 = add2(_c3, mul2(conj2(adata[_i3][0]), bdata[_i3][0]));
      }
      return _c3;
    }
  }
  function _sparseDot(x, y) {
    _validateDim(x, y);
    var xindex = x._index;
    var xvalues = x._values;
    var yindex = y._index;
    var yvalues = y._values;
    var c = 0;
    var add2 = addScalar2;
    var mul2 = multiplyScalar2;
    var i2 = 0;
    var j = 0;
    while (i2 < xindex.length && j < yindex.length) {
      var I = xindex[i2];
      var J = yindex[j];
      if (I < J) {
        i2++;
        continue;
      }
      if (I > J) {
        j++;
        continue;
      }
      if (I === J) {
        c = add2(c, mul2(xvalues[i2], yvalues[j]));
        i2++;
        j++;
      }
    }
    return c;
  }
  function _size(x) {
    return isMatrix(x) ? x.size() : size2(x);
  }
});
var name$1w = "trace";
var dependencies$1w = ["typed", "matrix", "add"];
var createTrace = /* @__PURE__ */ factory(name$1w, dependencies$1w, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    add: add2
  } = _ref;
  return typed2("trace", {
    Array: function _arrayTrace(x) {
      return _denseTrace(matrix2(x));
    },
    SparseMatrix: _sparseTrace,
    DenseMatrix: _denseTrace,
    any: clone$2
  });
  function _denseTrace(m) {
    var size2 = m._size;
    var data = m._data;
    switch (size2.length) {
      case 1:
        if (size2[0] === 1) {
          return clone$2(data[0]);
        }
        throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
      case 2: {
        var rows = size2[0];
        var cols = size2[1];
        if (rows === cols) {
          var sum2 = 0;
          for (var i2 = 0; i2 < rows; i2++) {
            sum2 = add2(sum2, data[i2][i2]);
          }
          return sum2;
        } else {
          throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
        }
      }
      default:
        throw new RangeError("Matrix must be two dimensional (size: " + format$1(size2) + ")");
    }
  }
  function _sparseTrace(m) {
    var values2 = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var size2 = m._size;
    var rows = size2[0];
    var columns = size2[1];
    if (rows === columns) {
      var sum2 = 0;
      if (values2.length > 0) {
        for (var j = 0; j < columns; j++) {
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          for (var k = k0; k < k1; k++) {
            var i2 = index2[k];
            if (i2 === j) {
              sum2 = add2(sum2, values2[k]);
              break;
            }
            if (i2 > j) {
              break;
            }
          }
        }
      }
      return sum2;
    }
    throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
  }
});
var name$1v = "index";
var dependencies$1v = ["typed", "Index"];
var createIndex = /* @__PURE__ */ factory(name$1v, dependencies$1v, (_ref) => {
  var {
    typed: typed2,
    Index: Index2
  } = _ref;
  return typed2(name$1v, {
    "...number | string | BigNumber | Range | Array | Matrix": function numberStringBigNumberRangeArrayMatrix(args) {
      var ranges = args.map(function(arg2) {
        if (isBigNumber(arg2)) {
          return arg2.toNumber();
        } else if (Array.isArray(arg2) || isMatrix(arg2)) {
          return arg2.map(function(elem) {
            return isBigNumber(elem) ? elem.toNumber() : elem;
          });
        } else {
          return arg2;
        }
      });
      var res = new Index2();
      Index2.apply(res, ranges);
      return res;
    }
  });
});
var keywords = /* @__PURE__ */ new Set(["end"]);
var name$1u = "Node";
var dependencies$1u = ["mathWithTransform"];
var createNode = /* @__PURE__ */ factory(name$1u, dependencies$1u, (_ref) => {
  var {
    mathWithTransform: mathWithTransform2
  } = _ref;
  function _validateScope(scope) {
    for (var symbol of [...keywords]) {
      if (scope.has(symbol)) {
        throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
      }
    }
  }
  class Node2 {
    get type() {
      return "Node";
    }
    get isNode() {
      return true;
    }
    evaluate(scope) {
      return this.compile().evaluate(scope);
    }
    compile() {
      var expr = this._compile(mathWithTransform2, {});
      var args = {};
      var context = null;
      function evaluate2(scope) {
        var s = createMap$1(scope);
        _validateScope(s);
        return expr(s, args, context);
      }
      return {
        evaluate: evaluate2
      };
    }
    _compile(math2, argNames) {
      throw new Error("Method _compile must be implemented by type " + this.type);
    }
    forEach(callback) {
      throw new Error("Cannot run forEach on a Node interface");
    }
    map(callback) {
      throw new Error("Cannot run map on a Node interface");
    }
    _ifNode(node) {
      if (!isNode(node)) {
        throw new TypeError("Callback function must return a Node");
      }
      return node;
    }
    traverse(callback) {
      callback(this, null, null);
      function _traverse(node, callback2) {
        node.forEach(function(child, path, parent) {
          callback2(child, path, parent);
          _traverse(child, callback2);
        });
      }
      _traverse(this, callback);
    }
    transform(callback) {
      function _transform(child, path, parent) {
        var replacement = callback(child, path, parent);
        if (replacement !== child) {
          return replacement;
        }
        return child.map(_transform);
      }
      return _transform(this, null, null);
    }
    filter(callback) {
      var nodes2 = [];
      this.traverse(function(node, path, parent) {
        if (callback(node, path, parent)) {
          nodes2.push(node);
        }
      });
      return nodes2;
    }
    clone() {
      throw new Error("Cannot clone a Node interface");
    }
    cloneDeep() {
      return this.map(function(node) {
        return node.cloneDeep();
      });
    }
    equals(other) {
      return other ? this.type === other.type && deepStrictEqual(this, other) : false;
    }
    toString(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toString(options);
    }
    toJSON() {
      throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
    }
    toHTML(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this.toHTML(options);
    }
    _toString() {
      throw new Error("_toString not implemented for " + this.type);
    }
    toTex(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toTex(options);
    }
    _toTex(options) {
      throw new Error("_toTex not implemented for " + this.type);
    }
    _getCustomString(options) {
      if (options && typeof options === "object") {
        switch (typeof options.handler) {
          case "object":
          case "undefined":
            return;
          case "function":
            return options.handler(this, options);
          default:
            throw new TypeError("Object or function expected as callback");
        }
      }
    }
    getIdentifier() {
      return this.type;
    }
    getContent() {
      return this;
    }
  }
  return Node2;
}, {
  isClass: true,
  isNode: true
});
function errorTransform(err) {
  if (err && err.isIndexError) {
    return new IndexError(err.index + 1, err.min + 1, err.max !== void 0 ? err.max + 1 : void 0);
  }
  return err;
}
function accessFactory(_ref) {
  var {
    subset: subset2
  } = _ref;
  return function access(object, index2) {
    try {
      if (Array.isArray(object)) {
        return subset2(object, index2);
      } else if (object && typeof object.subset === "function") {
        return object.subset(index2);
      } else if (typeof object === "string") {
        return subset2(object, index2);
      } else if (typeof object === "object") {
        if (!index2.isObjectProperty()) {
          throw new TypeError("Cannot apply a numeric index as object property");
        }
        return getSafeProperty(object, index2.getObjectProperty());
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}
var name$1t = "AccessorNode";
var dependencies$1t = ["subset", "Node"];
var createAccessorNode = /* @__PURE__ */ factory(name$1t, dependencies$1t, (_ref) => {
  var {
    subset: subset2,
    Node: Node2
  } = _ref;
  var access = accessFactory({
    subset: subset2
  });
  function needParenthesis(node) {
    return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
  }
  class AccessorNode2 extends Node2 {
    constructor(object, index2) {
      super();
      if (!isNode(object)) {
        throw new TypeError('Node expected for parameter "object"');
      }
      if (!isIndexNode(index2)) {
        throw new TypeError('IndexNode expected for parameter "index"');
      }
      this.object = object;
      this.index = index2;
    }
    get name() {
      if (this.index) {
        return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
      } else {
        return this.object.name || "";
      }
    }
    get type() {
      return name$1t;
    }
    get isAccessorNode() {
      return true;
    }
    _compile(math2, argNames) {
      var evalObject = this.object._compile(math2, argNames);
      var evalIndex = this.index._compile(math2, argNames);
      if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAccessorNode(scope, args, context) {
          return getSafeProperty(evalObject(scope, args, context), prop);
        };
      } else {
        return function evalAccessorNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var index2 = evalIndex(scope, args, object);
          return access(object, index2);
        };
      }
    }
    forEach(callback) {
      callback(this.object, "object", this);
      callback(this.index, "index", this);
    }
    map(callback) {
      return new AccessorNode2(this._ifNode(callback(this.object, "object", this)), this._ifNode(callback(this.index, "index", this)));
    }
    clone() {
      return new AccessorNode2(this.object, this.index);
    }
    _toString(options) {
      var object = this.object.toString(options);
      if (needParenthesis(this.object)) {
        object = "(" + object + ")";
      }
      return object + this.index.toString(options);
    }
    toHTML(options) {
      var object = this.object.toHTML(options);
      if (needParenthesis(this.object)) {
        object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return object + this.index.toHTML(options);
    }
    _toTex(options) {
      var object = this.object.toTex(options);
      if (needParenthesis(this.object)) {
        object = "\\left(' + object + '\\right)";
      }
      return object + this.index.toTex(options);
    }
    toJSON() {
      return {
        mathjs: name$1t,
        object: this.object,
        index: this.index
      };
    }
    static fromJSON(json) {
      return new AccessorNode2(json.object, json.index);
    }
  }
  _defineProperty(AccessorNode2, "name", name$1t);
  return AccessorNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1s = "ArrayNode";
var dependencies$1s = ["Node"];
var createArrayNode = /* @__PURE__ */ factory(name$1s, dependencies$1s, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  class ArrayNode2 extends Node2 {
    constructor(items) {
      super();
      this.items = items || [];
      if (!Array.isArray(this.items) || !this.items.every(isNode)) {
        throw new TypeError("Array containing Nodes expected");
      }
    }
    get type() {
      return name$1s;
    }
    get isArrayNode() {
      return true;
    }
    _compile(math2, argNames) {
      var evalItems = map$1(this.items, function(item) {
        return item._compile(math2, argNames);
      });
      var asMatrix = math2.config.matrix !== "Array";
      if (asMatrix) {
        var matrix2 = math2.matrix;
        return function evalArrayNode(scope, args, context) {
          return matrix2(map$1(evalItems, function(evalItem) {
            return evalItem(scope, args, context);
          }));
        };
      } else {
        return function evalArrayNode(scope, args, context) {
          return map$1(evalItems, function(evalItem) {
            return evalItem(scope, args, context);
          });
        };
      }
    }
    forEach(callback) {
      for (var i2 = 0; i2 < this.items.length; i2++) {
        var node = this.items[i2];
        callback(node, "items[" + i2 + "]", this);
      }
    }
    map(callback) {
      var items = [];
      for (var i2 = 0; i2 < this.items.length; i2++) {
        items[i2] = this._ifNode(callback(this.items[i2], "items[" + i2 + "]", this));
      }
      return new ArrayNode2(items);
    }
    clone() {
      return new ArrayNode2(this.items.slice(0));
    }
    _toString(options) {
      var items = this.items.map(function(node) {
        return node.toString(options);
      });
      return "[" + items.join(", ") + "]";
    }
    toJSON() {
      return {
        mathjs: name$1s,
        items: this.items
      };
    }
    static fromJSON(json) {
      return new ArrayNode2(json.items);
    }
    toHTML(options) {
      var items = this.items.map(function(node) {
        return node.toHTML(options);
      });
      return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
    }
    _toTex(options) {
      function itemsToTex(items, nested) {
        var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);
        var itemsFormRow = nested || mixedItems;
        var itemSep = itemsFormRow ? "&" : "\\\\";
        var itemsTex = items.map(function(node) {
          if (node.items) {
            return itemsToTex(node.items, !nested);
          } else {
            return node.toTex(options);
          }
        }).join(itemSep);
        return mixedItems || !itemsFormRow || itemsFormRow && !nested ? "\\begin{bmatrix}" + itemsTex + "\\end{bmatrix}" : itemsTex;
      }
      return itemsToTex(this.items, false);
    }
  }
  _defineProperty(ArrayNode2, "name", name$1s);
  return ArrayNode2;
}, {
  isClass: true,
  isNode: true
});
function assignFactory(_ref) {
  var {
    subset: subset2,
    matrix: matrix2
  } = _ref;
  return function assign2(object, index2, value) {
    try {
      if (Array.isArray(object)) {
        return matrix2(object).subset(index2, value).valueOf();
      } else if (object && typeof object.subset === "function") {
        return object.subset(index2, value);
      } else if (typeof object === "string") {
        return subset2(object, index2, value);
      } else if (typeof object === "object") {
        if (!index2.isObjectProperty()) {
          throw TypeError("Cannot apply a numeric index as object property");
        }
        setSafeProperty(object, index2.getObjectProperty(), value);
        return object;
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}
var properties = [{
  AssignmentNode: {},
  FunctionAssignmentNode: {}
}, {
  ConditionalNode: {
    latexLeftParens: false,
    latexRightParens: false,
    latexParens: false
  }
}, {
  "OperatorNode:or": {
    op: "or",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:xor": {
    op: "xor",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:and": {
    op: "and",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:bitOr": {
    op: "|",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:bitXor": {
    op: "^|",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:bitAnd": {
    op: "&",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:equal": {
    op: "==",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:unequal": {
    op: "!=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smaller": {
    op: "<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:larger": {
    op: ">",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smallerEq": {
    op: "<=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:largerEq": {
    op: ">=",
    associativity: "left",
    associativeWith: []
  },
  RelationalNode: {
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:leftShift": {
    op: "<<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightArithShift": {
    op: ">>",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightLogShift": {
    op: ">>>",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:to": {
    op: "to",
    associativity: "left",
    associativeWith: []
  }
}, {
  RangeNode: {}
}, {
  "OperatorNode:add": {
    op: "+",
    associativity: "left",
    associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
  },
  "OperatorNode:subtract": {
    op: "-",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:multiply": {
    op: "*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  },
  "OperatorNode:divide": {
    op: "/",
    associativity: "left",
    associativeWith: [],
    latexLeftParens: false,
    latexRightParens: false,
    latexParens: false
  },
  "OperatorNode:dotMultiply": {
    op: ".*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
  },
  "OperatorNode:dotDivide": {
    op: "./",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:mod": {
    op: "mod",
    associativity: "left",
    associativeWith: []
  }
}, {
  "OperatorNode:multiply": {
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  }
}, {
  "OperatorNode:unaryPlus": {
    op: "+",
    associativity: "right"
  },
  "OperatorNode:unaryMinus": {
    op: "-",
    associativity: "right"
  },
  "OperatorNode:bitNot": {
    op: "~",
    associativity: "right"
  },
  "OperatorNode:not": {
    op: "not",
    associativity: "right"
  }
}, {
  "OperatorNode:pow": {
    op: "^",
    associativity: "right",
    associativeWith: [],
    latexRightParens: false
  },
  "OperatorNode:dotPow": {
    op: ".^",
    associativity: "right",
    associativeWith: []
  }
}, {
  "OperatorNode:factorial": {
    op: "!",
    associativity: "left"
  }
}, {
  "OperatorNode:ctranspose": {
    op: "'",
    associativity: "left"
  }
}];
function unwrapParen(_node, parenthesis) {
  if (!parenthesis || parenthesis !== "auto")
    return _node;
  var node = _node;
  while (isParenthesisNode(node)) {
    node = node.content;
  }
  return node;
}
function getPrecedence(_node, parenthesis, implicit, parent) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var precedence = null;
  for (var i2 = 0; i2 < properties.length; i2++) {
    if (identifier in properties[i2]) {
      precedence = i2;
      break;
    }
  }
  if (identifier === "OperatorNode:multiply" && node.implicit && implicit !== "show") {
    var leftArg = unwrapParen(node.args[0], parenthesis);
    if (!(isConstantNode(leftArg) && parent && parent.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(leftArg.args[0], parenthesis)) && isConstantNode(unwrapParen(leftArg.args[1])))) {
      precedence += 1;
    }
  }
  return precedence;
}
function getAssociativity(_node, parenthesis) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var index2 = getPrecedence(node, parenthesis);
  if (index2 === null) {
    return null;
  }
  var property = properties[index2][identifier];
  if (hasOwnProperty$2(property, "associativity")) {
    if (property.associativity === "left") {
      return "left";
    }
    if (property.associativity === "right") {
      return "right";
    }
    throw Error("'" + identifier + "' has the invalid associativity '" + property.associativity + "'.");
  }
  return null;
}
function isAssociativeWith(nodeA, nodeB, parenthesis) {
  var a = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
  var b = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
  var identifierA = a.getIdentifier();
  var identifierB = b.getIdentifier();
  var index2 = getPrecedence(a, parenthesis);
  if (index2 === null) {
    return null;
  }
  var property = properties[index2][identifierA];
  if (hasOwnProperty$2(property, "associativeWith") && property.associativeWith instanceof Array) {
    for (var i2 = 0; i2 < property.associativeWith.length; i2++) {
      if (property.associativeWith[i2] === identifierB) {
        return true;
      }
    }
    return false;
  }
  return null;
}
function getOperator(fn) {
  var identifier = "OperatorNode:" + fn;
  for (var group of properties) {
    if (identifier in group) {
      return group[identifier].op;
    }
  }
  return null;
}
var name$1r = "AssignmentNode";
var dependencies$1r = [
  "subset",
  "?matrix",
  "Node"
];
var createAssignmentNode = /* @__PURE__ */ factory(name$1r, dependencies$1r, (_ref) => {
  var {
    subset: subset2,
    matrix: matrix2,
    Node: Node2
  } = _ref;
  var access = accessFactory({
    subset: subset2
  });
  var assign2 = assignFactory({
    subset: subset2,
    matrix: matrix2
  });
  function needParenthesis(node, parenthesis, implicit) {
    if (!parenthesis) {
      parenthesis = "keep";
    }
    var precedence = getPrecedence(node, parenthesis, implicit);
    var exprPrecedence = getPrecedence(node.value, parenthesis, implicit);
    return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
  }
  class AssignmentNode2 extends Node2 {
    constructor(object, index2, value) {
      super();
      this.object = object;
      this.index = value ? index2 : null;
      this.value = value || index2;
      if (!isSymbolNode(object) && !isAccessorNode(object)) {
        throw new TypeError('SymbolNode or AccessorNode expected as "object"');
      }
      if (isSymbolNode(object) && object.name === "end") {
        throw new Error('Cannot assign to symbol "end"');
      }
      if (this.index && !isIndexNode(this.index)) {
        throw new TypeError('IndexNode expected as "index"');
      }
      if (!isNode(this.value)) {
        throw new TypeError('Node expected as "value"');
      }
    }
    get name() {
      if (this.index) {
        return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
      } else {
        return this.object.name || "";
      }
    }
    get type() {
      return name$1r;
    }
    get isAssignmentNode() {
      return true;
    }
    _compile(math2, argNames) {
      var evalObject = this.object._compile(math2, argNames);
      var evalIndex = this.index ? this.index._compile(math2, argNames) : null;
      var evalValue = this.value._compile(math2, argNames);
      var name2 = this.object.name;
      if (!this.index) {
        if (!isSymbolNode(this.object)) {
          throw new TypeError("SymbolNode expected as object");
        }
        return function evalAssignmentNode(scope, args, context) {
          var value = evalValue(scope, args, context);
          scope.set(name2, value);
          return value;
        };
      } else if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAssignmentNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          setSafeProperty(object, prop, value);
          return value;
        };
      } else if (isSymbolNode(this.object)) {
        return function evalAssignmentNode(scope, args, context) {
          var childObject = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          var index2 = evalIndex(scope, args, childObject);
          scope.set(name2, assign2(childObject, index2, value));
          return value;
        };
      } else {
        var evalParentObject = this.object.object._compile(math2, argNames);
        if (this.object.index.isObjectProperty()) {
          var parentProp = this.object.index.getObjectProperty();
          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var childObject = getSafeProperty(parent, parentProp);
            var index2 = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context);
            setSafeProperty(parent, parentProp, assign2(childObject, index2, value));
            return value;
          };
        } else {
          var evalParentIndex = this.object.index._compile(math2, argNames);
          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var parentIndex = evalParentIndex(scope, args, parent);
            var childObject = access(parent, parentIndex);
            var index2 = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context);
            assign2(parent, parentIndex, assign2(childObject, index2, value));
            return value;
          };
        }
      }
    }
    forEach(callback) {
      callback(this.object, "object", this);
      if (this.index) {
        callback(this.index, "index", this);
      }
      callback(this.value, "value", this);
    }
    map(callback) {
      var object = this._ifNode(callback(this.object, "object", this));
      var index2 = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
      var value = this._ifNode(callback(this.value, "value", this));
      return new AssignmentNode2(object, index2, value);
    }
    clone() {
      return new AssignmentNode2(this.object, this.index, this.value);
    }
    _toString(options) {
      var object = this.object.toString(options);
      var index2 = this.index ? this.index.toString(options) : "";
      var value = this.value.toString(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = "(" + value + ")";
      }
      return object + index2 + " = " + value;
    }
    toJSON() {
      return {
        mathjs: name$1r,
        object: this.object,
        index: this.index,
        value: this.value
      };
    }
    static fromJSON(json) {
      return new AssignmentNode2(json.object, json.index, json.value);
    }
    toHTML(options) {
      var object = this.object.toHTML(options);
      var index2 = this.index ? this.index.toHTML(options) : "";
      var value = this.value.toHTML(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      }
      return object + index2 + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + value;
    }
    _toTex(options) {
      var object = this.object.toTex(options);
      var index2 = this.index ? this.index.toTex(options) : "";
      var value = this.value.toTex(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = "\\left(".concat(value, "\\right)");
      }
      return object + index2 + ":=" + value;
    }
  }
  _defineProperty(AssignmentNode2, "name", name$1r);
  return AssignmentNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1q = "BlockNode";
var dependencies$1q = ["ResultSet", "Node"];
var createBlockNode = /* @__PURE__ */ factory(name$1q, dependencies$1q, (_ref) => {
  var {
    ResultSet: ResultSet2,
    Node: Node2
  } = _ref;
  class BlockNode2 extends Node2 {
    constructor(blocks) {
      super();
      if (!Array.isArray(blocks))
        throw new Error("Array expected");
      this.blocks = blocks.map(function(block) {
        var node = block && block.node;
        var visible = block && block.visible !== void 0 ? block.visible : true;
        if (!isNode(node))
          throw new TypeError('Property "node" must be a Node');
        if (typeof visible !== "boolean") {
          throw new TypeError('Property "visible" must be a boolean');
        }
        return {
          node,
          visible
        };
      });
    }
    get type() {
      return name$1q;
    }
    get isBlockNode() {
      return true;
    }
    _compile(math2, argNames) {
      var evalBlocks = map$1(this.blocks, function(block) {
        return {
          evaluate: block.node._compile(math2, argNames),
          visible: block.visible
        };
      });
      return function evalBlockNodes(scope, args, context) {
        var results = [];
        forEach$1(evalBlocks, function evalBlockNode(block) {
          var result = block.evaluate(scope, args, context);
          if (block.visible) {
            results.push(result);
          }
        });
        return new ResultSet2(results);
      };
    }
    forEach(callback) {
      for (var i2 = 0; i2 < this.blocks.length; i2++) {
        callback(this.blocks[i2].node, "blocks[" + i2 + "].node", this);
      }
    }
    map(callback) {
      var blocks = [];
      for (var i2 = 0; i2 < this.blocks.length; i2++) {
        var block = this.blocks[i2];
        var node = this._ifNode(callback(block.node, "blocks[" + i2 + "].node", this));
        blocks[i2] = {
          node,
          visible: block.visible
        };
      }
      return new BlockNode2(blocks);
    }
    clone() {
      var blocks = this.blocks.map(function(block) {
        return {
          node: block.node,
          visible: block.visible
        };
      });
      return new BlockNode2(blocks);
    }
    _toString(options) {
      return this.blocks.map(function(param) {
        return param.node.toString(options) + (param.visible ? "" : ";");
      }).join("\n");
    }
    toJSON() {
      return {
        mathjs: name$1q,
        blocks: this.blocks
      };
    }
    static fromJSON(json) {
      return new BlockNode2(json.blocks);
    }
    toHTML(options) {
      return this.blocks.map(function(param) {
        return param.node.toHTML(options) + (param.visible ? "" : '<span class="math-separator">;</span>');
      }).join('<span class="math-separator"><br /></span>');
    }
    _toTex(options) {
      return this.blocks.map(function(param) {
        return param.node.toTex(options) + (param.visible ? "" : ";");
      }).join("\\;\\;\n");
    }
  }
  _defineProperty(BlockNode2, "name", name$1q);
  return BlockNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1p = "ConditionalNode";
var dependencies$1p = ["Node"];
var createConditionalNode = /* @__PURE__ */ factory(name$1p, dependencies$1p, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  function testCondition(condition) {
    if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
      return !!condition;
    }
    if (condition) {
      if (isBigNumber(condition)) {
        return !condition.isZero();
      }
      if (isComplex(condition)) {
        return !!(condition.re || condition.im);
      }
      if (isUnit(condition)) {
        return !!condition.value;
      }
    }
    if (condition === null || condition === void 0) {
      return false;
    }
    throw new TypeError('Unsupported type of condition "' + typeOf$1(condition) + '"');
  }
  class ConditionalNode2 extends Node2 {
    constructor(condition, trueExpr, falseExpr) {
      super();
      if (!isNode(condition)) {
        throw new TypeError("Parameter condition must be a Node");
      }
      if (!isNode(trueExpr)) {
        throw new TypeError("Parameter trueExpr must be a Node");
      }
      if (!isNode(falseExpr)) {
        throw new TypeError("Parameter falseExpr must be a Node");
      }
      this.condition = condition;
      this.trueExpr = trueExpr;
      this.falseExpr = falseExpr;
    }
    get type() {
      return name$1p;
    }
    get isConditionalNode() {
      return true;
    }
    _compile(math2, argNames) {
      var evalCondition = this.condition._compile(math2, argNames);
      var evalTrueExpr = this.trueExpr._compile(math2, argNames);
      var evalFalseExpr = this.falseExpr._compile(math2, argNames);
      return function evalConditionalNode(scope, args, context) {
        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
      };
    }
    forEach(callback) {
      callback(this.condition, "condition", this);
      callback(this.trueExpr, "trueExpr", this);
      callback(this.falseExpr, "falseExpr", this);
    }
    map(callback) {
      return new ConditionalNode2(this._ifNode(callback(this.condition, "condition", this)), this._ifNode(callback(this.trueExpr, "trueExpr", this)), this._ifNode(callback(this.falseExpr, "falseExpr", this)));
    }
    clone() {
      return new ConditionalNode2(this.condition, this.trueExpr, this.falseExpr);
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var condition = this.condition.toString(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = "(" + condition + ")";
      }
      var trueExpr = this.trueExpr.toString(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = "(" + trueExpr + ")";
      }
      var falseExpr = this.falseExpr.toString(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = "(" + falseExpr + ")";
      }
      return condition + " ? " + trueExpr + " : " + falseExpr;
    }
    toJSON() {
      return {
        mathjs: name$1p,
        condition: this.condition,
        trueExpr: this.trueExpr,
        falseExpr: this.falseExpr
      };
    }
    static fromJSON(json) {
      return new ConditionalNode2(json.condition, json.trueExpr, json.falseExpr);
    }
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var condition = this.condition.toHTML(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var trueExpr = this.trueExpr.toHTML(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var falseExpr = this.falseExpr.toHTML(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
    }
    _toTex(options) {
      return "\\begin{cases} {" + this.trueExpr.toTex(options) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options) + "}\\\\{" + this.falseExpr.toTex(options) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
    }
  }
  _defineProperty(ConditionalNode2, "name", name$1p);
  return ConditionalNode2;
}, {
  isClass: true,
  isNode: true
});
var _extends = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var defaultEscapes = {
  "{": "\\{",
  "}": "\\}",
  "\\": "\\textbackslash{}",
  "#": "\\#",
  $: "\\$",
  "%": "\\%",
  "&": "\\&",
  "^": "\\textasciicircum{}",
  _: "\\_",
  "~": "\\textasciitilde{}"
};
var formatEscapes = {
  "\u2013": "\\--",
  "\u2014": "\\---",
  " ": "~",
  "	": "\\qquad{}",
  "\r\n": "\\newline{}",
  "\n": "\\newline{}"
};
var defaultEscapeMapFn = function defaultEscapeMapFn2(defaultEscapes2, formatEscapes2) {
  return _extends({}, defaultEscapes2, formatEscapes2);
};
var dist = function(str) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$preserveFormatti = _ref.preserveFormatting, preserveFormatting = _ref$preserveFormatti === void 0 ? false : _ref$preserveFormatti, _ref$escapeMapFn = _ref.escapeMapFn, escapeMapFn = _ref$escapeMapFn === void 0 ? defaultEscapeMapFn : _ref$escapeMapFn;
  var runningStr = String(str);
  var result = "";
  var escapes = escapeMapFn(_extends({}, defaultEscapes), preserveFormatting ? _extends({}, formatEscapes) : {});
  var escapeKeys = Object.keys(escapes);
  var _loop = function _loop2() {
    var specialCharFound = false;
    escapeKeys.forEach(function(key, index2) {
      if (specialCharFound) {
        return;
      }
      if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
        result += escapes[escapeKeys[index2]];
        runningStr = runningStr.slice(key.length, runningStr.length);
        specialCharFound = true;
      }
    });
    if (!specialCharFound) {
      result += runningStr.slice(0, 1);
      runningStr = runningStr.slice(1, runningStr.length);
    }
  };
  while (runningStr) {
    _loop();
  }
  return result;
};
var escapeLatexLib = dist;
var latexSymbols = {
  Alpha: "A",
  alpha: "\\alpha",
  Beta: "B",
  beta: "\\beta",
  Gamma: "\\Gamma",
  gamma: "\\gamma",
  Delta: "\\Delta",
  delta: "\\delta",
  Epsilon: "E",
  epsilon: "\\epsilon",
  varepsilon: "\\varepsilon",
  Zeta: "Z",
  zeta: "\\zeta",
  Eta: "H",
  eta: "\\eta",
  Theta: "\\Theta",
  theta: "\\theta",
  vartheta: "\\vartheta",
  Iota: "I",
  iota: "\\iota",
  Kappa: "K",
  kappa: "\\kappa",
  varkappa: "\\varkappa",
  Lambda: "\\Lambda",
  lambda: "\\lambda",
  Mu: "M",
  mu: "\\mu",
  Nu: "N",
  nu: "\\nu",
  Xi: "\\Xi",
  xi: "\\xi",
  Omicron: "O",
  omicron: "o",
  Pi: "\\Pi",
  pi: "\\pi",
  varpi: "\\varpi",
  Rho: "P",
  rho: "\\rho",
  varrho: "\\varrho",
  Sigma: "\\Sigma",
  sigma: "\\sigma",
  varsigma: "\\varsigma",
  Tau: "T",
  tau: "\\tau",
  Upsilon: "\\Upsilon",
  upsilon: "\\upsilon",
  Phi: "\\Phi",
  phi: "\\phi",
  varphi: "\\varphi",
  Chi: "X",
  chi: "\\chi",
  Psi: "\\Psi",
  psi: "\\psi",
  Omega: "\\Omega",
  omega: "\\omega",
  true: "\\mathrm{True}",
  false: "\\mathrm{False}",
  i: "i",
  inf: "\\infty",
  Inf: "\\infty",
  infinity: "\\infty",
  Infinity: "\\infty",
  oo: "\\infty",
  lim: "\\lim",
  undefined: "\\mathbf{?}"
};
var latexOperators = {
  transpose: "^\\top",
  ctranspose: "^H",
  factorial: "!",
  pow: "^",
  dotPow: ".^\\wedge",
  unaryPlus: "+",
  unaryMinus: "-",
  bitNot: "\\~",
  not: "\\neg",
  multiply: "\\cdot",
  divide: "\\frac",
  dotMultiply: ".\\cdot",
  dotDivide: ".:",
  mod: "\\mod",
  add: "+",
  subtract: "-",
  to: "\\rightarrow",
  leftShift: "<<",
  rightArithShift: ">>",
  rightLogShift: ">>>",
  equal: "=",
  unequal: "\\neq",
  smaller: "<",
  larger: ">",
  smallerEq: "\\leq",
  largerEq: "\\geq",
  bitAnd: "\\&",
  bitXor: "\\underline{|}",
  bitOr: "|",
  and: "\\wedge",
  xor: "\\veebar",
  or: "\\vee"
};
var latexFunctions = {
  abs: {
    1: "\\left|${args[0]}\\right|"
  },
  add: {
    2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
  },
  cbrt: {
    1: "\\sqrt[3]{${args[0]}}"
  },
  ceil: {
    1: "\\left\\lceil${args[0]}\\right\\rceil"
  },
  cube: {
    1: "\\left(${args[0]}\\right)^3"
  },
  divide: {
    2: "\\frac{${args[0]}}{${args[1]}}"
  },
  dotDivide: {
    2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
  },
  dotMultiply: {
    2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
  },
  dotPow: {
    2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
  },
  exp: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
  fix: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  floor: {
    1: "\\left\\lfloor${args[0]}\\right\\rfloor"
  },
  gcd: "\\gcd\\left(${args}\\right)",
  hypot: "\\hypot\\left(${args}\\right)",
  log: {
    1: "\\ln\\left(${args[0]}\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
  },
  log10: {
    1: "\\log_{10}\\left(${args[0]}\\right)"
  },
  log1p: {
    1: "\\ln\\left(${args[0]}+1\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
  },
  log2: "\\log_{2}\\left(${args[0]}\\right)",
  mod: {
    2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
  },
  multiply: {
    2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
  },
  norm: {
    1: "\\left\\|${args[0]}\\right\\|",
    2: void 0
  },
  nthRoot: {
    2: "\\sqrt[${args[1]}]{${args[0]}}"
  },
  nthRoots: {
    2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
  },
  pow: {
    2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
  },
  round: {
    1: "\\left\\lfloor${args[0]}\\right\\rceil",
    2: void 0
  },
  sign: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  sqrt: {
    1: "\\sqrt{${args[0]}}"
  },
  square: {
    1: "\\left(${args[0]}\\right)^2"
  },
  subtract: {
    2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
  },
  unaryMinus: {
    1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
  },
  unaryPlus: {
    1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
  },
  bitAnd: {
    2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
  },
  bitNot: {
    1: latexOperators.bitNot + "\\left(${args[0]}\\right)"
  },
  bitOr: {
    2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
  },
  bitXor: {
    2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
  },
  leftShift: {
    2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
  },
  rightArithShift: {
    2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
  },
  rightLogShift: {
    2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
  },
  bellNumbers: {
    1: "\\mathrm{B}_{${args[0]}}"
  },
  catalan: {
    1: "\\mathrm{C}_{${args[0]}}"
  },
  stirlingS2: {
    2: "\\mathrm{S}\\left(${args}\\right)"
  },
  arg: {
    1: "\\arg\\left(${args[0]}\\right)"
  },
  conj: {
    1: "\\left(${args[0]}\\right)^*"
  },
  im: {
    1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  re: {
    1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  and: {
    2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
  },
  not: {
    1: latexOperators.not + "\\left(${args[0]}\\right)"
  },
  or: {
    2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
  },
  xor: {
    2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
  },
  cross: {
    2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
  },
  ctranspose: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
  },
  det: {
    1: "\\det\\left(${args[0]}\\right)"
  },
  dot: {
    2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
  },
  expm: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  inv: {
    1: "\\left(${args[0]}\\right)^{-1}"
  },
  pinv: {
    1: "\\left(${args[0]}\\right)^{+}"
  },
  sqrtm: {
    1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
  },
  trace: {
    1: "\\mathrm{tr}\\left(${args[0]}\\right)"
  },
  transpose: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
  },
  combinations: {
    2: "\\binom{${args[0]}}{${args[1]}}"
  },
  combinationsWithRep: {
    2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
  },
  factorial: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
  },
  gamma: {
    1: "\\Gamma\\left(${args[0]}\\right)"
  },
  lgamma: {
    1: "\\ln\\Gamma\\left(${args[0]}\\right)"
  },
  equal: {
    2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
  },
  larger: {
    2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
  },
  largerEq: {
    2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
  },
  smaller: {
    2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
  },
  smallerEq: {
    2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
  },
  unequal: {
    2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
  },
  erf: {
    1: "erf\\left(${args[0]}\\right)"
  },
  max: "\\max\\left(${args}\\right)",
  min: "\\min\\left(${args}\\right)",
  variance: "\\mathrm{Var}\\left(${args}\\right)",
  acos: {
    1: "\\cos^{-1}\\left(${args[0]}\\right)"
  },
  acosh: {
    1: "\\cosh^{-1}\\left(${args[0]}\\right)"
  },
  acot: {
    1: "\\cot^{-1}\\left(${args[0]}\\right)"
  },
  acoth: {
    1: "\\coth^{-1}\\left(${args[0]}\\right)"
  },
  acsc: {
    1: "\\csc^{-1}\\left(${args[0]}\\right)"
  },
  acsch: {
    1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
  },
  asec: {
    1: "\\sec^{-1}\\left(${args[0]}\\right)"
  },
  asech: {
    1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
  },
  asin: {
    1: "\\sin^{-1}\\left(${args[0]}\\right)"
  },
  asinh: {
    1: "\\sinh^{-1}\\left(${args[0]}\\right)"
  },
  atan: {
    1: "\\tan^{-1}\\left(${args[0]}\\right)"
  },
  atan2: {
    2: "\\mathrm{atan2}\\left(${args}\\right)"
  },
  atanh: {
    1: "\\tanh^{-1}\\left(${args[0]}\\right)"
  },
  cos: {
    1: "\\cos\\left(${args[0]}\\right)"
  },
  cosh: {
    1: "\\cosh\\left(${args[0]}\\right)"
  },
  cot: {
    1: "\\cot\\left(${args[0]}\\right)"
  },
  coth: {
    1: "\\coth\\left(${args[0]}\\right)"
  },
  csc: {
    1: "\\csc\\left(${args[0]}\\right)"
  },
  csch: {
    1: "\\mathrm{csch}\\left(${args[0]}\\right)"
  },
  sec: {
    1: "\\sec\\left(${args[0]}\\right)"
  },
  sech: {
    1: "\\mathrm{sech}\\left(${args[0]}\\right)"
  },
  sin: {
    1: "\\sin\\left(${args[0]}\\right)"
  },
  sinh: {
    1: "\\sinh\\left(${args[0]}\\right)"
  },
  tan: {
    1: "\\tan\\left(${args[0]}\\right)"
  },
  tanh: {
    1: "\\tanh\\left(${args[0]}\\right)"
  },
  to: {
    2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
  },
  numeric: function numeric(node, options) {
    return node.args[0].toTex();
  },
  number: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  },
  string: {
    0: '\\mathtt{""}',
    1: "\\mathrm{string}\\left(${args[0]}\\right)"
  },
  bignumber: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  complex: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
  },
  matrix: {
    0: "\\begin{bmatrix}\\end{bmatrix}",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(${args[0]}\\right)"
  },
  sparse: {
    0: "\\begin{bsparse}\\end{bsparse}",
    1: "\\left(${args[0]}\\right)"
  },
  unit: {
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  }
};
var defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
var latexUnits = {
  deg: "^\\circ"
};
function escapeLatex(string2) {
  return escapeLatexLib(string2, {
    preserveFormatting: true
  });
}
function toSymbol(name2, isUnit2) {
  isUnit2 = typeof isUnit2 === "undefined" ? false : isUnit2;
  if (isUnit2) {
    if (hasOwnProperty$2(latexUnits, name2)) {
      return latexUnits[name2];
    }
    return "\\mathrm{" + escapeLatex(name2) + "}";
  }
  if (hasOwnProperty$2(latexSymbols, name2)) {
    return latexSymbols[name2];
  }
  return escapeLatex(name2);
}
var name$1o = "ConstantNode";
var dependencies$1o = ["Node"];
var createConstantNode = /* @__PURE__ */ factory(name$1o, dependencies$1o, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  class ConstantNode2 extends Node2 {
    constructor(value) {
      super();
      this.value = value;
    }
    get type() {
      return name$1o;
    }
    get isConstantNode() {
      return true;
    }
    _compile(math2, argNames) {
      var value = this.value;
      return function evalConstantNode() {
        return value;
      };
    }
    forEach(callback) {
    }
    map(callback) {
      return this.clone();
    }
    clone() {
      return new ConstantNode2(this.value);
    }
    _toString(options) {
      return format$1(this.value, options);
    }
    toHTML(options) {
      var value = this._toString(options);
      switch (typeOf$1(this.value)) {
        case "number":
        case "BigNumber":
        case "Fraction":
          return '<span class="math-number">' + value + "</span>";
        case "string":
          return '<span class="math-string">' + value + "</span>";
        case "boolean":
          return '<span class="math-boolean">' + value + "</span>";
        case "null":
          return '<span class="math-null-symbol">' + value + "</span>";
        case "undefined":
          return '<span class="math-undefined">' + value + "</span>";
        default:
          return '<span class="math-symbol">' + value + "</span>";
      }
    }
    toJSON() {
      return {
        mathjs: name$1o,
        value: this.value
      };
    }
    static fromJSON(json) {
      return new ConstantNode2(json.value);
    }
    _toTex(options) {
      var value = this._toString(options);
      switch (typeOf$1(this.value)) {
        case "string":
          return "\\mathtt{" + escapeLatex(value) + "}";
        case "number":
        case "BigNumber":
          {
            if (!isFinite(this.value)) {
              return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
            }
            var index2 = value.toLowerCase().indexOf("e");
            if (index2 !== -1) {
              return value.substring(0, index2) + "\\cdot10^{" + value.substring(index2 + 1) + "}";
            }
          }
          return value;
        case "Fraction":
          return this.value.toLatex();
        default:
          return value;
      }
    }
  }
  _defineProperty(ConstantNode2, "name", name$1o);
  return ConstantNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1n = "FunctionAssignmentNode";
var dependencies$1n = ["typed", "Node"];
var createFunctionAssignmentNode = /* @__PURE__ */ factory(name$1n, dependencies$1n, (_ref) => {
  var {
    typed: typed2,
    Node: Node2
  } = _ref;
  function needParenthesis(node, parenthesis, implicit) {
    var precedence = getPrecedence(node, parenthesis, implicit);
    var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);
    return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
  }
  class FunctionAssignmentNode2 extends Node2 {
    constructor(name2, params, expr) {
      super();
      if (typeof name2 !== "string") {
        throw new TypeError('String expected for parameter "name"');
      }
      if (!Array.isArray(params)) {
        throw new TypeError('Array containing strings or objects expected for parameter "params"');
      }
      if (!isNode(expr)) {
        throw new TypeError('Node expected for parameter "expr"');
      }
      if (keywords.has(name2)) {
        throw new Error('Illegal function name, "' + name2 + '" is a reserved keyword');
      }
      this.name = name2;
      this.params = params.map(function(param) {
        return param && param.name || param;
      });
      this.types = params.map(function(param) {
        return param && param.type || "any";
      });
      this.expr = expr;
    }
    get type() {
      return name$1n;
    }
    get isFunctionAssignmentNode() {
      return true;
    }
    _compile(math2, argNames) {
      var childArgNames = Object.create(argNames);
      forEach$1(this.params, function(param) {
        childArgNames[param] = true;
      });
      var evalExpr = this.expr._compile(math2, childArgNames);
      var name2 = this.name;
      var params = this.params;
      var signature = join(this.types, ",");
      var syntax = name2 + "(" + join(this.params, ", ") + ")";
      return function evalFunctionAssignmentNode(scope, args, context) {
        var signatures = {};
        signatures[signature] = function() {
          var childArgs = Object.create(args);
          for (var i2 = 0; i2 < params.length; i2++) {
            childArgs[params[i2]] = arguments[i2];
          }
          return evalExpr(scope, childArgs, context);
        };
        var fn = typed2(name2, signatures);
        fn.syntax = syntax;
        scope.set(name2, fn);
        return fn;
      };
    }
    forEach(callback) {
      callback(this.expr, "expr", this);
    }
    map(callback) {
      var expr = this._ifNode(callback(this.expr, "expr", this));
      return new FunctionAssignmentNode2(this.name, this.params.slice(0), expr);
    }
    clone() {
      return new FunctionAssignmentNode2(this.name, this.params.slice(0), this.expr);
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var expr = this.expr.toString(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = "(" + expr + ")";
      }
      return this.name + "(" + this.params.join(", ") + ") = " + expr;
    }
    toJSON() {
      var types = this.types;
      return {
        mathjs: name$1n,
        name: this.name,
        params: this.params.map(function(param, index2) {
          return {
            name: param,
            type: types[index2]
          };
        }),
        expr: this.expr
      };
    }
    static fromJSON(json) {
      return new FunctionAssignmentNode2(json.name, json.params, json.expr);
    }
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var params = [];
      for (var i2 = 0; i2 < this.params.length; i2++) {
        params.push('<span class="math-symbol math-parameter">' + escape(this.params[i2]) + "</span>");
      }
      var expr = this.expr.toHTML(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return '<span class="math-function">' + escape(this.name) + '</span><span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + expr;
    }
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var expr = this.expr.toTex(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = "\\left(".concat(expr, "\\right)");
      }
      return "\\mathrm{" + this.name + "}\\left(" + this.params.map(toSymbol).join(",") + "\\right):=" + expr;
    }
  }
  _defineProperty(FunctionAssignmentNode2, "name", name$1n);
  return FunctionAssignmentNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1m = "IndexNode";
var dependencies$1m = ["Node", "size"];
var createIndexNode = /* @__PURE__ */ factory(name$1m, dependencies$1m, (_ref) => {
  var {
    Node: Node2,
    size: size2
  } = _ref;
  class IndexNode2 extends Node2 {
    constructor(dimensions, dotNotation) {
      super();
      this.dimensions = dimensions;
      this.dotNotation = dotNotation || false;
      if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
      }
      if (this.dotNotation && !this.isObjectProperty()) {
        throw new Error("dotNotation only applicable for object properties");
      }
    }
    get type() {
      return name$1m;
    }
    get isIndexNode() {
      return true;
    }
    _compile(math2, argNames) {
      var evalDimensions = map$1(this.dimensions, function(dimension, i2) {
        var needsEnd = dimension.filter((node) => node.isSymbolNode && node.name === "end").length > 0;
        if (needsEnd) {
          var childArgNames = Object.create(argNames);
          childArgNames.end = true;
          var _evalDimension = dimension._compile(math2, childArgNames);
          return function evalDimension(scope, args, context) {
            if (!isMatrix(context) && !isArray$1(context) && !isString(context)) {
              throw new TypeError('Cannot resolve "end": context must be a Matrix, Array, or string but is ' + typeOf$1(context));
            }
            var s = size2(context).valueOf();
            var childArgs = Object.create(args);
            childArgs.end = s[i2];
            return _evalDimension(scope, childArgs, context);
          };
        } else {
          return dimension._compile(math2, argNames);
        }
      });
      var index2 = getSafeProperty(math2, "index");
      return function evalIndexNode(scope, args, context) {
        var dimensions = map$1(evalDimensions, function(evalDimension) {
          return evalDimension(scope, args, context);
        });
        return index2(...dimensions);
      };
    }
    forEach(callback) {
      for (var i2 = 0; i2 < this.dimensions.length; i2++) {
        callback(this.dimensions[i2], "dimensions[" + i2 + "]", this);
      }
    }
    map(callback) {
      var dimensions = [];
      for (var i2 = 0; i2 < this.dimensions.length; i2++) {
        dimensions[i2] = this._ifNode(callback(this.dimensions[i2], "dimensions[" + i2 + "]", this));
      }
      return new IndexNode2(dimensions, this.dotNotation);
    }
    clone() {
      return new IndexNode2(this.dimensions.slice(0), this.dotNotation);
    }
    isObjectProperty() {
      return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
    }
    getObjectProperty() {
      return this.isObjectProperty() ? this.dimensions[0].value : null;
    }
    _toString(options) {
      return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
    }
    toJSON() {
      return {
        mathjs: name$1m,
        dimensions: this.dimensions,
        dotNotation: this.dotNotation
      };
    }
    static fromJSON(json) {
      return new IndexNode2(json.dimensions, json.dotNotation);
    }
    toHTML(options) {
      var dimensions = [];
      for (var i2 = 0; i2 < this.dimensions.length; i2++) {
        dimensions[i2] = this.dimensions[i2].toHTML();
      }
      if (this.dotNotation) {
        return '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' + escape(this.getObjectProperty()) + "</span>";
      } else {
        return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
      }
    }
    _toTex(options) {
      var dimensions = this.dimensions.map(function(range2) {
        return range2.toTex(options);
      });
      return this.dotNotation ? "." + this.getObjectProperty() : "_{" + dimensions.join(",") + "}";
    }
  }
  _defineProperty(IndexNode2, "name", name$1m);
  return IndexNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1l = "ObjectNode";
var dependencies$1l = ["Node"];
var createObjectNode = /* @__PURE__ */ factory(name$1l, dependencies$1l, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  class ObjectNode2 extends Node2 {
    constructor(properties2) {
      super();
      this.properties = properties2 || {};
      if (properties2) {
        if (!(typeof properties2 === "object") || !Object.keys(properties2).every(function(key) {
          return isNode(properties2[key]);
        })) {
          throw new TypeError("Object containing Nodes expected");
        }
      }
    }
    get type() {
      return name$1l;
    }
    get isObjectNode() {
      return true;
    }
    _compile(math2, argNames) {
      var evalEntries = {};
      for (var key in this.properties) {
        if (hasOwnProperty$2(this.properties, key)) {
          var stringifiedKey = stringify(key);
          var parsedKey = JSON.parse(stringifiedKey);
          if (!isSafeProperty(this.properties, parsedKey)) {
            throw new Error('No access to property "' + parsedKey + '"');
          }
          evalEntries[parsedKey] = this.properties[key]._compile(math2, argNames);
        }
      }
      return function evalObjectNode(scope, args, context) {
        var obj = {};
        for (var _key in evalEntries) {
          if (hasOwnProperty$2(evalEntries, _key)) {
            obj[_key] = evalEntries[_key](scope, args, context);
          }
        }
        return obj;
      };
    }
    forEach(callback) {
      for (var key in this.properties) {
        if (hasOwnProperty$2(this.properties, key)) {
          callback(this.properties[key], "properties[" + stringify(key) + "]", this);
        }
      }
    }
    map(callback) {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty$2(this.properties, key)) {
          properties2[key] = this._ifNode(callback(this.properties[key], "properties[" + stringify(key) + "]", this));
        }
      }
      return new ObjectNode2(properties2);
    }
    clone() {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty$2(this.properties, key)) {
          properties2[key] = this.properties[key];
        }
      }
      return new ObjectNode2(properties2);
    }
    _toString(options) {
      var entries3 = [];
      for (var key in this.properties) {
        if (hasOwnProperty$2(this.properties, key)) {
          entries3.push(stringify(key) + ": " + this.properties[key].toString(options));
        }
      }
      return "{" + entries3.join(", ") + "}";
    }
    toJSON() {
      return {
        mathjs: name$1l,
        properties: this.properties
      };
    }
    static fromJSON(json) {
      return new ObjectNode2(json.properties);
    }
    toHTML(options) {
      var entries3 = [];
      for (var key in this.properties) {
        if (hasOwnProperty$2(this.properties, key)) {
          entries3.push('<span class="math-symbol math-property">' + escape(key) + '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[key].toHTML(options));
        }
      }
      return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries3.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
    }
    _toTex(options) {
      var entries3 = [];
      for (var key in this.properties) {
        if (hasOwnProperty$2(this.properties, key)) {
          entries3.push("\\mathbf{" + key + ":} & " + this.properties[key].toTex(options) + "\\\\");
        }
      }
      var tex = "\\left\\{\\begin{array}{ll}" + entries3.join("\n") + "\\end{array}\\right\\}";
      return tex;
    }
  }
  _defineProperty(ObjectNode2, "name", name$1l);
  return ObjectNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1k = "OperatorNode";
var dependencies$1k = ["Node"];
var createOperatorNode = /* @__PURE__ */ factory(name$1k, dependencies$1k, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  function startsWithConstant(expr, parenthesis) {
    var curNode = expr;
    if (parenthesis === "auto") {
      while (isParenthesisNode(curNode)) {
        curNode = curNode.content;
      }
    }
    if (isConstantNode(curNode))
      return true;
    if (isOperatorNode(curNode)) {
      return startsWithConstant(curNode.args[0], parenthesis);
    }
    return false;
  }
  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {
    var precedence = getPrecedence(root, parenthesis, implicit);
    var associativity = getAssociativity(root, parenthesis);
    if (parenthesis === "all" || args.length > 2 && root.getIdentifier() !== "OperatorNode:add" && root.getIdentifier() !== "OperatorNode:multiply") {
      return args.map(function(arg2) {
        switch (arg2.getContent().type) {
          case "ArrayNode":
          case "ConstantNode":
          case "SymbolNode":
          case "ParenthesisNode":
            return false;
          default:
            return true;
        }
      });
    }
    var result;
    switch (args.length) {
      case 0:
        result = [];
        break;
      case 1:
        {
          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
          if (latex && operandPrecedence !== null) {
            var operandIdentifier;
            var rootIdentifier;
            if (parenthesis === "keep") {
              operandIdentifier = args[0].getIdentifier();
              rootIdentifier = root.getIdentifier();
            } else {
              operandIdentifier = args[0].getContent().getIdentifier();
              rootIdentifier = root.getContent().getIdentifier();
            }
            if (properties[precedence][rootIdentifier].latexLeftParens === false) {
              result = [false];
              break;
            }
            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
              result = [false];
              break;
            }
          }
          if (operandPrecedence === null) {
            result = [false];
            break;
          }
          if (operandPrecedence <= precedence) {
            result = [true];
            break;
          }
          result = [false];
        }
        break;
      case 2:
        {
          var lhsParens;
          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);
          if (lhsPrecedence === null) {
            lhsParens = false;
          } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
            lhsParens = true;
          } else if (lhsPrecedence < precedence) {
            lhsParens = true;
          } else {
            lhsParens = false;
          }
          var rhsParens;
          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root);
          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);
          if (rhsPrecedence === null) {
            rhsParens = false;
          } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
            rhsParens = true;
          } else if (rhsPrecedence < precedence) {
            rhsParens = true;
          } else {
            rhsParens = false;
          }
          if (latex) {
            var _rootIdentifier;
            var lhsIdentifier;
            var rhsIdentifier;
            if (parenthesis === "keep") {
              _rootIdentifier = root.getIdentifier();
              lhsIdentifier = root.args[0].getIdentifier();
              rhsIdentifier = root.args[1].getIdentifier();
            } else {
              _rootIdentifier = root.getContent().getIdentifier();
              lhsIdentifier = root.args[0].getContent().getIdentifier();
              rhsIdentifier = root.args[1].getContent().getIdentifier();
            }
            if (lhsPrecedence !== null) {
              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {
                lhsParens = false;
              }
              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                lhsParens = false;
              }
            }
            if (rhsPrecedence !== null) {
              if (properties[precedence][_rootIdentifier].latexRightParens === false) {
                rhsParens = false;
              }
              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                rhsParens = false;
              }
            }
          }
          result = [lhsParens, rhsParens];
        }
        break;
      default:
        if (root.getIdentifier() === "OperatorNode:add" || root.getIdentifier() === "OperatorNode:multiply") {
          result = args.map(function(arg2) {
            var argPrecedence = getPrecedence(arg2, parenthesis, implicit, root);
            var assocWithArg = isAssociativeWith(root, arg2, parenthesis);
            var argAssociativity = getAssociativity(arg2, parenthesis);
            if (argPrecedence === null) {
              return false;
            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
              return true;
            } else if (argPrecedence < precedence) {
              return true;
            }
            return false;
          });
        }
        break;
    }
    if (args.length >= 2 && root.getIdentifier() === "OperatorNode:multiply" && root.implicit && parenthesis !== "all" && implicit === "hide") {
      for (var i2 = 1; i2 < result.length; ++i2) {
        if (startsWithConstant(args[i2], parenthesis) && !result[i2 - 1] && (parenthesis !== "keep" || !isParenthesisNode(args[i2 - 1]))) {
          result[i2] = true;
        }
      }
    }
    return result;
  }
  class OperatorNode2 extends Node2 {
    constructor(op2, fn, args, implicit, isPercentage) {
      super();
      if (typeof op2 !== "string") {
        throw new TypeError('string expected for parameter "op"');
      }
      if (typeof fn !== "string") {
        throw new TypeError('string expected for parameter "fn"');
      }
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.implicit = implicit === true;
      this.isPercentage = isPercentage === true;
      this.op = op2;
      this.fn = fn;
      this.args = args || [];
    }
    get type() {
      return name$1k;
    }
    get isOperatorNode() {
      return true;
    }
    _compile(math2, argNames) {
      if (typeof this.fn !== "string" || !isSafeMethod(math2, this.fn)) {
        if (!math2[this.fn]) {
          throw new Error("Function " + this.fn + ' missing in provided namespace "math"');
        } else {
          throw new Error('No access to function "' + this.fn + '"');
        }
      }
      var fn = getSafeProperty(math2, this.fn);
      var evalArgs = map$1(this.args, function(arg2) {
        return arg2._compile(math2, argNames);
      });
      if (evalArgs.length === 1) {
        var evalArg0 = evalArgs[0];
        return function evalOperatorNode(scope, args, context) {
          return fn(evalArg0(scope, args, context));
        };
      } else if (evalArgs.length === 2) {
        var _evalArg = evalArgs[0];
        var evalArg1 = evalArgs[1];
        return function evalOperatorNode(scope, args, context) {
          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));
        };
      } else {
        return function evalOperatorNode(scope, args, context) {
          return fn.apply(null, map$1(evalArgs, function(evalArg) {
            return evalArg(scope, args, context);
          }));
        };
      }
    }
    forEach(callback) {
      for (var i2 = 0; i2 < this.args.length; i2++) {
        callback(this.args[i2], "args[" + i2 + "]", this);
      }
    }
    map(callback) {
      var args = [];
      for (var i2 = 0; i2 < this.args.length; i2++) {
        args[i2] = this._ifNode(callback(this.args[i2], "args[" + i2 + "]", this));
      }
      return new OperatorNode2(this.op, this.fn, args, this.implicit, this.isPercentage);
    }
    clone() {
      return new OperatorNode2(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
    }
    isUnary() {
      return this.args.length === 1;
    }
    isBinary() {
      return this.args.length === 2;
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toString(options);
        if (parens[0]) {
          operand = "(" + operand + ")";
        }
        var opIsNamed = /[a-zA-Z]+/.test(this.op);
        if (assoc === "right") {
          return this.op + (opIsNamed ? " " : "") + operand;
        } else if (assoc === "left") {
          return operand + (opIsNamed ? " " : "") + this.op;
        }
        return operand + this.op;
      } else if (args.length === 2) {
        var lhs = args[0].toString(options);
        var rhs = args[1].toString(options);
        if (parens[0]) {
          lhs = "(" + lhs + ")";
        }
        if (parens[1]) {
          rhs = "(" + rhs + ")";
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return lhs + " " + rhs;
        }
        return lhs + " " + this.op + " " + rhs;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var stringifiedArgs = args.map(function(arg2, index2) {
          arg2 = arg2.toString(options);
          if (parens[index2]) {
            arg2 = "(" + arg2 + ")";
          }
          return arg2;
        });
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return stringifiedArgs.join(" ");
        }
        return stringifiedArgs.join(" " + this.op + " ");
      } else {
        return this.fn + "(" + this.args.join(", ") + ")";
      }
    }
    toJSON() {
      return {
        mathjs: name$1k,
        op: this.op,
        fn: this.fn,
        args: this.args,
        implicit: this.implicit,
        isPercentage: this.isPercentage
      };
    }
    static fromJSON(json) {
      return new OperatorNode2(json.op, json.fn, json.args, json.implicit, json.isPercentage);
    }
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toHTML(options);
        if (parens[0]) {
          operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (assoc === "right") {
          return '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + escape(this.op) + "</span>" + operand;
        } else {
          return operand + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + escape(this.op) + "</span>";
        }
      } else if (args.length === 2) {
        var lhs = args[0].toHTML(options);
        var rhs = args[1].toHTML(options);
        if (parens[0]) {
          lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (parens[1]) {
          rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return lhs + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + rhs;
        }
        return lhs + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>" + rhs;
      } else {
        var stringifiedArgs = args.map(function(arg2, index2) {
          arg2 = arg2.toHTML(options);
          if (parens[index2]) {
            arg2 = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg2 + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          return arg2;
        });
        if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return stringifiedArgs.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>');
          }
          return stringifiedArgs.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>");
        } else {
          return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
        }
      }
    }
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
      var op2 = latexOperators[this.fn];
      op2 = typeof op2 === "undefined" ? this.op : op2;
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toTex(options);
        if (parens[0]) {
          operand = "\\left(".concat(operand, "\\right)");
        }
        if (assoc === "right") {
          return op2 + operand;
        } else if (assoc === "left") {
          return operand + op2;
        }
        return operand + op2;
      } else if (args.length === 2) {
        var lhs = args[0];
        var lhsTex = lhs.toTex(options);
        if (parens[0]) {
          lhsTex = "\\left(".concat(lhsTex, "\\right)");
        }
        var rhs = args[1];
        var rhsTex = rhs.toTex(options);
        if (parens[1]) {
          rhsTex = "\\left(".concat(rhsTex, "\\right)");
        }
        var lhsIdentifier;
        if (parenthesis === "keep") {
          lhsIdentifier = lhs.getIdentifier();
        } else {
          lhsIdentifier = lhs.getContent().getIdentifier();
        }
        switch (this.getIdentifier()) {
          case "OperatorNode:divide":
            return op2 + "{" + lhsTex + "}{" + rhsTex + "}";
          case "OperatorNode:pow":
            lhsTex = "{" + lhsTex + "}";
            rhsTex = "{" + rhsTex + "}";
            switch (lhsIdentifier) {
              case "ConditionalNode":
              case "OperatorNode:divide":
                lhsTex = "\\left(".concat(lhsTex, "\\right)");
            }
            break;
          case "OperatorNode:multiply":
            if (this.implicit && implicit === "hide") {
              return lhsTex + "~" + rhsTex;
            }
        }
        return lhsTex + op2 + rhsTex;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var texifiedArgs = args.map(function(arg2, index2) {
          arg2 = arg2.toTex(options);
          if (parens[index2]) {
            arg2 = "\\left(".concat(arg2, "\\right)");
          }
          return arg2;
        });
        if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit && implicit === "hide") {
          return texifiedArgs.join("~");
        }
        return texifiedArgs.join(op2);
      } else {
        return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg2) {
          return arg2.toTex(options);
        }).join(",") + "\\right)";
      }
    }
    getIdentifier() {
      return this.type + ":" + this.fn;
    }
  }
  _defineProperty(OperatorNode2, "name", name$1k);
  return OperatorNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1j = "ParenthesisNode";
var dependencies$1j = ["Node"];
var createParenthesisNode = /* @__PURE__ */ factory(name$1j, dependencies$1j, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  class ParenthesisNode2 extends Node2 {
    constructor(content) {
      super();
      if (!isNode(content)) {
        throw new TypeError('Node expected for parameter "content"');
      }
      this.content = content;
    }
    get type() {
      return name$1j;
    }
    get isParenthesisNode() {
      return true;
    }
    _compile(math2, argNames) {
      return this.content._compile(math2, argNames);
    }
    getContent() {
      return this.content.getContent();
    }
    forEach(callback) {
      callback(this.content, "content", this);
    }
    map(callback) {
      var content = callback(this.content, "content", this);
      return new ParenthesisNode2(content);
    }
    clone() {
      return new ParenthesisNode2(this.content);
    }
    _toString(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return "(" + this.content.toString(options) + ")";
      }
      return this.content.toString(options);
    }
    toJSON() {
      return {
        mathjs: name$1j,
        content: this.content
      };
    }
    static fromJSON(json) {
      return new ParenthesisNode2(json.content);
    }
    toHTML(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return this.content.toHTML(options);
    }
    _toTex(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return "\\left(".concat(this.content.toTex(options), "\\right)");
      }
      return this.content.toTex(options);
    }
  }
  _defineProperty(ParenthesisNode2, "name", name$1j);
  return ParenthesisNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1i = "RangeNode";
var dependencies$1i = ["Node"];
var createRangeNode = /* @__PURE__ */ factory(name$1i, dependencies$1i, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  function calculateNecessaryParentheses(node, parenthesis, implicit) {
    var precedence = getPrecedence(node, parenthesis, implicit);
    var parens = {};
    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);
    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
    if (node.step) {
      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);
      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
    }
    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);
    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
    return parens;
  }
  class RangeNode2 extends Node2 {
    constructor(start2, end, step) {
      super();
      if (!isNode(start2))
        throw new TypeError("Node expected");
      if (!isNode(end))
        throw new TypeError("Node expected");
      if (step && !isNode(step))
        throw new TypeError("Node expected");
      if (arguments.length > 3)
        throw new Error("Too many arguments");
      this.start = start2;
      this.end = end;
      this.step = step || null;
    }
    get type() {
      return name$1i;
    }
    get isRangeNode() {
      return true;
    }
    needsEnd() {
      var endSymbols = this.filter(function(node) {
        return isSymbolNode(node) && node.name === "end";
      });
      return endSymbols.length > 0;
    }
    _compile(math2, argNames) {
      var range2 = math2.range;
      var evalStart = this.start._compile(math2, argNames);
      var evalEnd = this.end._compile(math2, argNames);
      if (this.step) {
        var evalStep = this.step._compile(math2, argNames);
        return function evalRangeNode(scope, args, context) {
          return range2(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
        };
      } else {
        return function evalRangeNode(scope, args, context) {
          return range2(evalStart(scope, args, context), evalEnd(scope, args, context));
        };
      }
    }
    forEach(callback) {
      callback(this.start, "start", this);
      callback(this.end, "end", this);
      if (this.step) {
        callback(this.step, "step", this);
      }
    }
    map(callback) {
      return new RangeNode2(this._ifNode(callback(this.start, "start", this)), this._ifNode(callback(this.end, "end", this)), this.step && this._ifNode(callback(this.step, "step", this)));
    }
    clone() {
      return new RangeNode2(this.start, this.end, this.step && this.step);
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str;
      var start2 = this.start.toString(options);
      if (parens.start) {
        start2 = "(" + start2 + ")";
      }
      str = start2;
      if (this.step) {
        var step = this.step.toString(options);
        if (parens.step) {
          step = "(" + step + ")";
        }
        str += ":" + step;
      }
      var end = this.end.toString(options);
      if (parens.end) {
        end = "(" + end + ")";
      }
      str += ":" + end;
      return str;
    }
    toJSON() {
      return {
        mathjs: name$1i,
        start: this.start,
        end: this.end,
        step: this.step
      };
    }
    static fromJSON(json) {
      return new RangeNode2(json.start, json.end, json.step);
    }
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str;
      var start2 = this.start.toHTML(options);
      if (parens.start) {
        start2 = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start2 + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str = start2;
      if (this.step) {
        var step = this.step.toHTML(options);
        if (parens.step) {
          step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str += '<span class="math-operator math-range-operator">:</span>' + step;
      }
      var end = this.end.toHTML(options);
      if (parens.end) {
        end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str += '<span class="math-operator math-range-operator">:</span>' + end;
      return str;
    }
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str = this.start.toTex(options);
      if (parens.start) {
        str = "\\left(".concat(str, "\\right)");
      }
      if (this.step) {
        var step = this.step.toTex(options);
        if (parens.step) {
          step = "\\left(".concat(step, "\\right)");
        }
        str += ":" + step;
      }
      var end = this.end.toTex(options);
      if (parens.end) {
        end = "\\left(".concat(end, "\\right)");
      }
      str += ":" + end;
      return str;
    }
  }
  _defineProperty(RangeNode2, "name", name$1i);
  return RangeNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1h = "RelationalNode";
var dependencies$1h = ["Node"];
var createRelationalNode = /* @__PURE__ */ factory(name$1h, dependencies$1h, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  var operatorMap = {
    equal: "==",
    unequal: "!=",
    smaller: "<",
    larger: ">",
    smallerEq: "<=",
    largerEq: ">="
  };
  class RelationalNode2 extends Node2 {
    constructor(conditionals, params) {
      super();
      if (!Array.isArray(conditionals)) {
        throw new TypeError("Parameter conditionals must be an array");
      }
      if (!Array.isArray(params)) {
        throw new TypeError("Parameter params must be an array");
      }
      if (conditionals.length !== params.length - 1) {
        throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");
      }
      this.conditionals = conditionals;
      this.params = params;
    }
    get type() {
      return name$1h;
    }
    get isRelationalNode() {
      return true;
    }
    _compile(math2, argNames) {
      var self2 = this;
      var compiled = this.params.map((p2) => p2._compile(math2, argNames));
      return function evalRelationalNode(scope, args, context) {
        var evalLhs;
        var evalRhs = compiled[0](scope, args, context);
        for (var i2 = 0; i2 < self2.conditionals.length; i2++) {
          evalLhs = evalRhs;
          evalRhs = compiled[i2 + 1](scope, args, context);
          var condFn = getSafeProperty(math2, self2.conditionals[i2]);
          if (!condFn(evalLhs, evalRhs)) {
            return false;
          }
        }
        return true;
      };
    }
    forEach(callback) {
      this.params.forEach((n, i2) => callback(n, "params[" + i2 + "]", this), this);
    }
    map(callback) {
      return new RelationalNode2(this.conditionals.slice(), this.params.map((n, i2) => this._ifNode(callback(n, "params[" + i2 + "]", this)), this));
    }
    clone() {
      return new RelationalNode2(this.conditionals, this.params);
    }
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p2, index2) {
        var paramPrecedence = getPrecedence(p2, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p2.toString(options) + ")" : p2.toString(options);
      });
      var ret = paramStrings[0];
      for (var i2 = 0; i2 < this.conditionals.length; i2++) {
        ret += " " + operatorMap[this.conditionals[i2]];
        ret += " " + paramStrings[i2 + 1];
      }
      return ret;
    }
    toJSON() {
      return {
        mathjs: name$1h,
        conditionals: this.conditionals,
        params: this.params
      };
    }
    static fromJSON(json) {
      return new RelationalNode2(json.conditionals, json.params);
    }
    toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p2, index2) {
        var paramPrecedence = getPrecedence(p2, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p2.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p2.toHTML(options);
      });
      var ret = paramStrings[0];
      for (var i2 = 0; i2 < this.conditionals.length; i2++) {
        ret += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i2]]) + "</span>" + paramStrings[i2 + 1];
      }
      return ret;
    }
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p2, index2) {
        var paramPrecedence = getPrecedence(p2, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p2.toTex(options) + "\right)" : p2.toTex(options);
      });
      var ret = paramStrings[0];
      for (var i2 = 0; i2 < this.conditionals.length; i2++) {
        ret += latexOperators[this.conditionals[i2]] + paramStrings[i2 + 1];
      }
      return ret;
    }
  }
  _defineProperty(RelationalNode2, "name", name$1h);
  return RelationalNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1g = "SymbolNode";
var dependencies$1g = ["math", "?Unit", "Node"];
var createSymbolNode = /* @__PURE__ */ factory(name$1g, dependencies$1g, (_ref) => {
  var {
    math: math2,
    Unit: Unit2,
    Node: Node2
  } = _ref;
  function isValuelessUnit(name2) {
    return Unit2 ? Unit2.isValuelessUnit(name2) : false;
  }
  class SymbolNode2 extends Node2 {
    constructor(name2) {
      super();
      if (typeof name2 !== "string") {
        throw new TypeError('String expected for parameter "name"');
      }
      this.name = name2;
    }
    get type() {
      return "SymbolNode";
    }
    get isSymbolNode() {
      return true;
    }
    _compile(math3, argNames) {
      var name2 = this.name;
      if (argNames[name2] === true) {
        return function(scope, args, context) {
          return args[name2];
        };
      } else if (name2 in math3) {
        return function(scope, args, context) {
          return scope.has(name2) ? scope.get(name2) : getSafeProperty(math3, name2);
        };
      } else {
        var isUnit2 = isValuelessUnit(name2);
        return function(scope, args, context) {
          return scope.has(name2) ? scope.get(name2) : isUnit2 ? new Unit2(null, name2) : SymbolNode2.onUndefinedSymbol(name2);
        };
      }
    }
    forEach(callback) {
    }
    map(callback) {
      return this.clone();
    }
    static onUndefinedSymbol(name2) {
      throw new Error("Undefined symbol " + name2);
    }
    clone() {
      return new SymbolNode2(this.name);
    }
    _toString(options) {
      return this.name;
    }
    toHTML(options) {
      var name2 = escape(this.name);
      if (name2 === "true" || name2 === "false") {
        return '<span class="math-symbol math-boolean">' + name2 + "</span>";
      } else if (name2 === "i") {
        return '<span class="math-symbol math-imaginary-symbol">' + name2 + "</span>";
      } else if (name2 === "Infinity") {
        return '<span class="math-symbol math-infinity-symbol">' + name2 + "</span>";
      } else if (name2 === "NaN") {
        return '<span class="math-symbol math-nan-symbol">' + name2 + "</span>";
      } else if (name2 === "null") {
        return '<span class="math-symbol math-null-symbol">' + name2 + "</span>";
      } else if (name2 === "undefined") {
        return '<span class="math-symbol math-undefined-symbol">' + name2 + "</span>";
      }
      return '<span class="math-symbol">' + name2 + "</span>";
    }
    toJSON() {
      return {
        mathjs: "SymbolNode",
        name: this.name
      };
    }
    static fromJSON(json) {
      return new SymbolNode2(json.name);
    }
    _toTex(options) {
      var isUnit2 = false;
      if (typeof math2[this.name] === "undefined" && isValuelessUnit(this.name)) {
        isUnit2 = true;
      }
      var symbol = toSymbol(this.name, isUnit2);
      if (symbol[0] === "\\") {
        return symbol;
      }
      return " " + symbol;
    }
  }
  return SymbolNode2;
}, {
  isClass: true,
  isNode: true
});
function createSubScope(parentScope) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  if (typeof parentScope.createSubScope === "function") {
    return assign$1(parentScope.createSubScope(), ...args);
  }
  return assign$1(createEmptyMap(), parentScope, ...args);
}
var name$1f = "FunctionNode";
var dependencies$1f = ["math", "Node", "SymbolNode"];
var createFunctionNode = /* @__PURE__ */ factory(name$1f, dependencies$1f, (_ref) => {
  var {
    math: math2,
    Node: Node2,
    SymbolNode: SymbolNode2
  } = _ref;
  var strin = (entity) => format$1(entity, {
    truncate: 78
  });
  function expandTemplate(template, node, options) {
    var latex = "";
    var regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
    var inputPos = 0;
    var match;
    while ((match = regex.exec(template)) !== null) {
      latex += template.substring(inputPos, match.index);
      inputPos = match.index;
      if (match[0] === "$$") {
        latex += "$";
        inputPos++;
      } else {
        inputPos += match[0].length;
        var property = node[match[1]];
        if (!property) {
          throw new ReferenceError("Template: Property " + match[1] + " does not exist.");
        }
        if (match[2] === void 0) {
          switch (typeof property) {
            case "string":
              latex += property;
              break;
            case "object":
              if (isNode(property)) {
                latex += property.toTex(options);
              } else if (Array.isArray(property)) {
                latex += property.map(function(arg2, index2) {
                  if (isNode(arg2)) {
                    return arg2.toTex(options);
                  }
                  throw new TypeError("Template: " + match[1] + "[" + index2 + "] is not a Node.");
                }).join(",");
              } else {
                throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
              }
              break;
            default:
              throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
          }
        } else {
          if (isNode(property[match[2]] && property[match[2]])) {
            latex += property[match[2]].toTex(options);
          } else {
            throw new TypeError("Template: " + match[1] + "[" + match[2] + "] is not a Node.");
          }
        }
      }
    }
    latex += template.slice(inputPos);
    return latex;
  }
  class FunctionNode2 extends Node2 {
    constructor(fn, args) {
      super();
      if (typeof fn === "string") {
        fn = new SymbolNode2(fn);
      }
      if (!isNode(fn))
        throw new TypeError('Node expected as parameter "fn"');
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.fn = fn;
      this.args = args || [];
    }
    get name() {
      return this.fn.name || "";
    }
    get type() {
      return name$1f;
    }
    get isFunctionNode() {
      return true;
    }
    _compile(math3, argNames) {
      var evalArgs = this.args.map((arg2) => arg2._compile(math3, argNames));
      if (isSymbolNode(this.fn)) {
        var _name = this.fn.name;
        if (!argNames[_name]) {
          var fn = _name in math3 ? getSafeProperty(math3, _name) : void 0;
          var isRaw = typeof fn === "function" && fn.rawArgs === true;
          var resolveFn = (scope) => {
            var value;
            if (scope.has(_name)) {
              value = scope.get(_name);
            } else if (_name in math3) {
              value = getSafeProperty(math3, _name);
            } else {
              return FunctionNode2.onUndefinedFunction(_name);
            }
            if (typeof value === "function") {
              return value;
            }
            throw new TypeError("'".concat(_name, "' is not a function; its value is:\n  ").concat(strin(value)));
          };
          if (isRaw) {
            var rawArgs = this.args;
            return function evalFunctionNode(scope, args, context) {
              var fn2 = resolveFn(scope);
              return fn2(rawArgs, math3, createSubScope(scope, args), scope);
            };
          } else {
            switch (evalArgs.length) {
              case 0:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  return fn2();
                };
              case 1:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var evalArg0 = evalArgs[0];
                  return fn2(evalArg0(scope, args, context));
                };
              case 2:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var evalArg0 = evalArgs[0];
                  var evalArg1 = evalArgs[1];
                  return fn2(evalArg0(scope, args, context), evalArg1(scope, args, context));
                };
              default:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var values2 = evalArgs.map((evalArg) => evalArg(scope, args, context));
                  return fn2(...values2);
                };
            }
          }
        } else {
          var _rawArgs = this.args;
          return function evalFunctionNode(scope, args, context) {
            var fn2 = args[_name];
            if (typeof fn2 !== "function") {
              throw new TypeError("Argument '".concat(_name, "' was not a function; received: ").concat(strin(fn2)));
            }
            if (fn2.rawArgs) {
              return fn2(_rawArgs, math3, createSubScope(scope, args), scope);
            } else {
              var values2 = evalArgs.map((evalArg) => evalArg(scope, args, context));
              return fn2.apply(fn2, values2);
            }
          };
        }
      } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
        var evalObject = this.fn.object._compile(math3, argNames);
        var prop = this.fn.index.getObjectProperty();
        var _rawArgs2 = this.args;
        return function evalFunctionNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          validateSafeMethod(object, prop);
          var isRaw2 = object[prop] && object[prop].rawArgs;
          if (isRaw2) {
            return object[prop](_rawArgs2, math3, createSubScope(scope, args), scope);
          } else {
            var values2 = evalArgs.map((evalArg) => evalArg(scope, args, context));
            return object[prop].apply(object, values2);
          }
        };
      } else {
        var fnExpr = this.fn.toString();
        var evalFn = this.fn._compile(math3, argNames);
        var _rawArgs3 = this.args;
        return function evalFunctionNode(scope, args, context) {
          var fn2 = evalFn(scope, args, context);
          if (typeof fn2 !== "function") {
            throw new TypeError("Expression '".concat(fnExpr, "' did not evaluate to a function; value is:") + "\n  ".concat(strin(fn2)));
          }
          if (fn2.rawArgs) {
            return fn2(_rawArgs3, math3, createSubScope(scope, args), scope);
          } else {
            var values2 = evalArgs.map((evalArg) => evalArg(scope, args, context));
            return fn2.apply(fn2, values2);
          }
        };
      }
    }
    forEach(callback) {
      callback(this.fn, "fn", this);
      for (var i2 = 0; i2 < this.args.length; i2++) {
        callback(this.args[i2], "args[" + i2 + "]", this);
      }
    }
    map(callback) {
      var fn = this._ifNode(callback(this.fn, "fn", this));
      var args = [];
      for (var i2 = 0; i2 < this.args.length; i2++) {
        args[i2] = this._ifNode(callback(this.args[i2], "args[" + i2 + "]", this));
      }
      return new FunctionNode2(fn, args);
    }
    clone() {
      return new FunctionNode2(this.fn, this.args.slice(0));
    }
    toString(options) {
      var customString;
      var name2 = this.fn.toString(options);
      if (options && typeof options.handler === "object" && hasOwnProperty$2(options.handler, name2)) {
        customString = options.handler[name2](this, options);
      }
      if (typeof customString !== "undefined") {
        return customString;
      }
      return super.toString(options);
    }
    _toString(options) {
      var args = this.args.map(function(arg2) {
        return arg2.toString(options);
      });
      var fn = isFunctionAssignmentNode(this.fn) ? "(" + this.fn.toString(options) + ")" : this.fn.toString(options);
      return fn + "(" + args.join(", ") + ")";
    }
    toJSON() {
      return {
        mathjs: name$1f,
        fn: this.fn,
        args: this.args
      };
    }
    toHTML(options) {
      var args = this.args.map(function(arg2) {
        return arg2.toHTML(options);
      });
      return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
    }
    toTex(options) {
      var customTex;
      if (options && typeof options.handler === "object" && hasOwnProperty$2(options.handler, this.name)) {
        customTex = options.handler[this.name](this, options);
      }
      if (typeof customTex !== "undefined") {
        return customTex;
      }
      return super.toTex(options);
    }
    _toTex(options) {
      var args = this.args.map(function(arg2) {
        return arg2.toTex(options);
      });
      var latexConverter;
      if (latexFunctions[this.name]) {
        latexConverter = latexFunctions[this.name];
      }
      if (math2[this.name] && (typeof math2[this.name].toTex === "function" || typeof math2[this.name].toTex === "object" || typeof math2[this.name].toTex === "string")) {
        latexConverter = math2[this.name].toTex;
      }
      var customToTex;
      switch (typeof latexConverter) {
        case "function":
          customToTex = latexConverter(this, options);
          break;
        case "string":
          customToTex = expandTemplate(latexConverter, this, options);
          break;
        case "object":
          switch (typeof latexConverter[args.length]) {
            case "function":
              customToTex = latexConverter[args.length](this, options);
              break;
            case "string":
              customToTex = expandTemplate(latexConverter[args.length], this, options);
              break;
          }
      }
      if (typeof customToTex !== "undefined") {
        return customToTex;
      }
      return expandTemplate(defaultTemplate, this, options);
    }
    getIdentifier() {
      return this.type + ":" + this.name;
    }
  }
  _defineProperty(FunctionNode2, "name", name$1f);
  _defineProperty(FunctionNode2, "onUndefinedFunction", function(name2) {
    throw new Error("Undefined function " + name2);
  });
  _defineProperty(FunctionNode2, "fromJSON", function(json) {
    return new FunctionNode2(json.fn, json.args);
  });
  return FunctionNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1e = "parse";
var dependencies$1e = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"];
var createParse = /* @__PURE__ */ factory(name$1e, dependencies$1e, (_ref) => {
  var {
    typed: typed2,
    numeric: numeric3,
    config: config3,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    AssignmentNode: AssignmentNode2,
    BlockNode: BlockNode2,
    ConditionalNode: ConditionalNode2,
    ConstantNode: ConstantNode2,
    FunctionAssignmentNode: FunctionAssignmentNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2,
    RangeNode: RangeNode2,
    RelationalNode: RelationalNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var parse2 = typed2(name$1e, {
    string: function string2(expression) {
      return parseStart(expression, {});
    },
    "Array | Matrix": function ArrayMatrix(expressions) {
      return parseMultiple(expressions, {});
    },
    "string, Object": function stringObject(expression, options) {
      var extraNodes = options.nodes !== void 0 ? options.nodes : {};
      return parseStart(expression, extraNodes);
    },
    "Array | Matrix, Object": parseMultiple
  });
  function parseMultiple(expressions) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var extraNodes = options.nodes !== void 0 ? options.nodes : {};
    return deepMap(expressions, function(elem) {
      if (typeof elem !== "string")
        throw new TypeError("String expected");
      return parseStart(elem, extraNodes);
    });
  }
  var TOKENTYPE = {
    NULL: 0,
    DELIMITER: 1,
    NUMBER: 2,
    SYMBOL: 3,
    UNKNOWN: 4
  };
  var DELIMITERS = {
    ",": true,
    "(": true,
    ")": true,
    "[": true,
    "]": true,
    "{": true,
    "}": true,
    '"': true,
    "'": true,
    ";": true,
    "+": true,
    "-": true,
    "*": true,
    ".*": true,
    "/": true,
    "./": true,
    "%": true,
    "^": true,
    ".^": true,
    "~": true,
    "!": true,
    "&": true,
    "|": true,
    "^|": true,
    "=": true,
    ":": true,
    "?": true,
    "==": true,
    "!=": true,
    "<": true,
    ">": true,
    "<=": true,
    ">=": true,
    "<<": true,
    ">>": true,
    ">>>": true
  };
  var NAMED_DELIMITERS = {
    mod: true,
    to: true,
    in: true,
    and: true,
    xor: true,
    or: true,
    not: true
  };
  var CONSTANTS = {
    true: true,
    false: false,
    null: null,
    undefined: void 0
  };
  var NUMERIC_CONSTANTS = ["NaN", "Infinity"];
  function initialState() {
    return {
      extraNodes: {},
      expression: "",
      comment: "",
      index: 0,
      token: "",
      tokenType: TOKENTYPE.NULL,
      nestingLevel: 0,
      conditionalLevel: null
    };
  }
  function currentString(state2, length) {
    return state2.expression.substr(state2.index, length);
  }
  function currentCharacter(state2) {
    return currentString(state2, 1);
  }
  function next(state2) {
    state2.index++;
  }
  function prevCharacter(state2) {
    return state2.expression.charAt(state2.index - 1);
  }
  function nextCharacter(state2) {
    return state2.expression.charAt(state2.index + 1);
  }
  function getToken(state2) {
    state2.tokenType = TOKENTYPE.NULL;
    state2.token = "";
    state2.comment = "";
    while (true) {
      if (currentCharacter(state2) === "#") {
        while (currentCharacter(state2) !== "\n" && currentCharacter(state2) !== "") {
          state2.comment += currentCharacter(state2);
          next(state2);
        }
      }
      if (parse2.isWhitespace(currentCharacter(state2), state2.nestingLevel)) {
        next(state2);
      } else {
        break;
      }
    }
    if (currentCharacter(state2) === "") {
      state2.tokenType = TOKENTYPE.DELIMITER;
      return;
    }
    if (currentCharacter(state2) === "\n" && !state2.nestingLevel) {
      state2.tokenType = TOKENTYPE.DELIMITER;
      state2.token = currentCharacter(state2);
      next(state2);
      return;
    }
    var c1 = currentCharacter(state2);
    var c2 = currentString(state2, 2);
    var c3 = currentString(state2, 3);
    if (c3.length === 3 && DELIMITERS[c3]) {
      state2.tokenType = TOKENTYPE.DELIMITER;
      state2.token = c3;
      next(state2);
      next(state2);
      next(state2);
      return;
    }
    if (c2.length === 2 && DELIMITERS[c2]) {
      state2.tokenType = TOKENTYPE.DELIMITER;
      state2.token = c2;
      next(state2);
      next(state2);
      return;
    }
    if (DELIMITERS[c1]) {
      state2.tokenType = TOKENTYPE.DELIMITER;
      state2.token = c1;
      next(state2);
      return;
    }
    if (parse2.isDigitDot(c1)) {
      state2.tokenType = TOKENTYPE.NUMBER;
      var _c = currentString(state2, 2);
      if (_c === "0b" || _c === "0o" || _c === "0x") {
        state2.token += currentCharacter(state2);
        next(state2);
        state2.token += currentCharacter(state2);
        next(state2);
        while (parse2.isHexDigit(currentCharacter(state2))) {
          state2.token += currentCharacter(state2);
          next(state2);
        }
        if (currentCharacter(state2) === ".") {
          state2.token += ".";
          next(state2);
          while (parse2.isHexDigit(currentCharacter(state2))) {
            state2.token += currentCharacter(state2);
            next(state2);
          }
        } else if (currentCharacter(state2) === "i") {
          state2.token += "i";
          next(state2);
          while (parse2.isDigit(currentCharacter(state2))) {
            state2.token += currentCharacter(state2);
            next(state2);
          }
        }
        return;
      }
      if (currentCharacter(state2) === ".") {
        state2.token += currentCharacter(state2);
        next(state2);
        if (!parse2.isDigit(currentCharacter(state2))) {
          state2.tokenType = TOKENTYPE.DELIMITER;
          return;
        }
      } else {
        while (parse2.isDigit(currentCharacter(state2))) {
          state2.token += currentCharacter(state2);
          next(state2);
        }
        if (parse2.isDecimalMark(currentCharacter(state2), nextCharacter(state2))) {
          state2.token += currentCharacter(state2);
          next(state2);
        }
      }
      while (parse2.isDigit(currentCharacter(state2))) {
        state2.token += currentCharacter(state2);
        next(state2);
      }
      if (currentCharacter(state2) === "E" || currentCharacter(state2) === "e") {
        if (parse2.isDigit(nextCharacter(state2)) || nextCharacter(state2) === "-" || nextCharacter(state2) === "+") {
          state2.token += currentCharacter(state2);
          next(state2);
          if (currentCharacter(state2) === "+" || currentCharacter(state2) === "-") {
            state2.token += currentCharacter(state2);
            next(state2);
          }
          if (!parse2.isDigit(currentCharacter(state2))) {
            throw createSyntaxError(state2, 'Digit expected, got "' + currentCharacter(state2) + '"');
          }
          while (parse2.isDigit(currentCharacter(state2))) {
            state2.token += currentCharacter(state2);
            next(state2);
          }
          if (parse2.isDecimalMark(currentCharacter(state2), nextCharacter(state2))) {
            throw createSyntaxError(state2, 'Digit expected, got "' + currentCharacter(state2) + '"');
          }
        } else if (nextCharacter(state2) === ".") {
          next(state2);
          throw createSyntaxError(state2, 'Digit expected, got "' + currentCharacter(state2) + '"');
        }
      }
      return;
    }
    if (parse2.isAlpha(currentCharacter(state2), prevCharacter(state2), nextCharacter(state2))) {
      while (parse2.isAlpha(currentCharacter(state2), prevCharacter(state2), nextCharacter(state2)) || parse2.isDigit(currentCharacter(state2))) {
        state2.token += currentCharacter(state2);
        next(state2);
      }
      if (hasOwnProperty$2(NAMED_DELIMITERS, state2.token)) {
        state2.tokenType = TOKENTYPE.DELIMITER;
      } else {
        state2.tokenType = TOKENTYPE.SYMBOL;
      }
      return;
    }
    state2.tokenType = TOKENTYPE.UNKNOWN;
    while (currentCharacter(state2) !== "") {
      state2.token += currentCharacter(state2);
      next(state2);
    }
    throw createSyntaxError(state2, 'Syntax error in part "' + state2.token + '"');
  }
  function getTokenSkipNewline(state2) {
    do {
      getToken(state2);
    } while (state2.token === "\n");
  }
  function openParams(state2) {
    state2.nestingLevel++;
  }
  function closeParams(state2) {
    state2.nestingLevel--;
  }
  parse2.isAlpha = function isAlpha(c, cPrev, cNext) {
    return parse2.isValidLatinOrGreek(c) || parse2.isValidMathSymbol(c, cNext) || parse2.isValidMathSymbol(cPrev, c);
  };
  parse2.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
    return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
  };
  parse2.isValidMathSymbol = function isValidMathSymbol(high, low) {
    return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
  };
  parse2.isWhitespace = function isWhitespace(c, nestingLevel) {
    return c === " " || c === "	" || c === "\n" && nestingLevel > 0;
  };
  parse2.isDecimalMark = function isDecimalMark(c, cNext) {
    return c === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
  };
  parse2.isDigitDot = function isDigitDot(c) {
    return c >= "0" && c <= "9" || c === ".";
  };
  parse2.isDigit = function isDigit(c) {
    return c >= "0" && c <= "9";
  };
  parse2.isHexDigit = function isHexDigit(c) {
    return c >= "0" && c <= "9" || c >= "a" && c <= "f" || c >= "A" && c <= "F";
  };
  function parseStart(expression, extraNodes) {
    var state2 = initialState();
    _extends$1(state2, {
      expression,
      extraNodes
    });
    getToken(state2);
    var node = parseBlock(state2);
    if (state2.token !== "") {
      if (state2.tokenType === TOKENTYPE.DELIMITER) {
        throw createError(state2, "Unexpected operator " + state2.token);
      } else {
        throw createSyntaxError(state2, 'Unexpected part "' + state2.token + '"');
      }
    }
    return node;
  }
  function parseBlock(state2) {
    var node;
    var blocks = [];
    var visible;
    if (state2.token !== "" && state2.token !== "\n" && state2.token !== ";") {
      node = parseAssignment(state2);
      if (state2.comment) {
        node.comment = state2.comment;
      }
    }
    while (state2.token === "\n" || state2.token === ";") {
      if (blocks.length === 0 && node) {
        visible = state2.token !== ";";
        blocks.push({
          node,
          visible
        });
      }
      getToken(state2);
      if (state2.token !== "\n" && state2.token !== ";" && state2.token !== "") {
        node = parseAssignment(state2);
        if (state2.comment) {
          node.comment = state2.comment;
        }
        visible = state2.token !== ";";
        blocks.push({
          node,
          visible
        });
      }
    }
    if (blocks.length > 0) {
      return new BlockNode2(blocks);
    } else {
      if (!node) {
        node = new ConstantNode2(void 0);
        if (state2.comment) {
          node.comment = state2.comment;
        }
      }
      return node;
    }
  }
  function parseAssignment(state2) {
    var name2, args, value, valid;
    var node = parseConditional(state2);
    if (state2.token === "=") {
      if (isSymbolNode(node)) {
        name2 = node.name;
        getTokenSkipNewline(state2);
        value = parseAssignment(state2);
        return new AssignmentNode2(new SymbolNode2(name2), value);
      } else if (isAccessorNode(node)) {
        getTokenSkipNewline(state2);
        value = parseAssignment(state2);
        return new AssignmentNode2(node.object, node.index, value);
      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
        valid = true;
        args = [];
        name2 = node.name;
        node.args.forEach(function(arg2, index2) {
          if (isSymbolNode(arg2)) {
            args[index2] = arg2.name;
          } else {
            valid = false;
          }
        });
        if (valid) {
          getTokenSkipNewline(state2);
          value = parseAssignment(state2);
          return new FunctionAssignmentNode2(name2, args, value);
        }
      }
      throw createSyntaxError(state2, "Invalid left hand side of assignment operator =");
    }
    return node;
  }
  function parseConditional(state2) {
    var node = parseLogicalOr(state2);
    while (state2.token === "?") {
      var prev = state2.conditionalLevel;
      state2.conditionalLevel = state2.nestingLevel;
      getTokenSkipNewline(state2);
      var condition = node;
      var trueExpr = parseAssignment(state2);
      if (state2.token !== ":")
        throw createSyntaxError(state2, "False part of conditional expression expected");
      state2.conditionalLevel = null;
      getTokenSkipNewline(state2);
      var falseExpr = parseAssignment(state2);
      node = new ConditionalNode2(condition, trueExpr, falseExpr);
      state2.conditionalLevel = prev;
    }
    return node;
  }
  function parseLogicalOr(state2) {
    var node = parseLogicalXor(state2);
    while (state2.token === "or") {
      getTokenSkipNewline(state2);
      node = new OperatorNode2("or", "or", [node, parseLogicalXor(state2)]);
    }
    return node;
  }
  function parseLogicalXor(state2) {
    var node = parseLogicalAnd(state2);
    while (state2.token === "xor") {
      getTokenSkipNewline(state2);
      node = new OperatorNode2("xor", "xor", [node, parseLogicalAnd(state2)]);
    }
    return node;
  }
  function parseLogicalAnd(state2) {
    var node = parseBitwiseOr(state2);
    while (state2.token === "and") {
      getTokenSkipNewline(state2);
      node = new OperatorNode2("and", "and", [node, parseBitwiseOr(state2)]);
    }
    return node;
  }
  function parseBitwiseOr(state2) {
    var node = parseBitwiseXor(state2);
    while (state2.token === "|") {
      getTokenSkipNewline(state2);
      node = new OperatorNode2("|", "bitOr", [node, parseBitwiseXor(state2)]);
    }
    return node;
  }
  function parseBitwiseXor(state2) {
    var node = parseBitwiseAnd(state2);
    while (state2.token === "^|") {
      getTokenSkipNewline(state2);
      node = new OperatorNode2("^|", "bitXor", [node, parseBitwiseAnd(state2)]);
    }
    return node;
  }
  function parseBitwiseAnd(state2) {
    var node = parseRelational(state2);
    while (state2.token === "&") {
      getTokenSkipNewline(state2);
      node = new OperatorNode2("&", "bitAnd", [node, parseRelational(state2)]);
    }
    return node;
  }
  function parseRelational(state2) {
    var params = [parseShift(state2)];
    var conditionals = [];
    var operators = {
      "==": "equal",
      "!=": "unequal",
      "<": "smaller",
      ">": "larger",
      "<=": "smallerEq",
      ">=": "largerEq"
    };
    while (hasOwnProperty$2(operators, state2.token)) {
      var cond = {
        name: state2.token,
        fn: operators[state2.token]
      };
      conditionals.push(cond);
      getTokenSkipNewline(state2);
      params.push(parseShift(state2));
    }
    if (params.length === 1) {
      return params[0];
    } else if (params.length === 2) {
      return new OperatorNode2(conditionals[0].name, conditionals[0].fn, params);
    } else {
      return new RelationalNode2(conditionals.map((c) => c.fn), params);
    }
  }
  function parseShift(state2) {
    var node, name2, fn, params;
    node = parseConversion(state2);
    var operators = {
      "<<": "leftShift",
      ">>": "rightArithShift",
      ">>>": "rightLogShift"
    };
    while (hasOwnProperty$2(operators, state2.token)) {
      name2 = state2.token;
      fn = operators[name2];
      getTokenSkipNewline(state2);
      params = [node, parseConversion(state2)];
      node = new OperatorNode2(name2, fn, params);
    }
    return node;
  }
  function parseConversion(state2) {
    var node, name2, fn, params;
    node = parseRange(state2);
    var operators = {
      to: "to",
      in: "to"
    };
    while (hasOwnProperty$2(operators, state2.token)) {
      name2 = state2.token;
      fn = operators[name2];
      getTokenSkipNewline(state2);
      if (name2 === "in" && state2.token === "") {
        node = new OperatorNode2("*", "multiply", [node, new SymbolNode2("in")], true);
      } else {
        params = [node, parseRange(state2)];
        node = new OperatorNode2(name2, fn, params);
      }
    }
    return node;
  }
  function parseRange(state2) {
    var node;
    var params = [];
    if (state2.token === ":") {
      node = new ConstantNode2(1);
    } else {
      node = parseAddSubtract(state2);
    }
    if (state2.token === ":" && state2.conditionalLevel !== state2.nestingLevel) {
      params.push(node);
      while (state2.token === ":" && params.length < 3) {
        getTokenSkipNewline(state2);
        if (state2.token === ")" || state2.token === "]" || state2.token === "," || state2.token === "") {
          params.push(new SymbolNode2("end"));
        } else {
          params.push(parseAddSubtract(state2));
        }
      }
      if (params.length === 3) {
        node = new RangeNode2(params[0], params[2], params[1]);
      } else {
        node = new RangeNode2(params[0], params[1]);
      }
    }
    return node;
  }
  function parseAddSubtract(state2) {
    var node, name2, fn, params;
    node = parseMultiplyDivide(state2);
    var operators = {
      "+": "add",
      "-": "subtract"
    };
    while (hasOwnProperty$2(operators, state2.token)) {
      name2 = state2.token;
      fn = operators[name2];
      getTokenSkipNewline(state2);
      var rightNode = parseMultiplyDivide(state2);
      if (rightNode.isPercentage) {
        params = [node, new OperatorNode2("*", "multiply", [node, rightNode])];
      } else {
        params = [node, rightNode];
      }
      node = new OperatorNode2(name2, fn, params);
    }
    return node;
  }
  function parseMultiplyDivide(state2) {
    var node, last3, name2, fn;
    node = parseImplicitMultiplication(state2);
    last3 = node;
    var operators = {
      "*": "multiply",
      ".*": "dotMultiply",
      "/": "divide",
      "./": "dotDivide"
    };
    while (true) {
      if (hasOwnProperty$2(operators, state2.token)) {
        name2 = state2.token;
        fn = operators[name2];
        getTokenSkipNewline(state2);
        last3 = parseImplicitMultiplication(state2);
        node = new OperatorNode2(name2, fn, [node, last3]);
      } else {
        break;
      }
    }
    return node;
  }
  function parseImplicitMultiplication(state2) {
    var node, last3;
    node = parseRule2(state2);
    last3 = node;
    while (true) {
      if (state2.tokenType === TOKENTYPE.SYMBOL || state2.token === "in" && isConstantNode(node) || state2.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last3) && (!isOperatorNode(last3) || last3.op === "!") || state2.token === "(") {
        last3 = parseRule2(state2);
        node = new OperatorNode2(
          "*",
          "multiply",
          [node, last3],
          true
        );
      } else {
        break;
      }
    }
    return node;
  }
  function parseRule2(state2) {
    var node = parsePercentage(state2);
    var last3 = node;
    var tokenStates = [];
    while (true) {
      if (state2.token === "/" && rule2Node(last3)) {
        tokenStates.push(_extends$1({}, state2));
        getTokenSkipNewline(state2);
        if (state2.tokenType === TOKENTYPE.NUMBER) {
          tokenStates.push(_extends$1({}, state2));
          getTokenSkipNewline(state2);
          if (state2.tokenType === TOKENTYPE.SYMBOL || state2.token === "(") {
            _extends$1(state2, tokenStates.pop());
            tokenStates.pop();
            last3 = parsePercentage(state2);
            node = new OperatorNode2("/", "divide", [node, last3]);
          } else {
            tokenStates.pop();
            _extends$1(state2, tokenStates.pop());
            break;
          }
        } else {
          _extends$1(state2, tokenStates.pop());
          break;
        }
      } else {
        break;
      }
    }
    return node;
  }
  function parsePercentage(state2) {
    var node, name2, fn, params;
    node = parseUnary(state2);
    var operators = {
      "%": "mod",
      mod: "mod"
    };
    while (hasOwnProperty$2(operators, state2.token)) {
      name2 = state2.token;
      fn = operators[name2];
      getTokenSkipNewline(state2);
      if (name2 === "%" && state2.tokenType === TOKENTYPE.DELIMITER && state2.token !== "(") {
        node = new OperatorNode2("/", "divide", [node, new ConstantNode2(100)], false, true);
      } else {
        params = [node, parseUnary(state2)];
        node = new OperatorNode2(name2, fn, params);
      }
    }
    return node;
  }
  function parseUnary(state2) {
    var name2, params, fn;
    var operators = {
      "-": "unaryMinus",
      "+": "unaryPlus",
      "~": "bitNot",
      not: "not"
    };
    if (hasOwnProperty$2(operators, state2.token)) {
      fn = operators[state2.token];
      name2 = state2.token;
      getTokenSkipNewline(state2);
      params = [parseUnary(state2)];
      return new OperatorNode2(name2, fn, params);
    }
    return parsePow(state2);
  }
  function parsePow(state2) {
    var node, name2, fn, params;
    node = parseLeftHandOperators(state2);
    if (state2.token === "^" || state2.token === ".^") {
      name2 = state2.token;
      fn = name2 === "^" ? "pow" : "dotPow";
      getTokenSkipNewline(state2);
      params = [node, parseUnary(state2)];
      node = new OperatorNode2(name2, fn, params);
    }
    return node;
  }
  function parseLeftHandOperators(state2) {
    var node, name2, fn, params;
    node = parseCustomNodes(state2);
    var operators = {
      "!": "factorial",
      "'": "ctranspose"
    };
    while (hasOwnProperty$2(operators, state2.token)) {
      name2 = state2.token;
      fn = operators[name2];
      getToken(state2);
      params = [node];
      node = new OperatorNode2(name2, fn, params);
      node = parseAccessors(state2, node);
    }
    return node;
  }
  function parseCustomNodes(state2) {
    var params = [];
    if (state2.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty$2(state2.extraNodes, state2.token)) {
      var CustomNode = state2.extraNodes[state2.token];
      getToken(state2);
      if (state2.token === "(") {
        params = [];
        openParams(state2);
        getToken(state2);
        if (state2.token !== ")") {
          params.push(parseAssignment(state2));
          while (state2.token === ",") {
            getToken(state2);
            params.push(parseAssignment(state2));
          }
        }
        if (state2.token !== ")") {
          throw createSyntaxError(state2, "Parenthesis ) expected");
        }
        closeParams(state2);
        getToken(state2);
      }
      return new CustomNode(params);
    }
    return parseSymbol(state2);
  }
  function parseSymbol(state2) {
    var node, name2;
    if (state2.tokenType === TOKENTYPE.SYMBOL || state2.tokenType === TOKENTYPE.DELIMITER && state2.token in NAMED_DELIMITERS) {
      name2 = state2.token;
      getToken(state2);
      if (hasOwnProperty$2(CONSTANTS, name2)) {
        node = new ConstantNode2(CONSTANTS[name2]);
      } else if (NUMERIC_CONSTANTS.indexOf(name2) !== -1) {
        node = new ConstantNode2(numeric3(name2, "number"));
      } else {
        node = new SymbolNode2(name2);
      }
      node = parseAccessors(state2, node);
      return node;
    }
    return parseDoubleQuotesString(state2);
  }
  function parseAccessors(state2, node, types) {
    var params;
    while ((state2.token === "(" || state2.token === "[" || state2.token === ".") && (!types || types.indexOf(state2.token) !== -1)) {
      params = [];
      if (state2.token === "(") {
        if (isSymbolNode(node) || isAccessorNode(node)) {
          openParams(state2);
          getToken(state2);
          if (state2.token !== ")") {
            params.push(parseAssignment(state2));
            while (state2.token === ",") {
              getToken(state2);
              params.push(parseAssignment(state2));
            }
          }
          if (state2.token !== ")") {
            throw createSyntaxError(state2, "Parenthesis ) expected");
          }
          closeParams(state2);
          getToken(state2);
          node = new FunctionNode2(node, params);
        } else {
          return node;
        }
      } else if (state2.token === "[") {
        openParams(state2);
        getToken(state2);
        if (state2.token !== "]") {
          params.push(parseAssignment(state2));
          while (state2.token === ",") {
            getToken(state2);
            params.push(parseAssignment(state2));
          }
        }
        if (state2.token !== "]") {
          throw createSyntaxError(state2, "Parenthesis ] expected");
        }
        closeParams(state2);
        getToken(state2);
        node = new AccessorNode2(node, new IndexNode2(params));
      } else {
        getToken(state2);
        if (state2.tokenType !== TOKENTYPE.SYMBOL) {
          throw createSyntaxError(state2, "Property name expected after dot");
        }
        params.push(new ConstantNode2(state2.token));
        getToken(state2);
        var dotNotation = true;
        node = new AccessorNode2(node, new IndexNode2(params, dotNotation));
      }
    }
    return node;
  }
  function parseDoubleQuotesString(state2) {
    var node, str;
    if (state2.token === '"') {
      str = parseDoubleQuotesStringToken(state2);
      node = new ConstantNode2(str);
      node = parseAccessors(state2, node);
      return node;
    }
    return parseSingleQuotesString(state2);
  }
  function parseDoubleQuotesStringToken(state2) {
    var str = "";
    while (currentCharacter(state2) !== "" && currentCharacter(state2) !== '"') {
      if (currentCharacter(state2) === "\\") {
        str += currentCharacter(state2);
        next(state2);
      }
      str += currentCharacter(state2);
      next(state2);
    }
    getToken(state2);
    if (state2.token !== '"') {
      throw createSyntaxError(state2, 'End of string " expected');
    }
    getToken(state2);
    return JSON.parse('"' + str + '"');
  }
  function parseSingleQuotesString(state2) {
    var node, str;
    if (state2.token === "'") {
      str = parseSingleQuotesStringToken(state2);
      node = new ConstantNode2(str);
      node = parseAccessors(state2, node);
      return node;
    }
    return parseMatrix(state2);
  }
  function parseSingleQuotesStringToken(state2) {
    var str = "";
    while (currentCharacter(state2) !== "" && currentCharacter(state2) !== "'") {
      if (currentCharacter(state2) === "\\") {
        str += currentCharacter(state2);
        next(state2);
      }
      str += currentCharacter(state2);
      next(state2);
    }
    getToken(state2);
    if (state2.token !== "'") {
      throw createSyntaxError(state2, "End of string ' expected");
    }
    getToken(state2);
    return JSON.parse('"' + str + '"');
  }
  function parseMatrix(state2) {
    var array, params, rows, cols;
    if (state2.token === "[") {
      openParams(state2);
      getToken(state2);
      if (state2.token !== "]") {
        var row2 = parseRow(state2);
        if (state2.token === ";") {
          rows = 1;
          params = [row2];
          while (state2.token === ";") {
            getToken(state2);
            params[rows] = parseRow(state2);
            rows++;
          }
          if (state2.token !== "]") {
            throw createSyntaxError(state2, "End of matrix ] expected");
          }
          closeParams(state2);
          getToken(state2);
          cols = params[0].items.length;
          for (var r = 1; r < rows; r++) {
            if (params[r].items.length !== cols) {
              throw createError(state2, "Column dimensions mismatch (" + params[r].items.length + " !== " + cols + ")");
            }
          }
          array = new ArrayNode2(params);
        } else {
          if (state2.token !== "]") {
            throw createSyntaxError(state2, "End of matrix ] expected");
          }
          closeParams(state2);
          getToken(state2);
          array = row2;
        }
      } else {
        closeParams(state2);
        getToken(state2);
        array = new ArrayNode2([]);
      }
      return parseAccessors(state2, array);
    }
    return parseObject(state2);
  }
  function parseRow(state2) {
    var params = [parseAssignment(state2)];
    var len = 1;
    while (state2.token === ",") {
      getToken(state2);
      params[len] = parseAssignment(state2);
      len++;
    }
    return new ArrayNode2(params);
  }
  function parseObject(state2) {
    if (state2.token === "{") {
      openParams(state2);
      var key;
      var properties2 = {};
      do {
        getToken(state2);
        if (state2.token !== "}") {
          if (state2.token === '"') {
            key = parseDoubleQuotesStringToken(state2);
          } else if (state2.token === "'") {
            key = parseSingleQuotesStringToken(state2);
          } else if (state2.tokenType === TOKENTYPE.SYMBOL || state2.tokenType === TOKENTYPE.DELIMITER && state2.token in NAMED_DELIMITERS) {
            key = state2.token;
            getToken(state2);
          } else {
            throw createSyntaxError(state2, "Symbol or string expected as object key");
          }
          if (state2.token !== ":") {
            throw createSyntaxError(state2, "Colon : expected after object key");
          }
          getToken(state2);
          properties2[key] = parseAssignment(state2);
        }
      } while (state2.token === ",");
      if (state2.token !== "}") {
        throw createSyntaxError(state2, "Comma , or bracket } expected after object value");
      }
      closeParams(state2);
      getToken(state2);
      var node = new ObjectNode2(properties2);
      node = parseAccessors(state2, node);
      return node;
    }
    return parseNumber(state2);
  }
  function parseNumber(state2) {
    var numberStr;
    if (state2.tokenType === TOKENTYPE.NUMBER) {
      numberStr = state2.token;
      getToken(state2);
      return new ConstantNode2(numeric3(numberStr, config3.number));
    }
    return parseParentheses(state2);
  }
  function parseParentheses(state2) {
    var node;
    if (state2.token === "(") {
      openParams(state2);
      getToken(state2);
      node = parseAssignment(state2);
      if (state2.token !== ")") {
        throw createSyntaxError(state2, "Parenthesis ) expected");
      }
      closeParams(state2);
      getToken(state2);
      node = new ParenthesisNode2(node);
      node = parseAccessors(state2, node);
      return node;
    }
    return parseEnd(state2);
  }
  function parseEnd(state2) {
    if (state2.token === "") {
      throw createSyntaxError(state2, "Unexpected end of expression");
    } else {
      throw createSyntaxError(state2, "Value expected");
    }
  }
  function col(state2) {
    return state2.index - state2.token.length + 1;
  }
  function createSyntaxError(state2, message) {
    var c = col(state2);
    var error = new SyntaxError(message + " (char " + c + ")");
    error.char = c;
    return error;
  }
  function createError(state2, message) {
    var c = col(state2);
    var error = new SyntaxError(message + " (char " + c + ")");
    error.char = c;
    return error;
  }
  typed2.addConversion({
    from: "string",
    to: "Node",
    convert: parse2
  });
  return parse2;
});
var name$1d = "compile";
var dependencies$1d = ["typed", "parse"];
var createCompile = /* @__PURE__ */ factory(name$1d, dependencies$1d, (_ref) => {
  var {
    typed: typed2,
    parse: parse2
  } = _ref;
  return typed2(name$1d, {
    string: function string2(expr) {
      return parse2(expr).compile();
    },
    "Array | Matrix": function ArrayMatrix(expr) {
      return deepMap(expr, function(entry) {
        return parse2(entry).compile();
      });
    }
  });
});
var name$1c = "evaluate";
var dependencies$1c = ["typed", "parse"];
var createEvaluate = /* @__PURE__ */ factory(name$1c, dependencies$1c, (_ref) => {
  var {
    typed: typed2,
    parse: parse2
  } = _ref;
  return typed2(name$1c, {
    string: function string2(expr) {
      var scope = createEmptyMap();
      return parse2(expr).compile().evaluate(scope);
    },
    "string, Map | Object": function stringMapObject(expr, scope) {
      return parse2(expr).compile().evaluate(scope);
    },
    "Array | Matrix": function ArrayMatrix(expr) {
      var scope = createEmptyMap();
      return deepMap(expr, function(entry) {
        return parse2(entry).compile().evaluate(scope);
      });
    },
    "Array | Matrix, Map | Object": function ArrayMatrixMapObject(expr, scope) {
      return deepMap(expr, function(entry) {
        return parse2(entry).compile().evaluate(scope);
      });
    }
  });
});
var name$1b = "Parser";
var dependencies$1b = ["evaluate"];
var createParserClass = /* @__PURE__ */ factory(name$1b, dependencies$1b, (_ref) => {
  var {
    evaluate: evaluate2
  } = _ref;
  function Parser2() {
    if (!(this instanceof Parser2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    Object.defineProperty(this, "scope", {
      value: createEmptyMap(),
      writable: false
    });
  }
  Parser2.prototype.type = "Parser";
  Parser2.prototype.isParser = true;
  Parser2.prototype.evaluate = function(expr) {
    return evaluate2(expr, this.scope);
  };
  Parser2.prototype.get = function(name2) {
    if (this.scope.has(name2)) {
      return this.scope.get(name2);
    }
  };
  Parser2.prototype.getAll = function() {
    return toObject$1(this.scope);
  };
  Parser2.prototype.getAllAsMap = function() {
    return this.scope;
  };
  Parser2.prototype.set = function(name2, value) {
    this.scope.set(name2, value);
    return value;
  };
  Parser2.prototype.remove = function(name2) {
    this.scope.delete(name2);
  };
  Parser2.prototype.clear = function() {
    this.scope.clear();
  };
  return Parser2;
}, {
  isClass: true
});
var name$1a = "parser";
var dependencies$1a = ["typed", "Parser"];
var createParser = /* @__PURE__ */ factory(name$1a, dependencies$1a, (_ref) => {
  var {
    typed: typed2,
    Parser: Parser2
  } = _ref;
  return typed2(name$1a, {
    "": function _() {
      return new Parser2();
    }
  });
});
var name$19 = "lup";
var dependencies$19 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtract", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
var createLup = /* @__PURE__ */ factory(name$19, dependencies$19, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    abs: abs2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtract: subtract2,
    larger: larger2,
    equalScalar: equalScalar2,
    unaryMinus: unaryMinus2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    Spa: Spa2
  } = _ref;
  return typed2(name$19, {
    DenseMatrix: function DenseMatrix3(m) {
      return _denseLUP(m);
    },
    SparseMatrix: function SparseMatrix3(m) {
      return _sparseLUP(m);
    },
    Array: function Array2(a) {
      var m = matrix2(a);
      var r = _denseLUP(m);
      return {
        L: r.L.valueOf(),
        U: r.U.valueOf(),
        p: r.p
      };
    }
  });
  function _denseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var data = clone$2(m._data);
    var ldata = [];
    var lsize = [rows, n];
    var udata = [];
    var usize = [n, columns];
    var i2, j, k;
    var p2 = [];
    for (i2 = 0; i2 < rows; i2++) {
      p2[i2] = i2;
    }
    for (j = 0; j < columns; j++) {
      if (j > 0) {
        for (i2 = 0; i2 < rows; i2++) {
          var min3 = Math.min(i2, j);
          var s = 0;
          for (k = 0; k < min3; k++) {
            s = addScalar2(s, multiplyScalar2(data[i2][k], data[k][j]));
          }
          data[i2][j] = subtract2(data[i2][j], s);
        }
      }
      var pi2 = j;
      var pabsv = 0;
      var vjj = 0;
      for (i2 = j; i2 < rows; i2++) {
        var v = data[i2][j];
        var absv = abs2(v);
        if (larger2(absv, pabsv)) {
          pi2 = i2;
          pabsv = absv;
          vjj = v;
        }
      }
      if (j !== pi2) {
        p2[j] = [p2[pi2], p2[pi2] = p2[j]][0];
        DenseMatrix2._swapRows(j, pi2, data);
      }
      if (j < rows) {
        for (i2 = j + 1; i2 < rows; i2++) {
          var vij = data[i2][j];
          if (!equalScalar2(vij, 0)) {
            data[i2][j] = divideScalar2(data[i2][j], vjj);
          }
        }
      }
    }
    for (j = 0; j < columns; j++) {
      for (i2 = 0; i2 < rows; i2++) {
        if (j === 0) {
          if (i2 < columns) {
            udata[i2] = [];
          }
          ldata[i2] = [];
        }
        if (i2 < j) {
          if (i2 < columns) {
            udata[i2][j] = data[i2][j];
          }
          if (j < rows) {
            ldata[i2][j] = 0;
          }
          continue;
        }
        if (i2 === j) {
          if (i2 < columns) {
            udata[i2][j] = data[i2][j];
          }
          if (j < rows) {
            ldata[i2][j] = 1;
          }
          continue;
        }
        if (i2 < columns) {
          udata[i2][j] = 0;
        }
        if (j < rows) {
          ldata[i2][j] = data[i2][j];
        }
      }
    }
    var l = new DenseMatrix2({
      data: ldata,
      size: lsize
    });
    var u = new DenseMatrix2({
      data: udata,
      size: usize
    });
    var pv = [];
    for (i2 = 0, n = p2.length; i2 < n; i2++) {
      pv[p2[i2]] = i2;
    }
    return {
      L: l,
      U: u,
      p: pv,
      toString: function toString5() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
  function _sparseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var values2 = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var lsize = [rows, n];
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var usize = [n, columns];
    var i2, j, k;
    var pvCo = [];
    var pvOc = [];
    for (i2 = 0; i2 < rows; i2++) {
      pvCo[i2] = i2;
      pvOc[i2] = i2;
    }
    var swapIndeces = function swapIndeces2(x, y) {
      var kx = pvOc[x];
      var ky = pvOc[y];
      pvCo[kx] = y;
      pvCo[ky] = x;
      pvOc[x] = ky;
      pvOc[y] = kx;
    };
    var _loop = function _loop2() {
      var spa = new Spa2();
      if (j < rows) {
        lptr.push(lvalues.length);
        lvalues.push(1);
        lindex.push(j);
      }
      uptr.push(uvalues.length);
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (k = k0; k < k1; k++) {
        i2 = index2[k];
        spa.set(pvCo[i2], values2[k]);
      }
      if (j > 0) {
        spa.forEach(0, j - 1, function(k2, vkj) {
          SparseMatrix2._forEachRow(k2, lvalues, lindex, lptr, function(i3, vik) {
            if (i3 > k2) {
              spa.accumulate(i3, unaryMinus2(multiplyScalar2(vik, vkj)));
            }
          });
        });
      }
      var pi2 = j;
      var vjj = spa.get(j);
      var pabsv = abs2(vjj);
      spa.forEach(j + 1, rows - 1, function(x, v) {
        var absv = abs2(v);
        if (larger2(absv, pabsv)) {
          pi2 = x;
          pabsv = absv;
          vjj = v;
        }
      });
      if (j !== pi2) {
        SparseMatrix2._swapRows(j, pi2, lsize[1], lvalues, lindex, lptr);
        SparseMatrix2._swapRows(j, pi2, usize[1], uvalues, uindex, uptr);
        spa.swap(j, pi2);
        swapIndeces(j, pi2);
      }
      spa.forEach(0, rows - 1, function(x, v) {
        if (x <= j) {
          uvalues.push(v);
          uindex.push(x);
        } else {
          v = divideScalar2(v, vjj);
          if (!equalScalar2(v, 0)) {
            lvalues.push(v);
            lindex.push(x);
          }
        }
      });
    };
    for (j = 0; j < columns; j++) {
      _loop();
    }
    uptr.push(uvalues.length);
    lptr.push(lvalues.length);
    return {
      L: new SparseMatrix2({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: lsize
      }),
      U: new SparseMatrix2({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: usize
      }),
      p: pvCo,
      toString: function toString5() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
});
var name$18 = "qr";
var dependencies$18 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtract", "complex"];
var createQr = /* @__PURE__ */ factory(name$18, dependencies$18, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    identity: identity2,
    isZero: isZero2,
    equal: equal2,
    sign: sign2,
    sqrt: sqrt2,
    conj: conj2,
    unaryMinus: unaryMinus2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtract: subtract2,
    complex: complex2
  } = _ref;
  return _extends$1(typed2(name$18, {
    DenseMatrix: function DenseMatrix2(m) {
      return _denseQR(m);
    },
    SparseMatrix: function SparseMatrix2(m) {
      return _sparseQR();
    },
    Array: function Array2(a) {
      var m = matrix2(a);
      var r = _denseQR(m);
      return {
        Q: r.Q.valueOf(),
        R: r.R.valueOf()
      };
    }
  }), {
    _denseQRimpl
  });
  function _denseQRimpl(m) {
    var rows = m._size[0];
    var cols = m._size[1];
    var Q2 = identity2([rows], "dense");
    var Qdata = Q2._data;
    var R = m.clone();
    var Rdata = R._data;
    var i2, j, k;
    var w = zeros2([rows], "");
    for (k = 0; k < Math.min(cols, rows); ++k) {
      var pivot = Rdata[k][k];
      var sgn = unaryMinus2(equal2(pivot, 0) ? 1 : sign2(pivot));
      var conjSgn = conj2(sgn);
      var alphaSquared = 0;
      for (i2 = k; i2 < rows; i2++) {
        alphaSquared = addScalar2(alphaSquared, multiplyScalar2(Rdata[i2][k], conj2(Rdata[i2][k])));
      }
      var alpha = multiplyScalar2(sgn, sqrt2(alphaSquared));
      if (!isZero2(alpha)) {
        var u1 = subtract2(pivot, alpha);
        w[k] = 1;
        for (i2 = k + 1; i2 < rows; i2++) {
          w[i2] = divideScalar2(Rdata[i2][k], u1);
        }
        var tau2 = unaryMinus2(conj2(divideScalar2(u1, alpha)));
        var s = void 0;
        for (j = k; j < cols; j++) {
          s = 0;
          for (i2 = k; i2 < rows; i2++) {
            s = addScalar2(s, multiplyScalar2(conj2(w[i2]), Rdata[i2][j]));
          }
          s = multiplyScalar2(s, tau2);
          for (i2 = k; i2 < rows; i2++) {
            Rdata[i2][j] = multiplyScalar2(subtract2(Rdata[i2][j], multiplyScalar2(w[i2], s)), conjSgn);
          }
        }
        for (i2 = 0; i2 < rows; i2++) {
          s = 0;
          for (j = k; j < rows; j++) {
            s = addScalar2(s, multiplyScalar2(Qdata[i2][j], w[j]));
          }
          s = multiplyScalar2(s, tau2);
          for (j = k; j < rows; ++j) {
            Qdata[i2][j] = divideScalar2(subtract2(Qdata[i2][j], multiplyScalar2(s, conj2(w[j]))), conjSgn);
          }
        }
      }
    }
    return {
      Q: Q2,
      R,
      toString: function toString5() {
        return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
      }
    };
  }
  function _denseQR(m) {
    var ret = _denseQRimpl(m);
    var Rdata = ret.R._data;
    if (m._data.length > 0) {
      var zero2 = Rdata[0][0].type === "Complex" ? complex2(0) : 0;
      for (var i2 = 0; i2 < Rdata.length; ++i2) {
        for (var j = 0; j < i2 && j < (Rdata[0] || []).length; ++j) {
          Rdata[i2][j] = zero2;
        }
      }
    }
    return ret;
  }
  function _sparseQR(m) {
    throw new Error("qr not implemented for sparse matrices yet");
  }
});
function csPermute(a, pinv2, q, values2) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var adt = a._datatype;
  var m = asize[0];
  var n = asize[1];
  var cvalues = values2 && a._values ? [] : null;
  var cindex = [];
  var cptr = [];
  var nz = 0;
  for (var k = 0; k < n; k++) {
    cptr[k] = nz;
    var j = q ? q[k] : k;
    for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
      var r = pinv2 ? pinv2[aindex[t]] : aindex[t];
      cindex[nz] = r;
      if (cvalues) {
        cvalues[nz] = avalues[t];
      }
      nz++;
    }
  }
  cptr[n] = nz;
  return a.createSparseMatrix({
    values: cvalues,
    index: cindex,
    ptr: cptr,
    size: [m, n],
    datatype: adt
  });
}
function csTdfs(j, k, w, head, next, post, stack2) {
  var top = 0;
  w[stack2] = j;
  while (top >= 0) {
    var p2 = w[stack2 + top];
    var i2 = w[head + p2];
    if (i2 === -1) {
      top--;
      post[k++] = p2;
    } else {
      w[head + p2] = w[next + i2];
      ++top;
      w[stack2 + top] = i2;
    }
  }
  return k;
}
function csPost(parent, n) {
  if (!parent) {
    return null;
  }
  var k = 0;
  var j;
  var post = [];
  var w = [];
  var head = 0;
  var next = n;
  var stack2 = 2 * n;
  for (j = 0; j < n; j++) {
    w[head + j] = -1;
  }
  for (j = n - 1; j >= 0; j--) {
    if (parent[j] === -1) {
      continue;
    }
    w[next + j] = w[head + parent[j]];
    w[head + parent[j]] = j;
  }
  for (j = 0; j < n; j++) {
    if (parent[j] !== -1) {
      continue;
    }
    k = csTdfs(j, k, w, head, next, post, stack2);
  }
  return post;
}
function csEtree(a, ata) {
  if (!a) {
    return null;
  }
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var m = asize[0];
  var n = asize[1];
  var parent = [];
  var w = [];
  var ancestor = 0;
  var prev = n;
  var i2, inext;
  if (ata) {
    for (i2 = 0; i2 < m; i2++) {
      w[prev + i2] = -1;
    }
  }
  for (var k = 0; k < n; k++) {
    parent[k] = -1;
    w[ancestor + k] = -1;
    for (var p0 = aptr[k], p1 = aptr[k + 1], p2 = p0; p2 < p1; p2++) {
      var r = aindex[p2];
      i2 = ata ? w[prev + r] : r;
      for (; i2 !== -1 && i2 < k; i2 = inext) {
        inext = w[ancestor + i2];
        w[ancestor + i2] = k;
        if (inext === -1) {
          parent[i2] = k;
        }
      }
      if (ata) {
        w[prev + r] = k;
      }
    }
  }
  return parent;
}
function csFkeep(a, callback, other) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var n = asize[1];
  var nz = 0;
  for (var j = 0; j < n; j++) {
    var p2 = aptr[j];
    aptr[j] = nz;
    for (; p2 < aptr[j + 1]; p2++) {
      if (callback(aindex[p2], j, avalues ? avalues[p2] : 1, other)) {
        aindex[nz] = aindex[p2];
        if (avalues) {
          avalues[nz] = avalues[p2];
        }
        nz++;
      }
    }
  }
  aptr[n] = nz;
  aindex.splice(nz, aindex.length - nz);
  if (avalues) {
    avalues.splice(nz, avalues.length - nz);
  }
  return nz;
}
function csFlip(i2) {
  return -i2 - 2;
}
var name$17 = "csAmd";
var dependencies$17 = ["add", "multiply", "transpose"];
var createCsAmd = /* @__PURE__ */ factory(name$17, dependencies$17, (_ref) => {
  var {
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  return function csAmd(order, a) {
    if (!a || order <= 0 || order > 3) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var lemax = 0;
    var dense = Math.max(16, 10 * Math.sqrt(n));
    dense = Math.min(n - 2, dense);
    var cm = _createTargetMatrix(order, a, m, n, dense);
    csFkeep(cm, _diag, null);
    var cindex = cm._index;
    var cptr = cm._ptr;
    var cnz = cptr[n];
    var P2 = [];
    var W = [];
    var len = 0;
    var nv = n + 1;
    var next = 2 * (n + 1);
    var head = 3 * (n + 1);
    var elen = 4 * (n + 1);
    var degree = 5 * (n + 1);
    var w = 6 * (n + 1);
    var hhead = 7 * (n + 1);
    var last3 = P2;
    var mark = _initializeQuotientGraph(n, cptr, W, len, head, last3, next, hhead, nv, w, elen, degree);
    var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last3, next);
    var mindeg = 0;
    var i2, j, k, k1, k2, e2, pj, ln2, nvi, pk, eln, p1, p2, pn, h2, d;
    while (nel < n) {
      for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++) {
      }
      if (W[next + k] !== -1) {
        last3[W[next + k]] = -1;
      }
      W[head + mindeg] = W[next + k];
      var elenk = W[elen + k];
      var nvk = W[nv + k];
      nel += nvk;
      var dk = 0;
      W[nv + k] = -nvk;
      var p3 = cptr[k];
      var pk1 = elenk === 0 ? p3 : cnz;
      var pk2 = pk1;
      for (k1 = 1; k1 <= elenk + 1; k1++) {
        if (k1 > elenk) {
          e2 = k;
          pj = p3;
          ln2 = W[len + k] - elenk;
        } else {
          e2 = cindex[p3++];
          pj = cptr[e2];
          ln2 = W[len + e2];
        }
        for (k2 = 1; k2 <= ln2; k2++) {
          i2 = cindex[pj++];
          if ((nvi = W[nv + i2]) <= 0) {
            continue;
          }
          dk += nvi;
          W[nv + i2] = -nvi;
          cindex[pk2++] = i2;
          if (W[next + i2] !== -1) {
            last3[W[next + i2]] = last3[i2];
          }
          if (last3[i2] !== -1) {
            W[next + last3[i2]] = W[next + i2];
          } else {
            W[head + W[degree + i2]] = W[next + i2];
          }
        }
        if (e2 !== k) {
          cptr[e2] = csFlip(k);
          W[w + e2] = 0;
        }
      }
      if (elenk !== 0) {
        cnz = pk2;
      }
      W[degree + k] = dk;
      cptr[k] = pk1;
      W[len + k] = pk2 - pk1;
      W[elen + k] = -2;
      mark = _wclear(mark, lemax, W, w, n);
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if ((eln = W[elen + i2]) <= 0) {
          continue;
        }
        nvi = -W[nv + i2];
        var wnvi = mark - nvi;
        for (p3 = cptr[i2], p1 = cptr[i2] + eln - 1; p3 <= p1; p3++) {
          e2 = cindex[p3];
          if (W[w + e2] >= mark) {
            W[w + e2] -= nvi;
          } else if (W[w + e2] !== 0) {
            W[w + e2] = W[degree + e2] + wnvi;
          }
        }
      }
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        p1 = cptr[i2];
        p2 = p1 + W[elen + i2] - 1;
        pn = p1;
        for (h2 = 0, d = 0, p3 = p1; p3 <= p2; p3++) {
          e2 = cindex[p3];
          if (W[w + e2] !== 0) {
            var dext = W[w + e2] - mark;
            if (dext > 0) {
              d += dext;
              cindex[pn++] = e2;
              h2 += e2;
            } else {
              cptr[e2] = csFlip(k);
              W[w + e2] = 0;
            }
          }
        }
        W[elen + i2] = pn - p1 + 1;
        var p32 = pn;
        var p4 = p1 + W[len + i2];
        for (p3 = p2 + 1; p3 < p4; p3++) {
          j = cindex[p3];
          var nvj = W[nv + j];
          if (nvj <= 0) {
            continue;
          }
          d += nvj;
          cindex[pn++] = j;
          h2 += j;
        }
        if (d === 0) {
          cptr[i2] = csFlip(k);
          nvi = -W[nv + i2];
          dk -= nvi;
          nvk += nvi;
          nel += nvi;
          W[nv + i2] = 0;
          W[elen + i2] = -1;
        } else {
          W[degree + i2] = Math.min(W[degree + i2], d);
          cindex[pn] = cindex[p32];
          cindex[p32] = cindex[p1];
          cindex[p1] = k;
          W[len + i2] = pn - p1 + 1;
          h2 = (h2 < 0 ? -h2 : h2) % n;
          W[next + i2] = W[hhead + h2];
          W[hhead + h2] = i2;
          last3[i2] = h2;
        }
      }
      W[degree + k] = dk;
      lemax = Math.max(lemax, dk);
      mark = _wclear(mark + lemax, lemax, W, w, n);
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if (W[nv + i2] >= 0) {
          continue;
        }
        h2 = last3[i2];
        i2 = W[hhead + h2];
        W[hhead + h2] = -1;
        for (; i2 !== -1 && W[next + i2] !== -1; i2 = W[next + i2], mark++) {
          ln2 = W[len + i2];
          eln = W[elen + i2];
          for (p3 = cptr[i2] + 1; p3 <= cptr[i2] + ln2 - 1; p3++) {
            W[w + cindex[p3]] = mark;
          }
          var jlast = i2;
          for (j = W[next + i2]; j !== -1; ) {
            var ok = W[len + j] === ln2 && W[elen + j] === eln;
            for (p3 = cptr[j] + 1; ok && p3 <= cptr[j] + ln2 - 1; p3++) {
              if (W[w + cindex[p3]] !== mark) {
                ok = 0;
              }
            }
            if (ok) {
              cptr[j] = csFlip(i2);
              W[nv + i2] += W[nv + j];
              W[nv + j] = 0;
              W[elen + j] = -1;
              j = W[next + j];
              W[next + jlast] = j;
            } else {
              jlast = j;
              j = W[next + j];
            }
          }
        }
      }
      for (p3 = pk1, pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if ((nvi = -W[nv + i2]) <= 0) {
          continue;
        }
        W[nv + i2] = nvi;
        d = W[degree + i2] + dk - nvi;
        d = Math.min(d, n - nel - nvi);
        if (W[head + d] !== -1) {
          last3[W[head + d]] = i2;
        }
        W[next + i2] = W[head + d];
        last3[i2] = -1;
        W[head + d] = i2;
        mindeg = Math.min(mindeg, d);
        W[degree + i2] = d;
        cindex[p3++] = i2;
      }
      W[nv + k] = nvk;
      if ((W[len + k] = p3 - pk1) === 0) {
        cptr[k] = -1;
        W[w + k] = 0;
      }
      if (elenk !== 0) {
        cnz = p3;
      }
    }
    for (i2 = 0; i2 < n; i2++) {
      cptr[i2] = csFlip(cptr[i2]);
    }
    for (j = 0; j <= n; j++) {
      W[head + j] = -1;
    }
    for (j = n; j >= 0; j--) {
      if (W[nv + j] > 0) {
        continue;
      }
      W[next + j] = W[head + cptr[j]];
      W[head + cptr[j]] = j;
    }
    for (e2 = n; e2 >= 0; e2--) {
      if (W[nv + e2] <= 0) {
        continue;
      }
      if (cptr[e2] !== -1) {
        W[next + e2] = W[head + cptr[e2]];
        W[head + cptr[e2]] = e2;
      }
    }
    for (k = 0, i2 = 0; i2 <= n; i2++) {
      if (cptr[i2] === -1) {
        k = csTdfs(i2, k, W, head, next, P2, w);
      }
    }
    P2.splice(P2.length - 1, 1);
    return P2;
  };
  function _createTargetMatrix(order, a, m, n, dense) {
    var at = transpose2(a);
    if (order === 1 && n === m) {
      return add2(a, at);
    }
    if (order === 2) {
      var tindex = at._index;
      var tptr = at._ptr;
      var p2 = 0;
      for (var j = 0; j < m; j++) {
        var p3 = tptr[j];
        tptr[j] = p2;
        if (tptr[j + 1] - p3 > dense) {
          continue;
        }
        for (var p1 = tptr[j + 1]; p3 < p1; p3++) {
          tindex[p2++] = tindex[p3];
        }
      }
      tptr[m] = p2;
      a = transpose2(at);
      return multiply2(at, a);
    }
    return multiply2(at, a);
  }
  function _initializeQuotientGraph(n, cptr, W, len, head, last3, next, hhead, nv, w, elen, degree) {
    for (var k = 0; k < n; k++) {
      W[len + k] = cptr[k + 1] - cptr[k];
    }
    W[len + n] = 0;
    for (var i2 = 0; i2 <= n; i2++) {
      W[head + i2] = -1;
      last3[i2] = -1;
      W[next + i2] = -1;
      W[hhead + i2] = -1;
      W[nv + i2] = 1;
      W[w + i2] = 1;
      W[elen + i2] = 0;
      W[degree + i2] = W[len + i2];
    }
    var mark = _wclear(0, 0, W, w, n);
    W[elen + n] = -2;
    cptr[n] = -1;
    W[w + n] = 0;
    return mark;
  }
  function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last3, next) {
    var nel = 0;
    for (var i2 = 0; i2 < n; i2++) {
      var d = W[degree + i2];
      if (d === 0) {
        W[elen + i2] = -2;
        nel++;
        cptr[i2] = -1;
        W[w + i2] = 0;
      } else if (d > dense) {
        W[nv + i2] = 0;
        W[elen + i2] = -1;
        nel++;
        cptr[i2] = csFlip(n);
        W[nv + n]++;
      } else {
        var h2 = W[head + d];
        if (h2 !== -1) {
          last3[h2] = i2;
        }
        W[next + i2] = W[head + d];
        W[head + d] = i2;
      }
    }
    return nel;
  }
  function _wclear(mark, lemax, W, w, n) {
    if (mark < 2 || mark + lemax < 0) {
      for (var k = 0; k < n; k++) {
        if (W[w + k] !== 0) {
          W[w + k] = 1;
        }
      }
      mark = 2;
    }
    return mark;
  }
  function _diag(i2, j) {
    return i2 !== j;
  }
});
function csLeaf(i2, j, w, first3, maxfirst, prevleaf, ancestor) {
  var s, sparent;
  var jleaf = 0;
  var q;
  if (i2 <= j || w[first3 + j] <= w[maxfirst + i2]) {
    return -1;
  }
  w[maxfirst + i2] = w[first3 + j];
  var jprev = w[prevleaf + i2];
  w[prevleaf + i2] = j;
  if (jprev === -1) {
    jleaf = 1;
    q = i2;
  } else {
    jleaf = 2;
    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q]) {
    }
    for (s = jprev; s !== q; s = sparent) {
      sparent = w[ancestor + s];
      w[ancestor + s] = q;
    }
  }
  return {
    jleaf,
    q
  };
}
var name$16 = "csCounts";
var dependencies$16 = ["transpose"];
var createCsCounts = /* @__PURE__ */ factory(name$16, dependencies$16, (_ref) => {
  var {
    transpose: transpose2
  } = _ref;
  return function(a, parent, post, ata) {
    if (!a || !parent || !post) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var i2, j, k, J, p2, p0, p1;
    var s = 4 * n + (ata ? n + m + 1 : 0);
    var w = [];
    var ancestor = 0;
    var maxfirst = n;
    var prevleaf = 2 * n;
    var first3 = 3 * n;
    var head = 4 * n;
    var next = 5 * n + 1;
    for (k = 0; k < s; k++) {
      w[k] = -1;
    }
    var colcount = [];
    var at = transpose2(a);
    var tindex = at._index;
    var tptr = at._ptr;
    for (k = 0; k < n; k++) {
      j = post[k];
      colcount[j] = w[first3 + j] === -1 ? 1 : 0;
      for (; j !== -1 && w[first3 + j] === -1; j = parent[j]) {
        w[first3 + j] = k;
      }
    }
    if (ata) {
      for (k = 0; k < n; k++) {
        w[post[k]] = k;
      }
      for (i2 = 0; i2 < m; i2++) {
        for (k = n, p0 = tptr[i2], p1 = tptr[i2 + 1], p2 = p0; p2 < p1; p2++) {
          k = Math.min(k, w[tindex[p2]]);
        }
        w[next + i2] = w[head + k];
        w[head + k] = i2;
      }
    }
    for (i2 = 0; i2 < n; i2++) {
      w[ancestor + i2] = i2;
    }
    for (k = 0; k < n; k++) {
      j = post[k];
      if (parent[j] !== -1) {
        colcount[parent[j]]--;
      }
      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {
        for (p2 = tptr[J]; p2 < tptr[J + 1]; p2++) {
          i2 = tindex[p2];
          var r = csLeaf(i2, j, w, first3, maxfirst, prevleaf, ancestor);
          if (r.jleaf >= 1) {
            colcount[j]++;
          }
          if (r.jleaf === 2) {
            colcount[r.q]--;
          }
        }
      }
      if (parent[j] !== -1) {
        w[ancestor + j] = parent[j];
      }
    }
    for (j = 0; j < n; j++) {
      if (parent[j] !== -1) {
        colcount[parent[j]] += colcount[j];
      }
    }
    return colcount;
  };
});
var name$15 = "csSqr";
var dependencies$15 = ["add", "multiply", "transpose"];
var createCsSqr = /* @__PURE__ */ factory(name$15, dependencies$15, (_ref) => {
  var {
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  var csAmd = createCsAmd({
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  });
  var csCounts = createCsCounts({
    transpose: transpose2
  });
  return function csSqr(order, a, qr2) {
    var aptr = a._ptr;
    var asize = a._size;
    var n = asize[1];
    var k;
    var s = {};
    s.q = csAmd(order, a);
    if (order && !s.q) {
      return null;
    }
    if (qr2) {
      var c = order ? csPermute(a, null, s.q, 0) : a;
      s.parent = csEtree(c, 1);
      var post = csPost(s.parent, n);
      s.cp = csCounts(c, s.parent, post, 1);
      if (c && s.parent && s.cp && _vcount(c, s)) {
        for (s.unz = 0, k = 0; k < n; k++) {
          s.unz += s.cp[k];
        }
      }
    } else {
      s.unz = 4 * aptr[n] + n;
      s.lnz = s.unz;
    }
    return s;
  };
  function _vcount(a, s) {
    var aptr = a._ptr;
    var aindex = a._index;
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    s.pinv = [];
    s.leftmost = [];
    var parent = s.parent;
    var pinv2 = s.pinv;
    var leftmost = s.leftmost;
    var w = [];
    var next = 0;
    var head = m;
    var tail = m + n;
    var nque = m + 2 * n;
    var i2, k, p2, p0, p1;
    for (k = 0; k < n; k++) {
      w[head + k] = -1;
      w[tail + k] = -1;
      w[nque + k] = 0;
    }
    for (i2 = 0; i2 < m; i2++) {
      leftmost[i2] = -1;
    }
    for (k = n - 1; k >= 0; k--) {
      for (p0 = aptr[k], p1 = aptr[k + 1], p2 = p0; p2 < p1; p2++) {
        leftmost[aindex[p2]] = k;
      }
    }
    for (i2 = m - 1; i2 >= 0; i2--) {
      pinv2[i2] = -1;
      k = leftmost[i2];
      if (k === -1) {
        continue;
      }
      if (w[nque + k]++ === 0) {
        w[tail + k] = i2;
      }
      w[next + i2] = w[head + k];
      w[head + k] = i2;
    }
    s.lnz = 0;
    s.m2 = m;
    for (k = 0; k < n; k++) {
      i2 = w[head + k];
      s.lnz++;
      if (i2 < 0) {
        i2 = s.m2++;
      }
      pinv2[i2] = k;
      if (--nque[k] <= 0) {
        continue;
      }
      s.lnz += w[nque + k];
      var pa = parent[k];
      if (pa !== -1) {
        if (w[nque + pa] === 0) {
          w[tail + pa] = w[tail + k];
        }
        w[next + w[tail + k]] = w[head + pa];
        w[head + pa] = w[next + i2];
        w[nque + pa] += w[nque + k];
      }
    }
    for (i2 = 0; i2 < m; i2++) {
      if (pinv2[i2] < 0) {
        pinv2[i2] = k++;
      }
    }
    return true;
  }
});
function csMarked(w, j) {
  return w[j] < 0;
}
function csMark(w, j) {
  w[j] = csFlip(w[j]);
}
function csUnflip(i2) {
  return i2 < 0 ? csFlip(i2) : i2;
}
function csDfs(j, g, top, xi, pinv2) {
  var index2 = g._index;
  var ptr = g._ptr;
  var size2 = g._size;
  var n = size2[1];
  var i2, p2, p22;
  var head = 0;
  xi[0] = j;
  while (head >= 0) {
    j = xi[head];
    var jnew = pinv2 ? pinv2[j] : j;
    if (!csMarked(ptr, j)) {
      csMark(ptr, j);
      xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
    }
    var done = 1;
    for (p2 = xi[n + head], p22 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p2 < p22; p2++) {
      i2 = index2[p2];
      if (csMarked(ptr, i2)) {
        continue;
      }
      xi[n + head] = p2;
      xi[++head] = i2;
      done = 0;
      break;
    }
    if (done) {
      head--;
      xi[--top] = j;
    }
  }
  return top;
}
function csReach(g, b, k, xi, pinv2) {
  var gptr = g._ptr;
  var gsize = g._size;
  var bindex = b._index;
  var bptr = b._ptr;
  var n = gsize[1];
  var p2, p0, p1;
  var top = n;
  for (p0 = bptr[k], p1 = bptr[k + 1], p2 = p0; p2 < p1; p2++) {
    var i2 = bindex[p2];
    if (!csMarked(gptr, i2)) {
      top = csDfs(i2, g, top, xi, pinv2);
    }
  }
  for (p2 = top; p2 < n; p2++) {
    csMark(gptr, xi[p2]);
  }
  return top;
}
var name$14 = "csSpsolve";
var dependencies$14 = ["divideScalar", "multiply", "subtract"];
var createCsSpsolve = /* @__PURE__ */ factory(name$14, dependencies$14, (_ref) => {
  var {
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2
  } = _ref;
  return function csSpsolve(g, b, k, xi, x, pinv2, lo) {
    var gvalues = g._values;
    var gindex = g._index;
    var gptr = g._ptr;
    var gsize = g._size;
    var n = gsize[1];
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var p2, p0, p1, q;
    var top = csReach(g, b, k, xi, pinv2);
    for (p2 = top; p2 < n; p2++) {
      x[xi[p2]] = 0;
    }
    for (p0 = bptr[k], p1 = bptr[k + 1], p2 = p0; p2 < p1; p2++) {
      x[bindex[p2]] = bvalues[p2];
    }
    for (var px = top; px < n; px++) {
      var j = xi[px];
      var J = pinv2 ? pinv2[j] : j;
      if (J < 0) {
        continue;
      }
      p0 = gptr[J];
      p1 = gptr[J + 1];
      x[j] = divideScalar2(x[j], gvalues[lo ? p0 : p1 - 1]);
      p2 = lo ? p0 + 1 : p0;
      q = lo ? p1 : p1 - 1;
      for (; p2 < q; p2++) {
        var i2 = gindex[p2];
        x[i2] = subtract2(x[i2], multiply2(gvalues[p2], x[j]));
      }
    }
    return top;
  };
});
var name$13 = "csLu";
var dependencies$13 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
var createCsLu = /* @__PURE__ */ factory(name$13, dependencies$13, (_ref) => {
  var {
    abs: abs2,
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var csSpsolve = createCsSpsolve({
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2
  });
  return function csLu(m, s, tol) {
    if (!m) {
      return null;
    }
    var size2 = m._size;
    var n = size2[1];
    var q;
    var lnz = 100;
    var unz = 100;
    if (s) {
      q = s.q;
      lnz = s.lnz || lnz;
      unz = s.unz || unz;
    }
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var L = new SparseMatrix2({
      values: lvalues,
      index: lindex,
      ptr: lptr,
      size: [n, n]
    });
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var U = new SparseMatrix2({
      values: uvalues,
      index: uindex,
      ptr: uptr,
      size: [n, n]
    });
    var pinv2 = [];
    var i2, p2;
    var x = [];
    var xi = [];
    for (i2 = 0; i2 < n; i2++) {
      x[i2] = 0;
      pinv2[i2] = -1;
      lptr[i2 + 1] = 0;
    }
    lnz = 0;
    unz = 0;
    for (var k = 0; k < n; k++) {
      lptr[k] = lnz;
      uptr[k] = unz;
      var col = q ? q[k] : k;
      var top = csSpsolve(L, m, col, xi, x, pinv2, 1);
      var ipiv = -1;
      var a = -1;
      for (p2 = top; p2 < n; p2++) {
        i2 = xi[p2];
        if (pinv2[i2] < 0) {
          var xabs = abs2(x[i2]);
          if (larger2(xabs, a)) {
            a = xabs;
            ipiv = i2;
          }
        } else {
          uindex[unz] = pinv2[i2];
          uvalues[unz++] = x[i2];
        }
      }
      if (ipiv === -1 || a <= 0) {
        return null;
      }
      if (pinv2[col] < 0 && largerEq2(abs2(x[col]), multiply2(a, tol))) {
        ipiv = col;
      }
      var pivot = x[ipiv];
      uindex[unz] = k;
      uvalues[unz++] = pivot;
      pinv2[ipiv] = k;
      lindex[lnz] = ipiv;
      lvalues[lnz++] = 1;
      for (p2 = top; p2 < n; p2++) {
        i2 = xi[p2];
        if (pinv2[i2] < 0) {
          lindex[lnz] = i2;
          lvalues[lnz++] = divideScalar2(x[i2], pivot);
        }
        x[i2] = 0;
      }
    }
    lptr[n] = lnz;
    uptr[n] = unz;
    for (p2 = 0; p2 < lnz; p2++) {
      lindex[p2] = pinv2[lindex[p2]];
    }
    lvalues.splice(lnz, lvalues.length - lnz);
    lindex.splice(lnz, lindex.length - lnz);
    uvalues.splice(unz, uvalues.length - unz);
    uindex.splice(unz, uindex.length - unz);
    return {
      L,
      U,
      pinv: pinv2
    };
  };
});
var name$12 = "slu";
var dependencies$12 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
var createSlu = /* @__PURE__ */ factory(name$12, dependencies$12, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    multiply: multiply2,
    transpose: transpose2,
    divideScalar: divideScalar2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var csSqr = createCsSqr({
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  });
  var csLu = createCsLu({
    abs: abs2,
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  });
  return typed2(name$12, {
    "SparseMatrix, number, number": function SparseMatrixNumberNumber(a, order, threshold) {
      if (!isInteger$1(order) || order < 0 || order > 3) {
        throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
      }
      if (threshold < 0 || threshold > 1) {
        throw new Error("Partial pivoting threshold must be a number from 0 to 1");
      }
      var s = csSqr(order, a, false);
      var f = csLu(a, s, threshold);
      return {
        L: f.L,
        U: f.U,
        p: f.pinv,
        q: s.q,
        toString: function toString5() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
        }
      };
    }
  });
});
function csIpvec(p2, b) {
  var k;
  var n = b.length;
  var x = [];
  if (p2) {
    for (k = 0; k < n; k++) {
      x[p2[k]] = b[k];
    }
  } else {
    for (k = 0; k < n; k++) {
      x[k] = b[k];
    }
  }
  return x;
}
var name$11 = "lusolve";
var dependencies$11 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
var createLusolve = /* @__PURE__ */ factory(name$11, dependencies$11, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    lup: lup2,
    slu: slu2,
    usolve: usolve2,
    lsolve: lsolve2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name$11, {
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      a = matrix2(a);
      var d = lup2(a);
      var x = _lusolve(d.L, d.U, d.p, null, b);
      return x.valueOf();
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(a, b) {
      var d = lup2(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(a, b) {
      var d = lup2(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix, number, number": function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {
      var d = slu2(a, order, threshold);
      return _lusolve(d.L, d.U, d.p, d.q, b);
    },
    "Object, Array | Matrix": function ObjectArrayMatrix(d, b) {
      return _lusolve(d.L, d.U, d.p, d.q, b);
    }
  });
  function _toMatrix(a) {
    if (isMatrix(a)) {
      return a;
    }
    if (isArray$1(a)) {
      return matrix2(a);
    }
    throw new TypeError("Invalid Matrix LU decomposition");
  }
  function _lusolve(l, u, p2, q, b) {
    l = _toMatrix(l);
    u = _toMatrix(u);
    if (p2) {
      b = solveValidation(l, b, true);
      b._data = csIpvec(p2, b._data);
    }
    var y = lsolve2(l, b);
    var x = usolve2(u, y);
    if (q) {
      x._data = csIpvec(q, x._data);
    }
    return x;
  }
});
var name$10 = "Help";
var dependencies$10 = ["parse"];
var createHelpClass = /* @__PURE__ */ factory(name$10, dependencies$10, (_ref) => {
  var {
    parse: parse2
  } = _ref;
  function Help2(doc2) {
    if (!(this instanceof Help2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (!doc2)
      throw new Error('Argument "doc" missing');
    this.doc = doc2;
  }
  Help2.prototype.type = "Help";
  Help2.prototype.isHelp = true;
  Help2.prototype.toString = function() {
    var doc2 = this.doc || {};
    var desc = "\n";
    if (doc2.name) {
      desc += "Name: " + doc2.name + "\n\n";
    }
    if (doc2.category) {
      desc += "Category: " + doc2.category + "\n\n";
    }
    if (doc2.description) {
      desc += "Description:\n    " + doc2.description + "\n\n";
    }
    if (doc2.syntax) {
      desc += "Syntax:\n    " + doc2.syntax.join("\n    ") + "\n\n";
    }
    if (doc2.examples) {
      desc += "Examples:\n";
      var scope = {};
      for (var i2 = 0; i2 < doc2.examples.length; i2++) {
        var expr = doc2.examples[i2];
        desc += "    " + expr + "\n";
        var res = void 0;
        try {
          res = parse2(expr).compile().evaluate(scope);
        } catch (e2) {
          res = e2;
        }
        if (res !== void 0 && !isHelp(res)) {
          desc += "        " + format$1(res, {
            precision: 14
          }) + "\n";
        }
      }
      desc += "\n";
    }
    if (doc2.mayThrow && doc2.mayThrow.length) {
      desc += "Throws: " + doc2.mayThrow.join(", ") + "\n\n";
    }
    if (doc2.seealso && doc2.seealso.length) {
      desc += "See also: " + doc2.seealso.join(", ") + "\n";
    }
    return desc;
  };
  Help2.prototype.toJSON = function() {
    var obj = clone$2(this.doc);
    obj.mathjs = "Help";
    return obj;
  };
  Help2.fromJSON = function(json) {
    var doc2 = {};
    Object.keys(json).filter((prop) => prop !== "mathjs").forEach((prop) => {
      doc2[prop] = json[prop];
    });
    return new Help2(doc2);
  };
  Help2.prototype.valueOf = Help2.prototype.toString;
  return Help2;
}, {
  isClass: true
});
var name$$ = "Chain";
var dependencies$$ = ["?on", "math", "typed"];
var createChainClass = /* @__PURE__ */ factory(name$$, dependencies$$, (_ref) => {
  var {
    on: on2,
    math: math2,
    typed: typed2
  } = _ref;
  function Chain2(value) {
    if (!(this instanceof Chain2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (isChain(value)) {
      this.value = value.value;
    } else {
      this.value = value;
    }
  }
  Chain2.prototype.type = "Chain";
  Chain2.prototype.isChain = true;
  Chain2.prototype.done = function() {
    return this.value;
  };
  Chain2.prototype.valueOf = function() {
    return this.value;
  };
  Chain2.prototype.toString = function() {
    return format$1(this.value);
  };
  Chain2.prototype.toJSON = function() {
    return {
      mathjs: "Chain",
      value: this.value
    };
  };
  Chain2.fromJSON = function(json) {
    return new Chain2(json.value);
  };
  function createProxy(name2, fn) {
    if (typeof fn === "function") {
      Chain2.prototype[name2] = chainify(fn);
    }
  }
  function createLazyProxy(name2, resolver) {
    lazy(Chain2.prototype, name2, function outerResolver() {
      var fn = resolver();
      if (typeof fn === "function") {
        return chainify(fn);
      }
      return void 0;
    });
  }
  function chainify(fn) {
    return function() {
      if (arguments.length === 0) {
        return new Chain2(fn(this.value));
      }
      var args = [this.value];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        args[i2 + 1] = arguments[i2];
      }
      if (typed2.isTypedFunction(fn)) {
        var sigObject = typed2.resolve(fn, args);
        if (sigObject.params.length === 1) {
          throw new Error("chain function " + fn.name + " cannot match rest parameter between chain value and additional arguments.");
        }
        return new Chain2(sigObject.implementation.apply(fn, args));
      }
      return new Chain2(fn.apply(fn, args));
    };
  }
  Chain2.createProxy = function(arg0, arg1) {
    if (typeof arg0 === "string") {
      createProxy(arg0, arg1);
    } else {
      var _loop = function _loop2(_name2) {
        if (hasOwnProperty$2(arg0, _name2) && excludedNames[_name2] === void 0) {
          createLazyProxy(_name2, () => arg0[_name2]);
        }
      };
      for (var _name in arg0) {
        _loop(_name);
      }
    }
  };
  var excludedNames = {
    expression: true,
    docs: true,
    type: true,
    classes: true,
    json: true,
    error: true,
    isChain: true
  };
  Chain2.createProxy(math2);
  if (on2) {
    on2("import", function(name2, resolver, path) {
      if (!path) {
        createLazyProxy(name2, resolver);
      }
    });
  }
  return Chain2;
}, {
  isClass: true
});
var eDocs = {
  name: "e",
  category: "Constants",
  syntax: ["e"],
  description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
  examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
  seealso: ["exp"]
};
var falseDocs = {
  name: "false",
  category: "Constants",
  syntax: ["false"],
  description: "Boolean value false",
  examples: ["false"],
  seealso: ["true"]
};
var iDocs = {
  name: "i",
  category: "Constants",
  syntax: ["i"],
  description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
  examples: ["i", "i * i", "sqrt(-1)"],
  seealso: []
};
var InfinityDocs = {
  name: "Infinity",
  category: "Constants",
  syntax: ["Infinity"],
  description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
  examples: ["Infinity", "1 / 0"],
  seealso: []
};
var LN10Docs = {
  name: "LN10",
  category: "Constants",
  syntax: ["LN10"],
  description: "Returns the natural logarithm of 10, approximately equal to 2.302",
  examples: ["LN10", "log(10)"],
  seealso: []
};
var LN2Docs = {
  name: "LN2",
  category: "Constants",
  syntax: ["LN2"],
  description: "Returns the natural logarithm of 2, approximately equal to 0.693",
  examples: ["LN2", "log(2)"],
  seealso: []
};
var LOG10EDocs = {
  name: "LOG10E",
  category: "Constants",
  syntax: ["LOG10E"],
  description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
  examples: ["LOG10E", "log(e, 10)"],
  seealso: []
};
var LOG2EDocs = {
  name: "LOG2E",
  category: "Constants",
  syntax: ["LOG2E"],
  description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
  examples: ["LOG2E", "log(e, 2)"],
  seealso: []
};
var NaNDocs = {
  name: "NaN",
  category: "Constants",
  syntax: ["NaN"],
  description: "Not a number",
  examples: ["NaN", "0 / 0"],
  seealso: []
};
var nullDocs = {
  name: "null",
  category: "Constants",
  syntax: ["null"],
  description: "Value null",
  examples: ["null"],
  seealso: ["true", "false"]
};
var phiDocs = {
  name: "phi",
  category: "Constants",
  syntax: ["phi"],
  description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
  examples: ["phi"],
  seealso: []
};
var piDocs = {
  name: "pi",
  category: "Constants",
  syntax: ["pi"],
  description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
  examples: ["pi", "sin(pi/2)"],
  seealso: ["tau"]
};
var SQRT12Docs = {
  name: "SQRT1_2",
  category: "Constants",
  syntax: ["SQRT1_2"],
  description: "Returns the square root of 1/2, approximately equal to 0.707",
  examples: ["SQRT1_2", "sqrt(1/2)"],
  seealso: []
};
var SQRT2Docs = {
  name: "SQRT2",
  category: "Constants",
  syntax: ["SQRT2"],
  description: "Returns the square root of 2, approximately equal to 1.414",
  examples: ["SQRT2", "sqrt(2)"],
  seealso: []
};
var tauDocs = {
  name: "tau",
  category: "Constants",
  syntax: ["tau"],
  description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
  examples: ["tau", "2 * pi"],
  seealso: ["pi"]
};
var trueDocs = {
  name: "true",
  category: "Constants",
  syntax: ["true"],
  description: "Boolean value true",
  examples: ["true"],
  seealso: ["false"]
};
var versionDocs = {
  name: "version",
  category: "Constants",
  syntax: ["version"],
  description: "A string with the version number of math.js",
  examples: ["version"],
  seealso: []
};
var bignumberDocs = {
  name: "bignumber",
  category: "Construction",
  syntax: ["bignumber(x)"],
  description: "Create a big number from a number or string.",
  examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
  seealso: ["boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
};
var booleanDocs = {
  name: "boolean",
  category: "Construction",
  syntax: ["x", "boolean(x)"],
  description: "Convert a string or number into a boolean.",
  examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
  seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
};
var complexDocs = {
  name: "complex",
  category: "Construction",
  syntax: ["complex()", "complex(re, im)", "complex(string)"],
  description: "Create a complex number.",
  examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
  seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
};
var createUnitDocs = {
  name: "createUnit",
  category: "Construction",
  syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
  description: "Create a user-defined unit and register it with the Unit type.",
  examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
  seealso: ["unit", "splitUnit"]
};
var fractionDocs = {
  name: "fraction",
  category: "Construction",
  syntax: ["fraction(num)", "fraction(matrix)", "fraction(num,den)", "fraction({n: num, d: den})"],
  description: "Create a fraction from a number or from integer numerator and denominator.",
  examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)", "fraction({n: 333, d: 53})", "fraction([sqrt(9), sqrt(10), sqrt(11)])"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
};
var indexDocs = {
  name: "index",
  category: "Construction",
  syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
  description: "Create an index to get or replace a subset of a matrix",
  examples: ["[]", "[1, 2, 3]", "A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[0:2, 0:2] = ones(2, 2)"],
  seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
};
var matrixDocs = {
  name: "matrix",
  category: "Construction",
  syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
  description: "Create a matrix.",
  examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
};
var numberDocs = {
  name: "number",
  category: "Construction",
  syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
  description: "Create a number or convert a string or boolean into a number.",
  examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
  seealso: ["bignumber", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
};
var sparseDocs = {
  name: "sparse",
  category: "Construction",
  syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
  description: "Create a sparse matrix.",
  examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
};
var splitUnitDocs = {
  name: "splitUnit",
  category: "Construction",
  syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
  description: "Split a unit in an array of units whose sum is equal to the original unit.",
  examples: ['splitUnit(1 m, ["feet", "inch"])'],
  seealso: ["unit", "createUnit"]
};
var stringDocs = {
  name: "string",
  category: "Construction",
  syntax: ['"text"', "string(x)"],
  description: "Create a string or convert a value to a string",
  examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
};
var unitDocs = {
  name: "unit",
  category: "Construction",
  syntax: ["value unit", "unit(value, unit)", "unit(string)"],
  description: "Create a unit.",
  examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
};
var configDocs = {
  name: "config",
  category: "Core",
  syntax: ["config()", "config(options)"],
  description: "Get configuration or change configuration.",
  examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
  seealso: []
};
var importDocs = {
  name: "import",
  category: "Core",
  syntax: ["import(functions)", "import(functions, options)"],
  description: "Import functions or constants from an object.",
  examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
  seealso: []
};
var typedDocs = {
  name: "typed",
  category: "Core",
  syntax: ["typed(signatures)", "typed(name, signatures)"],
  description: "Create a typed function.",
  examples: ['double = typed({ "number": f(x)=x+x })', "double(2)", 'double("hello")'],
  seealso: []
};
var derivativeDocs = {
  name: "derivative",
  category: "Algebra",
  syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
  description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
  examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
  seealso: ["simplify", "parse", "evaluate"]
};
var leafCountDocs = {
  name: "leafCount",
  category: "Algebra",
  syntax: ["leafCount(expr)"],
  description: "Computes the number of leaves in the parse tree of the given expression",
  examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
  seealso: ["simplify"]
};
var lsolveDocs = {
  name: "lsolve",
  category: "Algebra",
  syntax: ["x=lsolve(L, b)"],
  description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
};
var lsolveAllDocs = {
  name: "lsolveAll",
  category: "Algebra",
  syntax: ["x=lsolveAll(L, b)"],
  description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
};
var lupDocs = {
  name: "lup",
  category: "Algebra",
  syntax: ["lup(m)"],
  description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
  examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
};
var lusolveDocs = {
  name: "lusolve",
  category: "Algebra",
  syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
  description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
  seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
};
var qrDocs = {
  name: "qr",
  category: "Algebra",
  syntax: ["qr(A)"],
  description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
  examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
  seealso: ["lup", "slu", "matrix"]
};
var rationalizeDocs = {
  name: "rationalize",
  category: "Algebra",
  syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
  description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
  examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
  seealso: ["simplify"]
};
var resolveDocs = {
  name: "resolve",
  category: "Algebra",
  syntax: ["resolve(node, scope)"],
  description: "Recursively substitute variables in an expression tree.",
  examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
  seealso: ["simplify", "evaluate"],
  mayThrow: ["ReferenceError"]
};
var simplifyDocs = {
  name: "simplify",
  category: "Algebra",
  syntax: ["simplify(expr)", "simplify(expr, rules)"],
  description: "Simplify an expression tree.",
  examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
  seealso: ["simplifyCore", "derivative", "evaluate", "parse", "rationalize", "resolve"]
};
var simplifyConstantDocs = {
  name: "simplifyConstant",
  category: "Algebra",
  syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
  description: "Replace constant subexpressions of node with their values.",
  examples: ['simplifyConatant("(3-3)*x")', 'simplifyConstant(parse("z-cos(tau/8)"))'],
  seealso: ["simplify", "simplifyCore", "evaluate"]
};
var simplifyCoreDocs = {
  name: "simplifyCore",
  category: "Algebra",
  syntax: ["simplifyCore(node)"],
  description: "Perform simple one-pass simplifications on an expression tree.",
  examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
  seealso: ["simplify", "simplifyConstant", "evaluate"]
};
var sluDocs = {
  name: "slu",
  category: "Algebra",
  syntax: ["slu(A, order, threshold)"],
  description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
  examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
};
var symbolicEqualDocs = {
  name: "symbolicEqual",
  category: "Algebra",
  syntax: ["symbolicEqual(expr1, expr2)", "symbolicEqual(expr1, expr2, options)"],
  description: "Returns true if the difference of the expressions simplifies to 0",
  examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
  seealso: ["simplify", "evaluate"]
};
var usolveDocs = {
  name: "usolve",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};
var usolveAllDocs = {
  name: "usolveAll",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};
var absDocs = {
  name: "abs",
  category: "Arithmetic",
  syntax: ["abs(x)"],
  description: "Compute the absolute value.",
  examples: ["abs(3.5)", "abs(-4.2)"],
  seealso: ["sign"]
};
var addDocs = {
  name: "add",
  category: "Operators",
  syntax: ["x + y", "add(x, y)"],
  description: "Add two values.",
  examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
  seealso: ["subtract"]
};
var cbrtDocs = {
  name: "cbrt",
  category: "Arithmetic",
  syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
  description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
  examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
  seealso: ["square", "sqrt", "cube", "multiply"]
};
var ceilDocs = {
  name: "ceil",
  category: "Arithmetic",
  syntax: ["ceil(x)"],
  description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
  examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
  seealso: ["floor", "fix", "round"]
};
var cubeDocs = {
  name: "cube",
  category: "Arithmetic",
  syntax: ["cube(x)"],
  description: "Compute the cube of a value. The cube of x is x * x * x.",
  examples: ["cube(2)", "2^3", "2 * 2 * 2"],
  seealso: ["multiply", "square", "pow"]
};
var divideDocs = {
  name: "divide",
  category: "Operators",
  syntax: ["x / y", "divide(x, y)"],
  description: "Divide two values.",
  examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
  seealso: ["multiply"]
};
var dotDivideDocs = {
  name: "dotDivide",
  category: "Operators",
  syntax: ["x ./ y", "dotDivide(x, y)"],
  description: "Divide two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
  seealso: ["multiply", "dotMultiply", "divide"]
};
var dotMultiplyDocs = {
  name: "dotMultiply",
  category: "Operators",
  syntax: ["x .* y", "dotMultiply(x, y)"],
  description: "Multiply two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
  seealso: ["multiply", "divide", "dotDivide"]
};
var dotPowDocs = {
  name: "dotPow",
  category: "Operators",
  syntax: ["x .^ y", "dotPow(x, y)"],
  description: "Calculates the power of x to y element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
  seealso: ["pow"]
};
var expDocs = {
  name: "exp",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Calculate the exponent of a value.",
  examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],
  seealso: ["expm", "expm1", "pow", "log"]
};
var expmDocs = {
  name: "expm",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
  examples: ["expm([[0,2],[0,0]])"],
  seealso: ["exp"]
};
var expm1Docs = {
  name: "expm1",
  category: "Arithmetic",
  syntax: ["expm1(x)"],
  description: "Calculate the value of subtracting 1 from the exponential value.",
  examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
  seealso: ["exp", "pow", "log"]
};
var fixDocs = {
  name: "fix",
  category: "Arithmetic",
  syntax: ["fix(x)"],
  description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
  examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
  seealso: ["ceil", "floor", "round"]
};
var floorDocs = {
  name: "floor",
  category: "Arithmetic",
  syntax: ["floor(x)"],
  description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
  examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
  seealso: ["ceil", "fix", "round"]
};
var gcdDocs = {
  name: "gcd",
  category: "Arithmetic",
  syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
  description: "Compute the greatest common divisor.",
  examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
  seealso: ["lcm", "xgcd"]
};
var hypotDocs = {
  name: "hypot",
  category: "Arithmetic",
  syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
  description: "Calculate the hypotenusa of a list with values. ",
  examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
  seealso: ["abs", "norm"]
};
var invmodDocs = {
  name: "invmod",
  category: "Arithmetic",
  syntax: ["invmod(a, b)"],
  description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax \u2263 1 (mod b)",
  examples: ["invmod(8, 12)=NaN", "invmod(7, 13)=2", "math.invmod(15151, 15122)=10429"],
  seealso: ["gcd", "xgcd"]
};
var lcmDocs = {
  name: "lcm",
  category: "Arithmetic",
  syntax: ["lcm(x, y)"],
  description: "Compute the least common multiple.",
  examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
  seealso: ["gcd"]
};
var logDocs = {
  name: "log",
  category: "Arithmetic",
  syntax: ["log(x)", "log(x, base)"],
  description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
  examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
  seealso: ["exp", "log1p", "log2", "log10"]
};
var log10Docs = {
  name: "log10",
  category: "Arithmetic",
  syntax: ["log10(x)"],
  description: "Compute the 10-base logarithm of a value.",
  examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
  seealso: ["exp", "log"]
};
var log1pDocs = {
  name: "log1p",
  category: "Arithmetic",
  syntax: ["log1p(x)", "log1p(x, base)"],
  description: "Calculate the logarithm of a `value+1`",
  examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
  seealso: ["exp", "log", "log2", "log10"]
};
var log2Docs = {
  name: "log2",
  category: "Arithmetic",
  syntax: ["log2(x)"],
  description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
  examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
  seealso: ["exp", "log1p", "log", "log10"]
};
var modDocs = {
  name: "mod",
  category: "Operators",
  syntax: ["x % y", "x mod y", "mod(x, y)"],
  description: "Calculates the modulus, the remainder of an integer division.",
  examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
  seealso: ["divide"]
};
var multiplyDocs = {
  name: "multiply",
  category: "Operators",
  syntax: ["x * y", "multiply(x, y)"],
  description: "multiply two values.",
  examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
  seealso: ["divide"]
};
var normDocs = {
  name: "norm",
  category: "Arithmetic",
  syntax: ["norm(x)", "norm(x, p)"],
  description: "Calculate the norm of a number, vector or matrix.",
  examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
};
var nthRootDocs = {
  name: "nthRoot",
  category: "Arithmetic",
  syntax: ["nthRoot(a)", "nthRoot(a, root)"],
  description: 'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
  examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
  seealso: ["nthRoots", "pow", "sqrt"]
};
var nthRootsDocs = {
  name: "nthRoots",
  category: "Arithmetic",
  syntax: ["nthRoots(A)", "nthRoots(A, root)"],
  description: 'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
  examples: ["nthRoots(1)", "nthRoots(1, 3)"],
  seealso: ["sqrt", "pow", "nthRoot"]
};
var powDocs = {
  name: "pow",
  category: "Operators",
  syntax: ["x ^ y", "pow(x, y)"],
  description: "Calculates the power of x to y, x^y.",
  examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)", "math.pow([[1, 2], [4, 3]], 2)", "math.pow([[1, 2], [4, 3]], -1)"],
  seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
};
var roundDocs = {
  name: "round",
  category: "Arithmetic",
  syntax: ["round(x)", "round(x, n)"],
  description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
  examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)"],
  seealso: ["ceil", "floor", "fix"]
};
var signDocs = {
  name: "sign",
  category: "Arithmetic",
  syntax: ["sign(x)"],
  description: "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
  examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
  seealso: ["abs"]
};
var sqrtDocs = {
  name: "sqrt",
  category: "Arithmetic",
  syntax: ["sqrt(x)"],
  description: "Compute the square root value. If x = y * y, then y is the square root of x.",
  examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
  seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
};
var sqrtmDocs = {
  name: "sqrtm",
  category: "Arithmetic",
  syntax: ["sqrtm(x)"],
  description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
  examples: ["sqrtm([[1, 2], [3, 4]])"],
  seealso: ["sqrt", "abs", "square", "multiply"]
};
var squareDocs = {
  name: "square",
  category: "Arithmetic",
  syntax: ["square(x)"],
  description: "Compute the square of a value. The square of x is x * x.",
  examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
  seealso: ["multiply", "pow", "sqrt", "cube"]
};
var subtractDocs = {
  name: "subtract",
  category: "Operators",
  syntax: ["x - y", "subtract(x, y)"],
  description: "subtract two values.",
  examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
  seealso: ["add"]
};
var unaryMinusDocs = {
  name: "unaryMinus",
  category: "Operators",
  syntax: ["-x", "unaryMinus(x)"],
  description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
  examples: ["-4.5", "-(-5.6)", '-"22"'],
  seealso: ["add", "subtract", "unaryPlus"]
};
var unaryPlusDocs = {
  name: "unaryPlus",
  category: "Operators",
  syntax: ["+x", "unaryPlus(x)"],
  description: "Converts booleans and strings to numbers.",
  examples: ["+true", '+"2"'],
  seealso: ["add", "subtract", "unaryMinus"]
};
var xgcdDocs = {
  name: "xgcd",
  category: "Arithmetic",
  syntax: ["xgcd(a, b)"],
  description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
  examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
  seealso: ["gcd", "lcm"]
};
var bitAndDocs = {
  name: "bitAnd",
  category: "Bitwise",
  syntax: ["x & y", "bitAnd(x, y)"],
  description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
  examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
  seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};
var bitNotDocs = {
  name: "bitNot",
  category: "Bitwise",
  syntax: ["~x", "bitNot(x)"],
  description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
  examples: ["~1", "~2", "bitNot([2, -3, 4])"],
  seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};
var bitOrDocs = {
  name: "bitOr",
  category: "Bitwise",
  syntax: ["x | y", "bitOr(x, y)"],
  description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
  examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
  seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};
var bitXorDocs = {
  name: "bitXor",
  category: "Bitwise",
  syntax: ["bitXor(x, y)"],
  description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
  examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
  seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
};
var leftShiftDocs = {
  name: "leftShift",
  category: "Bitwise",
  syntax: ["x << y", "leftShift(x, y)"],
  description: "Bitwise left logical shift of a value x by y number of bits.",
  examples: ["4 << 1", "8 >> 1"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
};
var rightArithShiftDocs = {
  name: "rightArithShift",
  category: "Bitwise",
  syntax: ["x >> y", "rightArithShift(x, y)"],
  description: "Bitwise right arithmetic shift of a value x by y number of bits.",
  examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
};
var rightLogShiftDocs = {
  name: "rightLogShift",
  category: "Bitwise",
  syntax: ["x >>> y", "rightLogShift(x, y)"],
  description: "Bitwise right logical shift of a value x by y number of bits.",
  examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
};
var bellNumbersDocs = {
  name: "bellNumbers",
  category: "Combinatorics",
  syntax: ["bellNumbers(n)"],
  description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["bellNumbers(3)", "bellNumbers(8)"],
  seealso: ["stirlingS2"]
};
var catalanDocs = {
  name: "catalan",
  category: "Combinatorics",
  syntax: ["catalan(n)"],
  description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["catalan(3)", "catalan(8)"],
  seealso: ["bellNumbers"]
};
var compositionDocs = {
  name: "composition",
  category: "Combinatorics",
  syntax: ["composition(n, k)"],
  description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
  examples: ["composition(5, 3)"],
  seealso: ["combinations"]
};
var stirlingS2Docs = {
  name: "stirlingS2",
  category: "Combinatorics",
  syntax: ["stirlingS2(n, k)"],
  description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
  examples: ["stirlingS2(5, 3)"],
  seealso: ["bellNumbers"]
};
var argDocs = {
  name: "arg",
  category: "Complex",
  syntax: ["arg(x)"],
  description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
  examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
  seealso: ["re", "im", "conj", "abs"]
};
var conjDocs = {
  name: "conj",
  category: "Complex",
  syntax: ["conj(x)"],
  description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
  examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
  seealso: ["re", "im", "abs", "arg"]
};
var imDocs = {
  name: "im",
  category: "Complex",
  syntax: ["im(x)"],
  description: "Get the imaginary part of a complex number.",
  examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
  seealso: ["re", "conj", "abs", "arg"]
};
var reDocs = {
  name: "re",
  category: "Complex",
  syntax: ["re(x)"],
  description: "Get the real part of a complex number.",
  examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
  seealso: ["im", "conj", "abs", "arg"]
};
var evaluateDocs = {
  name: "evaluate",
  category: "Expression",
  syntax: ["evaluate(expression)", "evaluate([expr1, expr2, expr3, ...])"],
  description: "Evaluate an expression or an array with expressions.",
  examples: ['evaluate("2 + 3")', 'evaluate("sqrt(" + 4 + ")")'],
  seealso: []
};
var helpDocs = {
  name: "help",
  category: "Expression",
  syntax: ["help(object)", "help(string)"],
  description: "Display documentation on a function or data type.",
  examples: ["help(sqrt)", 'help("complex")'],
  seealso: []
};
var distanceDocs = {
  name: "distance",
  category: "Geometry",
  syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
  description: "Calculates the Euclidean distance between two points.",
  examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
  seealso: []
};
var intersectDocs = {
  name: "intersect",
  category: "Geometry",
  syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
  description: "Computes the intersection point of lines and/or planes.",
  examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
  seealso: []
};
var andDocs = {
  name: "and",
  category: "Logical",
  syntax: ["x and y", "and(x, y)"],
  description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
  examples: ["true and false", "true and true", "2 and 4"],
  seealso: ["not", "or", "xor"]
};
var notDocs = {
  name: "not",
  category: "Logical",
  syntax: ["not x", "not(x)"],
  description: "Logical not. Flips the boolean value of given argument.",
  examples: ["not true", "not false", "not 2", "not 0"],
  seealso: ["and", "or", "xor"]
};
var orDocs = {
  name: "or",
  category: "Logical",
  syntax: ["x or y", "or(x, y)"],
  description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
  examples: ["true or false", "false or false", "0 or 4"],
  seealso: ["not", "and", "xor"]
};
var xorDocs = {
  name: "xor",
  category: "Logical",
  syntax: ["x xor y", "xor(x, y)"],
  description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
  examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
  seealso: ["not", "and", "or"]
};
var columnDocs = {
  name: "column",
  category: "Matrix",
  syntax: ["column(x, index)"],
  description: "Return a column from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
  seealso: ["row", "matrixFromColumns"]
};
var concatDocs = {
  name: "concat",
  category: "Matrix",
  syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
  description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
  examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
  seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var countDocs = {
  name: "count",
  category: "Matrix",
  syntax: ["count(x)"],
  description: "Count the number of elements of a matrix, array or string.",
  examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
  seealso: ["size"]
};
var crossDocs = {
  name: "cross",
  category: "Matrix",
  syntax: ["cross(A, B)"],
  description: "Calculate the cross product for two vectors in three dimensional space.",
  examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
  seealso: ["multiply", "dot"]
};
var ctransposeDocs = {
  name: "ctranspose",
  category: "Matrix",
  syntax: ["x'", "ctranspose(x)"],
  description: "Complex Conjugate and Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
};
var detDocs = {
  name: "det",
  category: "Matrix",
  syntax: ["det(x)"],
  description: "Calculate the determinant of a matrix",
  examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
  seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var diagDocs = {
  name: "diag",
  category: "Matrix",
  syntax: ["diag(x)", "diag(x, k)"],
  description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
  examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
  seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var diffDocs = {
  name: "diff",
  category: "Matrix",
  syntax: ["diff(arr)", "diff(arr, dim)"],
  description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be 'rectangular' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
  examples: ["diff([1, 2, 4, 7, 0])", "diff([1, 2, 4, 7, 0], 0)", "diff(matrix([1, 2, 4, 7, 0]))", "diff([[1, 2], [3, 4]])", "diff([[1, 2], [3, 4]], 0)", "diff([[1, 2], [3, 4]], 1)", "diff([[1, 2], [3, 4]], bignumber(1))", "diff(matrix([[1, 2], [3, 4]]), 1)", "diff([[1, 2], matrix([3, 4])], 1)"],
  seealso: ["subtract", "partitionSelect"]
};
var dotDocs = {
  name: "dot",
  category: "Matrix",
  syntax: ["dot(A, B)", "A * B"],
  description: "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
  examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
  seealso: ["multiply", "cross"]
};
var eigsDocs = {
  name: "eigs",
  category: "Matrix",
  syntax: ["eigs(x)"],
  description: "Calculate the eigenvalues and eigenvectors of a real symmetric matrix",
  examples: ["eigs([[5, 2.3], [2.3, 1]])"],
  seealso: ["inv"]
};
var filterDocs = {
  name: "filter",
  category: "Matrix",
  syntax: ["filter(x, test)"],
  description: "Filter items in a matrix.",
  examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
  seealso: ["sort", "map", "forEach"]
};
var flattenDocs = {
  name: "flatten",
  category: "Matrix",
  syntax: ["flatten(x)"],
  description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
  seealso: ["concat", "resize", "size", "squeeze"]
};
var forEachDocs = {
  name: "forEach",
  category: "Matrix",
  syntax: ["forEach(x, callback)"],
  description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
  examples: ["numberOfPets = {}", "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;", 'forEach(["Dog","Cat","Cat"], addPet)', "numberOfPets"],
  seealso: ["map", "sort", "filter"]
};
var getMatrixDataTypeDocs = {
  name: "getMatrixDataType",
  category: "Matrix",
  syntax: ["getMatrixDataType(x)"],
  description: 'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
  examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
  seealso: ["matrix", "sparse", "typeOf"]
};
var identityDocs = {
  name: "identity",
  category: "Matrix",
  syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
  description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
  examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
  seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var invDocs = {
  name: "inv",
  category: "Matrix",
  syntax: ["inv(x)"],
  description: "Calculate the inverse of a matrix",
  examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
  seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var pinvDocs = {
  name: "pinv",
  category: "Matrix",
  syntax: ["pinv(x)"],
  description: "Calculate the Moore\u2013Penrose inverse of a matrix",
  examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
  seealso: ["inv"]
};
var kronDocs = {
  name: "kron",
  category: "Matrix",
  syntax: ["kron(x, y)"],
  description: "Calculates the kronecker product of 2 matrices or vectors.",
  examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
  seealso: ["multiply", "dot", "cross"]
};
var mapDocs = {
  name: "map",
  category: "Matrix",
  syntax: ["map(x, callback)"],
  description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
  examples: ["map([1, 2, 3], square)"],
  seealso: ["filter", "forEach"]
};
var matrixFromColumnsDocs = {
  name: "matrixFromColumns",
  category: "Matrix",
  syntax: ["math.matrixFromColumns(...arr)", "math.matrixFromColumns(row1, row2)", "math.matrixFromColumns(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual columns.",
  examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
};
var matrixFromFunctionDocs = {
  name: "matrixFromFunction",
  category: "Matrix",
  syntax: ["math.matrixFromFunction(size, fn)", "math.matrixFromFunction(size, fn, format)", "math.matrixFromFunction(size, fn, format, datatype)", "math.matrixFromFunction(size, format, fn)", "math.matrixFromFunction(size, format, datatype, fn)"],
  description: "Create a matrix by evaluating a generating function at each index.",
  examples: ["f(I) = I[1] - I[2]", "matrixFromFunction([3,3], f)", "g(I) = I[1] - I[2] == 1 ? 4 : 0", 'matrixFromFunction([100, 100], "sparse", g)', "matrixFromFunction([5], random)"],
  seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
};
var matrixFromRowsDocs = {
  name: "matrixFromRows",
  category: "Matrix",
  syntax: ["math.matrixFromRows(...arr)", "math.matrixFromRows(row1, row2)", "math.matrixFromRows(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual rows.",
  examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
};
var onesDocs = {
  name: "ones",
  category: "Matrix",
  syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
  description: "Create a matrix containing ones.",
  examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var partitionSelectDocs = {
  name: "partitionSelect",
  category: "Matrix",
  syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
  description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
  examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1)'],
  seealso: ["sort"]
};
var rangeDocs = {
  name: "range",
  category: "Type",
  syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
  description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
  examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var reshapeDocs = {
  name: "reshape",
  category: "Matrix",
  syntax: ["reshape(x, sizes)"],
  description: "Reshape a multi dimensional array to fit the specified dimensions.",
  examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])"],
  seealso: ["size", "squeeze", "resize"]
};
var resizeDocs = {
  name: "resize",
  category: "Matrix",
  syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
  description: "Resize a matrix.",
  examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
  seealso: ["size", "subset", "squeeze", "reshape"]
};
var rotateDocs = {
  name: "rotate",
  category: "Matrix",
  syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotate([1, 0], math.pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
  seealso: ["matrix", "rotationMatrix"]
};
var rotationMatrixDocs = {
  name: "rotationMatrix",
  category: "Matrix",
  syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
  seealso: ["cos", "sin"]
};
var rowDocs = {
  name: "row",
  category: "Matrix",
  syntax: ["row(x, index)"],
  description: "Return a row from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
  seealso: ["column", "matrixFromRows"]
};
var sizeDocs = {
  name: "size",
  category: "Matrix",
  syntax: ["size(x)"],
  description: "Calculate the size of a matrix.",
  examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
  seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var sortDocs = {
  name: "sort",
  category: "Matrix",
  syntax: ["sort(x)", "sort(x, compare)"],
  description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
  examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"])', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
  seealso: ["map", "filter", "forEach"]
};
var squeezeDocs = {
  name: "squeeze",
  category: "Matrix",
  syntax: ["squeeze(x)"],
  description: "Remove inner and outer singleton dimensions from a matrix.",
  examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
};
var subsetDocs = {
  name: "subset",
  category: "Matrix",
  syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
  description: "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
  examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]", "f[[1,2], [1,3]] = [9, 10; 11, 12]", "f"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
};
var traceDocs = {
  name: "trace",
  category: "Matrix",
  syntax: ["trace(A)"],
  description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
  examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
};
var transposeDocs = {
  name: "transpose",
  category: "Matrix",
  syntax: ["x'", "transpose(x)"],
  description: "Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
};
var zerosDocs = {
  name: "zeros",
  category: "Matrix",
  syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
  description: "Create a matrix containing zeros.",
  examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
};
var fftDocs = {
  name: "fft",
  category: "Matrix",
  syntax: ["fft(x)"],
  description: "Calculate N-dimensional fourier transform",
  examples: ["fft([[1, 0], [1, 0]])"],
  seealso: ["ifft"]
};
var ifftDocs = {
  name: "ifft",
  category: "Matrix",
  syntax: ["ifft(x)"],
  description: "Calculate N-dimensional inverse fourier transform",
  examples: ["ifft([[2, 2], [0, 0]])"],
  seealso: ["fft"]
};
var combinationsDocs = {
  name: "combinations",
  category: "Probability",
  syntax: ["combinations(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time",
  examples: ["combinations(7, 5)"],
  seealso: ["combinationsWithRep", "permutations", "factorial"]
};
var combinationsWithRepDocs = {
  name: "combinationsWithRep",
  category: "Probability",
  syntax: ["combinationsWithRep(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time with replacements.",
  examples: ["combinationsWithRep(7, 5)"],
  seealso: ["combinations", "permutations", "factorial"]
};
var factorialDocs = {
  name: "factorial",
  category: "Probability",
  syntax: ["n!", "factorial(n)"],
  description: "Compute the factorial of a value",
  examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
  seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
};
var gammaDocs = {
  name: "gamma",
  category: "Probability",
  syntax: ["gamma(n)"],
  description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
  examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
  seealso: ["factorial"]
};
var lgammaDocs = {
  name: "lgamma",
  category: "Probability",
  syntax: ["lgamma(n)"],
  description: "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
  examples: ["lgamma(4)", "lgamma(1/2)", "lgamma(math.i)", "lgamma(complex(1.1, 2))"],
  seealso: ["gamma"]
};
var kldivergenceDocs = {
  name: "kldivergence",
  category: "Probability",
  syntax: ["kldivergence(x, y)"],
  description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
  examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
  seealso: []
};
var multinomialDocs = {
  name: "multinomial",
  category: "Probability",
  syntax: ["multinomial(A)"],
  description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
  examples: ["multinomial([1, 2, 1])"],
  seealso: ["combinations", "factorial"]
};
var permutationsDocs = {
  name: "permutations",
  category: "Probability",
  syntax: ["permutations(n)", "permutations(n, k)"],
  description: "Compute the number of permutations of n items taken k at a time",
  examples: ["permutations(5)", "permutations(5, 3)"],
  seealso: ["combinations", "combinationsWithRep", "factorial"]
};
var pickRandomDocs = {
  name: "pickRandom",
  category: "Probability",
  syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
  description: "Pick a random entry from a given array.",
  examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
  seealso: ["random", "randomInt"]
};
var randomDocs = {
  name: "random",
  category: "Probability",
  syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
  description: "Return a random number.",
  examples: ["random()", "random(10, 20)", "random([2, 3])"],
  seealso: ["pickRandom", "randomInt"]
};
var randomIntDocs = {
  name: "randomInt",
  category: "Probability",
  syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
  description: "Return a random integer number",
  examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
  seealso: ["pickRandom", "random"]
};
var compareDocs = {
  name: "compare",
  category: "Relational",
  syntax: ["compare(x, y)"],
  description: "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
};
var compareNaturalDocs = {
  name: "compareNatural",
  category: "Relational",
  syntax: ["compareNatural(x, y)"],
  description: "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
};
var compareTextDocs = {
  name: "compareText",
  category: "Relational",
  syntax: ["compareText(x, y)"],
  description: "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural"]
};
var deepEqualDocs = {
  name: "deepEqual",
  category: "Relational",
  syntax: ["deepEqual(x, y)"],
  description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
  examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
  seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
};
var equalDocs = {
  name: "equal",
  category: "Relational",
  syntax: ["x == y", "equal(x, y)"],
  description: "Check equality of two values. Returns true if the values are equal, and false if not.",
  examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
  seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
};
var equalTextDocs = {
  name: "equalText",
  category: "Relational",
  syntax: ["equalText(x, y)"],
  description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
  examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural", "compareText", "equal"]
};
var largerDocs = {
  name: "larger",
  category: "Relational",
  syntax: ["x > y", "larger(x, y)"],
  description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
  examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
};
var largerEqDocs = {
  name: "largerEq",
  category: "Relational",
  syntax: ["x >= y", "largerEq(x, y)"],
  description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
  examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
  seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
};
var smallerDocs = {
  name: "smaller",
  category: "Relational",
  syntax: ["x < y", "smaller(x, y)"],
  description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
  seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
};
var smallerEqDocs = {
  name: "smallerEq",
  category: "Relational",
  syntax: ["x <= y", "smallerEq(x, y)"],
  description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
  seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
};
var unequalDocs = {
  name: "unequal",
  category: "Relational",
  syntax: ["x != y", "unequal(x, y)"],
  description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
  examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
  seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
};
var setCartesianDocs = {
  name: "setCartesian",
  category: "Set",
  syntax: ["setCartesian(set1, set2)"],
  description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
  examples: ["setCartesian([1, 2], [3, 4])"],
  seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
};
var setDifferenceDocs = {
  name: "setDifference",
  category: "Set",
  syntax: ["setDifference(set1, set2)"],
  description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setSymDifference"]
};
var setDistinctDocs = {
  name: "setDistinct",
  category: "Set",
  syntax: ["setDistinct(set)"],
  description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
  seealso: ["setMultiplicity"]
};
var setIntersectDocs = {
  name: "setIntersect",
  category: "Set",
  syntax: ["setIntersect(set1, set2)"],
  description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setDifference"]
};
var setIsSubsetDocs = {
  name: "setIsSubset",
  category: "Set",
  syntax: ["setIsSubset(set1, set2)"],
  description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};
var setMultiplicityDocs = {
  name: "setMultiplicity",
  category: "Set",
  syntax: ["setMultiplicity(element, set)"],
  description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
  seealso: ["setDistinct", "setSize"]
};
var setPowersetDocs = {
  name: "setPowerset",
  category: "Set",
  syntax: ["setPowerset(set)"],
  description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setPowerset([1, 2, 3])"],
  seealso: ["setCartesian"]
};
var setSizeDocs = {
  name: "setSize",
  category: "Set",
  syntax: ["setSize(set)", "setSize(set, unique)"],
  description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
  examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};
var setSymDifferenceDocs = {
  name: "setSymDifference",
  category: "Set",
  syntax: ["setSymDifference(set1, set2)"],
  description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};
var setUnionDocs = {
  name: "setUnion",
  category: "Set",
  syntax: ["setUnion(set1, set2)"],
  description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setIntersect", "setDifference"]
};
var erfDocs = {
  name: "erf",
  category: "Special",
  syntax: ["erf(x)"],
  description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
  examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
  seealso: []
};
var madDocs = {
  name: "mad",
  category: "Statistics",
  syntax: ["mad(a, b, c, ...)", "mad(A)"],
  description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
  examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
  seealso: ["mean", "median", "std", "abs"]
};
var maxDocs = {
  name: "max",
  category: "Statistics",
  syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dim)"],
  description: "Compute the maximum value of a list of values.",
  examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
};
var meanDocs = {
  name: "mean",
  category: "Statistics",
  syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dim)"],
  description: "Compute the arithmetic mean of a list of values.",
  examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
  seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
};
var medianDocs = {
  name: "median",
  category: "Statistics",
  syntax: ["median(a, b, c, ...)", "median(A)"],
  description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
  examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
  seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
};
var minDocs = {
  name: "min",
  category: "Statistics",
  syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dim)"],
  description: "Compute the minimum value of a list of values.",
  examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
};
var modeDocs = {
  name: "mode",
  category: "Statistics",
  syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
  description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
  examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
  seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
};
var prodDocs = {
  name: "prod",
  category: "Statistics",
  syntax: ["prod(a, b, c, ...)", "prod(A)"],
  description: "Compute the product of all values.",
  examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
  seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
};
var quantileSeqDocs = {
  name: "quantileSeq",
  category: "Statistics",
  syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
  description: "Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",
  examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
  seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
};
var stdDocs = {
  name: "std",
  category: "Statistics",
  syntax: ["std(a, b, c, ...)", "std(A)", "std(A, normalization)"],
  description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
};
var cumSumDocs = {
  name: "cumsum",
  category: "Statistics",
  syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
  description: "Compute the cumulative sum of all values.",
  examples: ["cumsum(2, 3, 4, 1)", "cumsum([2, 3, 4, 1])", "cumsum([1, 2; 3, 4])", "cumsum([1, 2; 3, 4], 1)", "cumsum([1, 2; 3, 4], 2)"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
};
var sumDocs = {
  name: "sum",
  category: "Statistics",
  syntax: ["sum(a, b, c, ...)", "sum(A)"],
  description: "Compute the sum of all values.",
  examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
};
var varianceDocs = {
  name: "variance",
  category: "Statistics",
  syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, normalization)"],
  description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
};
var acosDocs = {
  name: "acos",
  category: "Trigonometry",
  syntax: ["acos(x)"],
  description: "Compute the inverse cosine of a value in radians.",
  examples: ["acos(0.5)", "acos(cos(2.3))"],
  seealso: ["cos", "atan", "asin"]
};
var acoshDocs = {
  name: "acosh",
  category: "Trigonometry",
  syntax: ["acosh(x)"],
  description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
  examples: ["acosh(1.5)"],
  seealso: ["cosh", "asinh", "atanh"]
};
var acotDocs = {
  name: "acot",
  category: "Trigonometry",
  syntax: ["acot(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
  seealso: ["cot", "atan"]
};
var acothDocs = {
  name: "acoth",
  category: "Trigonometry",
  syntax: ["acoth(x)"],
  description: "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
  examples: ["acoth(2)", "acoth(0.5)"],
  seealso: ["acsch", "asech"]
};
var acscDocs = {
  name: "acsc",
  category: "Trigonometry",
  syntax: ["acsc(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
  seealso: ["csc", "asin", "asec"]
};
var acschDocs = {
  name: "acsch",
  category: "Trigonometry",
  syntax: ["acsch(x)"],
  description: "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
  examples: ["acsch(0.5)"],
  seealso: ["asech", "acoth"]
};
var asecDocs = {
  name: "asec",
  category: "Trigonometry",
  syntax: ["asec(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
  seealso: ["acos", "acot", "acsc"]
};
var asechDocs = {
  name: "asech",
  category: "Trigonometry",
  syntax: ["asech(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asech(0.5)"],
  seealso: ["acsch", "acoth"]
};
var asinDocs = {
  name: "asin",
  category: "Trigonometry",
  syntax: ["asin(x)"],
  description: "Compute the inverse sine of a value in radians.",
  examples: ["asin(0.5)", "asin(sin(0.5))"],
  seealso: ["sin", "acos", "atan"]
};
var asinhDocs = {
  name: "asinh",
  category: "Trigonometry",
  syntax: ["asinh(x)"],
  description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
  examples: ["asinh(0.5)"],
  seealso: ["acosh", "atanh"]
};
var atanDocs = {
  name: "atan",
  category: "Trigonometry",
  syntax: ["atan(x)"],
  description: "Compute the inverse tangent of a value in radians.",
  examples: ["atan(0.5)", "atan(tan(0.5))"],
  seealso: ["tan", "acos", "asin"]
};
var atan2Docs = {
  name: "atan2",
  category: "Trigonometry",
  syntax: ["atan2(y, x)"],
  description: "Computes the principal value of the arc tangent of y/x in radians.",
  examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
  seealso: ["sin", "cos", "tan"]
};
var atanhDocs = {
  name: "atanh",
  category: "Trigonometry",
  syntax: ["atanh(x)"],
  description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
  examples: ["atanh(0.5)"],
  seealso: ["acosh", "asinh"]
};
var cosDocs = {
  name: "cos",
  category: "Trigonometry",
  syntax: ["cos(x)"],
  description: "Compute the cosine of x in radians.",
  examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["acos", "sin", "tan"]
};
var coshDocs = {
  name: "cosh",
  category: "Trigonometry",
  syntax: ["cosh(x)"],
  description: "Compute the hyperbolic cosine of x in radians.",
  examples: ["cosh(0.5)"],
  seealso: ["sinh", "tanh", "coth"]
};
var cotDocs = {
  name: "cot",
  category: "Trigonometry",
  syntax: ["cot(x)"],
  description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
  examples: ["cot(2)", "1 / tan(2)"],
  seealso: ["sec", "csc", "tan"]
};
var cothDocs = {
  name: "coth",
  category: "Trigonometry",
  syntax: ["coth(x)"],
  description: "Compute the hyperbolic cotangent of x in radians.",
  examples: ["coth(2)", "1 / tanh(2)"],
  seealso: ["sech", "csch", "tanh"]
};
var cscDocs = {
  name: "csc",
  category: "Trigonometry",
  syntax: ["csc(x)"],
  description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
  examples: ["csc(2)", "1 / sin(2)"],
  seealso: ["sec", "cot", "sin"]
};
var cschDocs = {
  name: "csch",
  category: "Trigonometry",
  syntax: ["csch(x)"],
  description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
  examples: ["csch(2)", "1 / sinh(2)"],
  seealso: ["sech", "coth", "sinh"]
};
var secDocs = {
  name: "sec",
  category: "Trigonometry",
  syntax: ["sec(x)"],
  description: "Compute the secant of x in radians. Defined as 1/cos(x)",
  examples: ["sec(2)", "1 / cos(2)"],
  seealso: ["cot", "csc", "cos"]
};
var sechDocs = {
  name: "sech",
  category: "Trigonometry",
  syntax: ["sech(x)"],
  description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
  examples: ["sech(2)", "1 / cosh(2)"],
  seealso: ["coth", "csch", "cosh"]
};
var sinDocs = {
  name: "sin",
  category: "Trigonometry",
  syntax: ["sin(x)"],
  description: "Compute the sine of x in radians.",
  examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["asin", "cos", "tan"]
};
var sinhDocs = {
  name: "sinh",
  category: "Trigonometry",
  syntax: ["sinh(x)"],
  description: "Compute the hyperbolic sine of x in radians.",
  examples: ["sinh(0.5)"],
  seealso: ["cosh", "tanh"]
};
var tanDocs = {
  name: "tan",
  category: "Trigonometry",
  syntax: ["tan(x)"],
  description: "Compute the tangent of x in radians.",
  examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
  seealso: ["atan", "sin", "cos"]
};
var tanhDocs = {
  name: "tanh",
  category: "Trigonometry",
  syntax: ["tanh(x)"],
  description: "Compute the hyperbolic tangent of x in radians.",
  examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
  seealso: ["sinh", "cosh"]
};
var toDocs = {
  name: "to",
  category: "Units",
  syntax: ["x to unit", "to(x, unit)"],
  description: "Change the unit of a value.",
  examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
  seealso: []
};
var binDocs = {
  name: "bin",
  category: "Utils",
  syntax: ["bin(value)"],
  description: "Format a number as binary",
  examples: ["bin(2)"],
  seealso: ["oct", "hex"]
};
var cloneDocs = {
  name: "clone",
  category: "Utils",
  syntax: ["clone(x)"],
  description: "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
  examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
  seealso: []
};
var formatDocs = {
  name: "format",
  category: "Utils",
  syntax: ["format(value)", "format(value, precision)"],
  description: "Format a value of any type as string.",
  examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
  seealso: ["print"]
};
var hasNumericValueDocs = {
  name: "hasNumericValue",
  category: "Utils",
  syntax: ["hasNumericValue(x)"],
  description: "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
  examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
};
var hexDocs = {
  name: "hex",
  category: "Utils",
  syntax: ["hex(value)"],
  description: "Format a number as hexadecimal",
  examples: ["hex(240)"],
  seealso: ["bin", "oct"]
};
var isIntegerDocs = {
  name: "isInteger",
  category: "Utils",
  syntax: ["isInteger(x)"],
  description: "Test whether a value is an integer number.",
  examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
};
var isNaNDocs = {
  name: "isNaN",
  category: "Utils",
  syntax: ["isNaN(x)"],
  description: "Test whether a value is NaN (not a number)",
  examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
};
var isNegativeDocs = {
  name: "isNegative",
  category: "Utils",
  syntax: ["isNegative(x)"],
  description: "Test whether a value is negative: smaller than zero.",
  examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
};
var isNumericDocs = {
  name: "isNumeric",
  category: "Utils",
  syntax: ["isNumeric(x)"],
  description: "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
  examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
};
var isPositiveDocs = {
  name: "isPositive",
  category: "Utils",
  syntax: ["isPositive(x)"],
  description: "Test whether a value is positive: larger than zero.",
  examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};
var isPrimeDocs = {
  name: "isPrime",
  category: "Utils",
  syntax: ["isPrime(x)"],
  description: "Test whether a value is prime: has no divisors other than itself and one.",
  examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};
var isZeroDocs = {
  name: "isZero",
  category: "Utils",
  syntax: ["isZero(x)"],
  description: "Test whether a value is zero.",
  examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
};
var numericDocs = {
  name: "numeric",
  category: "Utils",
  syntax: ["numeric(x)"],
  description: "Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",
  examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction)', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number)'],
  seealso: ["number", "fraction", "bignumber", "string", "format"]
};
var octDocs = {
  name: "oct",
  category: "Utils",
  syntax: ["oct(value)"],
  description: "Format a number as octal",
  examples: ["oct(56)"],
  seealso: ["bin", "hex"]
};
var printDocs = {
  name: "print",
  category: "Utils",
  syntax: ["print(template, values)", "print(template, values, precision)"],
  description: "Interpolate values into a string template.",
  examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $0, $1, $2", [6, 9, 4])'],
  seealso: ["format"]
};
var typeOfDocs = {
  name: "typeOf",
  category: "Utils",
  syntax: ["typeOf(x)"],
  description: "Get the type of a variable.",
  examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
  seealso: ["getMatrixDataType"]
};
var embeddedDocs = {
  bignumber: bignumberDocs,
  boolean: booleanDocs,
  complex: complexDocs,
  createUnit: createUnitDocs,
  fraction: fractionDocs,
  index: indexDocs,
  matrix: matrixDocs,
  number: numberDocs,
  sparse: sparseDocs,
  splitUnit: splitUnitDocs,
  string: stringDocs,
  unit: unitDocs,
  e: eDocs,
  E: eDocs,
  false: falseDocs,
  i: iDocs,
  Infinity: InfinityDocs,
  LN2: LN2Docs,
  LN10: LN10Docs,
  LOG2E: LOG2EDocs,
  LOG10E: LOG10EDocs,
  NaN: NaNDocs,
  null: nullDocs,
  pi: piDocs,
  PI: piDocs,
  phi: phiDocs,
  SQRT1_2: SQRT12Docs,
  SQRT2: SQRT2Docs,
  tau: tauDocs,
  true: trueDocs,
  version: versionDocs,
  speedOfLight: {
    description: "Speed of light in vacuum",
    examples: ["speedOfLight"]
  },
  gravitationConstant: {
    description: "Newtonian constant of gravitation",
    examples: ["gravitationConstant"]
  },
  planckConstant: {
    description: "Planck constant",
    examples: ["planckConstant"]
  },
  reducedPlanckConstant: {
    description: "Reduced Planck constant",
    examples: ["reducedPlanckConstant"]
  },
  magneticConstant: {
    description: "Magnetic constant (vacuum permeability)",
    examples: ["magneticConstant"]
  },
  electricConstant: {
    description: "Electric constant (vacuum permeability)",
    examples: ["electricConstant"]
  },
  vacuumImpedance: {
    description: "Characteristic impedance of vacuum",
    examples: ["vacuumImpedance"]
  },
  coulomb: {
    description: "Coulomb's constant",
    examples: ["coulomb"]
  },
  elementaryCharge: {
    description: "Elementary charge",
    examples: ["elementaryCharge"]
  },
  bohrMagneton: {
    description: "Borh magneton",
    examples: ["bohrMagneton"]
  },
  conductanceQuantum: {
    description: "Conductance quantum",
    examples: ["conductanceQuantum"]
  },
  inverseConductanceQuantum: {
    description: "Inverse conductance quantum",
    examples: ["inverseConductanceQuantum"]
  },
  magneticFluxQuantum: {
    description: "Magnetic flux quantum",
    examples: ["magneticFluxQuantum"]
  },
  nuclearMagneton: {
    description: "Nuclear magneton",
    examples: ["nuclearMagneton"]
  },
  klitzing: {
    description: "Von Klitzing constant",
    examples: ["klitzing"]
  },
  bohrRadius: {
    description: "Borh radius",
    examples: ["bohrRadius"]
  },
  classicalElectronRadius: {
    description: "Classical electron radius",
    examples: ["classicalElectronRadius"]
  },
  electronMass: {
    description: "Electron mass",
    examples: ["electronMass"]
  },
  fermiCoupling: {
    description: "Fermi coupling constant",
    examples: ["fermiCoupling"]
  },
  fineStructure: {
    description: "Fine-structure constant",
    examples: ["fineStructure"]
  },
  hartreeEnergy: {
    description: "Hartree energy",
    examples: ["hartreeEnergy"]
  },
  protonMass: {
    description: "Proton mass",
    examples: ["protonMass"]
  },
  deuteronMass: {
    description: "Deuteron Mass",
    examples: ["deuteronMass"]
  },
  neutronMass: {
    description: "Neutron mass",
    examples: ["neutronMass"]
  },
  quantumOfCirculation: {
    description: "Quantum of circulation",
    examples: ["quantumOfCirculation"]
  },
  rydberg: {
    description: "Rydberg constant",
    examples: ["rydberg"]
  },
  thomsonCrossSection: {
    description: "Thomson cross section",
    examples: ["thomsonCrossSection"]
  },
  weakMixingAngle: {
    description: "Weak mixing angle",
    examples: ["weakMixingAngle"]
  },
  efimovFactor: {
    description: "Efimov factor",
    examples: ["efimovFactor"]
  },
  atomicMass: {
    description: "Atomic mass constant",
    examples: ["atomicMass"]
  },
  avogadro: {
    description: "Avogadro's number",
    examples: ["avogadro"]
  },
  boltzmann: {
    description: "Boltzmann constant",
    examples: ["boltzmann"]
  },
  faraday: {
    description: "Faraday constant",
    examples: ["faraday"]
  },
  firstRadiation: {
    description: "First radiation constant",
    examples: ["firstRadiation"]
  },
  loschmidt: {
    description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
    examples: ["loschmidt"]
  },
  gasConstant: {
    description: "Gas constant",
    examples: ["gasConstant"]
  },
  molarPlanckConstant: {
    description: "Molar Planck constant",
    examples: ["molarPlanckConstant"]
  },
  molarVolume: {
    description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
    examples: ["molarVolume"]
  },
  sackurTetrode: {
    description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
    examples: ["sackurTetrode"]
  },
  secondRadiation: {
    description: "Second radiation constant",
    examples: ["secondRadiation"]
  },
  stefanBoltzmann: {
    description: "Stefan-Boltzmann constant",
    examples: ["stefanBoltzmann"]
  },
  wienDisplacement: {
    description: "Wien displacement law constant",
    examples: ["wienDisplacement"]
  },
  molarMass: {
    description: "Molar mass constant",
    examples: ["molarMass"]
  },
  molarMassC12: {
    description: "Molar mass constant of carbon-12",
    examples: ["molarMassC12"]
  },
  gravity: {
    description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
    examples: ["gravity"]
  },
  planckLength: {
    description: "Planck length",
    examples: ["planckLength"]
  },
  planckMass: {
    description: "Planck mass",
    examples: ["planckMass"]
  },
  planckTime: {
    description: "Planck time",
    examples: ["planckTime"]
  },
  planckCharge: {
    description: "Planck charge",
    examples: ["planckCharge"]
  },
  planckTemperature: {
    description: "Planck temperature",
    examples: ["planckTemperature"]
  },
  derivative: derivativeDocs,
  lsolve: lsolveDocs,
  lsolveAll: lsolveAllDocs,
  lup: lupDocs,
  lusolve: lusolveDocs,
  leafCount: leafCountDocs,
  resolve: resolveDocs,
  simplify: simplifyDocs,
  simplifyConstant: simplifyConstantDocs,
  simplifyCore: simplifyCoreDocs,
  symbolicEqual: symbolicEqualDocs,
  rationalize: rationalizeDocs,
  slu: sluDocs,
  usolve: usolveDocs,
  usolveAll: usolveAllDocs,
  qr: qrDocs,
  abs: absDocs,
  add: addDocs,
  cbrt: cbrtDocs,
  ceil: ceilDocs,
  cube: cubeDocs,
  divide: divideDocs,
  dotDivide: dotDivideDocs,
  dotMultiply: dotMultiplyDocs,
  dotPow: dotPowDocs,
  exp: expDocs,
  expm: expmDocs,
  expm1: expm1Docs,
  fix: fixDocs,
  floor: floorDocs,
  gcd: gcdDocs,
  hypot: hypotDocs,
  lcm: lcmDocs,
  log: logDocs,
  log2: log2Docs,
  log1p: log1pDocs,
  log10: log10Docs,
  mod: modDocs,
  multiply: multiplyDocs,
  norm: normDocs,
  nthRoot: nthRootDocs,
  nthRoots: nthRootsDocs,
  pow: powDocs,
  round: roundDocs,
  sign: signDocs,
  sqrt: sqrtDocs,
  sqrtm: sqrtmDocs,
  square: squareDocs,
  subtract: subtractDocs,
  unaryMinus: unaryMinusDocs,
  unaryPlus: unaryPlusDocs,
  xgcd: xgcdDocs,
  invmod: invmodDocs,
  bitAnd: bitAndDocs,
  bitNot: bitNotDocs,
  bitOr: bitOrDocs,
  bitXor: bitXorDocs,
  leftShift: leftShiftDocs,
  rightArithShift: rightArithShiftDocs,
  rightLogShift: rightLogShiftDocs,
  bellNumbers: bellNumbersDocs,
  catalan: catalanDocs,
  composition: compositionDocs,
  stirlingS2: stirlingS2Docs,
  config: configDocs,
  import: importDocs,
  typed: typedDocs,
  arg: argDocs,
  conj: conjDocs,
  re: reDocs,
  im: imDocs,
  evaluate: evaluateDocs,
  help: helpDocs,
  distance: distanceDocs,
  intersect: intersectDocs,
  and: andDocs,
  not: notDocs,
  or: orDocs,
  xor: xorDocs,
  concat: concatDocs,
  count: countDocs,
  cross: crossDocs,
  column: columnDocs,
  ctranspose: ctransposeDocs,
  det: detDocs,
  diag: diagDocs,
  diff: diffDocs,
  dot: dotDocs,
  getMatrixDataType: getMatrixDataTypeDocs,
  identity: identityDocs,
  filter: filterDocs,
  flatten: flattenDocs,
  forEach: forEachDocs,
  inv: invDocs,
  pinv: pinvDocs,
  eigs: eigsDocs,
  kron: kronDocs,
  matrixFromFunction: matrixFromFunctionDocs,
  matrixFromRows: matrixFromRowsDocs,
  matrixFromColumns: matrixFromColumnsDocs,
  map: mapDocs,
  ones: onesDocs,
  partitionSelect: partitionSelectDocs,
  range: rangeDocs,
  resize: resizeDocs,
  reshape: reshapeDocs,
  rotate: rotateDocs,
  rotationMatrix: rotationMatrixDocs,
  row: rowDocs,
  size: sizeDocs,
  sort: sortDocs,
  squeeze: squeezeDocs,
  subset: subsetDocs,
  trace: traceDocs,
  transpose: transposeDocs,
  zeros: zerosDocs,
  fft: fftDocs,
  ifft: ifftDocs,
  combinations: combinationsDocs,
  combinationsWithRep: combinationsWithRepDocs,
  factorial: factorialDocs,
  gamma: gammaDocs,
  kldivergence: kldivergenceDocs,
  lgamma: lgammaDocs,
  multinomial: multinomialDocs,
  permutations: permutationsDocs,
  pickRandom: pickRandomDocs,
  random: randomDocs,
  randomInt: randomIntDocs,
  compare: compareDocs,
  compareNatural: compareNaturalDocs,
  compareText: compareTextDocs,
  deepEqual: deepEqualDocs,
  equal: equalDocs,
  equalText: equalTextDocs,
  larger: largerDocs,
  largerEq: largerEqDocs,
  smaller: smallerDocs,
  smallerEq: smallerEqDocs,
  unequal: unequalDocs,
  setCartesian: setCartesianDocs,
  setDifference: setDifferenceDocs,
  setDistinct: setDistinctDocs,
  setIntersect: setIntersectDocs,
  setIsSubset: setIsSubsetDocs,
  setMultiplicity: setMultiplicityDocs,
  setPowerset: setPowersetDocs,
  setSize: setSizeDocs,
  setSymDifference: setSymDifferenceDocs,
  setUnion: setUnionDocs,
  erf: erfDocs,
  cumsum: cumSumDocs,
  mad: madDocs,
  max: maxDocs,
  mean: meanDocs,
  median: medianDocs,
  min: minDocs,
  mode: modeDocs,
  prod: prodDocs,
  quantileSeq: quantileSeqDocs,
  std: stdDocs,
  sum: sumDocs,
  variance: varianceDocs,
  acos: acosDocs,
  acosh: acoshDocs,
  acot: acotDocs,
  acoth: acothDocs,
  acsc: acscDocs,
  acsch: acschDocs,
  asec: asecDocs,
  asech: asechDocs,
  asin: asinDocs,
  asinh: asinhDocs,
  atan: atanDocs,
  atanh: atanhDocs,
  atan2: atan2Docs,
  cos: cosDocs,
  cosh: coshDocs,
  cot: cotDocs,
  coth: cothDocs,
  csc: cscDocs,
  csch: cschDocs,
  sec: secDocs,
  sech: sechDocs,
  sin: sinDocs,
  sinh: sinhDocs,
  tan: tanDocs,
  tanh: tanhDocs,
  to: toDocs,
  clone: cloneDocs,
  format: formatDocs,
  bin: binDocs,
  oct: octDocs,
  hex: hexDocs,
  isNaN: isNaNDocs,
  isInteger: isIntegerDocs,
  isNegative: isNegativeDocs,
  isNumeric: isNumericDocs,
  hasNumericValue: hasNumericValueDocs,
  isPositive: isPositiveDocs,
  isPrime: isPrimeDocs,
  isZero: isZeroDocs,
  print: printDocs,
  typeOf: typeOfDocs,
  numeric: numericDocs
};
var name$_ = "help";
var dependencies$_ = ["typed", "mathWithTransform", "Help"];
var createHelp = /* @__PURE__ */ factory(name$_, dependencies$_, (_ref) => {
  var {
    typed: typed2,
    mathWithTransform: mathWithTransform2,
    Help: Help2
  } = _ref;
  return typed2(name$_, {
    any: function any(search) {
      var prop;
      var searchName = search;
      if (typeof search !== "string") {
        for (prop in mathWithTransform2) {
          if (hasOwnProperty$2(mathWithTransform2, prop) && search === mathWithTransform2[prop]) {
            searchName = prop;
            break;
          }
        }
      }
      var doc2 = getSafeProperty(embeddedDocs, searchName);
      if (!doc2) {
        var searchText = typeof searchName === "function" ? searchName.name : searchName;
        throw new Error('No documentation found on "' + searchText + '"');
      }
      return new Help2(doc2);
    }
  });
});
var name$Z = "chain";
var dependencies$Z = ["typed", "Chain"];
var createChain = /* @__PURE__ */ factory(name$Z, dependencies$Z, (_ref) => {
  var {
    typed: typed2,
    Chain: Chain2
  } = _ref;
  return typed2(name$Z, {
    "": function _() {
      return new Chain2();
    },
    any: function any(value) {
      return new Chain2(value);
    }
  });
});
var name$Y = "det";
var dependencies$Y = ["typed", "matrix", "subtract", "multiply", "divideScalar", "isZero", "unaryMinus"];
var createDet = /* @__PURE__ */ factory(name$Y, dependencies$Y, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    multiply: multiply2,
    divideScalar: divideScalar2,
    isZero: isZero2,
    unaryMinus: unaryMinus2
  } = _ref;
  return typed2(name$Y, {
    any: function any(x) {
      return clone$2(x);
    },
    "Array | Matrix": function det2(x) {
      var size2;
      if (isMatrix(x)) {
        size2 = x.size();
      } else if (Array.isArray(x)) {
        x = matrix2(x);
        size2 = x.size();
      } else {
        size2 = [];
      }
      switch (size2.length) {
        case 0:
          return clone$2(x);
        case 1:
          if (size2[0] === 1) {
            return clone$2(x.valueOf()[0]);
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            return _det(x.clone().valueOf(), rows);
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format$1(size2) + ")");
      }
    }
  });
  function _det(matrix3, rows, cols) {
    if (rows === 1) {
      return clone$2(matrix3[0][0]);
    } else if (rows === 2) {
      return subtract2(multiply2(matrix3[0][0], matrix3[1][1]), multiply2(matrix3[1][0], matrix3[0][1]));
    } else {
      var negated = false;
      var rowIndices = new Array(rows).fill(0).map((_, i3) => i3);
      for (var k = 0; k < rows; k++) {
        var k_ = rowIndices[k];
        if (isZero2(matrix3[k_][k])) {
          var _k = void 0;
          for (_k = k + 1; _k < rows; _k++) {
            if (!isZero2(matrix3[rowIndices[_k]][k])) {
              k_ = rowIndices[_k];
              rowIndices[_k] = rowIndices[k];
              rowIndices[k] = k_;
              negated = !negated;
              break;
            }
          }
          if (_k === rows)
            return matrix3[k_][k];
        }
        var piv = matrix3[k_][k];
        var piv_ = k === 0 ? 1 : matrix3[rowIndices[k - 1]][k - 1];
        for (var i2 = k + 1; i2 < rows; i2++) {
          var i_ = rowIndices[i2];
          for (var j = k + 1; j < rows; j++) {
            matrix3[i_][j] = divideScalar2(subtract2(multiply2(matrix3[i_][j], piv), multiply2(matrix3[i_][k], matrix3[k_][j])), piv_);
          }
        }
      }
      var det2 = matrix3[rowIndices[rows - 1]][rows - 1];
      return negated ? unaryMinus2(det2) : det2;
    }
  }
});
var name$X = "inv";
var dependencies$X = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
var createInv = /* @__PURE__ */ factory(name$X, dependencies$X, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    addScalar: addScalar2,
    multiply: multiply2,
    unaryMinus: unaryMinus2,
    det: det2,
    identity: identity2,
    abs: abs2
  } = _ref;
  return typed2(name$X, {
    "Array | Matrix": function ArrayMatrix(x) {
      var size2 = isMatrix(x) ? x.size() : arraySize(x);
      switch (size2.length) {
        case 1:
          if (size2[0] === 1) {
            if (isMatrix(x)) {
              return matrix2([divideScalar2(1, x.valueOf()[0])]);
            } else {
              return [divideScalar2(1, x[0])];
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            if (isMatrix(x)) {
              return matrix2(_inv(x.valueOf(), rows, cols), x.storage());
            } else {
              return _inv(x, rows, cols);
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format$1(size2) + ")");
      }
    },
    any: function any(x) {
      return divideScalar2(1, x);
    }
  });
  function _inv(mat, rows, cols) {
    var r, s, f, value, temp;
    if (rows === 1) {
      value = mat[0][0];
      if (value === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar2(1, value)]];
    } else if (rows === 2) {
      var d = det2(mat);
      if (d === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar2(mat[1][1], d), divideScalar2(unaryMinus2(mat[0][1]), d)], [divideScalar2(unaryMinus2(mat[1][0]), d), divideScalar2(mat[0][0], d)]];
    } else {
      var A = mat.concat();
      for (r = 0; r < rows; r++) {
        A[r] = A[r].concat();
      }
      var B = identity2(rows).valueOf();
      for (var c = 0; c < cols; c++) {
        var ABig = abs2(A[c][c]);
        var rBig = c;
        r = c + 1;
        while (r < rows) {
          if (abs2(A[r][c]) > ABig) {
            ABig = abs2(A[r][c]);
            rBig = r;
          }
          r++;
        }
        if (ABig === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        r = rBig;
        if (r !== c) {
          temp = A[c];
          A[c] = A[r];
          A[r] = temp;
          temp = B[c];
          B[c] = B[r];
          B[r] = temp;
        }
        var Ac = A[c];
        var Bc = B[c];
        for (r = 0; r < rows; r++) {
          var Ar = A[r];
          var Br = B[r];
          if (r !== c) {
            if (Ar[c] !== 0) {
              f = divideScalar2(unaryMinus2(Ar[c]), Ac[c]);
              for (s = c; s < cols; s++) {
                Ar[s] = addScalar2(Ar[s], multiply2(f, Ac[s]));
              }
              for (s = 0; s < cols; s++) {
                Br[s] = addScalar2(Br[s], multiply2(f, Bc[s]));
              }
            }
          } else {
            f = Ac[c];
            for (s = c; s < cols; s++) {
              Ar[s] = divideScalar2(Ar[s], f);
            }
            for (s = 0; s < cols; s++) {
              Br[s] = divideScalar2(Br[s], f);
            }
          }
        }
      }
      return B;
    }
  }
});
var name$W = "pinv";
var dependencies$W = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"];
var createPinv = /* @__PURE__ */ factory(name$W, dependencies$W, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    inv: inv2,
    deepEqual: deepEqual2,
    equal: equal2,
    dotDivide: dotDivide2,
    dot: dot2,
    ctranspose: ctranspose2,
    divideScalar: divideScalar2,
    multiply: multiply2,
    add: add2,
    Complex: Complex2
  } = _ref;
  return typed2(name$W, {
    "Array | Matrix": function ArrayMatrix(x) {
      var size2 = isMatrix(x) ? x.size() : arraySize(x);
      switch (size2.length) {
        case 1:
          if (_isZeros(x))
            return ctranspose2(x);
          if (size2[0] === 1) {
            return inv2(x);
          } else {
            return dotDivide2(ctranspose2(x), dot2(x, x));
          }
        case 2: {
          if (_isZeros(x))
            return ctranspose2(x);
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            try {
              return inv2(x);
            } catch (err) {
              if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/))
                ;
              else {
                throw err;
              }
            }
          }
          if (isMatrix(x)) {
            return matrix2(_pinv(x.valueOf(), rows, cols), x.storage());
          } else {
            return _pinv(x, rows, cols);
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format$1(size2) + ")");
      }
    },
    any: function any(x) {
      if (equal2(x, 0))
        return clone$2(x);
      return divideScalar2(1, x);
    }
  });
  function _pinv(mat, rows, cols) {
    var {
      C,
      F
    } = _rankFact(mat, rows, cols);
    var Cpinv = multiply2(inv2(multiply2(ctranspose2(C), C)), ctranspose2(C));
    var Fpinv = multiply2(ctranspose2(F), inv2(multiply2(F, ctranspose2(F))));
    return multiply2(Fpinv, Cpinv);
  }
  function _rref(mat, rows, cols) {
    var M = clone$2(mat);
    var lead = 0;
    for (var r = 0; r < rows; r++) {
      if (cols <= lead) {
        return M;
      }
      var i2 = r;
      while (_isZero(M[i2][lead])) {
        i2++;
        if (rows === i2) {
          i2 = r;
          lead++;
          if (cols === lead) {
            return M;
          }
        }
      }
      [M[i2], M[r]] = [M[r], M[i2]];
      var val = M[r][lead];
      for (var j = 0; j < cols; j++) {
        M[r][j] = dotDivide2(M[r][j], val);
      }
      for (var _i = 0; _i < rows; _i++) {
        if (_i === r)
          continue;
        val = M[_i][lead];
        for (var _j = 0; _j < cols; _j++) {
          M[_i][_j] = add2(M[_i][_j], multiply2(-1, multiply2(val, M[r][_j])));
        }
      }
      lead++;
    }
    return M;
  }
  function _rankFact(mat, rows, cols) {
    var rref = _rref(mat, rows, cols);
    var C = mat.map((_, i2) => _.filter((_2, j) => j < rows && !_isZero(dot2(rref[j], rref[j]))));
    var F = rref.filter((_, i2) => !_isZero(dot2(rref[i2], rref[i2])));
    return {
      C,
      F
    };
  }
  function _isZero(x) {
    return equal2(add2(x, Complex2(1, 1)), add2(0, Complex2(1, 1)));
  }
  function _isZeros(arr) {
    return deepEqual2(add2(arr, Complex2(1, 1)), add2(multiply2(arr, 0), Complex2(1, 1)));
  }
});
function createComplexEigs(_ref) {
  var {
    addScalar: addScalar2,
    subtract: subtract2,
    flatten: flatten4,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    sqrt: sqrt2,
    abs: abs2,
    bignumber: bignumber2,
    diag: diag2,
    inv: inv2,
    qr: qr2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    equal: equal2,
    complex: complex2,
    larger: larger2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  } = _ref;
  function complexEigs(arr, N, prec, type, findVectors) {
    if (findVectors === void 0) {
      findVectors = true;
    }
    var R = balance(arr, N, prec, type, findVectors);
    reduceToHessenberg(arr, N, prec, type, findVectors, R);
    var {
      values: values2,
      C
    } = iterateUntilTriangular(arr, N, prec, type, findVectors);
    var vectors;
    if (findVectors) {
      vectors = findEigenvectors(arr, N, C, R, values2, prec, type);
      vectors = matrixFromColumns2(...vectors);
    }
    return {
      values: values2,
      vectors
    };
  }
  function balance(arr, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var realzero = big ? bignumber2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    var realone = big ? bignumber2(1) : 1;
    var radix = big ? bignumber2(10) : 2;
    var radixSq = multiplyScalar2(radix, radix);
    var Rdiag;
    if (findVectors) {
      Rdiag = Array(N).fill(one);
    }
    var last3 = false;
    while (!last3) {
      last3 = true;
      for (var i2 = 0; i2 < N; i2++) {
        var colNorm = realzero;
        var rowNorm = realzero;
        for (var j = 0; j < N; j++) {
          if (i2 === j)
            continue;
          var c = abs2(arr[i2][j]);
          colNorm = addScalar2(colNorm, c);
          rowNorm = addScalar2(rowNorm, c);
        }
        if (!equal2(colNorm, 0) && !equal2(rowNorm, 0)) {
          var f = realone;
          var _c = colNorm;
          var rowDivRadix = divideScalar2(rowNorm, radix);
          var rowMulRadix = multiplyScalar2(rowNorm, radix);
          while (smaller2(_c, rowDivRadix)) {
            _c = multiplyScalar2(_c, radixSq);
            f = multiplyScalar2(f, radix);
          }
          while (larger2(_c, rowMulRadix)) {
            _c = divideScalar2(_c, radixSq);
            f = divideScalar2(f, radix);
          }
          var condition = smaller2(divideScalar2(addScalar2(_c, rowNorm), f), multiplyScalar2(addScalar2(colNorm, rowNorm), 0.95));
          if (condition) {
            last3 = false;
            var g = divideScalar2(1, f);
            for (var _j = 0; _j < N; _j++) {
              if (i2 === _j) {
                continue;
              }
              arr[i2][_j] = multiplyScalar2(arr[i2][_j], f);
              arr[_j][i2] = multiplyScalar2(arr[_j][i2], g);
            }
            if (findVectors) {
              Rdiag[i2] = multiplyScalar2(Rdiag[i2], f);
            }
          }
        }
      }
    }
    return diag2(Rdiag);
  }
  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero2 = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    if (big) {
      prec = bignumber2(prec);
    }
    for (var i2 = 0; i2 < N - 2; i2++) {
      var maxIndex = 0;
      var max3 = zero2;
      for (var j = i2 + 1; j < N; j++) {
        var el = arr[j][i2];
        if (smaller2(abs2(max3), abs2(el))) {
          max3 = el;
          maxIndex = j;
        }
      }
      if (smaller2(abs2(max3), prec)) {
        continue;
      }
      if (maxIndex !== i2 + 1) {
        var tmp1 = arr[maxIndex];
        arr[maxIndex] = arr[i2 + 1];
        arr[i2 + 1] = tmp1;
        for (var _j2 = 0; _j2 < N; _j2++) {
          var tmp2 = arr[_j2][maxIndex];
          arr[_j2][maxIndex] = arr[_j2][i2 + 1];
          arr[_j2][i2 + 1] = tmp2;
        }
        if (findVectors) {
          var tmp3 = R[maxIndex];
          R[maxIndex] = R[i2 + 1];
          R[i2 + 1] = tmp3;
        }
      }
      for (var _j3 = i2 + 2; _j3 < N; _j3++) {
        var n = divideScalar2(arr[_j3][i2], max3);
        if (n === 0) {
          continue;
        }
        for (var k = 0; k < N; k++) {
          arr[_j3][k] = subtract2(arr[_j3][k], multiplyScalar2(n, arr[i2 + 1][k]));
        }
        for (var _k = 0; _k < N; _k++) {
          arr[_k][i2 + 1] = addScalar2(arr[_k][i2 + 1], multiplyScalar2(n, arr[_k][_j3]));
        }
        if (findVectors) {
          for (var _k2 = 0; _k2 < N; _k2++) {
            R[_j3][_k2] = subtract2(R[_j3][_k2], multiplyScalar2(n, R[i2 + 1][_k2]));
          }
        }
      }
    }
    return R;
  }
  function iterateUntilTriangular(A, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    if (big) {
      prec = bignumber2(prec);
    }
    var arr = clone$2(A);
    var lambdas = [];
    var n = N;
    var Sdiag = [];
    var Qtotal = findVectors ? diag2(Array(N).fill(one)) : void 0;
    var Qpartial = findVectors ? diag2(Array(n).fill(one)) : void 0;
    var lastConvergenceBefore = 0;
    while (lastConvergenceBefore <= 100) {
      lastConvergenceBefore += 1;
      var k = 0;
      for (var i2 = 0; i2 < n; i2++) {
        arr[i2][i2] = subtract2(arr[i2][i2], k);
      }
      var {
        Q: Q2,
        R
      } = qr2(arr);
      arr = multiply2(R, Q2);
      for (var _i = 0; _i < n; _i++) {
        arr[_i][_i] = addScalar2(arr[_i][_i], k);
      }
      if (findVectors) {
        Qpartial = multiply2(Qpartial, Q2);
      }
      if (n === 1 || smaller2(abs2(arr[n - 1][n - 2]), prec)) {
        lastConvergenceBefore = 0;
        lambdas.push(arr[n - 1][n - 1]);
        if (findVectors) {
          Sdiag.unshift([[1]]);
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 1) {
            Qpartial = diag2(Array(n - 1).fill(one));
          }
        }
        n -= 1;
        arr.pop();
        for (var _i2 = 0; _i2 < n; _i2++) {
          arr[_i2].pop();
        }
      } else if (n === 2 || smaller2(abs2(arr[n - 2][n - 3]), prec)) {
        lastConvergenceBefore = 0;
        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
        lambdas.push(...ll);
        if (findVectors) {
          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 2) {
            Qpartial = diag2(Array(n - 2).fill(one));
          }
        }
        n -= 2;
        arr.pop();
        arr.pop();
        for (var _i3 = 0; _i3 < n; _i3++) {
          arr[_i3].pop();
          arr[_i3].pop();
        }
      }
      if (n === 0) {
        break;
      }
    }
    lambdas.sort((a, b) => +subtract2(abs2(a), abs2(b)));
    if (lastConvergenceBefore > 100) {
      var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
      err.values = lambdas;
      err.vectors = [];
      throw err;
    }
    var C = findVectors ? multiply2(Qtotal, blockDiag(Sdiag, N)) : void 0;
    return {
      values: lambdas,
      C
    };
  }
  function findEigenvectors(A, N, C, R, values2, prec, type) {
    var Cinv = inv2(C);
    var U = multiply2(Cinv, A, C);
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero2 = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    var uniqueValues = [];
    var multiplicities = [];
    for (var \u03BB of values2) {
      var i2 = indexOf2(uniqueValues, \u03BB, equal2);
      if (i2 === -1) {
        uniqueValues.push(\u03BB);
        multiplicities.push(1);
      } else {
        multiplicities[i2] += 1;
      }
    }
    var vectors = [];
    var len = uniqueValues.length;
    var b = Array(N).fill(zero2);
    var E = diag2(Array(N).fill(one));
    var failedLambdas = [];
    var _loop = function _loop2(_i42) {
      var \u03BB2 = uniqueValues[_i42];
      var S = subtract2(U, multiply2(\u03BB2, E));
      var solutions = usolveAll2(S, b);
      solutions.shift();
      while (solutions.length < multiplicities[_i42]) {
        var approxVec = inverseIterate(S, N, solutions, prec, type);
        if (approxVec == null) {
          failedLambdas.push(\u03BB2);
          break;
        }
        solutions.push(approxVec);
      }
      var correction = multiply2(inv2(R), C);
      solutions = solutions.map((v) => multiply2(correction, v));
      vectors.push(...solutions.map((v) => flatten4(v)));
    };
    for (var _i4 = 0; _i4 < len; _i4++) {
      _loop(_i4);
    }
    if (failedLambdas.length !== 0) {
      var err = new Error("Failed to find eigenvectors for the following eigenvalues: " + failedLambdas.join(", "));
      err.values = values2;
      err.vectors = vectors;
      throw err;
    }
    return vectors;
  }
  function eigenvalues2x2(a, b, c, d) {
    var trA = addScalar2(a, d);
    var detA = subtract2(multiplyScalar2(a, d), multiplyScalar2(b, c));
    var x = multiplyScalar2(trA, 0.5);
    var y = multiplyScalar2(sqrt2(subtract2(multiplyScalar2(trA, trA), multiplyScalar2(4, detA))), 0.5);
    return [addScalar2(x, y), subtract2(x, y)];
  }
  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero2 = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    if (smaller2(abs2(c), prec)) {
      return [[one, zero2], [zero2, one]];
    }
    if (larger2(abs2(subtract2(l1, l2)), prec)) {
      return [[subtract2(l1, d), subtract2(l2, d)], [c, c]];
    }
    var na = subtract2(a, l1);
    var nb = subtract2(b, l1);
    var nc = subtract2(c, l1);
    var nd = subtract2(d, l1);
    if (smaller2(abs2(nb), prec)) {
      return [[na, one], [nc, zero2]];
    } else {
      return [[nb, zero2], [nd, one]];
    }
  }
  function inflateMatrix(arr, N) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      arr[i2].push(...Array(N - arr[i2].length).fill(0));
    }
    for (var _i5 = arr.length; _i5 < N; _i5++) {
      arr.push(Array(N).fill(0));
      arr[_i5][_i5] = 1;
    }
    return arr;
  }
  function blockDiag(arr, N) {
    var M = [];
    for (var i2 = 0; i2 < N; i2++) {
      M[i2] = Array(N).fill(0);
    }
    var I = 0;
    for (var sub2 of arr) {
      var n = sub2.length;
      for (var _i6 = 0; _i6 < n; _i6++) {
        for (var j = 0; j < n; j++) {
          M[I + _i6][I + j] = sub2[_i6][j];
        }
      }
      I += n;
    }
    return M;
  }
  function indexOf2(arr, el, fn) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      if (fn(arr[i2], el)) {
        return i2;
      }
    }
    return -1;
  }
  function inverseIterate(A, N, orthog, prec, type) {
    var largeNum = type === "BigNumber" ? bignumber2(1e3) : 1e3;
    var b;
    var i2 = 0;
    while (true) {
      b = randomOrthogonalVector(N, orthog, type);
      b = usolve2(A, b);
      if (larger2(norm2(b), largeNum)) {
        break;
      }
      if (++i2 >= 5) {
        return null;
      }
    }
    i2 = 0;
    while (true) {
      var c = usolve2(A, b);
      if (smaller2(norm2(orthogonalComplement(b, [c])), prec)) {
        break;
      }
      if (++i2 >= 10) {
        return null;
      }
      b = normalize(c);
    }
    return b;
  }
  function randomOrthogonalVector(N, orthog, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var v = Array(N).fill(0).map((_) => 2 * Math.random() - 1);
    if (big) {
      v = v.map((n) => bignumber2(n));
    }
    if (cplx) {
      v = v.map((n) => complex2(n));
    }
    v = orthogonalComplement(v, orthog);
    return normalize(v, type);
  }
  function orthogonalComplement(v, orthog) {
    for (var w of orthog) {
      v = subtract2(v, multiply2(divideScalar2(dot2(w, v), dot2(w, w)), w));
    }
    return v;
  }
  function norm2(v) {
    return abs2(sqrt2(dot2(v, v)));
  }
  function normalize(v, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    return multiply2(divideScalar2(one, norm2(v)), v);
  }
  return complexEigs;
}
function createRealSymmetric(_ref) {
  var {
    config: config3,
    addScalar: addScalar2,
    subtract: subtract2,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar: multiplyScalar2,
    inv: inv2,
    bignumber: bignumber2,
    multiply: multiply2,
    add: add2
  } = _ref;
  function main(arr, N) {
    var prec = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : config3.epsilon;
    var type = arguments.length > 3 ? arguments[3] : void 0;
    if (type === "number") {
      return diag2(arr, prec);
    }
    if (type === "BigNumber") {
      return diagBig(arr, prec);
    }
    throw TypeError("Unsupported data type: " + type);
  }
  function diag2(x, precision) {
    var N = x.length;
    var e0 = Math.abs(precision / N);
    var psi;
    var Sij = new Array(N);
    for (var i2 = 0; i2 < N; i2++) {
      Sij[i2] = createArray(N, 0);
      Sij[i2][i2] = 1;
    }
    var Vab = getAij(x);
    while (Math.abs(Vab[1]) >= Math.abs(e0)) {
      var _i = Vab[0][0];
      var j = Vab[0][1];
      psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
      x = x1(x, psi, _i, j);
      Sij = Sij1(Sij, psi, _i, j);
      Vab = getAij(x);
    }
    var Ei = createArray(N, 0);
    for (var _i2 = 0; _i2 < N; _i2++) {
      Ei[_i2] = x[_i2][_i2];
    }
    return sorting(clone$2(Ei), clone$2(Sij));
  }
  function diagBig(x, precision) {
    var N = x.length;
    var e0 = abs2(precision / N);
    var psi;
    var Sij = new Array(N);
    for (var i2 = 0; i2 < N; i2++) {
      Sij[i2] = createArray(N, 0);
      Sij[i2][i2] = 1;
    }
    var Vab = getAijBig(x);
    while (abs2(Vab[1]) >= abs2(e0)) {
      var _i3 = Vab[0][0];
      var j = Vab[0][1];
      psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
      x = x1Big(x, psi, _i3, j);
      Sij = Sij1Big(Sij, psi, _i3, j);
      Vab = getAijBig(x);
    }
    var Ei = createArray(N, 0);
    for (var _i4 = 0; _i4 < N; _i4++) {
      Ei[_i4] = x[_i4][_i4];
    }
    return sorting(clone$2(Ei), clone$2(Sij));
  }
  function getTheta(aii, ajj, aij) {
    var denom = ajj - aii;
    if (Math.abs(denom) <= config3.epsilon) {
      return Math.PI / 4;
    } else {
      return 0.5 * Math.atan(2 * aij / (ajj - aii));
    }
  }
  function getThetaBig(aii, ajj, aij) {
    var denom = subtract2(ajj, aii);
    if (abs2(denom) <= config3.epsilon) {
      return bignumber2(-1).acos().div(4);
    } else {
      return multiplyScalar2(0.5, atan3(multiply2(2, aij, inv2(denom))));
    }
  }
  function Sij1(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var Ski = createArray(N, 0);
    var Skj = createArray(N, 0);
    for (var k = 0; k < N; k++) {
      Ski[k] = c * Sij[k][i2] - s * Sij[k][j];
      Skj[k] = s * Sij[k][i2] + c * Sij[k][j];
    }
    for (var _k = 0; _k < N; _k++) {
      Sij[_k][i2] = Ski[_k];
      Sij[_k][j] = Skj[_k];
    }
    return Sij;
  }
  function Sij1Big(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = cos2(theta);
    var s = sin2(theta);
    var Ski = createArray(N, bignumber2(0));
    var Skj = createArray(N, bignumber2(0));
    for (var k = 0; k < N; k++) {
      Ski[k] = subtract2(multiplyScalar2(c, Sij[k][i2]), multiplyScalar2(s, Sij[k][j]));
      Skj[k] = addScalar2(multiplyScalar2(s, Sij[k][i2]), multiplyScalar2(c, Sij[k][j]));
    }
    for (var _k2 = 0; _k2 < N; _k2++) {
      Sij[_k2][i2] = Ski[_k2];
      Sij[_k2][j] = Skj[_k2];
    }
    return Sij;
  }
  function x1Big(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = bignumber2(cos2(theta));
    var s = bignumber2(sin2(theta));
    var c2 = multiplyScalar2(c, c);
    var s2 = multiplyScalar2(s, s);
    var Aki = createArray(N, bignumber2(0));
    var Akj = createArray(N, bignumber2(0));
    var csHij = multiply2(bignumber2(2), c, s, Hij[i2][j]);
    var Aii = addScalar2(subtract2(multiplyScalar2(c2, Hij[i2][i2]), csHij), multiplyScalar2(s2, Hij[j][j]));
    var Ajj = add2(multiplyScalar2(s2, Hij[i2][i2]), csHij, multiplyScalar2(c2, Hij[j][j]));
    for (var k = 0; k < N; k++) {
      Aki[k] = subtract2(multiplyScalar2(c, Hij[i2][k]), multiplyScalar2(s, Hij[j][k]));
      Akj[k] = addScalar2(multiplyScalar2(s, Hij[i2][k]), multiplyScalar2(c, Hij[j][k]));
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = bignumber2(0);
    Hij[j][i2] = bignumber2(0);
    for (var _k3 = 0; _k3 < N; _k3++) {
      if (_k3 !== i2 && _k3 !== j) {
        Hij[i2][_k3] = Aki[_k3];
        Hij[_k3][i2] = Aki[_k3];
        Hij[j][_k3] = Akj[_k3];
        Hij[_k3][j] = Akj[_k3];
      }
    }
    return Hij;
  }
  function x1(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var c2 = c * c;
    var s2 = s * s;
    var Aki = createArray(N, 0);
    var Akj = createArray(N, 0);
    var Aii = c2 * Hij[i2][i2] - 2 * c * s * Hij[i2][j] + s2 * Hij[j][j];
    var Ajj = s2 * Hij[i2][i2] + 2 * c * s * Hij[i2][j] + c2 * Hij[j][j];
    for (var k = 0; k < N; k++) {
      Aki[k] = c * Hij[i2][k] - s * Hij[j][k];
      Akj[k] = s * Hij[i2][k] + c * Hij[j][k];
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = 0;
    Hij[j][i2] = 0;
    for (var _k4 = 0; _k4 < N; _k4++) {
      if (_k4 !== i2 && _k4 !== j) {
        Hij[i2][_k4] = Aki[_k4];
        Hij[_k4][i2] = Aki[_k4];
        Hij[j][_k4] = Akj[_k4];
        Hij[_k4][j] = Akj[_k4];
      }
    }
    return Hij;
  }
  function getAij(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2 + 1; j < N; j++) {
        if (Math.abs(maxMij) < Math.abs(Mij[i2][j])) {
          maxMij = Math.abs(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function getAijBig(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2 + 1; j < N; j++) {
        if (abs2(maxMij) < abs2(Mij[i2][j])) {
          maxMij = abs2(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function sorting(E, S) {
    var N = E.length;
    var values2 = Array(N);
    var vectors = Array(N);
    for (var k = 0; k < N; k++) {
      vectors[k] = Array(N);
    }
    for (var i2 = 0; i2 < N; i2++) {
      var minID = 0;
      var minE = E[0];
      for (var j = 0; j < E.length; j++) {
        if (abs2(E[j]) < abs2(minE)) {
          minID = j;
          minE = E[minID];
        }
      }
      values2[i2] = E.splice(minID, 1)[0];
      for (var _k5 = 0; _k5 < N; _k5++) {
        vectors[_k5][i2] = S[_k5][minID];
        S[_k5].splice(minID, 1);
      }
    }
    return {
      values: values2,
      vectors
    };
  }
  function createArray(size2, value) {
    var array = new Array(size2);
    for (var i2 = 0; i2 < size2; i2++) {
      array[i2] = value;
    }
    return array;
  }
  return main;
}
var name$V = "eigs";
var dependencies$V = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
var createEigs = /* @__PURE__ */ factory(name$V, dependencies$V, (_ref) => {
  var {
    config: config3,
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    subtract: subtract2,
    equal: equal2,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    inv: inv2,
    bignumber: bignumber2,
    multiply: multiply2,
    add: add2,
    larger: larger2,
    column: column2,
    flatten: flatten4,
    number: number2,
    complex: complex2,
    sqrt: sqrt2,
    diag: diag2,
    qr: qr2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    im: im2,
    re: re2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  } = _ref;
  var doRealSymetric = createRealSymmetric({
    config: config3,
    addScalar: addScalar2,
    subtract: subtract2,
    column: column2,
    flatten: flatten4,
    equal: equal2,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar: multiplyScalar2,
    inv: inv2,
    bignumber: bignumber2,
    complex: complex2,
    multiply: multiply2,
    add: add2
  });
  var doComplexEigs = createComplexEigs({
    config: config3,
    addScalar: addScalar2,
    subtract: subtract2,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    flatten: flatten4,
    divideScalar: divideScalar2,
    sqrt: sqrt2,
    abs: abs2,
    bignumber: bignumber2,
    diag: diag2,
    qr: qr2,
    inv: inv2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    equal: equal2,
    complex: complex2,
    larger: larger2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  });
  return typed2("eigs", {
    Array: function Array2(x) {
      var mat = matrix2(x);
      return computeValuesAndVectors(mat);
    },
    "Array, number|BigNumber": function ArrayNumberBigNumber(x, prec) {
      var mat = matrix2(x);
      return computeValuesAndVectors(mat, prec);
    },
    Matrix: function Matrix2(mat) {
      var {
        values: values2,
        vectors
      } = computeValuesAndVectors(mat);
      return {
        values: matrix2(values2),
        vectors: matrix2(vectors)
      };
    },
    "Matrix, number|BigNumber": function MatrixNumberBigNumber(mat, prec) {
      var {
        values: values2,
        vectors
      } = computeValuesAndVectors(mat, prec);
      return {
        values: matrix2(values2),
        vectors: matrix2(vectors)
      };
    }
  });
  function computeValuesAndVectors(mat, prec) {
    if (prec === void 0) {
      prec = config3.epsilon;
    }
    var size2 = mat.size();
    if (size2.length !== 2 || size2[0] !== size2[1]) {
      throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
    }
    var arr = mat.toArray();
    var N = size2[0];
    if (isReal(arr, N, prec)) {
      coerceReal(arr, N);
      if (isSymmetric(arr, N, prec)) {
        var _type = coerceTypes(mat, arr, N);
        return doRealSymetric(arr, N, prec, _type);
      }
    }
    var type = coerceTypes(mat, arr, N);
    return doComplexEigs(arr, N, prec, type);
  }
  function isSymmetric(arr, N, prec) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2; j < N; j++) {
        if (larger2(bignumber2(abs2(subtract2(arr[i2][j], arr[j][i2]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function isReal(arr, N, prec) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        if (larger2(bignumber2(abs2(im2(arr[i2][j]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function coerceReal(arr, N) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        arr[i2][j] = re2(arr[i2][j]);
      }
    }
  }
  function coerceTypes(mat, arr, N) {
    var type = mat.datatype();
    if (type === "number" || type === "BigNumber" || type === "Complex") {
      return type;
    }
    var hasNumber = false;
    var hasBig = false;
    var hasComplex = false;
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        var el = arr[i2][j];
        if (isNumber(el) || isFraction(el)) {
          hasNumber = true;
        } else if (isBigNumber(el)) {
          hasBig = true;
        } else if (isComplex(el)) {
          hasComplex = true;
        } else {
          throw TypeError("Unsupported type in Matrix: " + typeOf$1(el));
        }
      }
    }
    if (hasBig && hasComplex) {
      console.warn("Complex BigNumbers not supported, this operation will lose precission.");
    }
    if (hasComplex) {
      for (var _i = 0; _i < N; _i++) {
        for (var _j = 0; _j < N; _j++) {
          arr[_i][_j] = complex2(arr[_i][_j]);
        }
      }
      return "Complex";
    }
    if (hasBig) {
      for (var _i2 = 0; _i2 < N; _i2++) {
        for (var _j2 = 0; _j2 < N; _j2++) {
          arr[_i2][_j2] = bignumber2(arr[_i2][_j2]);
        }
      }
      return "BigNumber";
    }
    if (hasNumber) {
      for (var _i3 = 0; _i3 < N; _i3++) {
        for (var _j3 = 0; _j3 < N; _j3++) {
          arr[_i3][_j3] = number2(arr[_i3][_j3]);
        }
      }
      return "number";
    } else {
      throw TypeError("Matrix contains unsupported types only.");
    }
  }
});
var name$U = "expm";
var dependencies$U = ["typed", "abs", "add", "identity", "inv", "multiply"];
var createExpm = /* @__PURE__ */ factory(name$U, dependencies$U, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    identity: identity2,
    inv: inv2,
    multiply: multiply2
  } = _ref;
  return typed2(name$U, {
    Matrix: function Matrix2(A) {
      var size2 = A.size();
      if (size2.length !== 2 || size2[0] !== size2[1]) {
        throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
      }
      var n = size2[0];
      var eps = 1e-15;
      var infNorm = infinityNorm(A);
      var params = findParams(infNorm, eps);
      var q = params.q;
      var j = params.j;
      var Apos = multiply2(A, Math.pow(2, -j));
      var N = identity2(n);
      var D = identity2(n);
      var factor = 1;
      var AposToI = Apos;
      var alternate = -1;
      for (var i2 = 1; i2 <= q; i2++) {
        if (i2 > 1) {
          AposToI = multiply2(AposToI, Apos);
          alternate = -alternate;
        }
        factor = factor * (q - i2 + 1) / ((2 * q - i2 + 1) * i2);
        N = add2(N, multiply2(factor, AposToI));
        D = add2(D, multiply2(factor * alternate, AposToI));
      }
      var R = multiply2(inv2(D), N);
      for (var _i = 0; _i < j; _i++) {
        R = multiply2(R, R);
      }
      return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;
    }
  });
  function infinityNorm(A) {
    var n = A.size()[0];
    var infNorm = 0;
    for (var i2 = 0; i2 < n; i2++) {
      var rowSum = 0;
      for (var j = 0; j < n; j++) {
        rowSum += abs2(A.get([i2, j]));
      }
      infNorm = Math.max(rowSum, infNorm);
    }
    return infNorm;
  }
  function findParams(infNorm, eps) {
    var maxSearchSize = 30;
    for (var k = 0; k < maxSearchSize; k++) {
      for (var q = 0; q <= k; q++) {
        var j = k - q;
        if (errorEstimate(infNorm, q, j) < eps) {
          return {
            q,
            j
          };
        }
      }
    }
    throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
  }
  function errorEstimate(infNorm, q, j) {
    var qfac = 1;
    for (var i2 = 2; i2 <= q; i2++) {
      qfac *= i2;
    }
    var twoqfac = qfac;
    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {
      twoqfac *= _i2;
    }
    var twoqp1fac = twoqfac * (2 * q + 1);
    return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
  }
});
var name$T = "sqrtm";
var dependencies$T = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"];
var createSqrtm = /* @__PURE__ */ factory(name$T, dependencies$T, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    multiply: multiply2,
    map: map3,
    sqrt: sqrt2,
    subtract: subtract2,
    inv: inv2,
    size: size2,
    max: max3,
    identity: identity2
  } = _ref;
  var _maxIterations = 1e3;
  var _tolerance = 1e-6;
  function _denmanBeavers(A) {
    var error;
    var iterations = 0;
    var Y = A;
    var Z = identity2(size2(A));
    do {
      var Yk = Y;
      Y = multiply2(0.5, add2(Yk, inv2(Z)));
      Z = multiply2(0.5, add2(Z, inv2(Yk)));
      error = max3(abs2(subtract2(Y, Yk)));
      if (error > _tolerance && ++iterations > _maxIterations) {
        throw new Error("computing square root of matrix: iterative method could not converge");
      }
    } while (error > _tolerance);
    return Y;
  }
  return typed2(name$T, {
    "Array | Matrix": function ArrayMatrix(A) {
      var size3 = isMatrix(A) ? A.size() : arraySize(A);
      switch (size3.length) {
        case 1:
          if (size3[0] === 1) {
            return map3(A, sqrt2);
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size3) + ")");
          }
        case 2: {
          var rows = size3[0];
          var cols = size3[1];
          if (rows === cols) {
            return _denmanBeavers(A);
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size3) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be at most two dimensional (size: " + format$1(size3) + ")");
      }
    }
  });
});
var name$S = "divide";
var dependencies$S = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
var createDivide = /* @__PURE__ */ factory(name$S, dependencies$S, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    multiply: multiply2,
    equalScalar: equalScalar2,
    divideScalar: divideScalar2,
    inv: inv2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  return typed2("divide", extend({
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(x, y) {
      return multiply2(x, inv2(y));
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return matAlgo14xDs(x, y, divideScalar2, false);
    },
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return matAlgo11xS0s(x, y, divideScalar2, false);
    },
    "Array, any": function ArrayAny(x, y) {
      return matAlgo14xDs(matrix2(x), y, divideScalar2, false).valueOf();
    },
    "any, Array | Matrix": function anyArrayMatrix(x, y) {
      return multiply2(x, inv2(y));
    }
  }, divideScalar2.signatures));
});
var name$R = "distance";
var dependencies$R = ["typed", "addScalar", "subtract", "divideScalar", "multiplyScalar", "unaryMinus", "sqrt", "abs"];
var createDistance = /* @__PURE__ */ factory(name$R, dependencies$R, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    subtract: subtract2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    unaryMinus: unaryMinus2,
    sqrt: sqrt2,
    abs: abs2
  } = _ref;
  return typed2(name$R, {
    "Array, Array, Array": function ArrayArrayArray(x, y, z) {
      if (x.length === 2 && y.length === 2 && z.length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_2d(y)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
        }
        if (!_2d(z)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
        }
        var m = divideScalar2(subtract2(z[1], z[0]), subtract2(y[1], y[0]));
        var xCoeff = multiplyScalar2(multiplyScalar2(m, m), y[0]);
        var yCoeff = unaryMinus2(multiplyScalar2(m, y[0]));
        var constant = x[1];
        return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object, Object": function ObjectObjectObject(x, y, z) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
        }
        if (!_2d(z)) {
          throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "lineOnePtX" in y && "lineOnePtY" in y && "lineTwoPtX" in z && "lineTwoPtY" in z) {
          var m = divideScalar2(subtract2(z.lineTwoPtY, z.lineTwoPtX), subtract2(y.lineOnePtY, y.lineOnePtX));
          var xCoeff = multiplyScalar2(multiplyScalar2(m, m), y.lineOnePtX);
          var yCoeff = unaryMinus2(multiplyScalar2(m, y.lineOnePtX));
          var constant = x.pointX;
          return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Array, Array": function ArrayArray(x, y) {
      if (x.length === 2 && y.length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_3d(y)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
      } else if (x.length === 3 && y.length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
      } else if (x.length === y.length && x.length > 0) {
        if (!_containsOnlyNumbers(x)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        if (!_containsOnlyNumbers(y)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        return _euclideanDistance(x, y);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object": function ObjectObject(x, y) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "xCoeffLine" in y && "yCoeffLine" in y && "constant" in y) {
          return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "x0" in y && "y0" in y && "z0" in y && "a" in y && "b" in y && "c" in y) {
          return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointTwoX" in y && "pointTwoY" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY], [y.pointTwoX, y.pointTwoY]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointOneZ" in x && "pointTwoX" in y && "pointTwoY" in y && "pointTwoZ" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y.pointTwoX, y.pointTwoY, y.pointTwoZ]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    Array: function Array2(arr) {
      if (!_pairwise(arr)) {
        throw new TypeError("Incorrect array format entered for pairwise distance calculation");
      }
      return _distancePairwise(arr);
    }
  });
  function _isNumber(a) {
    return typeof a === "number" || isBigNumber(a);
  }
  function _2d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]);
  }
  function _3d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
  }
  function _containsOnlyNumbers(a) {
    if (!Array.isArray(a)) {
      a = _objectToArray(a);
    }
    return a.every(_isNumber);
  }
  function _parametricLine(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
  }
  function _objectToArray(o) {
    var keys2 = Object.keys(o);
    var a = [];
    for (var i2 = 0; i2 < keys2.length; i2++) {
      a.push(o[keys2[i2]]);
    }
    return a;
  }
  function _pairwise(a) {
    if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
      if (a.some((aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
        return false;
      }
    } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
      if (a.some((aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
        return false;
      }
    } else {
      return false;
    }
    return true;
  }
  function _distancePointLine2D(x, y, a, b, c) {
    var num = abs2(addScalar2(addScalar2(multiplyScalar2(a, x), multiplyScalar2(b, y)), c));
    var den = sqrt2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)));
    return divideScalar2(num, den);
  }
  function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
    var num = [subtract2(multiplyScalar2(subtract2(y0, y), c), multiplyScalar2(subtract2(z0, z), b)), subtract2(multiplyScalar2(subtract2(z0, z), a), multiplyScalar2(subtract2(x0, x), c)), subtract2(multiplyScalar2(subtract2(x0, x), b), multiplyScalar2(subtract2(y0, y), a))];
    num = sqrt2(addScalar2(addScalar2(multiplyScalar2(num[0], num[0]), multiplyScalar2(num[1], num[1])), multiplyScalar2(num[2], num[2])));
    var den = sqrt2(addScalar2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)), multiplyScalar2(c, c)));
    return divideScalar2(num, den);
  }
  function _euclideanDistance(x, y) {
    var vectorSize = x.length;
    var result = 0;
    var diff2 = 0;
    for (var i2 = 0; i2 < vectorSize; i2++) {
      diff2 = subtract2(x[i2], y[i2]);
      result = addScalar2(multiplyScalar2(diff2, diff2), result);
    }
    return sqrt2(result);
  }
  function _distancePairwise(a) {
    var result = [];
    var pointA = [];
    var pointB = [];
    for (var i2 = 0; i2 < a.length - 1; i2++) {
      for (var j = i2 + 1; j < a.length; j++) {
        if (a[0].length === 2) {
          pointA = [a[i2][0], a[i2][1]];
          pointB = [a[j][0], a[j][1]];
        } else if (a[0].length === 3) {
          pointA = [a[i2][0], a[i2][1], a[i2][2]];
          pointB = [a[j][0], a[j][1], a[j][2]];
        }
        result.push(_euclideanDistance(pointA, pointB));
      }
    }
    return result;
  }
});
var name$Q = "intersect";
var dependencies$Q = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"];
var createIntersect = /* @__PURE__ */ factory(name$Q, dependencies$Q, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    abs: abs2,
    add: add2,
    addScalar: addScalar2,
    matrix: matrix2,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    subtract: subtract2,
    smaller: smaller2,
    equalScalar: equalScalar2,
    flatten: flatten4,
    isZero: isZero2,
    isNumeric: isNumeric2
  } = _ref;
  return typed2("intersect", {
    "Array, Array, Array": _AAA,
    "Array, Array, Array, Array": _AAAA,
    "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(x, y, plane) {
      var arr = _AAA(x.valueOf(), y.valueOf(), plane.valueOf());
      return arr === null ? null : matrix2(arr);
    },
    "Matrix, Matrix, Matrix, Matrix": function MatrixMatrixMatrixMatrix(w, x, y, z) {
      var arr = _AAAA(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf());
      return arr === null ? null : matrix2(arr);
    }
  });
  function _AAA(x, y, plane) {
    x = _coerceArr(x);
    y = _coerceArr(y);
    plane = _coerceArr(plane);
    if (!_3d(x)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
    }
    if (!_3d(y)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
    }
    if (!_4d(plane)) {
      throw new TypeError("Array with 4 numbers expected as third argument");
    }
    return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
  }
  function _AAAA(w, x, y, z) {
    w = _coerceArr(w);
    x = _coerceArr(x);
    y = _coerceArr(y);
    z = _coerceArr(z);
    if (w.length === 2) {
      if (!_2d(w)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
      }
      if (!_2d(x)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
      }
      if (!_2d(y)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
      }
      if (!_2d(z)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect2d(w, x, y, z);
    } else if (w.length === 3) {
      if (!_3d(w)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
      }
      if (!_3d(x)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
      }
      if (!_3d(y)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
      }
      if (!_3d(z)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
    } else {
      throw new TypeError("Arrays with two or thee dimensional points expected");
    }
  }
  function _coerceArr(arr) {
    if (arr.length === 1)
      return arr[0];
    if (arr.length > 1 && Array.isArray(arr[0])) {
      if (arr.every((el) => Array.isArray(el) && el.length === 1))
        return flatten4(arr);
    }
    return arr;
  }
  function _2d(x) {
    return x.length === 2 && isNumeric2(x[0]) && isNumeric2(x[1]);
  }
  function _3d(x) {
    return x.length === 3 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]);
  }
  function _4d(x) {
    return x.length === 4 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]) && isNumeric2(x[3]);
  }
  function _intersect2d(p1a, p1b, p2a, p2b) {
    var o1 = p1a;
    var o2 = p2a;
    var d1 = subtract2(o1, p1b);
    var d2 = subtract2(o2, p2b);
    var det2 = subtract2(multiplyScalar2(d1[0], d2[1]), multiplyScalar2(d2[0], d1[1]));
    if (isZero2(det2))
      return null;
    if (smaller2(abs2(det2), config3.epsilon)) {
      return null;
    }
    var d20o11 = multiplyScalar2(d2[0], o1[1]);
    var d21o10 = multiplyScalar2(d2[1], o1[0]);
    var d20o21 = multiplyScalar2(d2[0], o2[1]);
    var d21o20 = multiplyScalar2(d2[1], o2[0]);
    var t = divideScalar2(addScalar2(subtract2(subtract2(d20o11, d21o10), d20o21), d21o20), det2);
    return add2(multiply2(d1, t), o1);
  }
  function _intersect3dHelper(a, b, c, d, e2, f, g, h2, i2, j, k, l) {
    var add1 = multiplyScalar2(subtract2(a, b), subtract2(c, d));
    var add22 = multiplyScalar2(subtract2(e2, f), subtract2(g, h2));
    var add3 = multiplyScalar2(subtract2(i2, j), subtract2(k, l));
    return addScalar2(addScalar2(add1, add22), add3);
  }
  function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
    var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
    var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
    var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
    var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
    var numerator = subtract2(multiplyScalar2(d1343, d4321), multiplyScalar2(d1321, d4343));
    var denominator = subtract2(multiplyScalar2(d2121, d4343), multiplyScalar2(d4321, d4321));
    if (isZero2(denominator))
      return null;
    var ta = divideScalar2(numerator, denominator);
    var tb = divideScalar2(addScalar2(d1343, multiplyScalar2(ta, d4321)), d4343);
    var pax = addScalar2(x1, multiplyScalar2(ta, subtract2(x2, x1)));
    var pay = addScalar2(y1, multiplyScalar2(ta, subtract2(y2, y1)));
    var paz = addScalar2(z1, multiplyScalar2(ta, subtract2(z2, z1)));
    var pbx = addScalar2(x3, multiplyScalar2(tb, subtract2(x4, x3)));
    var pby = addScalar2(y3, multiplyScalar2(tb, subtract2(y4, y3)));
    var pbz = addScalar2(z3, multiplyScalar2(tb, subtract2(z4, z3)));
    if (equalScalar2(pax, pbx) && equalScalar2(pay, pby) && equalScalar2(paz, pbz)) {
      return [pax, pay, paz];
    } else {
      return null;
    }
  }
  function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
    var x1x = multiplyScalar2(x1, x);
    var x2x = multiplyScalar2(x2, x);
    var y1y = multiplyScalar2(y1, y);
    var y2y = multiplyScalar2(y2, y);
    var z1z = multiplyScalar2(z1, z);
    var z2z = multiplyScalar2(z2, z);
    var numerator = subtract2(subtract2(subtract2(c, x1x), y1y), z1z);
    var denominator = subtract2(subtract2(subtract2(addScalar2(addScalar2(x2x, y2y), z2z), x1x), y1y), z1z);
    var t = divideScalar2(numerator, denominator);
    var px = addScalar2(x1, multiplyScalar2(t, subtract2(x2, x1)));
    var py = addScalar2(y1, multiplyScalar2(t, subtract2(y2, y1)));
    var pz = addScalar2(z1, multiplyScalar2(t, subtract2(z2, z1)));
    return [px, py, pz];
  }
});
var name$P = "sum";
var dependencies$P = ["typed", "config", "add", "numeric"];
var createSum = /* @__PURE__ */ factory(name$P, dependencies$P, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    add: add2,
    numeric: numeric3
  } = _ref;
  return typed2(name$P, {
    "Array | Matrix": _sum,
    "Array | Matrix, number | BigNumber": _nsumDim,
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function sum");
      }
      return _sum(args);
    }
  });
  function _sum(array) {
    var sum2;
    deepForEach(array, function(value) {
      try {
        sum2 = sum2 === void 0 ? value : add2(sum2, value);
      } catch (err) {
        throw improveErrorMessage(err, "sum", value);
      }
    });
    if (sum2 === void 0) {
      sum2 = numeric3(0, config3.number);
    }
    if (typeof sum2 === "string") {
      sum2 = numeric3(sum2, config3.number);
    }
    return sum2;
  }
  function _nsumDim(array, dim) {
    try {
      var sum2 = reduce$1(array, dim, add2);
      return sum2;
    } catch (err) {
      throw improveErrorMessage(err, "sum");
    }
  }
});
var name$O = "cumsum";
var dependencies$O = ["typed", "add", "unaryPlus"];
var createCumSum = /* @__PURE__ */ factory(name$O, dependencies$O, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    unaryPlus: unaryPlus2
  } = _ref;
  return typed2(name$O, {
    Array: _cumsum,
    Matrix: function Matrix2(matrix2) {
      return matrix2.create(_cumsum(matrix2.valueOf()));
    },
    "Array, number | BigNumber": _ncumSumDim,
    "Matrix, number | BigNumber": function MatrixNumberBigNumber(matrix2, dim) {
      return matrix2.create(_ncumSumDim(matrix2.valueOf(), dim));
    },
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("All values expected to be scalar in function cumsum");
      }
      return _cumsum(args);
    }
  });
  function _cumsum(array) {
    try {
      return _cumsummap(array);
    } catch (err) {
      throw improveErrorMessage(err, name$O);
    }
  }
  function _cumsummap(array) {
    if (array.length === 0) {
      return [];
    }
    var sums = [unaryPlus2(array[0])];
    for (var i2 = 1; i2 < array.length; ++i2) {
      sums.push(add2(sums[i2 - 1], array[i2]));
    }
    return sums;
  }
  function _ncumSumDim(array, dim) {
    var size2 = arraySize(array);
    if (dim < 0 || dim >= size2.length) {
      throw new IndexError(dim, size2.length);
    }
    try {
      return _cumsumDimensional(array, dim);
    } catch (err) {
      throw improveErrorMessage(err, name$O);
    }
  }
  function _cumsumDimensional(mat, dim) {
    var i2, ret, tran;
    if (dim <= 0) {
      var initialValue = mat[0][0];
      if (!Array.isArray(initialValue)) {
        return _cumsummap(mat);
      } else {
        tran = _switch$1(mat);
        ret = [];
        for (i2 = 0; i2 < tran.length; i2++) {
          ret[i2] = _cumsumDimensional(tran[i2], dim - 1);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i2 = 0; i2 < mat.length; i2++) {
        ret[i2] = _cumsumDimensional(mat[i2], dim - 1);
      }
      return ret;
    }
  }
});
var name$N = "mean";
var dependencies$N = ["typed", "add", "divide"];
var createMean = /* @__PURE__ */ factory(name$N, dependencies$N, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    divide: divide2
  } = _ref;
  return typed2(name$N, {
    "Array | Matrix": _mean,
    "Array | Matrix, number | BigNumber": _nmeanDim,
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function mean");
      }
      return _mean(args);
    }
  });
  function _nmeanDim(array, dim) {
    try {
      var sum2 = reduce$1(array, dim, add2);
      var s = Array.isArray(array) ? arraySize(array) : array.size();
      return divide2(sum2, s[dim]);
    } catch (err) {
      throw improveErrorMessage(err, "mean");
    }
  }
  function _mean(array) {
    var sum2;
    var num = 0;
    deepForEach(array, function(value) {
      try {
        sum2 = sum2 === void 0 ? value : add2(sum2, value);
        num++;
      } catch (err) {
        throw improveErrorMessage(err, "mean", value);
      }
    });
    if (num === 0) {
      throw new Error("Cannot calculate the mean of an empty array");
    }
    return divide2(sum2, num);
  }
});
var name$M = "median";
var dependencies$M = ["typed", "add", "divide", "compare", "partitionSelect"];
var createMedian = /* @__PURE__ */ factory(name$M, dependencies$M, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    divide: divide2,
    compare: compare2,
    partitionSelect: partitionSelect2
  } = _ref;
  function _median(array) {
    try {
      array = flatten$1(array.valueOf());
      var num = array.length;
      if (num === 0) {
        throw new Error("Cannot calculate median of an empty array");
      }
      if (num % 2 === 0) {
        var mid = num / 2 - 1;
        var right = partitionSelect2(array, mid + 1);
        var left = array[mid];
        for (var i2 = 0; i2 < mid; ++i2) {
          if (compare2(array[i2], left) > 0) {
            left = array[i2];
          }
        }
        return middle2(left, right);
      } else {
        var m = partitionSelect2(array, (num - 1) / 2);
        return middle(m);
      }
    } catch (err) {
      throw improveErrorMessage(err, "median");
    }
  }
  var middle = typed2({
    "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(value) {
      return value;
    }
  });
  var middle2 = typed2({
    "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function numberBigNumberComplexUnitNumberBigNumberComplexUnit(left, right) {
      return divide2(add2(left, right), 2);
    }
  });
  return typed2(name$M, {
    "Array | Matrix": _median,
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      throw new Error("median(A, dim) is not yet supported");
    },
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function median");
      }
      return _median(args);
    }
  });
});
var name$L = "mad";
var dependencies$L = ["typed", "abs", "map", "median", "subtract"];
var createMad = /* @__PURE__ */ factory(name$L, dependencies$L, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    map: map3,
    median: median2,
    subtract: subtract2
  } = _ref;
  return typed2(name$L, {
    "Array | Matrix": _mad,
    "...": function _(args) {
      return _mad(args);
    }
  });
  function _mad(array) {
    array = flatten$1(array.valueOf());
    if (array.length === 0) {
      throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
    }
    try {
      var med = median2(array);
      return median2(map3(array, function(value) {
        return abs2(subtract2(value, med));
      }));
    } catch (err) {
      if (err instanceof TypeError && err.message.indexOf("median") !== -1) {
        throw new TypeError(err.message.replace("median", "mad"));
      } else {
        throw improveErrorMessage(err, "mad");
      }
    }
  }
});
var DEFAULT_NORMALIZATION = "unbiased";
var name$K = "variance";
var dependencies$K = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
var createVariance = /* @__PURE__ */ factory(name$K, dependencies$K, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    apply: apply2,
    isNaN: isNaN2
  } = _ref;
  return typed2(name$K, {
    "Array | Matrix": function ArrayMatrix(array) {
      return _var(array, DEFAULT_NORMALIZATION);
    },
    "Array | Matrix, string": _var,
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      return _varDim(array, dim, DEFAULT_NORMALIZATION);
    },
    "Array | Matrix, number | BigNumber, string": _varDim,
    "...": function _(args) {
      return _var(args, DEFAULT_NORMALIZATION);
    }
  });
  function _var(array, normalization) {
    var sum2;
    var num = 0;
    if (array.length === 0) {
      throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
    }
    deepForEach(array, function(value) {
      try {
        sum2 = sum2 === void 0 ? value : add2(sum2, value);
        num++;
      } catch (err) {
        throw improveErrorMessage(err, "variance", value);
      }
    });
    if (num === 0)
      throw new Error("Cannot calculate variance of an empty array");
    var mean2 = divide2(sum2, num);
    sum2 = void 0;
    deepForEach(array, function(value) {
      var diff2 = subtract2(value, mean2);
      sum2 = sum2 === void 0 ? multiply2(diff2, diff2) : add2(sum2, multiply2(diff2, diff2));
    });
    if (isNaN2(sum2)) {
      return sum2;
    }
    switch (normalization) {
      case "uncorrected":
        return divide2(sum2, num);
      case "biased":
        return divide2(sum2, num + 1);
      case "unbiased": {
        var zero2 = isBigNumber(sum2) ? sum2.mul(0) : 0;
        return num === 1 ? zero2 : divide2(sum2, num - 1);
      }
      default:
        throw new Error('Unknown normalization "' + normalization + '". Choose "unbiased" (default), "uncorrected", or "biased".');
    }
  }
  function _varDim(array, dim, normalization) {
    try {
      if (array.length === 0) {
        throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
      }
      return apply2(array, dim, (x) => _var(x, normalization));
    } catch (err) {
      throw improveErrorMessage(err, "variance");
    }
  }
});
var name$J = "quantileSeq";
var dependencies$J = ["typed", "add", "multiply", "partitionSelect", "compare"];
var createQuantileSeq = /* @__PURE__ */ factory(name$J, dependencies$J, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    multiply: multiply2,
    partitionSelect: partitionSelect2,
    compare: compare2
  } = _ref;
  function quantileSeq2(data, probOrN, sorted) {
    var probArr, dataArr, one;
    if (arguments.length < 2 || arguments.length > 3) {
      throw new SyntaxError("Function quantileSeq requires two or three parameters");
    }
    if (isCollection$1(data)) {
      sorted = sorted || false;
      if (typeof sorted === "boolean") {
        dataArr = data.valueOf();
        if (isNumber(probOrN)) {
          if (probOrN < 0) {
            throw new Error("N/prob must be non-negative");
          }
          if (probOrN <= 1) {
            return _quantileSeq(dataArr, probOrN, sorted);
          }
          if (probOrN > 1) {
            if (!isInteger$1(probOrN)) {
              throw new Error("N must be a positive integer");
            }
            var nPlusOne = probOrN + 1;
            probArr = new Array(probOrN);
            for (var i2 = 0; i2 < probOrN; ) {
              probArr[i2] = _quantileSeq(dataArr, ++i2 / nPlusOne, sorted);
            }
            return probArr;
          }
        }
        if (isBigNumber(probOrN)) {
          var BigNumber2 = probOrN.constructor;
          if (probOrN.isNegative()) {
            throw new Error("N/prob must be non-negative");
          }
          one = new BigNumber2(1);
          if (probOrN.lte(one)) {
            return new BigNumber2(_quantileSeq(dataArr, probOrN, sorted));
          }
          if (probOrN.gt(one)) {
            if (!probOrN.isInteger()) {
              throw new Error("N must be a positive integer");
            }
            var intN = probOrN.toNumber();
            if (intN > 4294967295) {
              throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
            }
            var _nPlusOne = new BigNumber2(intN + 1);
            probArr = new Array(intN);
            for (var _i = 0; _i < intN; ) {
              probArr[_i] = new BigNumber2(_quantileSeq(dataArr, new BigNumber2(++_i).div(_nPlusOne), sorted));
            }
            return probArr;
          }
        }
        if (Array.isArray(probOrN)) {
          probArr = new Array(probOrN.length);
          for (var _i2 = 0; _i2 < probArr.length; ++_i2) {
            var currProb = probOrN[_i2];
            if (isNumber(currProb)) {
              if (currProb < 0 || currProb > 1) {
                throw new Error("Probability must be between 0 and 1, inclusive");
              }
            } else if (isBigNumber(currProb)) {
              one = new currProb.constructor(1);
              if (currProb.isNegative() || currProb.gt(one)) {
                throw new Error("Probability must be between 0 and 1, inclusive");
              }
            } else {
              throw new TypeError("Unexpected type of argument in function quantileSeq");
            }
            probArr[_i2] = _quantileSeq(dataArr, currProb, sorted);
          }
          return probArr;
        }
        throw new TypeError("Unexpected type of argument in function quantileSeq");
      }
      throw new TypeError("Unexpected type of argument in function quantileSeq");
    }
    throw new TypeError("Unexpected type of argument in function quantileSeq");
  }
  function _quantileSeq(array, prob, sorted) {
    var flat = flatten$1(array);
    var len = flat.length;
    if (len === 0) {
      throw new Error("Cannot calculate quantile of an empty sequence");
    }
    if (isNumber(prob)) {
      var _index = prob * (len - 1);
      var _fracPart = _index % 1;
      if (_fracPart === 0) {
        var value = sorted ? flat[_index] : partitionSelect2(flat, _index);
        validate2(value);
        return value;
      }
      var _integerPart = Math.floor(_index);
      var _left;
      var _right;
      if (sorted) {
        _left = flat[_integerPart];
        _right = flat[_integerPart + 1];
      } else {
        _right = partitionSelect2(flat, _integerPart + 1);
        _left = flat[_integerPart];
        for (var i2 = 0; i2 < _integerPart; ++i2) {
          if (compare2(flat[i2], _left) > 0) {
            _left = flat[i2];
          }
        }
      }
      validate2(_left);
      validate2(_right);
      return add2(multiply2(_left, 1 - _fracPart), multiply2(_right, _fracPart));
    }
    var index2 = prob.times(len - 1);
    if (index2.isInteger()) {
      index2 = index2.toNumber();
      var _value = sorted ? flat[index2] : partitionSelect2(flat, index2);
      validate2(_value);
      return _value;
    }
    var integerPart = index2.floor();
    var fracPart = index2.minus(integerPart);
    var integerPartNumber = integerPart.toNumber();
    var left;
    var right;
    if (sorted) {
      left = flat[integerPartNumber];
      right = flat[integerPartNumber + 1];
    } else {
      right = partitionSelect2(flat, integerPartNumber + 1);
      left = flat[integerPartNumber];
      for (var _i3 = 0; _i3 < integerPartNumber; ++_i3) {
        if (compare2(flat[_i3], left) > 0) {
          left = flat[_i3];
        }
      }
    }
    validate2(left);
    validate2(right);
    var one = new fracPart.constructor(1);
    return add2(multiply2(left, one.minus(fracPart)), multiply2(right, fracPart));
  }
  var validate2 = typed2({
    "number | BigNumber | Unit": function numberBigNumberUnit(x) {
      return x;
    }
  });
  return quantileSeq2;
});
var name$I = "std";
var dependencies$I = ["typed", "map", "sqrt", "variance"];
var createStd = /* @__PURE__ */ factory(name$I, dependencies$I, (_ref) => {
  var {
    typed: typed2,
    map: map3,
    sqrt: sqrt2,
    variance: variance2
  } = _ref;
  return typed2(name$I, {
    "Array | Matrix": _std,
    "Array | Matrix, string": _std,
    "Array | Matrix, number | BigNumber": _std,
    "Array | Matrix, number | BigNumber, string": _std,
    "...": function _(args) {
      return _std(args);
    }
  });
  function _std(array, normalization) {
    if (array.length === 0) {
      throw new SyntaxError("Function std requires one or more parameters (0 provided)");
    }
    try {
      var v = variance2.apply(null, arguments);
      if (isCollection$1(v)) {
        return map3(v, sqrt2);
      } else {
        return sqrt2(v);
      }
    } catch (err) {
      if (err instanceof TypeError && err.message.indexOf(" variance") !== -1) {
        throw new TypeError(err.message.replace(" variance", " std"));
      } else {
        throw err;
      }
    }
  }
});
var name$H = "combinations";
var dependencies$H = ["typed"];
var createCombinations = /* @__PURE__ */ factory(name$H, dependencies$H, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$H, {
    "number, number": combinationsNumber,
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
      var BigNumber2 = n.constructor;
      var result, i2;
      var nMinusk = n.minus(k);
      var one = new BigNumber2(1);
      if (!isPositiveInteger$2(n) || !isPositiveInteger$2(k)) {
        throw new TypeError("Positive integer value expected in function combinations");
      }
      if (k.gt(n)) {
        throw new TypeError("k must be less than n in function combinations");
      }
      result = one;
      if (k.lt(nMinusk)) {
        for (i2 = one; i2.lte(nMinusk); i2 = i2.plus(one)) {
          result = result.times(k.plus(i2)).dividedBy(i2);
        }
      } else {
        for (i2 = one; i2.lte(k); i2 = i2.plus(one)) {
          result = result.times(nMinusk.plus(i2)).dividedBy(i2);
        }
      }
      return result;
    }
  });
});
function isPositiveInteger$2(n) {
  return n.isInteger() && n.gte(0);
}
var name$G = "combinationsWithRep";
var dependencies$G = ["typed"];
var createCombinationsWithRep = /* @__PURE__ */ factory(name$G, dependencies$G, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$G, {
    "number, number": function numberNumber(n, k) {
      if (!isInteger$1(n) || n < 0) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (!isInteger$1(k) || k < 0) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (n < 1) {
        throw new TypeError("k must be less than or equal to n + k - 1");
      }
      if (k < n - 1) {
        var _prodrange = product(n, n + k - 1);
        return _prodrange / product(1, k);
      }
      var prodrange = product(k + 1, n + k - 1);
      return prodrange / product(1, n - 1);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
      var BigNumber2 = n.constructor;
      var result, i2;
      var one = new BigNumber2(1);
      var nMinusOne = n.minus(one);
      if (!isPositiveInteger$1(n) || !isPositiveInteger$1(k)) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (n.lt(one)) {
        throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
      }
      result = one;
      if (k.lt(nMinusOne)) {
        for (i2 = one; i2.lte(nMinusOne); i2 = i2.plus(one)) {
          result = result.times(k.plus(i2)).dividedBy(i2);
        }
      } else {
        for (i2 = one; i2.lte(k); i2 = i2.plus(one)) {
          result = result.times(nMinusOne.plus(i2)).dividedBy(i2);
        }
      }
      return result;
    }
  });
});
function isPositiveInteger$1(n) {
  return n.isInteger() && n.gte(0);
}
var name$F = "gamma";
var dependencies$F = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
var createGamma = /* @__PURE__ */ factory(name$F, dependencies$F, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    multiplyScalar: multiplyScalar2,
    pow: pow2,
    BigNumber: _BigNumber,
    Complex: Complex2
  } = _ref;
  function gammaComplex(n) {
    if (n.im === 0) {
      return gammaNumber(n.re);
    }
    if (n.re < 0.5) {
      var _t = new Complex2(1 - n.re, -n.im);
      var r = new Complex2(Math.PI * n.re, Math.PI * n.im);
      return new Complex2(Math.PI).div(r.sin()).div(gammaComplex(_t));
    }
    n = new Complex2(n.re - 1, n.im);
    var x = new Complex2(gammaP[0], 0);
    for (var i2 = 1; i2 < gammaP.length; ++i2) {
      var gammaPval = new Complex2(gammaP[i2], 0);
      x = x.add(gammaPval.div(n.add(i2)));
    }
    var t = new Complex2(n.re + gammaG + 0.5, n.im);
    var twoPiSqrt = Math.sqrt(2 * Math.PI);
    var tpow = t.pow(n.add(0.5));
    var expt = t.neg().exp();
    return x.mul(twoPiSqrt).mul(tpow).mul(expt);
  }
  return typed2(name$F, {
    number: gammaNumber,
    Complex: gammaComplex,
    BigNumber: function BigNumber2(n) {
      if (n.isInteger()) {
        return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
      }
      if (!n.isFinite()) {
        return new _BigNumber(n.isNegative() ? NaN : Infinity);
      }
      throw new Error("Integer BigNumber expected");
    }
  });
  function bigFactorial(n) {
    if (n < 8) {
      return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
    }
    var precision = config3.precision + (Math.log(n.toNumber()) | 0);
    var Big = _BigNumber.clone({
      precision
    });
    if (n % 2 === 1) {
      return n.times(bigFactorial(new _BigNumber(n - 1)));
    }
    var p2 = n;
    var prod2 = new Big(n);
    var sum2 = n.toNumber();
    while (p2 > 2) {
      p2 -= 2;
      sum2 += p2;
      prod2 = prod2.times(sum2);
    }
    return new _BigNumber(prod2.toPrecision(_BigNumber.precision));
  }
});
var name$E = "lgamma";
var dependencies$E = ["Complex", "typed"];
var createLgamma = /* @__PURE__ */ factory(name$E, dependencies$E, (_ref) => {
  var {
    Complex: Complex2,
    typed: typed2
  } = _ref;
  var SMALL_RE = 7;
  var SMALL_IM = 7;
  var coeffs = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 8417508417508417e-19, -5952380952380953e-19, 7936507936507937e-19, -0.002777777777777778, 0.08333333333333333];
  return typed2(name$E, {
    number: lgammaNumber,
    Complex: lgammaComplex,
    BigNumber: function BigNumber2() {
      throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
    }
  });
  function lgammaComplex(n) {
    var TWOPI = 6.283185307179586;
    var LOGPI = 1.1447298858494002;
    var REFLECTION = 0.1;
    if (n.isNaN()) {
      return new Complex2(NaN, NaN);
    } else if (n.im === 0) {
      return new Complex2(lgammaNumber(n.re), 0);
    } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
      return lgammaStirling(n);
    } else if (n.re <= REFLECTION) {
      var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
      var a = n.mul(Math.PI).sin().log();
      var b = lgammaComplex(new Complex2(1 - n.re, -n.im));
      return new Complex2(LOGPI, tmp).sub(a).sub(b);
    } else if (n.im >= 0) {
      return lgammaRecurrence(n);
    } else {
      return lgammaRecurrence(n.conjugate()).conjugate();
    }
  }
  function lgammaStirling(z) {
    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);
    var rz = new Complex2(1, 0).div(z);
    var rzz = rz.div(z);
    var a = coeffs[0];
    var b = coeffs[1];
    var r = 2 * rzz.re;
    var s = rzz.re * rzz.re + rzz.im * rzz.im;
    for (var i2 = 2; i2 < 8; i2++) {
      var tmp = b;
      b = -s * a + coeffs[i2];
      a = r * a + tmp;
    }
    var rightPart = rz.mul(rzz.mul(a).add(b));
    return leftPart.add(rightPart);
  }
  function lgammaRecurrence(z) {
    var signflips = 0;
    var sb = 0;
    var shiftprod = z;
    z = z.add(1);
    while (z.re <= SMALL_RE) {
      shiftprod = shiftprod.mul(z);
      var nsb = shiftprod.im < 0 ? 1 : 0;
      if (nsb !== 0 && sb === 0)
        signflips++;
      sb = nsb;
      z = z.add(1);
    }
    return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex2(0, signflips * 2 * Math.PI * 1));
  }
});
var name$D = "factorial";
var dependencies$D = ["typed", "gamma"];
var createFactorial = /* @__PURE__ */ factory(name$D, dependencies$D, (_ref) => {
  var {
    typed: typed2,
    gamma: gamma2
  } = _ref;
  return typed2(name$D, {
    number: function number2(n) {
      if (n < 0) {
        throw new Error("Value must be non-negative");
      }
      return gamma2(n + 1);
    },
    BigNumber: function BigNumber2(n) {
      if (n.isNegative()) {
        throw new Error("Value must be non-negative");
      }
      return gamma2(n.plus(1));
    },
    "Array | Matrix": typed2.referToSelf((self2) => (n) => deepMap(n, self2))
  });
});
var name$C = "kldivergence";
var dependencies$C = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"];
var createKldivergence = /* @__PURE__ */ factory(name$C, dependencies$C, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divide: divide2,
    sum: sum2,
    multiply: multiply2,
    map: map3,
    dotDivide: dotDivide2,
    log: log3,
    isNumeric: isNumeric2
  } = _ref;
  return typed2(name$C, {
    "Array, Array": function ArrayArray(q, p2) {
      return _kldiv(matrix2(q), matrix2(p2));
    },
    "Matrix, Array": function MatrixArray(q, p2) {
      return _kldiv(q, matrix2(p2));
    },
    "Array, Matrix": function ArrayMatrix(q, p2) {
      return _kldiv(matrix2(q), p2);
    },
    "Matrix, Matrix": function MatrixMatrix(q, p2) {
      return _kldiv(q, p2);
    }
  });
  function _kldiv(q, p2) {
    var plength = p2.size().length;
    var qlength = q.size().length;
    if (plength > 1) {
      throw new Error("first object must be one dimensional");
    }
    if (qlength > 1) {
      throw new Error("second object must be one dimensional");
    }
    if (plength !== qlength) {
      throw new Error("Length of two vectors must be equal");
    }
    var sumq = sum2(q);
    if (sumq === 0) {
      throw new Error("Sum of elements in first object must be non zero");
    }
    var sump = sum2(p2);
    if (sump === 0) {
      throw new Error("Sum of elements in second object must be non zero");
    }
    var qnorm = divide2(q, sum2(q));
    var pnorm = divide2(p2, sum2(p2));
    var result = sum2(multiply2(qnorm, map3(dotDivide2(qnorm, pnorm), (x) => log3(x))));
    if (isNumeric2(result)) {
      return result;
    } else {
      return Number.NaN;
    }
  }
});
var name$B = "multinomial";
var dependencies$B = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"];
var createMultinomial = /* @__PURE__ */ factory(name$B, dependencies$B, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    divide: divide2,
    multiply: multiply2,
    factorial: factorial2,
    isInteger: isInteger2,
    isPositive: isPositive2
  } = _ref;
  return typed2(name$B, {
    "Array | Matrix": function ArrayMatrix(a) {
      var sum2 = 0;
      var denom = 1;
      deepForEach(a, function(ai) {
        if (!isInteger2(ai) || !isPositive2(ai)) {
          throw new TypeError("Positive integer value expected in function multinomial");
        }
        sum2 = add2(sum2, ai);
        denom = multiply2(denom, factorial2(ai));
      });
      return divide2(factorial2(sum2), denom);
    }
  });
});
var name$A = "permutations";
var dependencies$A = ["typed", "factorial"];
var createPermutations = /* @__PURE__ */ factory(name$A, dependencies$A, (_ref) => {
  var {
    typed: typed2,
    factorial: factorial2
  } = _ref;
  return typed2(name$A, {
    "number | BigNumber": factorial2,
    "number, number": function numberNumber(n, k) {
      if (!isInteger$1(n) || n < 0) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (!isInteger$1(k) || k < 0) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (k > n) {
        throw new TypeError("second argument k must be less than or equal to first argument n");
      }
      return product(n - k + 1, n);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
      var result, i2;
      if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (k.gt(n)) {
        throw new TypeError("second argument k must be less than or equal to first argument n");
      }
      var one = n.mul(0).add(1);
      result = one;
      for (i2 = n.minus(k).plus(1); i2.lte(n); i2 = i2.plus(1)) {
        result = result.times(i2);
      }
      return result;
    }
  });
});
function isPositiveInteger(n) {
  return n.isInteger() && n.gte(0);
}
var alea$1 = { exports: {} };
(function(module) {
  (function(global2, module2, define) {
    function Alea(seed) {
      var me = this, mash = Mash();
      me.next = function() {
        var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
        me.s0 = me.s1;
        me.s1 = me.s2;
        return me.s2 = t - (me.c = t | 0);
      };
      me.c = 1;
      me.s0 = mash(" ");
      me.s1 = mash(" ");
      me.s2 = mash(" ");
      me.s0 -= mash(seed);
      if (me.s0 < 0) {
        me.s0 += 1;
      }
      me.s1 -= mash(seed);
      if (me.s1 < 0) {
        me.s1 += 1;
      }
      me.s2 -= mash(seed);
      if (me.s2 < 0) {
        me.s2 += 1;
      }
      mash = null;
    }
    function copy2(f, t) {
      t.c = f.c;
      t.s0 = f.s0;
      t.s1 = f.s1;
      t.s2 = f.s2;
      return t;
    }
    function impl(seed, opts) {
      var xg = new Alea(seed), state2 = opts && opts.state, prng = xg.next;
      prng.int32 = function() {
        return xg.next() * 4294967296 | 0;
      };
      prng.double = function() {
        return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
      };
      prng.quick = prng;
      if (state2) {
        if (typeof state2 == "object")
          copy2(state2, xg);
        prng.state = function() {
          return copy2(xg, {});
        };
      }
      return prng;
    }
    function Mash() {
      var n = 4022871197;
      var mash = function(data) {
        data = String(data);
        for (var i2 = 0; i2 < data.length; i2++) {
          n += data.charCodeAt(i2);
          var h2 = 0.02519603282416938 * n;
          n = h2 >>> 0;
          h2 -= n;
          h2 *= n;
          n = h2 >>> 0;
          h2 -= n;
          n += h2 * 4294967296;
        }
        return (n >>> 0) * 23283064365386963e-26;
      };
      return mash;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define && define.amd) {
      define(function() {
        return impl;
      });
    } else {
      this.alea = impl;
    }
  })(
    commonjsGlobal,
    module,
    false
  );
})(alea$1);
var xor128$1 = { exports: {} };
(function(module) {
  (function(global2, module2, define) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.next = function() {
        var t = me.x ^ me.x << 11;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
      };
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy2(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state2) {
        if (typeof state2 == "object")
          copy2(state2, xg);
        prng.state = function() {
          return copy2(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define && define.amd) {
      define(function() {
        return impl;
      });
    } else {
      this.xor128 = impl;
    }
  })(
    commonjsGlobal,
    module,
    false
  );
})(xor128$1);
var xorwow$1 = { exports: {} };
(function(module) {
  (function(global2, module2, define) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var t = me.x ^ me.x >>> 2;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        me.w = me.v;
        return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
      };
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.v = 0;
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        if (k == strseed.length) {
          me.d = me.x << 10 ^ me.x >>> 4;
        }
        me.next();
      }
    }
    function copy2(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      t.v = f.v;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state2) {
        if (typeof state2 == "object")
          copy2(state2, xg);
        prng.state = function() {
          return copy2(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define && define.amd) {
      define(function() {
        return impl;
      });
    } else {
      this.xorwow = impl;
    }
  })(
    commonjsGlobal,
    module,
    false
  );
})(xorwow$1);
var xorshift7$1 = { exports: {} };
(function(module) {
  (function(global2, module2, define) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var X = me.x, i2 = me.i, t, v;
        t = X[i2];
        t ^= t >>> 7;
        v = t ^ t << 24;
        t = X[i2 + 1 & 7];
        v ^= t ^ t >>> 10;
        t = X[i2 + 3 & 7];
        v ^= t ^ t >>> 3;
        t = X[i2 + 4 & 7];
        v ^= t ^ t << 7;
        t = X[i2 + 7 & 7];
        t = t ^ t << 13;
        v ^= t ^ t << 9;
        X[i2] = v;
        me.i = i2 + 1 & 7;
        return v;
      };
      function init(me2, seed2) {
        var j, X = [];
        if (seed2 === (seed2 | 0)) {
          X[0] = seed2;
        } else {
          seed2 = "" + seed2;
          for (j = 0; j < seed2.length; ++j) {
            X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
          }
        }
        while (X.length < 8)
          X.push(0);
        for (j = 0; j < 8 && X[j] === 0; ++j)
          ;
        if (j == 8)
          X[7] = -1;
        else
          X[j];
        me2.x = X;
        me2.i = 0;
        for (j = 256; j > 0; --j) {
          me2.next();
        }
      }
      init(me, seed);
    }
    function copy2(f, t) {
      t.x = f.x.slice();
      t.i = f.i;
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +new Date();
      var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state2) {
        if (state2.x)
          copy2(state2, xg);
        prng.state = function() {
          return copy2(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define && define.amd) {
      define(function() {
        return impl;
      });
    } else {
      this.xorshift7 = impl;
    }
  })(
    commonjsGlobal,
    module,
    false
  );
})(xorshift7$1);
var xor4096$1 = { exports: {} };
(function(module) {
  (function(global2, module2, define) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var w = me.w, X = me.X, i2 = me.i, t, v;
        me.w = w = w + 1640531527 | 0;
        v = X[i2 + 34 & 127];
        t = X[i2 = i2 + 1 & 127];
        v ^= v << 13;
        t ^= t << 17;
        v ^= v >>> 15;
        t ^= t >>> 12;
        v = X[i2] = v ^ t;
        me.i = i2;
        return v + (w ^ w >>> 16) | 0;
      };
      function init(me2, seed2) {
        var t, v, i2, j, w, X = [], limit = 128;
        if (seed2 === (seed2 | 0)) {
          v = seed2;
          seed2 = null;
        } else {
          seed2 = seed2 + "\0";
          v = 0;
          limit = Math.max(limit, seed2.length);
        }
        for (i2 = 0, j = -32; j < limit; ++j) {
          if (seed2)
            v ^= seed2.charCodeAt((j + 32) % seed2.length);
          if (j === 0)
            w = v;
          v ^= v << 10;
          v ^= v >>> 15;
          v ^= v << 4;
          v ^= v >>> 13;
          if (j >= 0) {
            w = w + 1640531527 | 0;
            t = X[j & 127] ^= v + w;
            i2 = 0 == t ? i2 + 1 : 0;
          }
        }
        if (i2 >= 128) {
          X[(seed2 && seed2.length || 0) & 127] = -1;
        }
        i2 = 127;
        for (j = 4 * 128; j > 0; --j) {
          v = X[i2 + 34 & 127];
          t = X[i2 = i2 + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          X[i2] = v ^ t;
        }
        me2.w = w;
        me2.X = X;
        me2.i = i2;
      }
      init(me, seed);
    }
    function copy2(f, t) {
      t.i = f.i;
      t.w = f.w;
      t.X = f.X.slice();
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +new Date();
      var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state2) {
        if (state2.X)
          copy2(state2, xg);
        prng.state = function() {
          return copy2(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define && define.amd) {
      define(function() {
        return impl;
      });
    } else {
      this.xor4096 = impl;
    }
  })(
    commonjsGlobal,
    module,
    false
  );
})(xor4096$1);
var tychei$1 = { exports: {} };
(function(module) {
  (function(global2, module2, define) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var b = me.b, c = me.c, d = me.d, a = me.a;
        b = b << 25 ^ b >>> 7 ^ c;
        c = c - d | 0;
        d = d << 24 ^ d >>> 8 ^ a;
        a = a - b | 0;
        me.b = b = b << 20 ^ b >>> 12 ^ c;
        me.c = c = c - d | 0;
        me.d = d << 16 ^ c >>> 16 ^ a;
        return me.a = a - b | 0;
      };
      me.a = 0;
      me.b = 0;
      me.c = 2654435769 | 0;
      me.d = 1367130551;
      if (seed === Math.floor(seed)) {
        me.a = seed / 4294967296 | 0;
        me.b = seed | 0;
      } else {
        strseed += seed;
      }
      for (var k = 0; k < strseed.length + 20; k++) {
        me.b ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy2(f, t) {
      t.a = f.a;
      t.b = f.b;
      t.c = f.c;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state2 = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state2) {
        if (typeof state2 == "object")
          copy2(state2, xg);
        prng.state = function() {
          return copy2(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define && define.amd) {
      define(function() {
        return impl;
      });
    } else {
      this.tychei = impl;
    }
  })(
    commonjsGlobal,
    module,
    false
  );
})(tychei$1);
var seedrandom$1 = { exports: {} };
(function(module) {
  (function(global2, pool, math2) {
    var width = 256, chunks = 6, digits2 = 52, rngname = "random", startdenom = math2.pow(width, chunks), significance = math2.pow(2, digits2), overflow = significance * 2, mask = width - 1, nodecrypto;
    function seedrandom2(seed, options, callback) {
      var key = [];
      options = options == true ? { entropy: true } : options || {};
      var shortseed = mixkey(flatten4(
        options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
        3
      ), key);
      var arc4 = new ARC4(key);
      var prng = function() {
        var n = arc4.g(chunks), d = startdenom, x = 0;
        while (n < significance) {
          n = (n + x) * width;
          d *= width;
          x = arc4.g(1);
        }
        while (n >= overflow) {
          n /= 2;
          d /= 2;
          x >>>= 1;
        }
        return (n + x) / d;
      };
      prng.int32 = function() {
        return arc4.g(4) | 0;
      };
      prng.quick = function() {
        return arc4.g(4) / 4294967296;
      };
      prng.double = prng;
      mixkey(tostring(arc4.S), pool);
      return (options.pass || callback || function(prng2, seed2, is_math_call, state2) {
        if (state2) {
          if (state2.S) {
            copy2(state2, arc4);
          }
          prng2.state = function() {
            return copy2(arc4, {});
          };
        }
        if (is_math_call) {
          math2[rngname] = prng2;
          return seed2;
        } else
          return prng2;
      })(
        prng,
        shortseed,
        "global" in options ? options.global : this == math2,
        options.state
      );
    }
    function ARC4(key) {
      var t, keylen = key.length, me = this, i2 = 0, j = me.i = me.j = 0, s = me.S = [];
      if (!keylen) {
        key = [keylen++];
      }
      while (i2 < width) {
        s[i2] = i2++;
      }
      for (i2 = 0; i2 < width; i2++) {
        s[i2] = s[j = mask & j + key[i2 % keylen] + (t = s[i2])];
        s[j] = t;
      }
      (me.g = function(count3) {
        var t2, r = 0, i3 = me.i, j2 = me.j, s2 = me.S;
        while (count3--) {
          t2 = s2[i3 = mask & i3 + 1];
          r = r * width + s2[mask & (s2[i3] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
        }
        me.i = i3;
        me.j = j2;
        return r;
      })(width);
    }
    function copy2(f, t) {
      t.i = f.i;
      t.j = f.j;
      t.S = f.S.slice();
      return t;
    }
    function flatten4(obj, depth) {
      var result = [], typ = typeof obj, prop;
      if (depth && typ == "object") {
        for (prop in obj) {
          try {
            result.push(flatten4(obj[prop], depth - 1));
          } catch (e2) {
          }
        }
      }
      return result.length ? result : typ == "string" ? obj : obj + "\0";
    }
    function mixkey(seed, key) {
      var stringseed = seed + "", smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
      }
      return tostring(key);
    }
    function autoseed() {
      try {
        var out;
        if (nodecrypto && (out = nodecrypto.randomBytes)) {
          out = out(width);
        } else {
          out = new Uint8Array(width);
          (global2.crypto || global2.msCrypto).getRandomValues(out);
        }
        return tostring(out);
      } catch (e2) {
        var browser = global2.navigator, plugins = browser && browser.plugins;
        return [+new Date(), global2, plugins, global2.screen, tostring(pool)];
      }
    }
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }
    mixkey(math2.random(), pool);
    if (module.exports) {
      module.exports = seedrandom2;
      try {
        nodecrypto = require("crypto");
      } catch (ex) {
      }
    } else {
      math2["seed" + rngname] = seedrandom2;
    }
  })(
    typeof self !== "undefined" ? self : commonjsGlobal,
    [],
    Math
  );
})(seedrandom$1);
var alea = alea$1.exports;
var xor128 = xor128$1.exports;
var xorwow = xorwow$1.exports;
var xorshift7 = xorshift7$1.exports;
var xor4096 = xor4096$1.exports;
var tychei = tychei$1.exports;
var sr = seedrandom$1.exports;
sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;
var seedrandom = sr;
var singletonRandom = /* @__PURE__ */ seedrandom(Date.now());
function createRng(randomSeed) {
  var random2;
  function setSeed(seed) {
    random2 = seed === null ? singletonRandom : seedrandom(String(seed));
  }
  setSeed(randomSeed);
  function rng() {
    return random2();
  }
  return rng;
}
var name$z = "pickRandom";
var dependencies$z = ["typed", "config", "?on"];
var createPickRandom = /* @__PURE__ */ factory(name$z, dependencies$z, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    on: on2
  } = _ref;
  var rng = createRng(config3.randomSeed);
  if (on2) {
    on2("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed2(name$z, {
    "Array | Matrix": function ArrayMatrix(possibles) {
      return _pickRandom(possibles, {});
    },
    "Array | Matrix, Object": function ArrayMatrixObject(possibles, options) {
      return _pickRandom(possibles, options);
    },
    "Array | Matrix, number": function ArrayMatrixNumber(possibles, number2) {
      return _pickRandom(possibles, {
        number: number2
      });
    },
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(possibles, weights) {
      return _pickRandom(possibles, {
        weights
      });
    },
    "Array | Matrix, Array | Matrix, number": function ArrayMatrixArrayMatrixNumber(possibles, weights, number2) {
      return _pickRandom(possibles, {
        number: number2,
        weights
      });
    },
    "Array | Matrix, number, Array | Matrix": function ArrayMatrixNumberArrayMatrix(possibles, number2, weights) {
      return _pickRandom(possibles, {
        number: number2,
        weights
      });
    }
  });
  function _pickRandom(possibles, _ref2) {
    var {
      number: number2,
      weights,
      elementWise = true
    } = _ref2;
    var single = typeof number2 === "undefined";
    if (single) {
      number2 = 1;
    }
    var createMatrix2 = isMatrix(possibles) ? possibles.create : isMatrix(weights) ? weights.create : null;
    possibles = possibles.valueOf();
    if (weights) {
      weights = weights.valueOf();
    }
    if (elementWise === true) {
      possibles = flatten$1(possibles);
      weights = flatten$1(weights);
    }
    var totalWeights = 0;
    if (typeof weights !== "undefined") {
      if (weights.length !== possibles.length) {
        throw new Error("Weights must have the same length as possibles");
      }
      for (var i2 = 0, len = weights.length; i2 < len; i2++) {
        if (!isNumber(weights[i2]) || weights[i2] < 0) {
          throw new Error("Weights must be an array of positive numbers");
        }
        totalWeights += weights[i2];
      }
    }
    var length = possibles.length;
    var result = [];
    var pick;
    while (result.length < number2) {
      if (typeof weights === "undefined") {
        pick = possibles[Math.floor(rng() * length)];
      } else {
        var randKey = rng() * totalWeights;
        for (var _i = 0, _len = possibles.length; _i < _len; _i++) {
          randKey -= weights[_i];
          if (randKey < 0) {
            pick = possibles[_i];
            break;
          }
        }
      }
      result.push(pick);
    }
    return single ? result[0] : createMatrix2 ? createMatrix2(result) : result;
  }
});
function randomMatrix(size2, random2) {
  var data = [];
  size2 = size2.slice(0);
  if (size2.length > 1) {
    for (var i2 = 0, length = size2.shift(); i2 < length; i2++) {
      data.push(randomMatrix(size2, random2));
    }
  } else {
    for (var _i = 0, _length = size2.shift(); _i < _length; _i++) {
      data.push(random2());
    }
  }
  return data;
}
var name$y = "random";
var dependencies$y = ["typed", "config", "?on"];
var createRandom = /* @__PURE__ */ factory(name$y, dependencies$y, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    on: on2
  } = _ref;
  var rng = createRng(config3.randomSeed);
  if (on2) {
    on2("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed2(name$y, {
    "": () => _random(0, 1),
    number: (max3) => _random(0, max3),
    "number, number": (min3, max3) => _random(min3, max3),
    "Array | Matrix": (size2) => _randomMatrix(size2, 0, 1),
    "Array | Matrix, number": (size2, max3) => _randomMatrix(size2, 0, max3),
    "Array | Matrix, number, number": (size2, min3, max3) => _randomMatrix(size2, min3, max3)
  });
  function _randomMatrix(size2, min3, max3) {
    var res = randomMatrix(size2.valueOf(), () => _random(min3, max3));
    return isMatrix(size2) ? size2.create(res) : res;
  }
  function _random(min3, max3) {
    return min3 + rng() * (max3 - min3);
  }
});
var name$x = "randomInt";
var dependencies$x = ["typed", "config", "?on"];
var createRandomInt = /* @__PURE__ */ factory(name$x, dependencies$x, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    on: on2
  } = _ref;
  var rng = createRng(config3.randomSeed);
  if (on2) {
    on2("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed2(name$x, {
    "": () => _randomInt(0, 1),
    number: (max3) => _randomInt(0, max3),
    "number, number": (min3, max3) => _randomInt(min3, max3),
    "Array | Matrix": (size2) => _randomIntMatrix(size2, 0, 1),
    "Array | Matrix, number": (size2, max3) => _randomIntMatrix(size2, 0, max3),
    "Array | Matrix, number, number": (size2, min3, max3) => _randomIntMatrix(size2, min3, max3)
  });
  function _randomIntMatrix(size2, min3, max3) {
    var res = randomMatrix(size2.valueOf(), () => _randomInt(min3, max3));
    return isMatrix(size2) ? size2.create(res) : res;
  }
  function _randomInt(min3, max3) {
    return Math.floor(min3 + rng() * (max3 - min3));
  }
});
var name$w = "stirlingS2";
var dependencies$w = ["typed", "addScalar", "subtract", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "number", "?bignumber", "larger"];
var createStirlingS2 = /* @__PURE__ */ factory(name$w, dependencies$w, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    subtract: subtract2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    pow: pow2,
    factorial: factorial2,
    combinations: combinations2,
    isNegative: isNegative2,
    isInteger: isInteger2,
    number: number2,
    bignumber: bignumber2,
    larger: larger2
  } = _ref;
  var smallCache = [];
  var bigCache = [];
  return typed2(name$w, {
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
      if (!isInteger2(n) || isNegative2(n) || !isInteger2(k) || isNegative2(k)) {
        throw new TypeError("Non-negative integer value expected in function stirlingS2");
      } else if (larger2(k, n)) {
        throw new TypeError("k must be less than or equal to n in function stirlingS2");
      }
      var big = !(isNumber(n) && isNumber(k));
      var cache = big ? bigCache : smallCache;
      var make = big ? bignumber2 : number2;
      var nn = number2(n);
      var nk = number2(k);
      if (cache[nn] && cache[nn].length > nk) {
        return cache[nn][nk];
      }
      for (var m = 0; m <= nn; ++m) {
        if (!cache[m]) {
          cache[m] = [m === 0 ? make(1) : make(0)];
        }
        if (m === 0)
          continue;
        var row2 = cache[m];
        var prev = cache[m - 1];
        for (var i2 = row2.length; i2 <= m && i2 <= nk; ++i2) {
          if (i2 === m) {
            row2[i2] = 1;
          } else {
            row2[i2] = addScalar2(multiplyScalar2(make(i2), prev[i2]), prev[i2 - 1]);
          }
        }
      }
      return cache[nn][nk];
    }
  });
});
var name$v = "bellNumbers";
var dependencies$v = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"];
var createBellNumbers = /* @__PURE__ */ factory(name$v, dependencies$v, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    isNegative: isNegative2,
    isInteger: isInteger2,
    stirlingS2: stirlingS22
  } = _ref;
  return typed2(name$v, {
    "number | BigNumber": function numberBigNumber(n) {
      if (!isInteger2(n) || isNegative2(n)) {
        throw new TypeError("Non-negative integer value expected in function bellNumbers");
      }
      var result = 0;
      for (var i2 = 0; i2 <= n; i2++) {
        result = addScalar2(result, stirlingS22(n, i2));
      }
      return result;
    }
  });
});
var name$u = "catalan";
var dependencies$u = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"];
var createCatalan = /* @__PURE__ */ factory(name$u, dependencies$u, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    combinations: combinations2,
    isNegative: isNegative2,
    isInteger: isInteger2
  } = _ref;
  return typed2(name$u, {
    "number | BigNumber": function numberBigNumber(n) {
      if (!isInteger2(n) || isNegative2(n)) {
        throw new TypeError("Non-negative integer value expected in function catalan");
      }
      return divideScalar2(combinations2(multiplyScalar2(n, 2), n), addScalar2(n, 1));
    }
  });
});
var name$t = "composition";
var dependencies$t = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"];
var createComposition = /* @__PURE__ */ factory(name$t, dependencies$t, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    combinations: combinations2,
    isPositive: isPositive2,
    isNegative: isNegative2,
    isInteger: isInteger2,
    larger: larger2
  } = _ref;
  return typed2(name$t, {
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
      if (!isInteger2(n) || !isPositive2(n) || !isInteger2(k) || !isPositive2(k)) {
        throw new TypeError("Positive integer value expected in function composition");
      } else if (larger2(k, n)) {
        throw new TypeError("k must be less than or equal to n in function composition");
      }
      return combinations2(addScalar2(n, -1), addScalar2(k, -1));
    }
  });
});
var name$s = "leafCount";
var dependencies$s = ["parse", "typed"];
var createLeafCount = /* @__PURE__ */ factory(name$s, dependencies$s, (_ref) => {
  var {
    parse: parse2,
    typed: typed2
  } = _ref;
  function countLeaves(node) {
    var count3 = 0;
    node.forEach((n) => {
      count3 += countLeaves(n);
    });
    return count3 || 1;
  }
  return typed2(name$s, {
    Node: function Node2(expr) {
      return countLeaves(expr);
    }
  });
});
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var name$r = "simplifyUtil";
var dependencies$r = ["FunctionNode", "OperatorNode", "SymbolNode"];
var createUtil = /* @__PURE__ */ factory(name$r, dependencies$r, (_ref) => {
  var {
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var T = true;
  var F = false;
  var defaultName = "defaultF";
  var defaultContext = {
    add: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    unaryPlus: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    subtract: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    },
    multiply: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    divide: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    },
    paren: {
      trivial: T,
      total: T,
      commutative: T,
      associative: F
    },
    defaultF: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    }
  };
  var realContext = {
    divide: {
      total: F
    },
    log: {
      total: F
    }
  };
  var positiveContext = {
    subtract: {
      total: F
    },
    abs: {
      trivial: T
    },
    log: {
      total: T
    }
  };
  function hasProperty(nodeOrName, property) {
    var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultContext;
    var name2 = defaultName;
    if (typeof nodeOrName === "string") {
      name2 = nodeOrName;
    } else if (isOperatorNode(nodeOrName)) {
      name2 = nodeOrName.fn.toString();
    } else if (isFunctionNode(nodeOrName)) {
      name2 = nodeOrName.name;
    } else if (isParenthesisNode(nodeOrName)) {
      name2 = "paren";
    }
    if (hasOwnProperty$2(context, name2)) {
      var properties2 = context[name2];
      if (hasOwnProperty$2(properties2, property)) {
        return properties2[property];
      }
      if (hasOwnProperty$2(defaultContext, name2)) {
        return defaultContext[name2][property];
      }
    }
    if (hasOwnProperty$2(context, defaultName)) {
      var _properties = context[defaultName];
      if (hasOwnProperty$2(_properties, property)) {
        return _properties[property];
      }
      return defaultContext[defaultName][property];
    }
    if (hasOwnProperty$2(defaultContext, name2)) {
      var _properties2 = defaultContext[name2];
      if (hasOwnProperty$2(_properties2, property)) {
        return _properties2[property];
      }
    }
    return defaultContext[defaultName][property];
  }
  function isCommutative(node) {
    var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
    return hasProperty(node, "commutative", context);
  }
  function isAssociative2(node) {
    var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
    return hasProperty(node, "associative", context);
  }
  function mergeContext(primary, secondary) {
    var merged = _objectSpread({}, primary);
    for (var prop in secondary) {
      if (hasOwnProperty$2(primary, prop)) {
        merged[prop] = _objectSpread(_objectSpread({}, secondary[prop]), primary[prop]);
      } else {
        merged[prop] = secondary[prop];
      }
    }
    return merged;
  }
  function flatten4(node, context) {
    if (!node.args || node.args.length === 0) {
      return node;
    }
    node.args = allChildren(node, context);
    for (var i2 = 0; i2 < node.args.length; i2++) {
      flatten4(node.args[i2], context);
    }
  }
  function allChildren(node, context) {
    var op2;
    var children = [];
    var findChildren = function findChildren2(node2) {
      for (var i2 = 0; i2 < node2.args.length; i2++) {
        var child = node2.args[i2];
        if (isOperatorNode(child) && op2 === child.op) {
          findChildren2(child);
        } else {
          children.push(child);
        }
      }
    };
    if (isAssociative2(node, context)) {
      op2 = node.op;
      findChildren(node);
      return children;
    } else {
      return node.args;
    }
  }
  function unflattenr(node, context) {
    if (!node.args || node.args.length === 0) {
      return;
    }
    var makeNode = createMakeNodeFunction(node);
    var l = node.args.length;
    for (var i2 = 0; i2 < l; i2++) {
      unflattenr(node.args[i2], context);
    }
    if (l > 2 && isAssociative2(node, context)) {
      var curnode = node.args.pop();
      while (node.args.length > 0) {
        curnode = makeNode([node.args.pop(), curnode]);
      }
      node.args = curnode.args;
    }
  }
  function unflattenl(node, context) {
    if (!node.args || node.args.length === 0) {
      return;
    }
    var makeNode = createMakeNodeFunction(node);
    var l = node.args.length;
    for (var i2 = 0; i2 < l; i2++) {
      unflattenl(node.args[i2], context);
    }
    if (l > 2 && isAssociative2(node, context)) {
      var curnode = node.args.shift();
      while (node.args.length > 0) {
        curnode = makeNode([curnode, node.args.shift()]);
      }
      node.args = curnode.args;
    }
  }
  function createMakeNodeFunction(node) {
    if (isOperatorNode(node)) {
      return function(args) {
        try {
          return new OperatorNode2(node.op, node.fn, args, node.implicit);
        } catch (err) {
          console.error(err);
          return [];
        }
      };
    } else {
      return function(args) {
        return new FunctionNode2(new SymbolNode2(node.name), args);
      };
    }
  }
  return {
    createMakeNodeFunction,
    hasProperty,
    isCommutative,
    isAssociative: isAssociative2,
    mergeContext,
    flatten: flatten4,
    allChildren,
    unflattenr,
    unflattenl,
    defaultContext,
    realContext,
    positiveContext
  };
});
var name$q = "simplify";
var dependencies$q = ["config", "typed", "parse", "add", "subtract", "multiply", "divide", "pow", "isZero", "equal", "resolve", "simplifyConstant", "simplifyCore", "?fraction", "?bignumber", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createSimplify = /* @__PURE__ */ factory(name$q, dependencies$q, (_ref) => {
  var {
    config: config3,
    typed: typed2,
    parse: parse2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    pow: pow2,
    isZero: isZero2,
    equal: equal2,
    resolve: resolve2,
    simplifyConstant: simplifyConstant2,
    simplifyCore: simplifyCore2,
    fraction: fraction2,
    bignumber: bignumber2,
    mathWithTransform: mathWithTransform2,
    matrix: matrix2,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var {
    hasProperty,
    isCommutative,
    isAssociative: isAssociative2,
    mergeContext,
    flatten: flatten4,
    unflattenr,
    unflattenl,
    createMakeNodeFunction,
    defaultContext,
    realContext,
    positiveContext
  } = createUtil({
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  });
  typed2.addConversion({
    from: "Object",
    to: "Map",
    convert: createMap$1
  });
  var simplify2 = typed2("simplify", {
    Node: _simplify,
    "Node, Map": (expr, scope) => _simplify(expr, false, scope),
    "Node, Map, Object": (expr, scope, options) => _simplify(expr, false, scope, options),
    "Node, Array": _simplify,
    "Node, Array, Map": _simplify,
    "Node, Array, Map, Object": _simplify
  });
  typed2.removeConversion({
    from: "Object",
    to: "Map",
    convert: createMap$1
  });
  simplify2.defaultContext = defaultContext;
  simplify2.realContext = realContext;
  simplify2.positiveContext = positiveContext;
  function removeParens(node) {
    return node.transform(function(node2, path, parent) {
      return isParenthesisNode(node2) ? removeParens(node2.content) : node2;
    });
  }
  var SUPPORTED_CONSTANTS = {
    true: true,
    false: true,
    e: true,
    i: true,
    Infinity: true,
    LN2: true,
    LN10: true,
    LOG2E: true,
    LOG10E: true,
    NaN: true,
    phi: true,
    pi: true,
    SQRT1_2: true,
    SQRT2: true,
    tau: true
  };
  simplify2.rules = [
    simplifyCore2,
    {
      l: "log(e)",
      r: "1"
    },
    {
      s: "n-n1 -> n+-n1",
      assuming: {
        subtract: {
          total: true
        }
      }
    },
    {
      s: "n-n -> 0",
      assuming: {
        subtract: {
          total: false
        }
      }
    },
    {
      s: "-(c*v) -> v * (-c)",
      assuming: {
        multiply: {
          commutative: true
        },
        subtract: {
          total: true
        }
      }
    },
    {
      s: "-(c*v) -> (-c) * v",
      assuming: {
        multiply: {
          commutative: false
        },
        subtract: {
          total: true
        }
      }
    },
    {
      s: "-(v*c) -> v * (-c)",
      assuming: {
        multiply: {
          commutative: false
        },
        subtract: {
          total: true
        }
      }
    },
    {
      l: "-(n1/n2)",
      r: "-n1/n2"
    },
    {
      l: "-v",
      r: "v * (-1)"
    },
    {
      l: "(n1 + n2)*(-1)",
      r: "n1*(-1) + n2*(-1)",
      repeat: true
    },
    {
      l: "n/n1^n2",
      r: "n*n1^-n2"
    },
    {
      l: "n/n1",
      r: "n*n1^-1"
    },
    {
      s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      l: " v   * ( v   * n1 + n2)",
      r: "v^2       * n1 +  v   * n2"
    },
    {
      s: " v   * (v^n4 * n1 + n2)   ->  v^(1+n4)  * n1 +  v   * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      s: "v^n3 * ( v   * n1 + n2)   ->  v^(n3+1)  * n1 + v^n3 * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      s: "v^n3 * (v^n4 * n1 + n2)   ->  v^(n3+n4) * n1 + v^n3 * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      l: "n*n",
      r: "n^2"
    },
    {
      s: "n * n^n1 -> n^(n1+1)",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      s: "n^n1 * n^n2 -> n^(n1+n2)",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    simplifyConstant2,
    {
      s: "n+n -> 2*n",
      assuming: {
        add: {
          total: true
        }
      }
    },
    {
      l: "n+-n",
      r: "0"
    },
    {
      l: "v*n + v",
      r: "v*(n+1)"
    },
    {
      l: "n3*n1 + n3*n2",
      r: "n3*(n1+n2)"
    },
    {
      l: "n3^(-n4)*n1 +   n3  * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)"
    },
    {
      l: "n3^(-n4)*n1 + n3^n5 * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)"
    },
    {
      s: "n*v + v -> (n+1)*v",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      l: "n*c + c",
      r: "(n+1)*c"
    },
    {
      s: "c*n + c -> c*(n+1)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    simplifyConstant2,
    {
      s: "(-n)*n1 -> -(n*n1)",
      assuming: {
        subtract: {
          total: true
        }
      }
    },
    {
      s: "n1*(-n) -> -(n1*n)",
      assuming: {
        subtract: {
          total: true
        },
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "c+v -> v+c",
      assuming: {
        add: {
          commutative: true
        }
      },
      imposeContext: {
        add: {
          commutative: false
        }
      }
    },
    {
      s: "v*c -> c*v",
      assuming: {
        multiply: {
          commutative: true
        }
      },
      imposeContext: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      l: "n+-n1",
      r: "n-n1"
    },
    {
      s: "n*(n1^-1) -> n/n1",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "n*n1^-n2 -> n/n1^n2",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "n^-1 -> 1/n",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      l: "n^1",
      r: "n"
    },
    {
      s: "n*(n1/n2) -> (n*n1)/n2",
      assuming: {
        multiply: {
          associative: true
        }
      }
    },
    {
      s: "n-(n1+n2) -> n-n1-n2",
      assuming: {
        addition: {
          associative: true,
          commutative: true
        }
      }
    },
    {
      l: "1*n",
      r: "n",
      imposeContext: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "n1/(n2/n3) -> (n1*n3)/n2",
      assuming: {
        multiply: {
          associative: true
        }
      }
    },
    {
      l: "n1/(-n2)",
      r: "-n1/n2"
    }
  ];
  function _canonicalizeRule(ruleObject, context) {
    var newRule = {};
    if (ruleObject.s) {
      var lr = ruleObject.s.split("->");
      if (lr.length === 2) {
        newRule.l = lr[0];
        newRule.r = lr[1];
      } else {
        throw SyntaxError("Could not parse rule: " + ruleObject.s);
      }
    } else {
      newRule.l = ruleObject.l;
      newRule.r = ruleObject.r;
    }
    newRule.l = removeParens(parse2(newRule.l));
    newRule.r = removeParens(parse2(newRule.r));
    for (var prop of ["imposeContext", "repeat", "assuming"]) {
      if (prop in ruleObject) {
        newRule[prop] = ruleObject[prop];
      }
    }
    if (ruleObject.evaluate) {
      newRule.evaluate = parse2(ruleObject.evaluate);
    }
    if (isAssociative2(newRule.l, context)) {
      var makeNode = createMakeNodeFunction(newRule.l);
      var expandsym = _getExpandPlaceholderSymbol();
      newRule.expanded = {};
      newRule.expanded.l = makeNode([newRule.l.clone(), expandsym]);
      flatten4(newRule.expanded.l, context);
      unflattenr(newRule.expanded.l, context);
      newRule.expanded.r = makeNode([newRule.r, expandsym]);
    }
    return newRule;
  }
  function _buildRules(rules2, context) {
    var ruleSet = [];
    for (var i2 = 0; i2 < rules2.length; i2++) {
      var rule = rules2[i2];
      var newRule = void 0;
      var ruleType = typeof rule;
      switch (ruleType) {
        case "string":
          rule = {
            s: rule
          };
        case "object":
          newRule = _canonicalizeRule(rule, context);
          break;
        case "function":
          newRule = rule;
          break;
        default:
          throw TypeError("Unsupported type of rule: " + ruleType);
      }
      ruleSet.push(newRule);
    }
    return ruleSet;
  }
  var _lastsym = 0;
  function _getExpandPlaceholderSymbol() {
    return new SymbolNode2("_p" + _lastsym++);
  }
  function _simplify(expr, rules2) {
    var scope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : createEmptyMap();
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var debug = options.consoleDebug;
    rules2 = _buildRules(rules2 || simplify2.rules, options.context);
    var res = resolve2(expr, scope);
    res = removeParens(res);
    var visited = {};
    var str = res.toString({
      parenthesis: "all"
    });
    while (!visited[str]) {
      visited[str] = true;
      _lastsym = 0;
      var laststr = str;
      if (debug)
        console.log("Working on: ", str);
      for (var i2 = 0; i2 < rules2.length; i2++) {
        var rulestr = "";
        if (typeof rules2[i2] === "function") {
          res = rules2[i2](res, options);
          if (debug)
            rulestr = rules2[i2].name;
        } else {
          flatten4(res, options.context);
          res = applyRule(res, rules2[i2], options.context);
          if (debug) {
            rulestr = "".concat(rules2[i2].l.toString(), " -> ").concat(rules2[i2].r.toString());
          }
        }
        if (debug) {
          var newstr = res.toString({
            parenthesis: "all"
          });
          if (newstr !== laststr) {
            console.log("Applying", rulestr, "produced", newstr);
            laststr = newstr;
          }
        }
        unflattenl(res, options.context);
      }
      str = res.toString({
        parenthesis: "all"
      });
    }
    return res;
  }
  function mapRule(nodes2, rule, context) {
    var resNodes = nodes2;
    if (nodes2) {
      for (var i2 = 0; i2 < nodes2.length; ++i2) {
        var newNode = applyRule(nodes2[i2], rule, context);
        if (newNode !== nodes2[i2]) {
          if (resNodes === nodes2) {
            resNodes = nodes2.slice();
          }
          resNodes[i2] = newNode;
        }
      }
    }
    return resNodes;
  }
  function applyRule(node, rule, context) {
    if (rule.assuming) {
      for (var symbol in rule.assuming) {
        for (var property in rule.assuming[symbol]) {
          if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {
            return node;
          }
        }
      }
    }
    var mergedContext = mergeContext(rule.imposeContext, context);
    var res = node;
    if (res instanceof OperatorNode2 || res instanceof FunctionNode2) {
      var newArgs = mapRule(res.args, rule, context);
      if (newArgs !== res.args) {
        res = res.clone();
        res.args = newArgs;
      }
    } else if (res instanceof ParenthesisNode2) {
      if (res.content) {
        var newContent = applyRule(res.content, rule, context);
        if (newContent !== res.content) {
          res = new ParenthesisNode2(newContent);
        }
      }
    } else if (res instanceof ArrayNode2) {
      var newItems = mapRule(res.items, rule, context);
      if (newItems !== res.items) {
        res = new ArrayNode2(newItems);
      }
    } else if (res instanceof AccessorNode2) {
      var newObj = res.object;
      if (res.object) {
        newObj = applyRule(res.object, rule, context);
      }
      var newIndex = res.index;
      if (res.index) {
        newIndex = applyRule(res.index, rule, context);
      }
      if (newObj !== res.object || newIndex !== res.index) {
        res = new AccessorNode2(newObj, newIndex);
      }
    } else if (res instanceof IndexNode2) {
      var newDims = mapRule(res.dimensions, rule, context);
      if (newDims !== res.dimensions) {
        res = new IndexNode2(newDims);
      }
    } else if (res instanceof ObjectNode2) {
      var changed = false;
      var newProps = {};
      for (var prop in res.properties) {
        newProps[prop] = applyRule(res.properties[prop], rule, context);
        if (newProps[prop] !== res.properties[prop]) {
          changed = true;
        }
      }
      if (changed) {
        res = new ObjectNode2(newProps);
      }
    }
    var repl = rule.r;
    var matches2 = _ruleMatch(rule.l, res, mergedContext)[0];
    if (!matches2 && rule.expanded) {
      repl = rule.expanded.r;
      matches2 = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
    }
    if (matches2) {
      var implicit = res.implicit;
      res = repl.clone();
      if (implicit && "implicit" in repl) {
        res.implicit = true;
      }
      res = res.transform(function(node2) {
        if (node2.isSymbolNode && hasOwnProperty$2(matches2.placeholders, node2.name)) {
          return matches2.placeholders[node2.name].clone();
        } else {
          return node2;
        }
      });
    }
    if (rule.repeat && res !== node) {
      res = applyRule(res, rule, context);
    }
    return res;
  }
  function getSplits(node, context) {
    var res = [];
    var right, rightArgs;
    var makeNode = createMakeNodeFunction(node);
    if (isCommutative(node, context)) {
      for (var i2 = 0; i2 < node.args.length; i2++) {
        rightArgs = node.args.slice(0);
        rightArgs.splice(i2, 1);
        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([node.args[i2], right]));
      }
    } else {
      for (var _i = 1; _i < node.args.length; _i++) {
        var left = node.args[0];
        if (_i > 1) {
          left = makeNode(node.args.slice(0, _i));
        }
        rightArgs = node.args.slice(_i);
        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([left, right]));
      }
    }
    return res;
  }
  function mergeMatch(match1, match2) {
    var res = {
      placeholders: {}
    };
    if (!match1.placeholders && !match2.placeholders) {
      return res;
    } else if (!match1.placeholders) {
      return match2;
    } else if (!match2.placeholders) {
      return match1;
    }
    for (var key in match1.placeholders) {
      if (hasOwnProperty$2(match1.placeholders, key)) {
        res.placeholders[key] = match1.placeholders[key];
        if (hasOwnProperty$2(match2.placeholders, key)) {
          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
            return null;
          }
        }
      }
    }
    for (var _key in match2.placeholders) {
      if (hasOwnProperty$2(match2.placeholders, _key)) {
        res.placeholders[_key] = match2.placeholders[_key];
      }
    }
    return res;
  }
  function combineChildMatches(list1, list2) {
    var res = [];
    if (list1.length === 0 || list2.length === 0) {
      return res;
    }
    var merged;
    for (var i1 = 0; i1 < list1.length; i1++) {
      for (var i2 = 0; i2 < list2.length; i2++) {
        merged = mergeMatch(list1[i1], list2[i2]);
        if (merged) {
          res.push(merged);
        }
      }
    }
    return res;
  }
  function mergeChildMatches(childMatches) {
    if (childMatches.length === 0) {
      return childMatches;
    }
    var sets = childMatches.reduce(combineChildMatches);
    var uniqueSets = [];
    var unique2 = {};
    for (var i2 = 0; i2 < sets.length; i2++) {
      var s = JSON.stringify(sets[i2]);
      if (!unique2[s]) {
        unique2[s] = true;
        uniqueSets.push(sets[i2]);
      }
    }
    return uniqueSets;
  }
  function _ruleMatch(rule, node, context, isSplit) {
    var res = [{
      placeholders: {}
    }];
    if (rule instanceof OperatorNode2 && node instanceof OperatorNode2 || rule instanceof FunctionNode2 && node instanceof FunctionNode2) {
      if (rule instanceof OperatorNode2) {
        if (rule.op !== node.op || rule.fn !== node.fn) {
          return [];
        }
      } else if (rule instanceof FunctionNode2) {
        if (rule.name !== node.name) {
          return [];
        }
      }
      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative2(node, context) && node.args.length === rule.args.length || isSplit) {
        var childMatches = [];
        for (var i2 = 0; i2 < rule.args.length; i2++) {
          var childMatch = _ruleMatch(rule.args[i2], node.args[i2], context);
          if (childMatch.length === 0) {
            break;
          }
          childMatches.push(childMatch);
        }
        if (childMatches.length !== rule.args.length) {
          if (!isCommutative(node, context) || rule.args.length === 1) {
            return [];
          }
          if (rule.args.length > 2) {
            throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");
          }
          var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);
          if (leftMatch.length === 0) {
            return [];
          }
          var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);
          if (rightMatch.length === 0) {
            return [];
          }
          childMatches = [leftMatch, rightMatch];
        }
        res = mergeChildMatches(childMatches);
      } else if (node.args.length >= 2 && rule.args.length === 2) {
        var splits = getSplits(node, context);
        var splitMatches = [];
        for (var _i2 = 0; _i2 < splits.length; _i2++) {
          var matchSet = _ruleMatch(rule, splits[_i2], context, true);
          splitMatches = splitMatches.concat(matchSet);
        }
        return splitMatches;
      } else if (rule.args.length > 2) {
        throw Error("Unexpected non-binary associative function: " + rule.toString());
      } else {
        return [];
      }
    } else if (rule instanceof SymbolNode2) {
      if (rule.name.length === 0) {
        throw new Error("Symbol in rule has 0 length...!?");
      }
      if (SUPPORTED_CONSTANTS[rule.name]) {
        if (rule.name !== node.name) {
          return [];
        }
      } else if (rule.name[0] === "n" || rule.name.substring(0, 2) === "_p") {
        res[0].placeholders[rule.name] = node;
      } else if (rule.name[0] === "v") {
        if (!isConstantNode(node)) {
          res[0].placeholders[rule.name] = node;
        } else {
          return [];
        }
      } else if (rule.name[0] === "c") {
        if (node instanceof ConstantNode2) {
          res[0].placeholders[rule.name] = node;
        } else {
          return [];
        }
      } else {
        throw new Error("Invalid symbol in rule: " + rule.name);
      }
    } else if (rule instanceof ConstantNode2) {
      if (!equal2(rule.value, node.value)) {
        return [];
      }
    } else {
      return [];
    }
    return res;
  }
  function _exactMatch(p2, q) {
    if (p2 instanceof ConstantNode2 && q instanceof ConstantNode2) {
      if (!equal2(p2.value, q.value)) {
        return false;
      }
    } else if (p2 instanceof SymbolNode2 && q instanceof SymbolNode2) {
      if (p2.name !== q.name) {
        return false;
      }
    } else if (p2 instanceof OperatorNode2 && q instanceof OperatorNode2 || p2 instanceof FunctionNode2 && q instanceof FunctionNode2) {
      if (p2 instanceof OperatorNode2) {
        if (p2.op !== q.op || p2.fn !== q.fn) {
          return false;
        }
      } else if (p2 instanceof FunctionNode2) {
        if (p2.name !== q.name) {
          return false;
        }
      }
      if (p2.args.length !== q.args.length) {
        return false;
      }
      for (var i2 = 0; i2 < p2.args.length; i2++) {
        if (!_exactMatch(p2.args[i2], q.args[i2])) {
          return false;
        }
      }
    } else {
      return false;
    }
    return true;
  }
  return simplify2;
});
var name$p = "simplifyConstant";
var dependencies$p = ["typed", "parse", "config", "mathWithTransform", "matrix", "?fraction", "?bignumber", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode"];
var createSimplifyConstant = /* @__PURE__ */ factory(name$p, dependencies$p, (_ref) => {
  var {
    typed: typed2,
    parse: parse2,
    config: config3,
    mathWithTransform: mathWithTransform2,
    matrix: matrix2,
    fraction: fraction2,
    bignumber: bignumber2,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var {
    isCommutative,
    isAssociative: isAssociative2,
    allChildren,
    createMakeNodeFunction
  } = createUtil({
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  });
  var simplifyConstant2 = typed2("simplifyConstant", {
    Node: (node) => _ensureNode(foldFraction(node, {})),
    "Node, Object": function NodeObject(expr, options) {
      return _ensureNode(foldFraction(expr, options));
    }
  });
  function _removeFractions(thing) {
    if (isFraction(thing)) {
      return thing.valueOf();
    }
    if (thing instanceof Array) {
      return thing.map(_removeFractions);
    }
    if (isMatrix(thing)) {
      return matrix2(_removeFractions(thing.valueOf()));
    }
    return thing;
  }
  function _eval(fnname, args, options) {
    try {
      return mathWithTransform2[fnname].apply(null, args);
    } catch (ignore) {
      args = args.map(_removeFractions);
      return _toNumber(mathWithTransform2[fnname].apply(null, args), options);
    }
  }
  var _toNode = typed2({
    Fraction: _fractionToNode,
    number: function number2(n) {
      if (n < 0) {
        return unaryMinusNode(new ConstantNode2(-n));
      }
      return new ConstantNode2(n);
    },
    BigNumber: function BigNumber2(n) {
      if (n < 0) {
        return unaryMinusNode(new ConstantNode2(-n));
      }
      return new ConstantNode2(n);
    },
    Complex: function Complex2(s) {
      throw new Error("Cannot convert Complex number to Node");
    },
    string: function string2(s) {
      return new ConstantNode2(s);
    },
    Matrix: function Matrix2(m) {
      return new ArrayNode2(m.valueOf().map((e2) => _toNode(e2)));
    }
  });
  function _ensureNode(thing) {
    if (isNode(thing)) {
      return thing;
    }
    return _toNode(thing);
  }
  function _exactFraction(n, options) {
    var exactFractions = options && options.exactFractions !== false;
    if (exactFractions && isFinite(n) && fraction2) {
      var f = fraction2(n);
      var fractionsLimit = options && typeof options.fractionsLimit === "number" ? options.fractionsLimit : Infinity;
      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
        return f;
      }
    }
    return n;
  }
  var _toNumber = typed2({
    "string, Object": function stringObject(s, options) {
      if (config3.number === "BigNumber") {
        if (bignumber2 === void 0) {
          noBignumber();
        }
        return bignumber2(s);
      } else if (config3.number === "Fraction") {
        if (fraction2 === void 0) {
          noFraction();
        }
        return fraction2(s);
      } else {
        var n = parseFloat(s);
        return _exactFraction(n, options);
      }
    },
    "Fraction, Object": function FractionObject(s, options) {
      return s;
    },
    "BigNumber, Object": function BigNumberObject(s, options) {
      return s;
    },
    "number, Object": function numberObject(s, options) {
      return _exactFraction(s, options);
    },
    "Complex, Object": function ComplexObject(s, options) {
      if (s.im !== 0) {
        return s;
      }
      return _exactFraction(s.re, options);
    },
    "Matrix, Object": function MatrixObject(s, options) {
      return matrix2(_exactFraction(s.valueOf()));
    },
    "Array, Object": function ArrayObject(s, options) {
      return s.map(_exactFraction);
    }
  });
  function unaryMinusNode(n) {
    return new OperatorNode2("-", "unaryMinus", [n]);
  }
  function _fractionToNode(f) {
    var n;
    var vn = f.s * f.n;
    if (vn < 0) {
      n = new OperatorNode2("-", "unaryMinus", [new ConstantNode2(-vn)]);
    } else {
      n = new ConstantNode2(vn);
    }
    if (f.d === 1) {
      return n;
    }
    return new OperatorNode2("/", "divide", [n, new ConstantNode2(f.d)]);
  }
  function _foldAccessor(obj, index2, options) {
    if (!isIndexNode(index2)) {
      return new AccessorNode2(_ensureNode(obj), _ensureNode(index2));
    }
    if (isArrayNode(obj) || isMatrix(obj)) {
      var remainingDims = Array.from(index2.dimensions);
      while (remainingDims.length > 0) {
        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== "string") {
          var first3 = _toNumber(remainingDims.shift().value, options);
          if (isArrayNode(obj)) {
            obj = obj.items[first3 - 1];
          } else {
            obj = obj.valueOf()[first3 - 1];
            if (obj instanceof Array) {
              obj = matrix2(obj);
            }
          }
        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== "string") {
          var second = _toNumber(remainingDims[1].value, options);
          var tryItems = [];
          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();
          for (var item of fromItems) {
            if (isArrayNode(item)) {
              tryItems.push(item.items[second - 1]);
            } else if (isMatrix(obj)) {
              tryItems.push(item[second - 1]);
            } else {
              break;
            }
          }
          if (tryItems.length === fromItems.length) {
            if (isArrayNode(obj)) {
              obj = new ArrayNode2(tryItems);
            } else {
              obj = matrix2(tryItems);
            }
            remainingDims.splice(1, 1);
          } else {
            break;
          }
        } else {
          break;
        }
      }
      if (remainingDims.length === index2.dimensions.length) {
        return new AccessorNode2(_ensureNode(obj), index2);
      }
      if (remainingDims.length > 0) {
        index2 = new IndexNode2(remainingDims);
        return new AccessorNode2(_ensureNode(obj), index2);
      }
      return obj;
    }
    if (isObjectNode(obj) && index2.dimensions.length === 1 && isConstantNode(index2.dimensions[0])) {
      var key = index2.dimensions[0].value;
      if (key in obj.properties) {
        return obj.properties[key];
      }
      return new ConstantNode2();
    }
    return new AccessorNode2(_ensureNode(obj), index2);
  }
  function foldOp(fn, args, makeNode, options) {
    return args.reduce(function(a, b) {
      if (!isNode(a) && !isNode(b)) {
        try {
          return _eval(fn, [a, b], options);
        } catch (ignoreandcontinue) {
        }
        a = _toNode(a);
        b = _toNode(b);
      } else if (!isNode(a)) {
        a = _toNode(a);
      } else if (!isNode(b)) {
        b = _toNode(b);
      }
      return makeNode([a, b]);
    });
  }
  function foldFraction(node, options) {
    switch (node.type) {
      case "SymbolNode":
        return node;
      case "ConstantNode":
        switch (typeof node.value) {
          case "number":
            return _toNumber(node.value, options);
          case "string":
            return node.value;
          default:
            if (!isNaN(node.value))
              return _toNumber(node.value, options);
        }
        return node;
      case "FunctionNode":
        if (mathWithTransform2[node.name] && mathWithTransform2[node.name].rawArgs) {
          return node;
        }
        {
          var operatorFunctions = ["add", "multiply"];
          if (operatorFunctions.indexOf(node.name) === -1) {
            var args = node.args.map((arg2) => foldFraction(arg2, options));
            if (!args.some(isNode)) {
              try {
                return _eval(node.name, args, options);
              } catch (ignoreandcontinue) {
              }
            }
            if (node.name === "size" && args.length === 1 && isArrayNode(args[0])) {
              var sz = [];
              var section = args[0];
              while (isArrayNode(section)) {
                sz.push(section.items.length);
                section = section.items[0];
              }
              return matrix2(sz);
            }
            return new FunctionNode2(node.name, args.map(_ensureNode));
          }
        }
      case "OperatorNode": {
        var fn = node.fn.toString();
        var _args;
        var res;
        var makeNode = createMakeNodeFunction(node);
        if (isOperatorNode(node) && node.isUnary()) {
          _args = [foldFraction(node.args[0], options)];
          if (!isNode(_args[0])) {
            res = _eval(fn, _args, options);
          } else {
            res = makeNode(_args);
          }
        } else if (isAssociative2(node, options.context)) {
          _args = allChildren(node, options.context);
          _args = _args.map((arg2) => foldFraction(arg2, options));
          if (isCommutative(fn, options.context)) {
            var consts = [];
            var vars = [];
            for (var i2 = 0; i2 < _args.length; i2++) {
              if (!isNode(_args[i2])) {
                consts.push(_args[i2]);
              } else {
                vars.push(_args[i2]);
              }
            }
            if (consts.length > 1) {
              res = foldOp(fn, consts, makeNode, options);
              vars.unshift(res);
              res = foldOp(fn, vars, makeNode, options);
            } else {
              res = foldOp(fn, _args, makeNode, options);
            }
          } else {
            res = foldOp(fn, _args, makeNode, options);
          }
        } else {
          _args = node.args.map((arg2) => foldFraction(arg2, options));
          res = foldOp(fn, _args, makeNode, options);
        }
        return res;
      }
      case "ParenthesisNode":
        return foldFraction(node.content, options);
      case "AccessorNode":
        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);
      case "ArrayNode": {
        var foldItems = node.items.map((item) => foldFraction(item, options));
        if (foldItems.some(isNode)) {
          return new ArrayNode2(foldItems.map(_ensureNode));
        }
        return matrix2(foldItems);
      }
      case "IndexNode": {
        return new IndexNode2(node.dimensions.map((n) => simplifyConstant2(n, options)));
      }
      case "ObjectNode": {
        var foldProps = {};
        for (var prop in node.properties) {
          foldProps[prop] = simplifyConstant2(node.properties[prop], options);
        }
        return new ObjectNode2(foldProps);
      }
      case "AssignmentNode":
      case "BlockNode":
      case "FunctionAssignmentNode":
      case "RangeNode":
      case "ConditionalNode":
      default:
        throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
    }
  }
  return simplifyConstant2;
});
var name$o = "simplifyCore";
var dependencies$o = ["typed", "parse", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createSimplifyCore = /* @__PURE__ */ factory(name$o, dependencies$o, (_ref) => {
  var {
    typed: typed2,
    parse: parse2,
    equal: equal2,
    isZero: isZero2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    pow: pow2,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var node0 = new ConstantNode2(0);
  var node1 = new ConstantNode2(1);
  var nodeT = new ConstantNode2(true);
  var nodeF = new ConstantNode2(false);
  function isAlwaysBoolean(node) {
    return isOperatorNode(node) && ["and", "not", "or"].includes(node.op);
  }
  var {
    hasProperty,
    isCommutative
  } = createUtil({
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  });
  function _simplifyCore(nodeToSimplify) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var context = options ? options.context : void 0;
    if (hasProperty(nodeToSimplify, "trivial", context)) {
      if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {
        return _simplifyCore(nodeToSimplify.args[0], options);
      }
      var simpChild = false;
      var childCount = 0;
      nodeToSimplify.forEach((c) => {
        ++childCount;
        if (childCount === 1) {
          simpChild = _simplifyCore(c, options);
        }
      });
      if (childCount === 1) {
        return simpChild;
      }
    }
    var node = nodeToSimplify;
    if (isFunctionNode(node)) {
      var op2 = getOperator(node.name);
      if (op2) {
        if (node.args.length > 2 && hasProperty(node, "associative", context)) {
          while (node.args.length > 2) {
            var last3 = node.args.pop();
            var seclast = node.args.pop();
            node.args.push(new OperatorNode2(op2, node.name, [last3, seclast]));
          }
        }
        node = new OperatorNode2(op2, node.name, node.args);
      } else {
        return new FunctionNode2(_simplifyCore(node.fn), node.args.map((n) => _simplifyCore(n, options)));
      }
    }
    if (isOperatorNode(node) && node.isUnary()) {
      var a0 = _simplifyCore(node.args[0], options);
      if (node.op === "~") {
        if (isOperatorNode(a0) && a0.isUnary() && a0.op === "~") {
          return a0.args[0];
        }
      }
      if (node.op === "not") {
        if (isOperatorNode(a0) && a0.isUnary() && a0.op === "not") {
          if (isAlwaysBoolean(a0.args[0])) {
            return a0.args[0];
          }
        }
      }
      var finish = true;
      if (node.op === "-") {
        if (isOperatorNode(a0)) {
          if (a0.isBinary() && a0.fn === "subtract") {
            node = new OperatorNode2("-", "subtract", [a0.args[1], a0.args[0]]);
            finish = false;
          }
          if (a0.isUnary() && a0.op === "-") {
            return a0.args[0];
          }
        }
      }
      if (finish)
        return new OperatorNode2(node.op, node.fn, [a0]);
    }
    if (isOperatorNode(node) && node.isBinary()) {
      var _a = _simplifyCore(node.args[0], options);
      var a1 = _simplifyCore(node.args[1], options);
      if (node.op === "+") {
        if (isConstantNode(_a) && isZero2(_a.value)) {
          return a1;
        }
        if (isConstantNode(a1) && isZero2(a1.value)) {
          return _a;
        }
        if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
          a1 = a1.args[0];
          node = new OperatorNode2("-", "subtract", [_a, a1]);
        }
      }
      if (node.op === "-") {
        if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
          return _simplifyCore(new OperatorNode2("+", "add", [_a, a1.args[0]]), options);
        }
        if (isConstantNode(_a) && isZero2(_a.value)) {
          return _simplifyCore(new OperatorNode2("-", "unaryMinus", [a1]));
        }
        if (isConstantNode(a1) && isZero2(a1.value)) {
          return _a;
        }
        return new OperatorNode2(node.op, node.fn, [_a, a1]);
      }
      if (node.op === "*") {
        if (isConstantNode(_a)) {
          if (isZero2(_a.value)) {
            return node0;
          } else if (equal2(_a.value, 1)) {
            return a1;
          }
        }
        if (isConstantNode(a1)) {
          if (isZero2(a1.value)) {
            return node0;
          } else if (equal2(a1.value, 1)) {
            return _a;
          }
          if (isCommutative(node, context)) {
            return new OperatorNode2(node.op, node.fn, [a1, _a], node.implicit);
          }
        }
        return new OperatorNode2(node.op, node.fn, [_a, a1], node.implicit);
      }
      if (node.op === "/") {
        if (isConstantNode(_a) && isZero2(_a.value)) {
          return node0;
        }
        if (isConstantNode(a1) && equal2(a1.value, 1)) {
          return _a;
        }
        return new OperatorNode2(node.op, node.fn, [_a, a1]);
      }
      if (node.op === "^") {
        if (isConstantNode(a1)) {
          if (isZero2(a1.value)) {
            return node1;
          } else if (equal2(a1.value, 1)) {
            return _a;
          }
        }
      }
      if (node.op === "and") {
        if (isConstantNode(_a)) {
          if (_a.value) {
            if (isAlwaysBoolean(a1))
              return a1;
          } else {
            return nodeF;
          }
        }
        if (isConstantNode(a1)) {
          if (a1.value) {
            if (isAlwaysBoolean(_a))
              return _a;
          } else {
            return nodeF;
          }
        }
      }
      if (node.op === "or") {
        if (isConstantNode(_a)) {
          if (_a.value) {
            return nodeT;
          } else {
            if (isAlwaysBoolean(a1))
              return a1;
          }
        }
        if (isConstantNode(a1)) {
          if (a1.value) {
            return nodeT;
          } else {
            if (isAlwaysBoolean(_a))
              return _a;
          }
        }
      }
      return new OperatorNode2(node.op, node.fn, [_a, a1]);
    }
    if (isOperatorNode(node)) {
      return new OperatorNode2(node.op, node.fn, node.args.map((a) => _simplifyCore(a, options)));
    }
    if (isArrayNode(node)) {
      return new ArrayNode2(node.items.map((n) => _simplifyCore(n, options)));
    }
    if (isAccessorNode(node)) {
      return new AccessorNode2(_simplifyCore(node.object, options), _simplifyCore(node.index, options));
    }
    if (isIndexNode(node)) {
      return new IndexNode2(node.dimensions.map((n) => _simplifyCore(n, options)));
    }
    if (isObjectNode(node)) {
      var newProps = {};
      for (var prop in node.properties) {
        newProps[prop] = _simplifyCore(node.properties[prop], options);
      }
      return new ObjectNode2(newProps);
    }
    return node;
  }
  return typed2(name$o, {
    Node: _simplifyCore,
    "Node,Object": _simplifyCore
  });
});
var name$n = "resolve";
var dependencies$n = ["typed", "parse", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode"];
var createResolve = /* @__PURE__ */ factory(name$n, dependencies$n, (_ref) => {
  var {
    typed: typed2,
    parse: parse2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2
  } = _ref;
  function _resolve(node, scope) {
    var within = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
    if (!scope) {
      return node;
    }
    if (isSymbolNode(node)) {
      if (within.has(node.name)) {
        var variables = Array.from(within).join(", ");
        throw new ReferenceError("recursive loop of variable definitions among {".concat(variables, "}"));
      }
      var value = scope.get(node.name);
      if (isNode(value)) {
        var nextWithin = new Set(within);
        nextWithin.add(node.name);
        return _resolve(value, scope, nextWithin);
      } else if (typeof value === "number") {
        return parse2(String(value));
      } else if (value !== void 0) {
        return new ConstantNode2(value);
      } else {
        return node;
      }
    } else if (isOperatorNode(node)) {
      var args = node.args.map(function(arg2) {
        return _resolve(arg2, scope, within);
      });
      return new OperatorNode2(node.op, node.fn, args, node.implicit);
    } else if (isParenthesisNode(node)) {
      return new ParenthesisNode2(_resolve(node.content, scope, within));
    } else if (isFunctionNode(node)) {
      var _args = node.args.map(function(arg2) {
        return _resolve(arg2, scope, within);
      });
      return new FunctionNode2(node.name, _args);
    }
    return node.map((child) => _resolve(child, scope, within));
  }
  return typed2("resolve", {
    Node: _resolve,
    "Node, Map | null | undefined": _resolve,
    "Node, Object": (n, scope) => _resolve(n, createMap$1(scope)),
    "Array | Matrix": typed2.referToSelf((self2) => (A) => A.map((n) => self2(n))),
    "Array | Matrix, null | undefined": typed2.referToSelf((self2) => (A) => A.map((n) => self2(n))),
    "Array, Object": typed2.referTo("Array,Map", (selfAM) => (A, scope) => selfAM(A, createMap$1(scope))),
    "Matrix, Object": typed2.referTo("Matrix,Map", (selfMM) => (A, scope) => selfMM(A, createMap$1(scope))),
    "Array | Matrix, Map": typed2.referToSelf((self2) => (A, scope) => A.map((n) => self2(n, scope)))
  });
});
var name$m = "symbolicEqual";
var dependencies$m = ["parse", "simplify", "typed", "OperatorNode"];
var createSymbolicEqual = /* @__PURE__ */ factory(name$m, dependencies$m, (_ref) => {
  var {
    parse: parse2,
    simplify: simplify2,
    typed: typed2,
    OperatorNode: OperatorNode2
  } = _ref;
  function _symbolicEqual(e1, e2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var diff2 = new OperatorNode2("-", "subtract", [e1, e2]);
    var simplified = simplify2(diff2, {}, options);
    return isConstantNode(simplified) && !simplified.value;
  }
  return typed2(name$m, {
    "Node, Node": _symbolicEqual,
    "Node, Node, Object": _symbolicEqual
  });
});
var name$l = "derivative";
var dependencies$l = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createDerivative = /* @__PURE__ */ factory(name$l, dependencies$l, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    parse: parse2,
    simplify: simplify2,
    equal: equal2,
    isZero: isZero2,
    numeric: numeric3,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  function plainDerivative(expr, variable) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      simplify: true
    };
    var constNodes = {};
    constTag(constNodes, expr, variable.name);
    var res = _derivative(expr, constNodes);
    return options.simplify ? simplify2(res) : res;
  }
  typed2.addConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: parse2
  });
  var derivative2 = typed2(name$l, {
    "Node, SymbolNode": plainDerivative,
    "Node, SymbolNode, Object": plainDerivative
  });
  typed2.removeConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: parse2
  });
  derivative2._simplify = true;
  derivative2.toTex = function(deriv) {
    return _derivTex.apply(null, deriv.args);
  };
  var _derivTex = typed2("_derivTex", {
    "Node, SymbolNode": function NodeSymbolNode(expr, x) {
      if (isConstantNode(expr) && typeOf$1(expr.value) === "string") {
        return _derivTex(parse2(expr.value).toString(), x.toString(), 1);
      } else {
        return _derivTex(expr.toTex(), x.toString(), 1);
      }
    },
    "Node, ConstantNode": function NodeConstantNode(expr, x) {
      if (typeOf$1(x.value) === "string") {
        return _derivTex(expr, parse2(x.value));
      } else {
        throw new Error("The second parameter to 'derivative' is a non-string constant");
      }
    },
    "Node, SymbolNode, ConstantNode": function NodeSymbolNodeConstantNode(expr, x, order) {
      return _derivTex(expr.toString(), x.name, order.value);
    },
    "string, string, number": function stringStringNumber(expr, x, order) {
      var d;
      if (order === 1) {
        d = "{d\\over d" + x + "}";
      } else {
        d = "{d^{" + order + "}\\over d" + x + "^{" + order + "}}";
      }
      return d + "\\left[".concat(expr, "\\right]");
    }
  });
  var constTag = typed2("constTag", {
    "Object, ConstantNode, string": function ObjectConstantNodeString(constNodes, node) {
      constNodes[node] = true;
      return true;
    },
    "Object, SymbolNode, string": function ObjectSymbolNodeString(constNodes, node, varName) {
      if (node.name !== varName) {
        constNodes[node] = true;
        return true;
      }
      return false;
    },
    "Object, ParenthesisNode, string": function ObjectParenthesisNodeString(constNodes, node, varName) {
      return constTag(constNodes, node.content, varName);
    },
    "Object, FunctionAssignmentNode, string": function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {
      if (node.params.indexOf(varName) === -1) {
        constNodes[node] = true;
        return true;
      }
      return constTag(constNodes, node.expr, varName);
    },
    "Object, FunctionNode | OperatorNode, string": function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {
      if (node.args.length > 0) {
        var isConst = constTag(constNodes, node.args[0], varName);
        for (var i2 = 1; i2 < node.args.length; ++i2) {
          isConst = constTag(constNodes, node.args[i2], varName) && isConst;
        }
        if (isConst) {
          constNodes[node] = true;
          return true;
        }
      }
      return false;
    }
  });
  var _derivative = typed2("_derivative", {
    "ConstantNode, Object": function ConstantNodeObject(node) {
      return createConstantNode2(0);
    },
    "SymbolNode, Object": function SymbolNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      return createConstantNode2(1);
    },
    "ParenthesisNode, Object": function ParenthesisNodeObject(node, constNodes) {
      return new ParenthesisNode2(_derivative(node.content, constNodes));
    },
    "FunctionAssignmentNode, Object": function FunctionAssignmentNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      return _derivative(node.expr, constNodes);
    },
    "FunctionNode, Object": function FunctionNodeObject(node, constNodes) {
      if (node.args.length !== 1) {
        funcArgsCheck(node);
      }
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      var arg0 = node.args[0];
      var arg1;
      var div2 = false;
      var negative = false;
      var funcDerivative;
      switch (node.name) {
        case "cbrt":
          div2 = true;
          funcDerivative = new OperatorNode2("*", "multiply", [createConstantNode2(3), new OperatorNode2("^", "pow", [arg0, new OperatorNode2("/", "divide", [createConstantNode2(2), createConstantNode2(3)])])]);
          break;
        case "sqrt":
        case "nthRoot":
          if (node.args.length === 1) {
            div2 = true;
            funcDerivative = new OperatorNode2("*", "multiply", [createConstantNode2(2), new FunctionNode2("sqrt", [arg0])]);
          } else if (node.args.length === 2) {
            arg1 = new OperatorNode2("/", "divide", [createConstantNode2(1), node.args[1]]);
            constNodes[arg1] = constNodes[node.args[1]];
            return _derivative(new OperatorNode2("^", "pow", [arg0, arg1]), constNodes);
          }
          break;
        case "log10":
          arg1 = createConstantNode2(10);
        case "log":
          if (!arg1 && node.args.length === 1) {
            funcDerivative = arg0.clone();
            div2 = true;
          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== void 0) {
            funcDerivative = new OperatorNode2("*", "multiply", [arg0.clone(), new FunctionNode2("log", [arg1 || node.args[1]])]);
            div2 = true;
          } else if (node.args.length === 2) {
            return _derivative(new OperatorNode2("/", "divide", [new FunctionNode2("log", [arg0]), new FunctionNode2("log", [node.args[1]])]), constNodes);
          }
          break;
        case "pow":
          constNodes[arg1] = constNodes[node.args[1]];
          return _derivative(new OperatorNode2("^", "pow", [arg0, node.args[1]]), constNodes);
        case "exp":
          funcDerivative = new FunctionNode2("exp", [arg0.clone()]);
          break;
        case "sin":
          funcDerivative = new FunctionNode2("cos", [arg0.clone()]);
          break;
        case "cos":
          funcDerivative = new OperatorNode2("-", "unaryMinus", [new FunctionNode2("sin", [arg0.clone()])]);
          break;
        case "tan":
          funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("sec", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "sec":
          funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("tan", [arg0.clone()])]);
          break;
        case "csc":
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("cot", [arg0.clone()])]);
          break;
        case "cot":
          negative = true;
          funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("csc", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "asin":
          div2 = true;
          funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
          break;
        case "acos":
          div2 = true;
          negative = true;
          funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
          break;
        case "atan":
          div2 = true;
          funcDerivative = new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
          break;
        case "asec":
          div2 = true;
          funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acsc":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acot":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
          break;
        case "sinh":
          funcDerivative = new FunctionNode2("cosh", [arg0.clone()]);
          break;
        case "cosh":
          funcDerivative = new FunctionNode2("sinh", [arg0.clone()]);
          break;
        case "tanh":
          funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("sech", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "sech":
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("tanh", [arg0.clone()])]);
          break;
        case "csch":
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("coth", [arg0.clone()])]);
          break;
        case "coth":
          negative = true;
          funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("csch", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "asinh":
          div2 = true;
          funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
          break;
        case "acosh":
          div2 = true;
          funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
          break;
        case "atanh":
          div2 = true;
          funcDerivative = new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
          break;
        case "asech":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [arg0.clone(), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])])]);
          break;
        case "acsch":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acoth":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
          break;
        case "abs":
          funcDerivative = new OperatorNode2("/", "divide", [new FunctionNode2(new SymbolNode2("abs"), [arg0.clone()]), arg0.clone()]);
          break;
        case "gamma":
        default:
          throw new Error('Function "' + node.name + '" is not supported by derivative, or a wrong number of arguments is passed');
      }
      var op2, func;
      if (div2) {
        op2 = "/";
        func = "divide";
      } else {
        op2 = "*";
        func = "multiply";
      }
      var chainDerivative = _derivative(arg0, constNodes);
      if (negative) {
        chainDerivative = new OperatorNode2("-", "unaryMinus", [chainDerivative]);
      }
      return new OperatorNode2(op2, func, [chainDerivative, funcDerivative]);
    },
    "OperatorNode, Object": function OperatorNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      if (node.op === "+") {
        return new OperatorNode2(node.op, node.fn, node.args.map(function(arg2) {
          return _derivative(arg2, constNodes);
        }));
      }
      if (node.op === "-") {
        if (node.isUnary()) {
          return new OperatorNode2(node.op, node.fn, [_derivative(node.args[0], constNodes)]);
        }
        if (node.isBinary()) {
          return new OperatorNode2(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);
        }
      }
      if (node.op === "*") {
        var constantTerms = node.args.filter(function(arg2) {
          return constNodes[arg2] !== void 0;
        });
        if (constantTerms.length > 0) {
          var nonConstantTerms = node.args.filter(function(arg2) {
            return constNodes[arg2] === void 0;
          });
          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode2("*", "multiply", nonConstantTerms);
          var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
          return new OperatorNode2("*", "multiply", newArgs);
        }
        return new OperatorNode2("+", "add", node.args.map(function(argOuter) {
          return new OperatorNode2("*", "multiply", node.args.map(function(argInner) {
            return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
          }));
        }));
      }
      if (node.op === "/" && node.isBinary()) {
        var arg0 = node.args[0];
        var arg1 = node.args[1];
        if (constNodes[arg1] !== void 0) {
          return new OperatorNode2("/", "divide", [_derivative(arg0, constNodes), arg1]);
        }
        if (constNodes[arg0] !== void 0) {
          return new OperatorNode2("*", "multiply", [new OperatorNode2("-", "unaryMinus", [arg0]), new OperatorNode2("/", "divide", [_derivative(arg1, constNodes), new OperatorNode2("^", "pow", [arg1.clone(), createConstantNode2(2)])])]);
        }
        return new OperatorNode2("/", "divide", [new OperatorNode2("-", "subtract", [new OperatorNode2("*", "multiply", [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode2("*", "multiply", [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode2("^", "pow", [arg1.clone(), createConstantNode2(2)])]);
      }
      if (node.op === "^" && node.isBinary()) {
        var _arg = node.args[0];
        var _arg2 = node.args[1];
        if (constNodes[_arg] !== void 0) {
          if (isConstantNode(_arg) && (isZero2(_arg.value) || equal2(_arg.value, 1))) {
            return createConstantNode2(0);
          }
          return new OperatorNode2("*", "multiply", [node, new OperatorNode2("*", "multiply", [new FunctionNode2("log", [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);
        }
        if (constNodes[_arg2] !== void 0) {
          if (isConstantNode(_arg2)) {
            if (isZero2(_arg2.value)) {
              return createConstantNode2(0);
            }
            if (equal2(_arg2.value, 1)) {
              return _derivative(_arg, constNodes);
            }
          }
          var powMinusOne = new OperatorNode2("^", "pow", [_arg.clone(), new OperatorNode2("-", "subtract", [_arg2, createConstantNode2(1)])]);
          return new OperatorNode2("*", "multiply", [_arg2.clone(), new OperatorNode2("*", "multiply", [_derivative(_arg, constNodes), powMinusOne])]);
        }
        return new OperatorNode2("*", "multiply", [new OperatorNode2("^", "pow", [_arg.clone(), _arg2.clone()]), new OperatorNode2("+", "add", [new OperatorNode2("*", "multiply", [_derivative(_arg, constNodes), new OperatorNode2("/", "divide", [_arg2.clone(), _arg.clone()])]), new OperatorNode2("*", "multiply", [_derivative(_arg2, constNodes), new FunctionNode2("log", [_arg.clone()])])])]);
      }
      throw new Error('Operator "' + node.op + '" is not supported by derivative, or a wrong number of arguments is passed');
    }
  });
  function funcArgsCheck(node) {
    if ((node.name === "log" || node.name === "nthRoot" || node.name === "pow") && node.args.length === 2) {
      return;
    }
    for (var i2 = 0; i2 < node.args.length; ++i2) {
      node.args[i2] = createConstantNode2(0);
    }
    node.compile().evaluate();
    throw new Error("Expected TypeError, but none found");
  }
  function createConstantNode2(value, valueType) {
    return new ConstantNode2(numeric3(value, valueType || config3.number));
  }
  return derivative2;
});
var name$k = "rationalize";
var dependencies$k = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplifyConstant", "simplifyCore", "simplify", "?bignumber", "?fraction", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode", "ParenthesisNode"];
var createRationalize = /* @__PURE__ */ factory(name$k, dependencies$k, (_ref) => {
  var {
    config: config3,
    typed: typed2,
    equal: equal2,
    isZero: isZero2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    pow: pow2,
    parse: parse2,
    simplifyConstant: simplifyConstant2,
    simplifyCore: simplifyCore2,
    simplify: simplify2,
    fraction: fraction2,
    bignumber: bignumber2,
    mathWithTransform: mathWithTransform2,
    matrix: matrix2,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2,
    ParenthesisNode: ParenthesisNode2
  } = _ref;
  function _rationalize(expr) {
    var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var detailed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var setRules = rulesRationalize();
    var polyRet = polynomial(expr, scope, true, setRules.firstRules);
    var nVars = polyRet.variables.length;
    var noExactFractions = {
      exactFractions: false
    };
    var withExactFractions = {
      exactFractions: true
    };
    expr = polyRet.expression;
    if (nVars >= 1) {
      expr = expandPower(expr);
      var sBefore;
      var rules2;
      var eDistrDiv = true;
      var redoInic = false;
      expr = simplify2(expr, setRules.firstRules, {}, noExactFractions);
      var s;
      while (true) {
        rules2 = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
        expr = simplify2(expr, rules2, {}, withExactFractions);
        eDistrDiv = !eDistrDiv;
        s = expr.toString();
        if (s === sBefore) {
          break;
        }
        redoInic = true;
        sBefore = s;
      }
      if (redoInic) {
        expr = simplify2(expr, setRules.firstRulesAgain, {}, noExactFractions);
      }
      expr = simplify2(expr, setRules.finalRules, {}, noExactFractions);
    }
    var coefficients = [];
    var retRationalize = {};
    if (expr.type === "OperatorNode" && expr.isBinary() && expr.op === "/") {
      if (nVars === 1) {
        expr.args[0] = polyToCanonical(expr.args[0], coefficients);
        expr.args[1] = polyToCanonical(expr.args[1]);
      }
      if (detailed) {
        retRationalize.numerator = expr.args[0];
        retRationalize.denominator = expr.args[1];
      }
    } else {
      if (nVars === 1) {
        expr = polyToCanonical(expr, coefficients);
      }
      if (detailed) {
        retRationalize.numerator = expr;
        retRationalize.denominator = null;
      }
    }
    if (!detailed)
      return expr;
    retRationalize.coefficients = coefficients;
    retRationalize.variables = polyRet.variables;
    retRationalize.expression = expr;
    return retRationalize;
  }
  return typed2(name$k, {
    Node: _rationalize,
    "Node, boolean": (expr, detailed) => _rationalize(expr, {}, detailed),
    "Node, Object": _rationalize,
    "Node, Object, boolean": _rationalize
  });
  function polynomial(expr, scope, extended, rules2) {
    var variables = [];
    var node = simplify2(expr, rules2, scope, {
      exactFractions: false
    });
    extended = !!extended;
    var oper = "+-*" + (extended ? "/" : "");
    recPoly(node);
    var retFunc = {};
    retFunc.expression = node;
    retFunc.variables = variables;
    return retFunc;
    function recPoly(node2) {
      var tp = node2.type;
      if (tp === "FunctionNode") {
        throw new Error("There is an unsolved function call");
      } else if (tp === "OperatorNode") {
        if (node2.op === "^") {
          if (node2.args[1].type !== "ConstantNode" || !isInteger$1(parseFloat(node2.args[1].value))) {
            throw new Error("There is a non-integer exponent");
          } else {
            recPoly(node2.args[0]);
          }
        } else {
          if (oper.indexOf(node2.op) === -1) {
            throw new Error("Operator " + node2.op + " invalid in polynomial expression");
          }
          for (var i2 = 0; i2 < node2.args.length; i2++) {
            recPoly(node2.args[i2]);
          }
        }
      } else if (tp === "SymbolNode") {
        var _name = node2.name;
        var pos = variables.indexOf(_name);
        if (pos === -1) {
          variables.push(_name);
        }
      } else if (tp === "ParenthesisNode") {
        recPoly(node2.content);
      } else if (tp !== "ConstantNode") {
        throw new Error("type " + tp + " is not allowed in polynomial expression");
      }
    }
  }
  function rulesRationalize() {
    var oldRules = [
      simplifyCore2,
      {
        l: "n+n",
        r: "2*n"
      },
      {
        l: "n+-n",
        r: "0"
      },
      simplifyConstant2,
      {
        l: "n*(n1^-1)",
        r: "n/n1"
      },
      {
        l: "n*n1^-n2",
        r: "n/n1^n2"
      },
      {
        l: "n1^-1",
        r: "1/n1"
      },
      {
        l: "n*(n1/n2)",
        r: "(n*n1)/n2"
      },
      {
        l: "1*n",
        r: "n"
      }
    ];
    var rulesFirst = [
      {
        l: "(-n1)/(-n2)",
        r: "n1/n2"
      },
      {
        l: "(-n1)*(-n2)",
        r: "n1*n2"
      },
      {
        l: "n1--n2",
        r: "n1+n2"
      },
      {
        l: "n1-n2",
        r: "n1+(-n2)"
      },
      {
        l: "(n1+n2)*n3",
        r: "(n1*n3 + n2*n3)"
      },
      {
        l: "n1*(n2+n3)",
        r: "(n1*n2+n1*n3)"
      },
      {
        l: "c1*n + c2*n",
        r: "(c1+c2)*n"
      },
      {
        l: "c1*n + n",
        r: "(c1+1)*n"
      },
      {
        l: "c1*n - c2*n",
        r: "(c1-c2)*n"
      },
      {
        l: "c1*n - n",
        r: "(c1-1)*n"
      },
      {
        l: "v/c",
        r: "(1/c)*v"
      },
      {
        l: "v/-c",
        r: "-(1/c)*v"
      },
      {
        l: "-v*-c",
        r: "c*v"
      },
      {
        l: "-v*c",
        r: "-c*v"
      },
      {
        l: "v*-c",
        r: "-c*v"
      },
      {
        l: "v*c",
        r: "c*v"
      },
      {
        l: "-(-n1*n2)",
        r: "(n1*n2)"
      },
      {
        l: "-(n1*n2)",
        r: "(-n1*n2)"
      },
      {
        l: "-(-n1+n2)",
        r: "(n1-n2)"
      },
      {
        l: "-(n1+n2)",
        r: "(-n1-n2)"
      },
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      },
      {
        l: "-(-n1/n2)",
        r: "(n1/n2)"
      },
      {
        l: "-(n1/n2)",
        r: "(-n1/n2)"
      }
    ];
    var rulesDistrDiv = [
      {
        l: "(n1/n2 + n3/n4)",
        r: "((n1*n4 + n3*n2)/(n2*n4))"
      },
      {
        l: "(n1/n2 + n3)",
        r: "((n1 + n3*n2)/n2)"
      },
      {
        l: "(n1 + n2/n3)",
        r: "((n1*n3 + n2)/n3)"
      }
    ];
    var rulesSucDiv = [
      {
        l: "(n1/(n2/n3))",
        r: "((n1*n3)/n2)"
      },
      {
        l: "(n1/n2/n3)",
        r: "(n1/(n2*n3))"
      }
    ];
    var setRules = {};
    setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv);
    setRules.distrDivRules = rulesDistrDiv;
    setRules.sucDivRules = rulesSucDiv;
    setRules.firstRulesAgain = oldRules.concat(rulesFirst);
    setRules.finalRules = [
      simplifyCore2,
      {
        l: "n*-n",
        r: "-n^2"
      },
      {
        l: "n*n",
        r: "n^2"
      },
      simplifyConstant2,
      {
        l: "n*-n^n1",
        r: "-n^(n1+1)"
      },
      {
        l: "n*n^n1",
        r: "n^(n1+1)"
      },
      {
        l: "n^n1*-n^n2",
        r: "-n^(n1+n2)"
      },
      {
        l: "n^n1*n^n2",
        r: "n^(n1+n2)"
      },
      {
        l: "n^n1*-n",
        r: "-n^(n1+1)"
      },
      {
        l: "n^n1*n",
        r: "n^(n1+1)"
      },
      {
        l: "n^n1/-n",
        r: "-n^(n1-1)"
      },
      {
        l: "n^n1/n",
        r: "n^(n1-1)"
      },
      {
        l: "n/-n^n1",
        r: "-n^(1-n1)"
      },
      {
        l: "n/n^n1",
        r: "n^(1-n1)"
      },
      {
        l: "n^n1/-n^n2",
        r: "n^(n1-n2)"
      },
      {
        l: "n^n1/n^n2",
        r: "n^(n1-n2)"
      },
      {
        l: "n1+(-n2*n3)",
        r: "n1-n2*n3"
      },
      {
        l: "v*(-c)",
        r: "-c*v"
      },
      {
        l: "n1+-n2",
        r: "n1-n2"
      },
      {
        l: "v*c",
        r: "c*v"
      },
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      }
    ];
    return setRules;
  }
  function expandPower(node, parent, indParent) {
    var tp = node.type;
    var internal = arguments.length > 1;
    if (tp === "OperatorNode" && node.isBinary()) {
      var does = false;
      var val;
      if (node.op === "^") {
        if ((node.args[0].type === "ParenthesisNode" || node.args[0].type === "OperatorNode") && node.args[1].type === "ConstantNode") {
          val = parseFloat(node.args[1].value);
          does = val >= 2 && isInteger$1(val);
        }
      }
      if (does) {
        if (val > 2) {
          var nEsqTopo = node.args[0];
          var nDirTopo = new OperatorNode2("^", "pow", [node.args[0].cloneDeep(), new ConstantNode2(val - 1)]);
          node = new OperatorNode2("*", "multiply", [nEsqTopo, nDirTopo]);
        } else {
          node = new OperatorNode2("*", "multiply", [node.args[0], node.args[0].cloneDeep()]);
        }
        if (internal) {
          if (indParent === "content") {
            parent.content = node;
          } else {
            parent.args[indParent] = node;
          }
        }
      }
    }
    if (tp === "ParenthesisNode") {
      expandPower(node.content, node, "content");
    } else if (tp !== "ConstantNode" && tp !== "SymbolNode") {
      for (var i2 = 0; i2 < node.args.length; i2++) {
        expandPower(node.args[i2], node, i2);
      }
    }
    if (!internal) {
      return node;
    }
  }
  function polyToCanonical(node, coefficients) {
    if (coefficients === void 0) {
      coefficients = [];
    }
    coefficients[0] = 0;
    var o = {};
    o.cte = 1;
    o.oper = "+";
    o.fire = "";
    var maxExpo = 0;
    var varname = "";
    recurPol(node, null, o);
    maxExpo = coefficients.length - 1;
    var first3 = true;
    var no;
    for (var i2 = maxExpo; i2 >= 0; i2--) {
      if (coefficients[i2] === 0)
        continue;
      var n12 = new ConstantNode2(first3 ? coefficients[i2] : Math.abs(coefficients[i2]));
      var op2 = coefficients[i2] < 0 ? "-" : "+";
      if (i2 > 0) {
        var n22 = new SymbolNode2(varname);
        if (i2 > 1) {
          var n3 = new ConstantNode2(i2);
          n22 = new OperatorNode2("^", "pow", [n22, n3]);
        }
        if (coefficients[i2] === -1 && first3) {
          n12 = new OperatorNode2("-", "unaryMinus", [n22]);
        } else if (Math.abs(coefficients[i2]) === 1) {
          n12 = n22;
        } else {
          n12 = new OperatorNode2("*", "multiply", [n12, n22]);
        }
      }
      if (first3) {
        no = n12;
      } else if (op2 === "+") {
        no = new OperatorNode2("+", "add", [no, n12]);
      } else {
        no = new OperatorNode2("-", "subtract", [no, n12]);
      }
      first3 = false;
    }
    if (first3) {
      return new ConstantNode2(0);
    } else {
      return no;
    }
    function recurPol(node2, noPai, o2) {
      var tp = node2.type;
      if (tp === "FunctionNode") {
        throw new Error("There is an unsolved function call");
      } else if (tp === "OperatorNode") {
        if ("+-*^".indexOf(node2.op) === -1)
          throw new Error("Operator " + node2.op + " invalid");
        if (noPai !== null) {
          if ((node2.fn === "unaryMinus" || node2.fn === "pow") && noPai.fn !== "add" && noPai.fn !== "subtract" && noPai.fn !== "multiply") {
            throw new Error("Invalid " + node2.op + " placing");
          }
          if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "multiply") && noPai.fn !== "add" && noPai.fn !== "subtract") {
            throw new Error("Invalid " + node2.op + " placing");
          }
          if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "unaryMinus") && o2.noFil !== 0) {
            throw new Error("Invalid " + node2.op + " placing");
          }
        }
        if (node2.op === "^" || node2.op === "*") {
          o2.fire = node2.op;
        }
        for (var _i = 0; _i < node2.args.length; _i++) {
          if (node2.fn === "unaryMinus")
            o2.oper = "-";
          if (node2.op === "+" || node2.fn === "subtract") {
            o2.fire = "";
            o2.cte = 1;
            o2.oper = _i === 0 ? "+" : node2.op;
          }
          o2.noFil = _i;
          recurPol(node2.args[_i], node2, o2);
        }
      } else if (tp === "SymbolNode") {
        if (node2.name !== varname && varname !== "") {
          throw new Error("There is more than one variable");
        }
        varname = node2.name;
        if (noPai === null) {
          coefficients[1] = 1;
          return;
        }
        if (noPai.op === "^" && o2.noFil !== 0) {
          throw new Error("In power the variable should be the first parameter");
        }
        if (noPai.op === "*" && o2.noFil !== 1) {
          throw new Error("In multiply the variable should be the second parameter");
        }
        if (o2.fire === "" || o2.fire === "*") {
          if (maxExpo < 1)
            coefficients[1] = 0;
          coefficients[1] += o2.cte * (o2.oper === "+" ? 1 : -1);
          maxExpo = Math.max(1, maxExpo);
        }
      } else if (tp === "ConstantNode") {
        var valor = parseFloat(node2.value);
        if (noPai === null) {
          coefficients[0] = valor;
          return;
        }
        if (noPai.op === "^") {
          if (o2.noFil !== 1)
            throw new Error("Constant cannot be powered");
          if (!isInteger$1(valor) || valor <= 0) {
            throw new Error("Non-integer exponent is not allowed");
          }
          for (var _i2 = maxExpo + 1; _i2 < valor; _i2++) {
            coefficients[_i2] = 0;
          }
          if (valor > maxExpo)
            coefficients[valor] = 0;
          coefficients[valor] += o2.cte * (o2.oper === "+" ? 1 : -1);
          maxExpo = Math.max(valor, maxExpo);
          return;
        }
        o2.cte = valor;
        if (o2.fire === "") {
          coefficients[0] += o2.cte * (o2.oper === "+" ? 1 : -1);
        }
      } else {
        throw new Error("Type " + tp + " is not allowed");
      }
    }
  }
});
var name$j = "reviver";
var dependencies$j = ["classes"];
var createReviver = /* @__PURE__ */ factory(name$j, dependencies$j, (_ref) => {
  var {
    classes: classes2
  } = _ref;
  return function reviver2(key, value) {
    var constructor = classes2[value && value.mathjs];
    if (constructor && typeof constructor.fromJSON === "function") {
      return constructor.fromJSON(value);
    }
    return value;
  };
});
var name$i = "replacer";
var dependencies$i = [];
var createReplacer = /* @__PURE__ */ factory(name$i, dependencies$i, () => {
  return function replacer2(key, value) {
    if (typeof value === "number" && (!isFinite(value) || isNaN(value))) {
      return {
        mathjs: "number",
        value: String(value)
      };
    }
    return value;
  };
});
var version$1 = "11.0.1";
var createTrue = /* @__PURE__ */ factory("true", [], () => true);
var createFalse = /* @__PURE__ */ factory("false", [], () => false);
var createNull = /* @__PURE__ */ factory("null", [], () => null);
var createInfinity = /* @__PURE__ */ recreateFactory("Infinity", ["config", "?BigNumber"], (_ref) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref;
  return config3.number === "BigNumber" ? new BigNumber2(Infinity) : Infinity;
});
var createNaN = /* @__PURE__ */ recreateFactory("NaN", ["config", "?BigNumber"], (_ref2) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref2;
  return config3.number === "BigNumber" ? new BigNumber2(NaN) : NaN;
});
var createPi = /* @__PURE__ */ recreateFactory("pi", ["config", "?BigNumber"], (_ref3) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref3;
  return config3.number === "BigNumber" ? createBigNumberPi(BigNumber2) : pi$1;
});
var createTau = /* @__PURE__ */ recreateFactory("tau", ["config", "?BigNumber"], (_ref4) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref4;
  return config3.number === "BigNumber" ? createBigNumberTau(BigNumber2) : tau$1;
});
var createE = /* @__PURE__ */ recreateFactory("e", ["config", "?BigNumber"], (_ref5) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref5;
  return config3.number === "BigNumber" ? createBigNumberE(BigNumber2) : e$1;
});
var createPhi = /* @__PURE__ */ recreateFactory("phi", ["config", "?BigNumber"], (_ref6) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref6;
  return config3.number === "BigNumber" ? createBigNumberPhi(BigNumber2) : phi$1;
});
var createLN2 = /* @__PURE__ */ recreateFactory("LN2", ["config", "?BigNumber"], (_ref7) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref7;
  return config3.number === "BigNumber" ? new BigNumber2(2).ln() : Math.LN2;
});
var createLN10 = /* @__PURE__ */ recreateFactory("LN10", ["config", "?BigNumber"], (_ref8) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref8;
  return config3.number === "BigNumber" ? new BigNumber2(10).ln() : Math.LN10;
});
var createLOG2E = /* @__PURE__ */ recreateFactory("LOG2E", ["config", "?BigNumber"], (_ref9) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref9;
  return config3.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(2).ln()) : Math.LOG2E;
});
var createLOG10E = /* @__PURE__ */ recreateFactory("LOG10E", ["config", "?BigNumber"], (_ref10) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref10;
  return config3.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(10).ln()) : Math.LOG10E;
});
var createSQRT1_2 = /* @__PURE__ */ recreateFactory(
  "SQRT1_2",
  ["config", "?BigNumber"],
  (_ref11) => {
    var {
      config: config3,
      BigNumber: BigNumber2
    } = _ref11;
    return config3.number === "BigNumber" ? new BigNumber2("0.5").sqrt() : Math.SQRT1_2;
  }
);
var createSQRT2 = /* @__PURE__ */ recreateFactory("SQRT2", ["config", "?BigNumber"], (_ref12) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref12;
  return config3.number === "BigNumber" ? new BigNumber2(2).sqrt() : Math.SQRT2;
});
var createI = /* @__PURE__ */ recreateFactory("i", ["Complex"], (_ref13) => {
  var {
    Complex: Complex2
  } = _ref13;
  return Complex2.I;
});
var createVersion = /* @__PURE__ */ factory("version", [], () => version$1);
function recreateFactory(name2, dependencies2, create2) {
  return factory(name2, dependencies2, create2, {
    recreateOnConfigChange: true
  });
}
var createSpeedOfLight = /* @__PURE__ */ unitFactory("speedOfLight", "299792458", "m s^-1");
var createGravitationConstant = /* @__PURE__ */ unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
var createPlanckConstant = /* @__PURE__ */ unitFactory("planckConstant", "6.62607015e-34", "J s");
var createReducedPlanckConstant = /* @__PURE__ */ unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
var createMagneticConstant = /* @__PURE__ */ unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
var createElectricConstant = /* @__PURE__ */ unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
var createVacuumImpedance = /* @__PURE__ */ unitFactory("vacuumImpedance", "376.730313667", "ohm");
var createCoulomb = /* @__PURE__ */ unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
var createElementaryCharge = /* @__PURE__ */ unitFactory("elementaryCharge", "1.602176634e-19", "C");
var createBohrMagneton = /* @__PURE__ */ unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
var createConductanceQuantum = /* @__PURE__ */ unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
var createInverseConductanceQuantum = /* @__PURE__ */ unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
var createMagneticFluxQuantum = /* @__PURE__ */ unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
var createNuclearMagneton = /* @__PURE__ */ unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
var createKlitzing = /* @__PURE__ */ unitFactory("klitzing", "25812.807459304513", "ohm");
var createBohrRadius = /* @__PURE__ */ unitFactory("bohrRadius", "5.29177210903e-11", "m");
var createClassicalElectronRadius = /* @__PURE__ */ unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
var createElectronMass = /* @__PURE__ */ unitFactory("electronMass", "9.1093837015e-31", "kg");
var createFermiCoupling = /* @__PURE__ */ unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
var createFineStructure = numberFactory("fineStructure", 0.0072973525693);
var createHartreeEnergy = /* @__PURE__ */ unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
var createProtonMass = /* @__PURE__ */ unitFactory("protonMass", "1.67262192369e-27", "kg");
var createDeuteronMass = /* @__PURE__ */ unitFactory("deuteronMass", "3.3435830926e-27", "kg");
var createNeutronMass = /* @__PURE__ */ unitFactory("neutronMass", "1.6749271613e-27", "kg");
var createQuantumOfCirculation = /* @__PURE__ */ unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
var createRydberg = /* @__PURE__ */ unitFactory("rydberg", "10973731.568160", "m^-1");
var createThomsonCrossSection = /* @__PURE__ */ unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
var createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
var createEfimovFactor = numberFactory("efimovFactor", 22.7);
var createAtomicMass = /* @__PURE__ */ unitFactory("atomicMass", "1.66053906660e-27", "kg");
var createAvogadro = /* @__PURE__ */ unitFactory("avogadro", "6.02214076e23", "mol^-1");
var createBoltzmann = /* @__PURE__ */ unitFactory("boltzmann", "1.380649e-23", "J K^-1");
var createFaraday = /* @__PURE__ */ unitFactory("faraday", "96485.33212331001", "C mol^-1");
var createFirstRadiation = /* @__PURE__ */ unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
var createLoschmidt = /* @__PURE__ */ unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
var createGasConstant = /* @__PURE__ */ unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
var createMolarPlanckConstant = /* @__PURE__ */ unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
var createMolarVolume = /* @__PURE__ */ unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
var createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
var createSecondRadiation = /* @__PURE__ */ unitFactory("secondRadiation", "0.014387768775039337", "m K");
var createStefanBoltzmann = /* @__PURE__ */ unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
var createWienDisplacement = /* @__PURE__ */ unitFactory("wienDisplacement", "2.897771955e-3", "m K");
var createMolarMass = /* @__PURE__ */ unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
var createMolarMassC12 = /* @__PURE__ */ unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
var createGravity = /* @__PURE__ */ unitFactory("gravity", "9.80665", "m s^-2");
var createPlanckLength = /* @__PURE__ */ unitFactory("planckLength", "1.616255e-35", "m");
var createPlanckMass = /* @__PURE__ */ unitFactory("planckMass", "2.176435e-8", "kg");
var createPlanckTime = /* @__PURE__ */ unitFactory("planckTime", "5.391245e-44", "s");
var createPlanckCharge = /* @__PURE__ */ unitFactory("planckCharge", "1.87554603778e-18", "C");
var createPlanckTemperature = /* @__PURE__ */ unitFactory("planckTemperature", "1.416785e+32", "K");
function unitFactory(name2, valueStr, unitStr) {
  var dependencies2 = ["config", "Unit", "BigNumber"];
  return factory(name2, dependencies2, (_ref) => {
    var {
      config: config3,
      Unit: Unit2,
      BigNumber: BigNumber2
    } = _ref;
    var value = config3.number === "BigNumber" ? new BigNumber2(valueStr) : parseFloat(valueStr);
    var unit2 = new Unit2(value, unitStr);
    unit2.fixPrefix = true;
    return unit2;
  });
}
function numberFactory(name2, value) {
  var dependencies2 = ["config", "BigNumber"];
  return factory(name2, dependencies2, (_ref2) => {
    var {
      config: config3,
      BigNumber: BigNumber2
    } = _ref2;
    return config3.number === "BigNumber" ? new BigNumber2(value) : value;
  });
}
var name$h = "apply";
var dependencies$h = ["typed", "isInteger"];
var createApplyTransform = /* @__PURE__ */ factory(name$h, dependencies$h, (_ref) => {
  var {
    typed: typed2,
    isInteger: isInteger2
  } = _ref;
  var apply2 = createApply({
    typed: typed2,
    isInteger: isInteger2
  });
  return typed2("apply", {
    "...any": function any(args) {
      var dim = args[1];
      if (isNumber(dim)) {
        args[1] = dim - 1;
      } else if (isBigNumber(dim)) {
        args[1] = dim.minus(1);
      }
      try {
        return apply2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$g = "column";
var dependencies$g = ["typed", "Index", "matrix", "range"];
var createColumnTransform = /* @__PURE__ */ factory(name$g, dependencies$g, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  var column2 = createColumn({
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  });
  return typed2("column", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last3 = args[lastIndex];
      if (isNumber(last3)) {
        args[lastIndex] = last3 - 1;
      }
      try {
        return column2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
function compileInlineExpression(expression, math2, scope) {
  var symbol = expression.filter(function(node) {
    return isSymbolNode(node) && !(node.name in math2) && !scope.has(node.name);
  })[0];
  if (!symbol) {
    throw new Error('No undefined variable found in inline expression "' + expression + '"');
  }
  var name2 = symbol.name;
  var subScope = createSubScope(scope);
  var eq = expression.compile();
  return function inlineExpression(x) {
    subScope.set(name2, x);
    return eq.evaluate(subScope);
  };
}
var name$f = "filter";
var dependencies$f = ["typed"];
var createFilterTransform = /* @__PURE__ */ factory(name$f, dependencies$f, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  function filterTransform(args, math2, scope) {
    var x, callback;
    if (args[0]) {
      x = args[0].compile().evaluate(scope);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope);
      } else {
        callback = compileInlineExpression(args[1], math2, scope);
      }
    }
    return filter4(x, callback);
  }
  filterTransform.rawArgs = true;
  var filter4 = typed2("filter", {
    "Array, function": _filter,
    "Matrix, function": function MatrixFunction(x, test) {
      return x.create(_filter(x.toArray(), test));
    },
    "Array, RegExp": filterRegExp,
    "Matrix, RegExp": function MatrixRegExp(x, test) {
      return x.create(filterRegExp(x.toArray(), test));
    }
  });
  return filterTransform;
}, {
  isTransformFunction: true
});
function _filter(x, callback) {
  var args = maxArgumentCount(callback);
  return filter$1(x, function(value, index2, array) {
    if (args === 1) {
      return callback(value);
    } else if (args === 2) {
      return callback(value, [index2 + 1]);
    } else {
      return callback(value, [index2 + 1], array);
    }
  });
}
var name$e = "forEach";
var dependencies$e = ["typed"];
var createForEachTransform = /* @__PURE__ */ factory(name$e, dependencies$e, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  function forEachTransform(args, math2, scope) {
    var x, callback;
    if (args[0]) {
      x = args[0].compile().evaluate(scope);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope);
      } else {
        callback = compileInlineExpression(args[1], math2, scope);
      }
    }
    return _forEach2(x, callback);
  }
  forEachTransform.rawArgs = true;
  var _forEach2 = typed2("forEach", {
    "Array | Matrix, function": function ArrayMatrixFunction(array, callback) {
      var args = maxArgumentCount(callback);
      var recurse = function recurse2(value, index2) {
        if (Array.isArray(value)) {
          forEach$1(value, function(child, i2) {
            recurse2(child, index2.concat(i2 + 1));
          });
        } else {
          if (args === 1) {
            callback(value);
          } else if (args === 2) {
            callback(value, index2);
          } else {
            callback(value, index2, array);
          }
        }
      };
      recurse(array.valueOf(), []);
    }
  });
  return forEachTransform;
}, {
  isTransformFunction: true
});
var name$d = "index";
var dependencies$d = ["Index"];
var createIndexTransform = /* @__PURE__ */ factory(name$d, dependencies$d, (_ref) => {
  var {
    Index: Index2
  } = _ref;
  return function indexTransform() {
    var args = [];
    for (var i2 = 0, ii = arguments.length; i2 < ii; i2++) {
      var arg2 = arguments[i2];
      if (isRange(arg2)) {
        arg2.start--;
        arg2.end -= arg2.step > 0 ? 0 : 2;
      } else if (arg2 && arg2.isSet === true) {
        arg2 = arg2.map(function(v) {
          return v - 1;
        });
      } else if (isArray$1(arg2) || isMatrix(arg2)) {
        arg2 = arg2.map(function(v) {
          return v - 1;
        });
      } else if (isNumber(arg2)) {
        arg2--;
      } else if (isBigNumber(arg2)) {
        arg2 = arg2.toNumber() - 1;
      } else if (typeof arg2 === "string")
        ;
      else {
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      }
      args[i2] = arg2;
    }
    var res = new Index2();
    Index2.apply(res, args);
    return res;
  };
}, {
  isTransformFunction: true
});
var name$c = "map";
var dependencies$c = ["typed"];
var createMapTransform = /* @__PURE__ */ factory(name$c, dependencies$c, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  function mapTransform(args, math2, scope) {
    var x, callback;
    if (args[0]) {
      x = args[0].compile().evaluate(scope);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope);
      } else {
        callback = compileInlineExpression(args[1], math2, scope);
      }
    }
    return map3(x, callback);
  }
  mapTransform.rawArgs = true;
  var map3 = typed2("map", {
    "Array, function": function ArrayFunction(x, callback) {
      return _map(x, callback, x);
    },
    "Matrix, function": function MatrixFunction(x, callback) {
      return x.create(_map(x.valueOf(), callback, x));
    }
  });
  return mapTransform;
}, {
  isTransformFunction: true
});
function _map(array, callback, orig) {
  var argsCount = maxArgumentCount(callback);
  function recurse(value, index2) {
    if (Array.isArray(value)) {
      return map$1(value, function(child, i2) {
        return recurse(child, index2.concat(i2 + 1));
      });
    } else {
      if (argsCount === 1) {
        return callback(value);
      } else if (argsCount === 2) {
        return callback(value, index2);
      } else {
        return callback(value, index2, orig);
      }
    }
  }
  return recurse(array, []);
}
function lastDimToZeroBase(args) {
  if (args.length === 2 && isCollection$1(args[0])) {
    args = args.slice();
    var dim = args[1];
    if (isNumber(dim)) {
      args[1] = dim - 1;
    } else if (isBigNumber(dim)) {
      args[1] = dim.minus(1);
    }
  }
  return args;
}
var name$b = "max";
var dependencies$b = ["typed", "config", "numeric", "larger"];
var createMaxTransform = /* @__PURE__ */ factory(name$b, dependencies$b, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    numeric: numeric3,
    larger: larger2
  } = _ref;
  var max3 = createMax({
    typed: typed2,
    config: config3,
    numeric: numeric3,
    larger: larger2
  });
  return typed2("max", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return max3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$a = "mean";
var dependencies$a = ["typed", "add", "divide"];
var createMeanTransform = /* @__PURE__ */ factory(name$a, dependencies$a, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    divide: divide2
  } = _ref;
  var mean2 = createMean({
    typed: typed2,
    add: add2,
    divide: divide2
  });
  return typed2("mean", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return mean2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$9 = "min";
var dependencies$9 = ["typed", "config", "numeric", "smaller"];
var createMinTransform = /* @__PURE__ */ factory(name$9, dependencies$9, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    numeric: numeric3,
    smaller: smaller2
  } = _ref;
  var min3 = createMin({
    typed: typed2,
    config: config3,
    numeric: numeric3,
    smaller: smaller2
  });
  return typed2("min", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return min3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$8 = "range";
var dependencies$8 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq"];
var createRangeTransform = /* @__PURE__ */ factory(name$8, dependencies$8, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    bignumber: bignumber2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2,
    largerEq: largerEq2
  } = _ref;
  var range2 = createRange({
    typed: typed2,
    config: config3,
    matrix: matrix2,
    bignumber: bignumber2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2,
    largerEq: largerEq2
  });
  return typed2("range", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last3 = args[lastIndex];
      if (typeof last3 !== "boolean") {
        args.push(true);
      }
      return range2.apply(null, args);
    }
  });
}, {
  isTransformFunction: true
});
var name$7 = "row";
var dependencies$7 = ["typed", "Index", "matrix", "range"];
var createRowTransform = /* @__PURE__ */ factory(name$7, dependencies$7, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  var row2 = createRow({
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  });
  return typed2("row", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last3 = args[lastIndex];
      if (isNumber(last3)) {
        args[lastIndex] = last3 - 1;
      }
      try {
        return row2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$6 = "subset";
var dependencies$6 = ["typed", "matrix"];
var createSubsetTransform = /* @__PURE__ */ factory(name$6, dependencies$6, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  var subset2 = createSubset({
    typed: typed2,
    matrix: matrix2
  });
  return typed2("subset", {
    "...any": function any(args) {
      try {
        return subset2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$5 = "concat";
var dependencies$5 = ["typed", "matrix", "isInteger"];
var createConcatTransform = /* @__PURE__ */ factory(name$5, dependencies$5, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger2
  } = _ref;
  var concat3 = createConcat({
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger2
  });
  return typed2("concat", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last3 = args[lastIndex];
      if (isNumber(last3)) {
        args[lastIndex] = last3 - 1;
      } else if (isBigNumber(last3)) {
        args[lastIndex] = last3.minus(1);
      }
      try {
        return concat3.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$4 = "diff";
var dependencies$4 = ["typed", "matrix", "subtract", "number", "bignumber"];
var createDiffTransform = /* @__PURE__ */ factory(name$4, dependencies$4, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number2,
    bignumber: bignumber2
  } = _ref;
  var diff2 = createDiff({
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number2,
    bignumber: bignumber2
  });
  return typed2(name$4, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return diff2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$3 = "std";
var dependencies$3 = ["typed", "map", "sqrt", "variance"];
var createStdTransform = /* @__PURE__ */ factory(name$3, dependencies$3, (_ref) => {
  var {
    typed: typed2,
    map: map3,
    sqrt: sqrt2,
    variance: variance2
  } = _ref;
  var std2 = createStd({
    typed: typed2,
    map: map3,
    sqrt: sqrt2,
    variance: variance2
  });
  return typed2("std", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return std2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$2 = "sum";
var dependencies$2 = ["typed", "config", "add", "numeric"];
var createSumTransform = /* @__PURE__ */ factory(name$2, dependencies$2, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    add: add2,
    numeric: numeric3
  } = _ref;
  var sum2 = createSum({
    typed: typed2,
    config: config3,
    add: add2,
    numeric: numeric3
  });
  return typed2(name$2, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return sum2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$1 = "cumsum";
var dependencies$1 = ["typed", "add", "unaryPlus"];
var createCumSumTransform = /* @__PURE__ */ factory(name$1, dependencies$1, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    unaryPlus: unaryPlus2
  } = _ref;
  var cumsum2 = createCumSum({
    typed: typed2,
    add: add2,
    unaryPlus: unaryPlus2
  });
  return typed2(name$1, {
    "...any": function any(args) {
      if (args.length === 2 && isCollection$1(args[0])) {
        var dim = args[1];
        if (isNumber(dim)) {
          args[1] = dim - 1;
        } else if (isBigNumber(dim)) {
          args[1] = dim.minus(1);
        }
      }
      try {
        return cumsum2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name = "variance";
var dependencies = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
var createVarianceTransform = /* @__PURE__ */ factory(name, dependencies, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    apply: apply2,
    isNaN: isNaN2
  } = _ref;
  var variance2 = createVariance({
    typed: typed2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    apply: apply2,
    isNaN: isNaN2
  });
  return typed2(name, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return variance2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var BigNumber = /* @__PURE__ */ createBigNumberClass({
  config: config$1
});
var Complex = /* @__PURE__ */ createComplexClass({});
var e = /* @__PURE__ */ createE({
  BigNumber,
  config: config$1
});
var _false = /* @__PURE__ */ createFalse({});
var fineStructure = /* @__PURE__ */ createFineStructure({
  BigNumber,
  config: config$1
});
var Fraction = /* @__PURE__ */ createFractionClass({});
var i = /* @__PURE__ */ createI({
  Complex
});
var _Infinity = /* @__PURE__ */ createInfinity({
  BigNumber,
  config: config$1
});
var LN10 = /* @__PURE__ */ createLN10({
  BigNumber,
  config: config$1
});
var LOG10E = /* @__PURE__ */ createLOG10E({
  BigNumber,
  config: config$1
});
var Matrix = /* @__PURE__ */ createMatrixClass({});
var _NaN = /* @__PURE__ */ createNaN({
  BigNumber,
  config: config$1
});
var _null = /* @__PURE__ */ createNull({});
var phi = /* @__PURE__ */ createPhi({
  BigNumber,
  config: config$1
});
var Range$1 = /* @__PURE__ */ createRangeClass({});
var ResultSet = /* @__PURE__ */ createResultSet({});
var SQRT1_2 = /* @__PURE__ */ createSQRT1_2({
  BigNumber,
  config: config$1
});
var sackurTetrode = /* @__PURE__ */ createSackurTetrode({
  BigNumber,
  config: config$1
});
var tau = /* @__PURE__ */ createTau({
  BigNumber,
  config: config$1
});
var _true = /* @__PURE__ */ createTrue({});
var version = /* @__PURE__ */ createVersion({});
var DenseMatrix = /* @__PURE__ */ createDenseMatrixClass({
  Matrix
});
var efimovFactor = /* @__PURE__ */ createEfimovFactor({
  BigNumber,
  config: config$1
});
var LN2 = /* @__PURE__ */ createLN2({
  BigNumber,
  config: config$1
});
var pi = /* @__PURE__ */ createPi({
  BigNumber,
  config: config$1
});
var replacer = /* @__PURE__ */ createReplacer({});
var SQRT2 = /* @__PURE__ */ createSQRT2({
  BigNumber,
  config: config$1
});
var typed = /* @__PURE__ */ createTyped({
  BigNumber,
  Complex,
  DenseMatrix,
  Fraction
});
var unaryPlus = /* @__PURE__ */ createUnaryPlus({
  BigNumber,
  config: config$1,
  typed
});
var weakMixingAngle = /* @__PURE__ */ createWeakMixingAngle({
  BigNumber,
  config: config$1
});
var abs = /* @__PURE__ */ createAbs({
  typed
});
var acos = /* @__PURE__ */ createAcos({
  Complex,
  config: config$1,
  typed
});
var acot = /* @__PURE__ */ createAcot({
  BigNumber,
  typed
});
var acsc = /* @__PURE__ */ createAcsc({
  BigNumber,
  Complex,
  config: config$1,
  typed
});
var addScalar = /* @__PURE__ */ createAddScalar({
  typed
});
var arg = /* @__PURE__ */ createArg({
  typed
});
var asech = /* @__PURE__ */ createAsech({
  BigNumber,
  Complex,
  config: config$1,
  typed
});
var asinh = /* @__PURE__ */ createAsinh({
  typed
});
var atan = /* @__PURE__ */ createAtan({
  typed
});
var atanh = /* @__PURE__ */ createAtanh({
  Complex,
  config: config$1,
  typed
});
var bignumber = /* @__PURE__ */ createBignumber({
  BigNumber,
  typed
});
var bitNot = /* @__PURE__ */ createBitNot({
  typed
});
var boolean = /* @__PURE__ */ createBoolean({
  typed
});
var clone = /* @__PURE__ */ createClone({
  typed
});
var combinations = /* @__PURE__ */ createCombinations({
  typed
});
var complex = /* @__PURE__ */ createComplex({
  Complex,
  typed
});
var conj = /* @__PURE__ */ createConj({
  typed
});
var cosh = /* @__PURE__ */ createCosh({
  typed
});
var coth = /* @__PURE__ */ createCoth({
  BigNumber,
  typed
});
var csc = /* @__PURE__ */ createCsc({
  BigNumber,
  typed
});
var cube = /* @__PURE__ */ createCube({
  typed
});
var equalScalar = /* @__PURE__ */ createEqualScalar({
  config: config$1,
  typed
});
var erf = /* @__PURE__ */ createErf({
  typed
});
var exp = /* @__PURE__ */ createExp({
  typed
});
var expm12 = /* @__PURE__ */ createExpm1({
  Complex,
  typed
});
var filter = /* @__PURE__ */ createFilter({
  typed
});
var forEach = /* @__PURE__ */ createForEach({
  typed
});
var format = /* @__PURE__ */ createFormat({
  typed
});
var getMatrixDataType = /* @__PURE__ */ createGetMatrixDataType({
  typed
});
var hex = /* @__PURE__ */ createHex({
  format,
  typed
});
var im = /* @__PURE__ */ createIm({
  typed
});
var isInteger = /* @__PURE__ */ createIsInteger({
  typed
});
var isNegative = /* @__PURE__ */ createIsNegative({
  typed
});
var isPositive = /* @__PURE__ */ createIsPositive({
  typed
});
var isZero = /* @__PURE__ */ createIsZero({
  typed
});
var LOG2E = /* @__PURE__ */ createLOG2E({
  BigNumber,
  config: config$1
});
var lgamma = /* @__PURE__ */ createLgamma({
  Complex,
  typed
});
var log102 = /* @__PURE__ */ createLog10({
  Complex,
  config: config$1,
  typed
});
var log22 = /* @__PURE__ */ createLog2({
  Complex,
  config: config$1,
  typed
});
var map = /* @__PURE__ */ createMap({
  typed
});
var multiplyScalar = /* @__PURE__ */ createMultiplyScalar({
  typed
});
var not$1 = /* @__PURE__ */ createNot({
  typed
});
var number = /* @__PURE__ */ createNumber({
  typed
});
var oct = /* @__PURE__ */ createOct({
  format,
  typed
});
var pickRandom = /* @__PURE__ */ createPickRandom({
  config: config$1,
  typed
});
var print = /* @__PURE__ */ createPrint({
  typed
});
var random = /* @__PURE__ */ createRandom({
  config: config$1,
  typed
});
var re = /* @__PURE__ */ createRe({
  typed
});
var sec = /* @__PURE__ */ createSec({
  BigNumber,
  typed
});
var sign = /* @__PURE__ */ createSign({
  BigNumber,
  Fraction,
  complex,
  typed
});
var sin = /* @__PURE__ */ createSin({
  typed
});
var SparseMatrix = /* @__PURE__ */ createSparseMatrixClass({
  Matrix,
  equalScalar,
  typed
});
var splitUnit = /* @__PURE__ */ createSplitUnit({
  typed
});
var square = /* @__PURE__ */ createSquare({
  typed
});
var string = /* @__PURE__ */ createString({
  typed
});
var tan = /* @__PURE__ */ createTan({
  typed
});
var typeOf = /* @__PURE__ */ createTypeOf({
  typed
});
var acosh = /* @__PURE__ */ createAcosh({
  Complex,
  config: config$1,
  typed
});
var acsch = /* @__PURE__ */ createAcsch({
  BigNumber,
  typed
});
var apply = /* @__PURE__ */ createApply({
  isInteger,
  typed
});
var asec = /* @__PURE__ */ createAsec({
  BigNumber,
  Complex,
  config: config$1,
  typed
});
var bin = /* @__PURE__ */ createBin({
  format,
  typed
});
var combinationsWithRep = /* @__PURE__ */ createCombinationsWithRep({
  typed
});
var cos = /* @__PURE__ */ createCos({
  typed
});
var csch = /* @__PURE__ */ createCsch({
  BigNumber,
  typed
});
var isNaN$1 = /* @__PURE__ */ createIsNaN({
  typed
});
var isPrime = /* @__PURE__ */ createIsPrime({
  typed
});
var randomInt = /* @__PURE__ */ createRandomInt({
  config: config$1,
  typed
});
var sech = /* @__PURE__ */ createSech({
  BigNumber,
  typed
});
var sinh = /* @__PURE__ */ createSinh({
  typed
});
var sparse = /* @__PURE__ */ createSparse({
  SparseMatrix,
  typed
});
var sqrt = /* @__PURE__ */ createSqrt({
  Complex,
  config: config$1,
  typed
});
var tanh = /* @__PURE__ */ createTanh({
  typed
});
var unaryMinus = /* @__PURE__ */ createUnaryMinus({
  typed
});
var acoth = /* @__PURE__ */ createAcoth({
  BigNumber,
  Complex,
  config: config$1,
  typed
});
var cot = /* @__PURE__ */ createCot({
  BigNumber,
  typed
});
var fraction = /* @__PURE__ */ createFraction({
  Fraction,
  typed
});
var isNumeric = /* @__PURE__ */ createIsNumeric({
  typed
});
var matrix = /* @__PURE__ */ createMatrix({
  DenseMatrix,
  Matrix,
  SparseMatrix,
  typed
});
var matrixFromFunction = /* @__PURE__ */ createMatrixFromFunction({
  isZero,
  matrix,
  typed
});
var mod = /* @__PURE__ */ createMod({
  DenseMatrix,
  equalScalar,
  matrix,
  typed
});
var nthRoot = /* @__PURE__ */ createNthRoot({
  BigNumber,
  equalScalar,
  matrix,
  typed
});
var numeric2 = /* @__PURE__ */ createNumeric({
  bignumber,
  fraction,
  number
});
var or = /* @__PURE__ */ createOr({
  DenseMatrix,
  equalScalar,
  matrix,
  typed
});
var prod = /* @__PURE__ */ createProd({
  config: config$1,
  multiplyScalar,
  numeric: numeric2,
  typed
});
var reshape = /* @__PURE__ */ createReshape({
  isInteger,
  matrix,
  typed
});
var size = /* @__PURE__ */ createSize({
  matrix,
  config: config$1,
  typed
});
var smaller = /* @__PURE__ */ createSmaller({
  DenseMatrix,
  config: config$1,
  matrix,
  typed
});
var squeeze = /* @__PURE__ */ createSqueeze({
  matrix,
  typed
});
var subset = /* @__PURE__ */ createSubset({
  matrix,
  typed
});
var subtract = /* @__PURE__ */ createSubtract({
  DenseMatrix,
  addScalar,
  equalScalar,
  matrix,
  typed,
  unaryMinus
});
var to = /* @__PURE__ */ createTo({
  matrix,
  typed
});
var transpose = /* @__PURE__ */ createTranspose({
  matrix,
  typed
});
var xgcd = /* @__PURE__ */ createXgcd({
  BigNumber,
  config: config$1,
  matrix,
  typed
});
var zeros = /* @__PURE__ */ createZeros({
  BigNumber,
  config: config$1,
  matrix,
  typed
});
var and = /* @__PURE__ */ createAnd({
  equalScalar,
  matrix,
  not: not$1,
  typed,
  zeros
});
var bitAnd = /* @__PURE__ */ createBitAnd({
  equalScalar,
  matrix,
  typed
});
var bitXor = /* @__PURE__ */ createBitXor({
  DenseMatrix,
  matrix,
  typed
});
var cbrt2 = /* @__PURE__ */ createCbrt({
  BigNumber,
  Complex,
  Fraction,
  config: config$1,
  isNegative,
  matrix,
  typed,
  unaryMinus
});
var compare = /* @__PURE__ */ createCompare({
  BigNumber,
  DenseMatrix,
  Fraction,
  config: config$1,
  equalScalar,
  matrix,
  typed
});
var compareText = /* @__PURE__ */ createCompareText({
  matrix,
  typed
});
var concat = /* @__PURE__ */ createConcat({
  isInteger,
  matrix,
  typed
});
var count = /* @__PURE__ */ createCount({
  prod,
  size,
  typed
});
var ctranspose = /* @__PURE__ */ createCtranspose({
  conj,
  transpose,
  typed
});
var diag = /* @__PURE__ */ createDiag({
  DenseMatrix,
  SparseMatrix,
  matrix,
  typed
});
var divideScalar = /* @__PURE__ */ createDivideScalar({
  numeric: numeric2,
  typed
});
var dotDivide = /* @__PURE__ */ createDotDivide({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  typed
});
var equal = /* @__PURE__ */ createEqual({
  DenseMatrix,
  equalScalar,
  matrix,
  typed
});
var fft = /* @__PURE__ */ createFft({
  addScalar,
  divideScalar,
  exp,
  i,
  matrix,
  multiplyScalar,
  tau,
  typed
});
var flatten = /* @__PURE__ */ createFlatten({
  matrix,
  typed
});
var gcd = /* @__PURE__ */ createGcd({
  BigNumber,
  DenseMatrix,
  equalScalar,
  matrix,
  typed
});
var hasNumericValue = /* @__PURE__ */ createHasNumericValue({
  isNumeric,
  typed
});
var hypot = /* @__PURE__ */ createHypot({
  abs,
  addScalar,
  divideScalar,
  isPositive,
  multiplyScalar,
  smaller,
  sqrt,
  typed
});
var ifft = /* @__PURE__ */ createIfft({
  conj,
  dotDivide,
  fft,
  typed
});
var kron = /* @__PURE__ */ createKron({
  matrix,
  multiplyScalar,
  typed
});
var largerEq = /* @__PURE__ */ createLargerEq({
  DenseMatrix,
  config: config$1,
  matrix,
  typed
});
var leftShift = /* @__PURE__ */ createLeftShift({
  DenseMatrix,
  equalScalar,
  matrix,
  typed,
  zeros
});
var lsolve = /* @__PURE__ */ createLsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtract,
  typed
});
var matrixFromColumns = /* @__PURE__ */ createMatrixFromColumns({
  flatten,
  matrix,
  size,
  typed
});
var min = /* @__PURE__ */ createMin({
  config: config$1,
  numeric: numeric2,
  smaller,
  typed
});
var mode = /* @__PURE__ */ createMode({
  isNaN: isNaN$1,
  isNumeric,
  typed
});
var nthRoots = /* @__PURE__ */ createNthRoots({
  Complex,
  config: config$1,
  divideScalar,
  typed
});
var ones = /* @__PURE__ */ createOnes({
  BigNumber,
  config: config$1,
  matrix,
  typed
});
var partitionSelect = /* @__PURE__ */ createPartitionSelect({
  compare,
  isNaN: isNaN$1,
  isNumeric,
  typed
});
var resize = /* @__PURE__ */ createResize({
  config: config$1,
  matrix
});
var rightArithShift = /* @__PURE__ */ createRightArithShift({
  DenseMatrix,
  equalScalar,
  matrix,
  typed,
  zeros
});
var round = /* @__PURE__ */ createRound({
  BigNumber,
  DenseMatrix,
  equalScalar,
  matrix,
  typed,
  zeros
});
var smallerEq = /* @__PURE__ */ createSmallerEq({
  DenseMatrix,
  config: config$1,
  matrix,
  typed
});
var unequal = /* @__PURE__ */ createUnequal({
  DenseMatrix,
  config: config$1,
  equalScalar,
  matrix,
  typed
});
var usolve = /* @__PURE__ */ createUsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtract,
  typed
});
var xor = /* @__PURE__ */ createXor({
  DenseMatrix,
  matrix,
  typed
});
var add = /* @__PURE__ */ createAdd({
  DenseMatrix,
  SparseMatrix,
  addScalar,
  equalScalar,
  matrix,
  typed
});
var atan2 = /* @__PURE__ */ createAtan2({
  BigNumber,
  DenseMatrix,
  equalScalar,
  matrix,
  typed
});
var bitOr = /* @__PURE__ */ createBitOr({
  DenseMatrix,
  equalScalar,
  matrix,
  typed
});
var catalan = /* @__PURE__ */ createCatalan({
  addScalar,
  combinations,
  divideScalar,
  isInteger,
  isNegative,
  multiplyScalar,
  typed
});
var compareNatural = /* @__PURE__ */ createCompareNatural({
  compare,
  typed
});
var cumsum = /* @__PURE__ */ createCumSum({
  add,
  typed,
  unaryPlus
});
var deepEqual$1 = /* @__PURE__ */ createDeepEqual({
  equal,
  typed
});
var diff = /* @__PURE__ */ createDiff({
  matrix,
  number,
  subtract,
  typed
});
var dot = /* @__PURE__ */ createDot({
  addScalar,
  conj,
  multiplyScalar,
  size,
  typed
});
var equalText = /* @__PURE__ */ createEqualText({
  compareText,
  isZero,
  typed
});
var floor = /* @__PURE__ */ createFloor({
  DenseMatrix,
  config: config$1,
  equalScalar,
  matrix,
  round,
  typed,
  zeros
});
var identity = /* @__PURE__ */ createIdentity({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  config: config$1,
  matrix,
  typed
});
var invmod = /* @__PURE__ */ createInvmod({
  BigNumber,
  add,
  config: config$1,
  equal,
  isInteger,
  mod,
  smaller,
  typed,
  xgcd
});
var larger = /* @__PURE__ */ createLarger({
  DenseMatrix,
  config: config$1,
  matrix,
  typed
});
var log = /* @__PURE__ */ createLog({
  Complex,
  config: config$1,
  divideScalar,
  typed
});
var lsolveAll = /* @__PURE__ */ createLsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtract,
  typed
});
var matrixFromRows = /* @__PURE__ */ createMatrixFromRows({
  flatten,
  matrix,
  size,
  typed
});
var multiply = /* @__PURE__ */ createMultiply({
  addScalar,
  dot,
  equalScalar,
  matrix,
  multiplyScalar,
  typed
});
var qr = /* @__PURE__ */ createQr({
  addScalar,
  complex,
  conj,
  divideScalar,
  equal,
  identity,
  isZero,
  matrix,
  multiplyScalar,
  sign,
  sqrt,
  subtract,
  typed,
  unaryMinus,
  zeros
});
var range = /* @__PURE__ */ createRange({
  bignumber,
  matrix,
  config: config$1,
  larger,
  largerEq,
  smaller,
  smallerEq,
  typed
});
var rightLogShift = /* @__PURE__ */ createRightLogShift({
  DenseMatrix,
  equalScalar,
  matrix,
  typed,
  zeros
});
var setSize = /* @__PURE__ */ createSetSize({
  compareNatural,
  typed
});
var slu = /* @__PURE__ */ createSlu({
  SparseMatrix,
  abs,
  add,
  divideScalar,
  larger,
  largerEq,
  multiply,
  subtract,
  transpose,
  typed
});
var sum = /* @__PURE__ */ createSum({
  add,
  config: config$1,
  numeric: numeric2,
  typed
});
var trace = /* @__PURE__ */ createTrace({
  add,
  matrix,
  typed
});
var usolveAll = /* @__PURE__ */ createUsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtract,
  typed
});
var asin = /* @__PURE__ */ createAsin({
  Complex,
  config: config$1,
  typed
});
var ceil = /* @__PURE__ */ createCeil({
  DenseMatrix,
  config: config$1,
  equalScalar,
  matrix,
  round,
  typed,
  zeros
});
var composition = /* @__PURE__ */ createComposition({
  addScalar,
  combinations,
  isInteger,
  isNegative,
  isPositive,
  larger,
  typed
});
var cross = /* @__PURE__ */ createCross({
  matrix,
  multiply,
  subtract,
  typed
});
var det = /* @__PURE__ */ createDet({
  divideScalar,
  isZero,
  matrix,
  multiply,
  subtract,
  typed,
  unaryMinus
});
var distance = /* @__PURE__ */ createDistance({
  abs,
  addScalar,
  divideScalar,
  multiplyScalar,
  sqrt,
  subtract,
  typed,
  unaryMinus
});
var dotMultiply = /* @__PURE__ */ createDotMultiply({
  equalScalar,
  matrix,
  multiplyScalar,
  typed
});
var FibonacciHeap = /* @__PURE__ */ createFibonacciHeapClass({
  larger,
  smaller
});
var fix = /* @__PURE__ */ createFix({
  Complex,
  DenseMatrix,
  ceil,
  equalScalar,
  floor,
  matrix,
  typed,
  zeros
});
var ImmutableDenseMatrix = /* @__PURE__ */ createImmutableDenseMatrixClass({
  DenseMatrix,
  smaller
});
var Index = /* @__PURE__ */ createIndexClass({
  ImmutableDenseMatrix
});
var intersect = /* @__PURE__ */ createIntersect({
  abs,
  add,
  addScalar,
  config: config$1,
  divideScalar,
  equalScalar,
  flatten,
  isNumeric,
  isZero,
  matrix,
  multiply,
  multiplyScalar,
  smaller,
  subtract,
  typed
});
var lcm = /* @__PURE__ */ createLcm({
  equalScalar,
  matrix,
  typed
});
var log1p = /* @__PURE__ */ createLog1p({
  Complex,
  config: config$1,
  divideScalar,
  log,
  typed
});
var max = /* @__PURE__ */ createMax({
  config: config$1,
  larger,
  numeric: numeric2,
  typed
});
var quantileSeq = /* @__PURE__ */ createQuantileSeq({
  add,
  compare,
  multiply,
  partitionSelect,
  typed
});
var row = /* @__PURE__ */ createRow({
  Index,
  matrix,
  range,
  typed
});
var setCartesian = /* @__PURE__ */ createSetCartesian({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setDistinct = /* @__PURE__ */ createSetDistinct({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setIsSubset = /* @__PURE__ */ createSetIsSubset({
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setPowerset = /* @__PURE__ */ createSetPowerset({
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var sort = /* @__PURE__ */ createSort({
  compare,
  compareNatural,
  matrix,
  typed
});
var column = /* @__PURE__ */ createColumn({
  Index,
  matrix,
  range,
  typed
});
var index = /* @__PURE__ */ createIndex({
  Index,
  typed
});
var inv = /* @__PURE__ */ createInv({
  abs,
  addScalar,
  det,
  divideScalar,
  identity,
  matrix,
  multiply,
  typed,
  unaryMinus
});
var pinv = /* @__PURE__ */ createPinv({
  Complex,
  add,
  ctranspose,
  deepEqual: deepEqual$1,
  divideScalar,
  dot,
  dotDivide,
  equal,
  inv,
  matrix,
  multiply,
  typed
});
var pow = /* @__PURE__ */ createPow({
  Complex,
  config: config$1,
  fraction,
  identity,
  inv,
  matrix,
  multiply,
  number,
  typed
});
var setDifference = /* @__PURE__ */ createSetDifference({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setMultiplicity = /* @__PURE__ */ createSetMultiplicity({
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var Spa = /* @__PURE__ */ createSpaClass({
  FibonacciHeap,
  addScalar,
  equalScalar
});
var sqrtm = /* @__PURE__ */ createSqrtm({
  abs,
  add,
  identity,
  inv,
  map,
  max,
  multiply,
  size,
  sqrt,
  subtract,
  typed
});
var Unit = /* @__PURE__ */ createUnitClass({
  BigNumber,
  Complex,
  Fraction,
  abs,
  addScalar,
  config: config$1,
  divideScalar,
  equal,
  fix,
  format,
  isNumeric,
  multiplyScalar,
  number,
  pow,
  round,
  subtract
});
var vacuumImpedance = /* @__PURE__ */ createVacuumImpedance({
  BigNumber,
  Unit,
  config: config$1
});
var wienDisplacement = /* @__PURE__ */ createWienDisplacement({
  BigNumber,
  Unit,
  config: config$1
});
var atomicMass = /* @__PURE__ */ createAtomicMass({
  BigNumber,
  Unit,
  config: config$1
});
var bohrMagneton = /* @__PURE__ */ createBohrMagneton({
  BigNumber,
  Unit,
  config: config$1
});
var boltzmann = /* @__PURE__ */ createBoltzmann({
  BigNumber,
  Unit,
  config: config$1
});
var conductanceQuantum = /* @__PURE__ */ createConductanceQuantum({
  BigNumber,
  Unit,
  config: config$1
});
var createUnit = /* @__PURE__ */ createCreateUnit({
  Unit,
  typed
});
var deuteronMass = /* @__PURE__ */ createDeuteronMass({
  BigNumber,
  Unit,
  config: config$1
});
var dotPow = /* @__PURE__ */ createDotPow({
  DenseMatrix,
  equalScalar,
  matrix,
  pow,
  typed
});
var electricConstant = /* @__PURE__ */ createElectricConstant({
  BigNumber,
  Unit,
  config: config$1
});
var elementaryCharge = /* @__PURE__ */ createElementaryCharge({
  BigNumber,
  Unit,
  config: config$1
});
var expm = /* @__PURE__ */ createExpm({
  abs,
  add,
  identity,
  inv,
  multiply,
  typed
});
var faraday = /* @__PURE__ */ createFaraday({
  BigNumber,
  Unit,
  config: config$1
});
var firstRadiation = /* @__PURE__ */ createFirstRadiation({
  BigNumber,
  Unit,
  config: config$1
});
var gamma = /* @__PURE__ */ createGamma({
  BigNumber,
  Complex,
  config: config$1,
  multiplyScalar,
  pow,
  typed
});
var gravitationConstant = /* @__PURE__ */ createGravitationConstant({
  BigNumber,
  Unit,
  config: config$1
});
var hartreeEnergy = /* @__PURE__ */ createHartreeEnergy({
  BigNumber,
  Unit,
  config: config$1
});
var klitzing = /* @__PURE__ */ createKlitzing({
  BigNumber,
  Unit,
  config: config$1
});
var loschmidt = /* @__PURE__ */ createLoschmidt({
  BigNumber,
  Unit,
  config: config$1
});
var magneticConstant = /* @__PURE__ */ createMagneticConstant({
  BigNumber,
  Unit,
  config: config$1
});
var molarMass = /* @__PURE__ */ createMolarMass({
  BigNumber,
  Unit,
  config: config$1
});
var molarPlanckConstant = /* @__PURE__ */ createMolarPlanckConstant({
  BigNumber,
  Unit,
  config: config$1
});
var neutronMass = /* @__PURE__ */ createNeutronMass({
  BigNumber,
  Unit,
  config: config$1
});
var nuclearMagneton = /* @__PURE__ */ createNuclearMagneton({
  BigNumber,
  Unit,
  config: config$1
});
var planckCharge = /* @__PURE__ */ createPlanckCharge({
  BigNumber,
  Unit,
  config: config$1
});
var planckLength = /* @__PURE__ */ createPlanckLength({
  BigNumber,
  Unit,
  config: config$1
});
var planckTemperature = /* @__PURE__ */ createPlanckTemperature({
  BigNumber,
  Unit,
  config: config$1
});
var protonMass = /* @__PURE__ */ createProtonMass({
  BigNumber,
  Unit,
  config: config$1
});
var reducedPlanckConstant = /* @__PURE__ */ createReducedPlanckConstant({
  BigNumber,
  Unit,
  config: config$1
});
var rydberg = /* @__PURE__ */ createRydberg({
  BigNumber,
  Unit,
  config: config$1
});
var setIntersect = /* @__PURE__ */ createSetIntersect({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var speedOfLight = /* @__PURE__ */ createSpeedOfLight({
  BigNumber,
  Unit,
  config: config$1
});
var stefanBoltzmann = /* @__PURE__ */ createStefanBoltzmann({
  BigNumber,
  Unit,
  config: config$1
});
var thomsonCrossSection = /* @__PURE__ */ createThomsonCrossSection({
  BigNumber,
  Unit,
  config: config$1
});
var avogadro = /* @__PURE__ */ createAvogadro({
  BigNumber,
  Unit,
  config: config$1
});
var bohrRadius = /* @__PURE__ */ createBohrRadius({
  BigNumber,
  Unit,
  config: config$1
});
var coulomb = /* @__PURE__ */ createCoulomb({
  BigNumber,
  Unit,
  config: config$1
});
var divide = /* @__PURE__ */ createDivide({
  divideScalar,
  equalScalar,
  inv,
  matrix,
  multiply,
  typed
});
var electronMass = /* @__PURE__ */ createElectronMass({
  BigNumber,
  Unit,
  config: config$1
});
var factorial = /* @__PURE__ */ createFactorial({
  gamma,
  typed
});
var gravity = /* @__PURE__ */ createGravity({
  BigNumber,
  Unit,
  config: config$1
});
var inverseConductanceQuantum = /* @__PURE__ */ createInverseConductanceQuantum({
  BigNumber,
  Unit,
  config: config$1
});
var lup = /* @__PURE__ */ createLup({
  DenseMatrix,
  Spa,
  SparseMatrix,
  abs,
  addScalar,
  divideScalar,
  equalScalar,
  larger,
  matrix,
  multiplyScalar,
  subtract,
  typed,
  unaryMinus
});
var magneticFluxQuantum = /* @__PURE__ */ createMagneticFluxQuantum({
  BigNumber,
  Unit,
  config: config$1
});
var molarMassC12 = /* @__PURE__ */ createMolarMassC12({
  BigNumber,
  Unit,
  config: config$1
});
var multinomial = /* @__PURE__ */ createMultinomial({
  add,
  divide,
  factorial,
  isInteger,
  isPositive,
  multiply,
  typed
});
var permutations = /* @__PURE__ */ createPermutations({
  factorial,
  typed
});
var planckMass = /* @__PURE__ */ createPlanckMass({
  BigNumber,
  Unit,
  config: config$1
});
var quantumOfCirculation = /* @__PURE__ */ createQuantumOfCirculation({
  BigNumber,
  Unit,
  config: config$1
});
var secondRadiation = /* @__PURE__ */ createSecondRadiation({
  BigNumber,
  Unit,
  config: config$1
});
var stirlingS2 = /* @__PURE__ */ createStirlingS2({
  bignumber,
  addScalar,
  combinations,
  divideScalar,
  factorial,
  isInteger,
  isNegative,
  larger,
  multiplyScalar,
  number,
  pow,
  subtract,
  typed
});
var unit = /* @__PURE__ */ createUnitFunction({
  Unit,
  typed
});
var bellNumbers = /* @__PURE__ */ createBellNumbers({
  addScalar,
  isInteger,
  isNegative,
  stirlingS2,
  typed
});
var eigs = /* @__PURE__ */ createEigs({
  abs,
  add,
  addScalar,
  atan,
  bignumber,
  column,
  complex,
  config: config$1,
  cos,
  diag,
  divideScalar,
  dot,
  equal,
  flatten,
  im,
  inv,
  larger,
  matrix,
  matrixFromColumns,
  multiply,
  multiplyScalar,
  number,
  qr,
  re,
  sin,
  smaller,
  sqrt,
  subtract,
  typed,
  usolve,
  usolveAll
});
var fermiCoupling = /* @__PURE__ */ createFermiCoupling({
  BigNumber,
  Unit,
  config: config$1
});
var mean = /* @__PURE__ */ createMean({
  add,
  divide,
  typed
});
var molarVolume = /* @__PURE__ */ createMolarVolume({
  BigNumber,
  Unit,
  config: config$1
});
var planckConstant = /* @__PURE__ */ createPlanckConstant({
  BigNumber,
  Unit,
  config: config$1
});
var setSymDifference = /* @__PURE__ */ createSetSymDifference({
  Index,
  concat,
  setDifference,
  size,
  subset,
  typed
});
var variance = /* @__PURE__ */ createVariance({
  add,
  apply,
  divide,
  isNaN: isNaN$1,
  multiply,
  subtract,
  typed
});
var classicalElectronRadius = /* @__PURE__ */ createClassicalElectronRadius({
  BigNumber,
  Unit,
  config: config$1
});
var lusolve = /* @__PURE__ */ createLusolve({
  DenseMatrix,
  lsolve,
  lup,
  matrix,
  slu,
  typed,
  usolve
});
var median = /* @__PURE__ */ createMedian({
  add,
  compare,
  divide,
  partitionSelect,
  typed
});
var setUnion = /* @__PURE__ */ createSetUnion({
  Index,
  concat,
  setIntersect,
  setSymDifference,
  size,
  subset,
  typed
});
var std = /* @__PURE__ */ createStd({
  map,
  sqrt,
  typed,
  variance
});
var gasConstant = /* @__PURE__ */ createGasConstant({
  BigNumber,
  Unit,
  config: config$1
});
var mad = /* @__PURE__ */ createMad({
  abs,
  map,
  median,
  subtract,
  typed
});
var norm = /* @__PURE__ */ createNorm({
  abs,
  add,
  conj,
  ctranspose,
  eigs,
  equalScalar,
  larger,
  matrix,
  multiply,
  pow,
  smaller,
  sqrt,
  typed
});
var rotationMatrix = /* @__PURE__ */ createRotationMatrix({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  addScalar,
  config: config$1,
  cos,
  matrix,
  multiplyScalar,
  norm,
  sin,
  typed,
  unaryMinus
});
var kldivergence = /* @__PURE__ */ createKldivergence({
  divide,
  dotDivide,
  isNumeric,
  log,
  map,
  matrix,
  multiply,
  sum,
  typed
});
var rotate = /* @__PURE__ */ createRotate({
  multiply,
  rotationMatrix,
  typed
});
var planckTime = /* @__PURE__ */ createPlanckTime({
  BigNumber,
  Unit,
  config: config$1
});
var math = {};
var mathWithTransform = {};
var classes = {};
var Node = createNode({
  mathWithTransform
});
var ObjectNode = createObjectNode({
  Node
});
var OperatorNode = createOperatorNode({
  Node
});
var ParenthesisNode = createParenthesisNode({
  Node
});
var RelationalNode = createRelationalNode({
  Node
});
var ArrayNode = createArrayNode({
  Node
});
var BlockNode = createBlockNode({
  Node,
  ResultSet
});
var ConditionalNode = createConditionalNode({
  Node
});
var ConstantNode = createConstantNode({
  Node
});
var RangeNode = createRangeNode({
  Node
});
var reviver = createReviver({
  classes
});
var Chain = createChainClass({
  math,
  typed
});
var FunctionAssignmentNode = createFunctionAssignmentNode({
  Node,
  typed
});
var chain = createChain({
  Chain,
  typed
});
var AccessorNode = createAccessorNode({
  Node,
  subset
});
var AssignmentNode = createAssignmentNode({
  matrix,
  Node,
  subset
});
var IndexNode = createIndexNode({
  Node,
  size
});
var SymbolNode = createSymbolNode({
  Unit,
  Node,
  math
});
var FunctionNode = createFunctionNode({
  Node,
  SymbolNode,
  math
});
var parse$2 = createParse({
  AccessorNode,
  ArrayNode,
  AssignmentNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  FunctionAssignmentNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  RangeNode,
  RelationalNode,
  SymbolNode,
  config: config$1,
  numeric: numeric2,
  typed
});
var resolve = createResolve({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  parse: parse$2,
  typed
});
var simplifyConstant = createSimplifyConstant({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  SymbolNode,
  config: config$1,
  mathWithTransform,
  matrix,
  parse: parse$2,
  typed
});
var compile = createCompile({
  parse: parse$2,
  typed
});
var Help = createHelpClass({
  parse: parse$2
});
var leafCount = createLeafCount({
  parse: parse$2,
  typed
});
var simplifyCore = createSimplifyCore({
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add,
  divide,
  equal,
  isZero,
  multiply,
  parse: parse$2,
  pow,
  subtract,
  typed
});
var evaluate = createEvaluate({
  parse: parse$2,
  typed
});
var help = createHelp({
  Help,
  mathWithTransform,
  typed
});
var Parser = createParserClass({
  evaluate
});
var parser = createParser({
  Parser,
  typed
});
var simplify$1 = createSimplify({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add,
  config: config$1,
  divide,
  equal,
  isZero,
  mathWithTransform,
  matrix,
  multiply,
  parse: parse$2,
  pow,
  resolve,
  simplifyConstant,
  simplifyCore,
  subtract,
  typed
});
var symbolicEqual = createSymbolicEqual({
  OperatorNode,
  parse: parse$2,
  simplify: simplify$1,
  typed
});
var derivative = createDerivative({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  config: config$1,
  equal,
  isZero,
  numeric: numeric2,
  parse: parse$2,
  simplify: simplify$1,
  typed
});
var rationalize = createRationalize({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add,
  config: config$1,
  divide,
  equal,
  isZero,
  mathWithTransform,
  matrix,
  multiply,
  parse: parse$2,
  pow,
  simplify: simplify$1,
  simplifyConstant,
  simplifyCore,
  subtract,
  typed
});
_extends$1(math, {
  e,
  false: _false,
  fineStructure,
  i,
  Infinity: _Infinity,
  LN10,
  LOG10E,
  NaN: _NaN,
  null: _null,
  phi,
  SQRT1_2,
  sackurTetrode,
  tau,
  true: _true,
  "E": e,
  version,
  efimovFactor,
  LN2,
  pi,
  replacer,
  reviver,
  SQRT2,
  typed,
  unaryPlus,
  "PI": pi,
  weakMixingAngle,
  abs,
  acos,
  acot,
  acsc,
  addScalar,
  arg,
  asech,
  asinh,
  atan,
  atanh,
  bignumber,
  bitNot,
  boolean,
  clone,
  combinations,
  complex,
  conj,
  cosh,
  coth,
  csc,
  cube,
  equalScalar,
  erf,
  exp,
  expm1: expm12,
  filter,
  forEach,
  format,
  getMatrixDataType,
  hex,
  im,
  isInteger,
  isNegative,
  isPositive,
  isZero,
  LOG2E,
  lgamma,
  log10: log102,
  log2: log22,
  map,
  multiplyScalar,
  not: not$1,
  number,
  oct,
  pickRandom,
  print,
  random,
  re,
  sec,
  sign,
  sin,
  splitUnit,
  square,
  string,
  tan,
  typeOf,
  acosh,
  acsch,
  apply,
  asec,
  bin,
  chain,
  combinationsWithRep,
  cos,
  csch,
  isNaN: isNaN$1,
  isPrime,
  randomInt,
  sech,
  sinh,
  sparse,
  sqrt,
  tanh,
  unaryMinus,
  acoth,
  cot,
  fraction,
  isNumeric,
  matrix,
  matrixFromFunction,
  mod,
  nthRoot,
  numeric: numeric2,
  or,
  prod,
  reshape,
  size,
  smaller,
  squeeze,
  subset,
  subtract,
  to,
  transpose,
  xgcd,
  zeros,
  and,
  bitAnd,
  bitXor,
  cbrt: cbrt2,
  compare,
  compareText,
  concat,
  count,
  ctranspose,
  diag,
  divideScalar,
  dotDivide,
  equal,
  fft,
  flatten,
  gcd,
  hasNumericValue,
  hypot,
  ifft,
  kron,
  largerEq,
  leftShift,
  lsolve,
  matrixFromColumns,
  min,
  mode,
  nthRoots,
  ones,
  partitionSelect,
  resize,
  rightArithShift,
  round,
  smallerEq,
  unequal,
  usolve,
  xor,
  add,
  atan2,
  bitOr,
  catalan,
  compareNatural,
  cumsum,
  deepEqual: deepEqual$1,
  diff,
  dot,
  equalText,
  floor,
  identity,
  invmod,
  larger,
  log,
  lsolveAll,
  matrixFromRows,
  multiply,
  qr,
  range,
  rightLogShift,
  setSize,
  slu,
  sum,
  trace,
  usolveAll,
  asin,
  ceil,
  composition,
  cross,
  det,
  distance,
  dotMultiply,
  fix,
  intersect,
  lcm,
  log1p,
  max,
  quantileSeq,
  row,
  setCartesian,
  setDistinct,
  setIsSubset,
  setPowerset,
  sort,
  column,
  index,
  inv,
  pinv,
  pow,
  setDifference,
  setMultiplicity,
  sqrtm,
  vacuumImpedance,
  wienDisplacement,
  atomicMass,
  bohrMagneton,
  boltzmann,
  conductanceQuantum,
  createUnit,
  deuteronMass,
  dotPow,
  electricConstant,
  elementaryCharge,
  expm,
  faraday,
  firstRadiation,
  gamma,
  gravitationConstant,
  hartreeEnergy,
  klitzing,
  loschmidt,
  magneticConstant,
  molarMass,
  molarPlanckConstant,
  neutronMass,
  nuclearMagneton,
  planckCharge,
  planckLength,
  planckTemperature,
  protonMass,
  reducedPlanckConstant,
  rydberg,
  setIntersect,
  speedOfLight,
  stefanBoltzmann,
  thomsonCrossSection,
  avogadro,
  bohrRadius,
  coulomb,
  divide,
  electronMass,
  factorial,
  gravity,
  inverseConductanceQuantum,
  lup,
  magneticFluxQuantum,
  molarMassC12,
  multinomial,
  parse: parse$2,
  permutations,
  planckMass,
  quantumOfCirculation,
  resolve,
  secondRadiation,
  simplifyConstant,
  stirlingS2,
  unit,
  bellNumbers,
  compile,
  eigs,
  fermiCoupling,
  leafCount,
  mean,
  molarVolume,
  planckConstant,
  setSymDifference,
  simplifyCore,
  variance,
  classicalElectronRadius,
  evaluate,
  help,
  lusolve,
  median,
  setUnion,
  std,
  gasConstant,
  mad,
  parser,
  simplify: simplify$1,
  symbolicEqual,
  derivative,
  norm,
  rationalize,
  rotationMatrix,
  kldivergence,
  rotate,
  planckTime,
  config: config$1
});
_extends$1(mathWithTransform, math, {
  filter: createFilterTransform({
    typed
  }),
  forEach: createForEachTransform({
    typed
  }),
  map: createMapTransform({
    typed
  }),
  apply: createApplyTransform({
    isInteger,
    typed
  }),
  diff: createDiffTransform({
    bignumber,
    matrix,
    number,
    subtract,
    typed
  }),
  subset: createSubsetTransform({
    matrix,
    typed
  }),
  concat: createConcatTransform({
    isInteger,
    matrix,
    typed
  }),
  max: createMaxTransform({
    config: config$1,
    larger,
    numeric: numeric2,
    typed
  }),
  min: createMinTransform({
    config: config$1,
    numeric: numeric2,
    smaller,
    typed
  }),
  range: createRangeTransform({
    bignumber,
    matrix,
    config: config$1,
    larger,
    largerEq,
    smaller,
    smallerEq,
    typed
  }),
  sum: createSumTransform({
    add,
    config: config$1,
    numeric: numeric2,
    typed
  }),
  cumsum: createCumSumTransform({
    add,
    typed,
    unaryPlus
  }),
  row: createRowTransform({
    Index,
    matrix,
    range,
    typed
  }),
  column: createColumnTransform({
    Index,
    matrix,
    range,
    typed
  }),
  index: createIndexTransform({
    Index
  }),
  mean: createMeanTransform({
    add,
    divide,
    typed
  }),
  variance: createVarianceTransform({
    add,
    apply,
    divide,
    isNaN: isNaN$1,
    multiply,
    subtract,
    typed
  }),
  std: createStdTransform({
    map,
    sqrt,
    typed,
    variance
  })
});
_extends$1(classes, {
  BigNumber,
  Complex,
  Fraction,
  Matrix,
  Node,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  Range: Range$1,
  RelationalNode,
  ResultSet,
  ArrayNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  DenseMatrix,
  RangeNode,
  Chain,
  FunctionAssignmentNode,
  SparseMatrix,
  AccessorNode,
  AssignmentNode,
  IndexNode,
  FibonacciHeap,
  ImmutableDenseMatrix,
  Index,
  Spa,
  Unit,
  SymbolNode,
  FunctionNode,
  Help,
  Parser
});
Chain.createProxy(math);
var DELETE = "delete";
var SHIFT = 5;
var SIZE = 1 << SHIFT;
var MASK = SIZE - 1;
var NOT_SET = {};
function MakeRef() {
  return { value: false };
}
function SetRef(ref2) {
  if (ref2) {
    ref2.value = true;
  }
}
function OwnerID() {
}
function ensureSize(iter) {
  if (iter.size === void 0) {
    iter.size = iter.__iterate(returnTrue);
  }
  return iter.size;
}
function wrapIndex(iter, index2) {
  if (typeof index2 !== "number") {
    var uint32Index = index2 >>> 0;
    if ("" + uint32Index !== index2 || uint32Index === 4294967295) {
      return NaN;
    }
    index2 = uint32Index;
  }
  return index2 < 0 ? ensureSize(iter) + index2 : index2;
}
function returnTrue() {
  return true;
}
function wholeSlice(begin, end, size2) {
  return (begin === 0 && !isNeg(begin) || size2 !== void 0 && begin <= -size2) && (end === void 0 || size2 !== void 0 && end >= size2);
}
function resolveBegin(begin, size2) {
  return resolveIndex(begin, size2, 0);
}
function resolveEnd(end, size2) {
  return resolveIndex(end, size2, size2);
}
function resolveIndex(index2, size2, defaultIndex) {
  return index2 === void 0 ? defaultIndex : isNeg(index2) ? size2 === Infinity ? size2 : Math.max(0, size2 + index2) | 0 : size2 === void 0 || size2 === index2 ? index2 : Math.min(size2, index2) | 0;
}
function isNeg(value) {
  return value < 0 || value === 0 && 1 / value === -Infinity;
}
var IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
function isCollection(maybeCollection) {
  return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
}
var IS_KEYED_SYMBOL = "@@__IMMUTABLE_KEYED__@@";
function isKeyed(maybeKeyed) {
  return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
}
var IS_INDEXED_SYMBOL = "@@__IMMUTABLE_INDEXED__@@";
function isIndexed(maybeIndexed) {
  return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
}
function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}
var Collection = function Collection2(value) {
  return isCollection(value) ? value : Seq(value);
};
var KeyedCollection = /* @__PURE__ */ function(Collection3) {
  function KeyedCollection2(value) {
    return isKeyed(value) ? value : KeyedSeq(value);
  }
  if (Collection3)
    KeyedCollection2.__proto__ = Collection3;
  KeyedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  KeyedCollection2.prototype.constructor = KeyedCollection2;
  return KeyedCollection2;
}(Collection);
var IndexedCollection = /* @__PURE__ */ function(Collection3) {
  function IndexedCollection2(value) {
    return isIndexed(value) ? value : IndexedSeq(value);
  }
  if (Collection3)
    IndexedCollection2.__proto__ = Collection3;
  IndexedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  IndexedCollection2.prototype.constructor = IndexedCollection2;
  return IndexedCollection2;
}(Collection);
var SetCollection = /* @__PURE__ */ function(Collection3) {
  function SetCollection2(value) {
    return isCollection(value) && !isAssociative(value) ? value : SetSeq(value);
  }
  if (Collection3)
    SetCollection2.__proto__ = Collection3;
  SetCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
  SetCollection2.prototype.constructor = SetCollection2;
  return SetCollection2;
}(Collection);
Collection.Keyed = KeyedCollection;
Collection.Indexed = IndexedCollection;
Collection.Set = SetCollection;
var IS_SEQ_SYMBOL = "@@__IMMUTABLE_SEQ__@@";
function isSeq(maybeSeq) {
  return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
}
var IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
function isRecord(maybeRecord) {
  return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
}
function isImmutable(maybeImmutable) {
  return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}
var IS_ORDERED_SYMBOL = "@@__IMMUTABLE_ORDERED__@@";
function isOrdered(maybeOrdered) {
  return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
}
var ITERATE_KEYS = 0;
var ITERATE_VALUES = 1;
var ITERATE_ENTRIES = 2;
var REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = "@@iterator";
var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
var Iterator = function Iterator2(next) {
  this.next = next;
};
Iterator.prototype.toString = function toString() {
  return "[Iterator]";
};
Iterator.KEYS = ITERATE_KEYS;
Iterator.VALUES = ITERATE_VALUES;
Iterator.ENTRIES = ITERATE_ENTRIES;
Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
  return this.toString();
};
Iterator.prototype[ITERATOR_SYMBOL] = function() {
  return this;
};
function iteratorValue(type, k, v, iteratorResult) {
  var value = type === 0 ? k : type === 1 ? v : [k, v];
  iteratorResult ? iteratorResult.value = value : iteratorResult = {
    value,
    done: false
  };
  return iteratorResult;
}
function iteratorDone() {
  return { value: void 0, done: true };
}
function hasIterator(maybeIterable) {
  if (Array.isArray(maybeIterable)) {
    return true;
  }
  return !!getIteratorFn(maybeIterable);
}
function isIterator(maybeIterator) {
  return maybeIterator && typeof maybeIterator.next === "function";
}
function getIterator(iterable) {
  var iteratorFn = getIteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}
function getIteratorFn(iterable) {
  var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === "function") {
    return iteratorFn;
  }
}
function isEntriesIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.entries;
}
function isKeysIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.keys;
}
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function isArrayLike(value) {
  if (Array.isArray(value) || typeof value === "string") {
    return true;
  }
  return value && typeof value === "object" && Number.isInteger(value.length) && value.length >= 0 && (value.length === 0 ? Object.keys(value).length === 1 : value.hasOwnProperty(value.length - 1));
}
var Seq = /* @__PURE__ */ function(Collection3) {
  function Seq2(value) {
    return value === void 0 || value === null ? emptySequence() : isImmutable(value) ? value.toSeq() : seqFromValue(value);
  }
  if (Collection3)
    Seq2.__proto__ = Collection3;
  Seq2.prototype = Object.create(Collection3 && Collection3.prototype);
  Seq2.prototype.constructor = Seq2;
  Seq2.prototype.toSeq = function toSeq3() {
    return this;
  };
  Seq2.prototype.toString = function toString5() {
    return this.__toString("Seq {", "}");
  };
  Seq2.prototype.cacheResult = function cacheResult() {
    if (!this._cache && this.__iterateUncached) {
      this._cache = this.entrySeq().toArray();
      this.size = this._cache.length;
    }
    return this;
  };
  Seq2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var cache = this._cache;
    if (cache) {
      var size2 = cache.length;
      var i2 = 0;
      while (i2 !== size2) {
        var entry = cache[reverse3 ? size2 - ++i2 : i2++];
        if (fn(entry[1], entry[0], this) === false) {
          break;
        }
      }
      return i2;
    }
    return this.__iterateUncached(fn, reverse3);
  };
  Seq2.prototype.__iterator = function __iterator2(type, reverse3) {
    var cache = this._cache;
    if (cache) {
      var size2 = cache.length;
      var i2 = 0;
      return new Iterator(function() {
        if (i2 === size2) {
          return iteratorDone();
        }
        var entry = cache[reverse3 ? size2 - ++i2 : i2++];
        return iteratorValue(type, entry[0], entry[1]);
      });
    }
    return this.__iteratorUncached(type, reverse3);
  };
  return Seq2;
}(Collection);
var KeyedSeq = /* @__PURE__ */ function(Seq2) {
  function KeyedSeq2(value) {
    return value === void 0 || value === null ? emptySequence().toKeyedSeq() : isCollection(value) ? isKeyed(value) ? value.toSeq() : value.fromEntrySeq() : isRecord(value) ? value.toSeq() : keyedSeqFromValue(value);
  }
  if (Seq2)
    KeyedSeq2.__proto__ = Seq2;
  KeyedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  KeyedSeq2.prototype.constructor = KeyedSeq2;
  KeyedSeq2.prototype.toKeyedSeq = function toKeyedSeq3() {
    return this;
  };
  return KeyedSeq2;
}(Seq);
var IndexedSeq = /* @__PURE__ */ function(Seq2) {
  function IndexedSeq2(value) {
    return value === void 0 || value === null ? emptySequence() : isCollection(value) ? isKeyed(value) ? value.entrySeq() : value.toIndexedSeq() : isRecord(value) ? value.toSeq().entrySeq() : indexedSeqFromValue(value);
  }
  if (Seq2)
    IndexedSeq2.__proto__ = Seq2;
  IndexedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  IndexedSeq2.prototype.constructor = IndexedSeq2;
  IndexedSeq2.of = function of() {
    return IndexedSeq2(arguments);
  };
  IndexedSeq2.prototype.toIndexedSeq = function toIndexedSeq2() {
    return this;
  };
  IndexedSeq2.prototype.toString = function toString5() {
    return this.__toString("Seq [", "]");
  };
  return IndexedSeq2;
}(Seq);
var SetSeq = /* @__PURE__ */ function(Seq2) {
  function SetSeq2(value) {
    return (isCollection(value) && !isAssociative(value) ? value : IndexedSeq(value)).toSetSeq();
  }
  if (Seq2)
    SetSeq2.__proto__ = Seq2;
  SetSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
  SetSeq2.prototype.constructor = SetSeq2;
  SetSeq2.of = function of() {
    return SetSeq2(arguments);
  };
  SetSeq2.prototype.toSetSeq = function toSetSeq2() {
    return this;
  };
  return SetSeq2;
}(Seq);
Seq.isSeq = isSeq;
Seq.Keyed = KeyedSeq;
Seq.Set = SetSeq;
Seq.Indexed = IndexedSeq;
Seq.prototype[IS_SEQ_SYMBOL] = true;
var ArraySeq = /* @__PURE__ */ function(IndexedSeq2) {
  function ArraySeq2(array) {
    this._array = array;
    this.size = array.length;
  }
  if (IndexedSeq2)
    ArraySeq2.__proto__ = IndexedSeq2;
  ArraySeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  ArraySeq2.prototype.constructor = ArraySeq2;
  ArraySeq2.prototype.get = function get11(index2, notSetValue) {
    return this.has(index2) ? this._array[wrapIndex(this, index2)] : notSetValue;
  };
  ArraySeq2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var array = this._array;
    var size2 = array.length;
    var i2 = 0;
    while (i2 !== size2) {
      var ii = reverse3 ? size2 - ++i2 : i2++;
      if (fn(array[ii], ii, this) === false) {
        break;
      }
    }
    return i2;
  };
  ArraySeq2.prototype.__iterator = function __iterator2(type, reverse3) {
    var array = this._array;
    var size2 = array.length;
    var i2 = 0;
    return new Iterator(function() {
      if (i2 === size2) {
        return iteratorDone();
      }
      var ii = reverse3 ? size2 - ++i2 : i2++;
      return iteratorValue(type, ii, array[ii]);
    });
  };
  return ArraySeq2;
}(IndexedSeq);
var ObjectSeq = /* @__PURE__ */ function(KeyedSeq2) {
  function ObjectSeq2(object) {
    var keys2 = Object.keys(object).concat(
      Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []
    );
    this._object = object;
    this._keys = keys2;
    this.size = keys2.length;
  }
  if (KeyedSeq2)
    ObjectSeq2.__proto__ = KeyedSeq2;
  ObjectSeq2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  ObjectSeq2.prototype.constructor = ObjectSeq2;
  ObjectSeq2.prototype.get = function get11(key, notSetValue) {
    if (notSetValue !== void 0 && !this.has(key)) {
      return notSetValue;
    }
    return this._object[key];
  };
  ObjectSeq2.prototype.has = function has5(key) {
    return hasOwnProperty$1.call(this._object, key);
  };
  ObjectSeq2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var object = this._object;
    var keys2 = this._keys;
    var size2 = keys2.length;
    var i2 = 0;
    while (i2 !== size2) {
      var key = keys2[reverse3 ? size2 - ++i2 : i2++];
      if (fn(object[key], key, this) === false) {
        break;
      }
    }
    return i2;
  };
  ObjectSeq2.prototype.__iterator = function __iterator2(type, reverse3) {
    var object = this._object;
    var keys2 = this._keys;
    var size2 = keys2.length;
    var i2 = 0;
    return new Iterator(function() {
      if (i2 === size2) {
        return iteratorDone();
      }
      var key = keys2[reverse3 ? size2 - ++i2 : i2++];
      return iteratorValue(type, key, object[key]);
    });
  };
  return ObjectSeq2;
}(KeyedSeq);
ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
var CollectionSeq = /* @__PURE__ */ function(IndexedSeq2) {
  function CollectionSeq2(collection) {
    this._collection = collection;
    this.size = collection.length || collection.size;
  }
  if (IndexedSeq2)
    CollectionSeq2.__proto__ = IndexedSeq2;
  CollectionSeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  CollectionSeq2.prototype.constructor = CollectionSeq2;
  CollectionSeq2.prototype.__iterateUncached = function __iterateUncached(fn, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    var iterations = 0;
    if (isIterator(iterator)) {
      var step;
      while (!(step = iterator.next()).done) {
        if (fn(step.value, iterations++, this) === false) {
          break;
        }
      }
    }
    return iterations;
  };
  CollectionSeq2.prototype.__iteratorUncached = function __iteratorUncached(type, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var collection = this._collection;
    var iterator = getIterator(collection);
    if (!isIterator(iterator)) {
      return new Iterator(iteratorDone);
    }
    var iterations = 0;
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, iterations++, step.value);
    });
  };
  return CollectionSeq2;
}(IndexedSeq);
var EMPTY_SEQ;
function emptySequence() {
  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}
function keyedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq.fromEntrySeq();
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of [k, v] entries, or keyed object: " + value
  );
}
function indexedSeqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return seq;
  }
  throw new TypeError(
    "Expected Array or collection object of values: " + value
  );
}
function seqFromValue(value) {
  var seq = maybeIndexedSeqFromValue(value);
  if (seq) {
    return isEntriesIterable(value) ? seq.fromEntrySeq() : isKeysIterable(value) ? seq.toSetSeq() : seq;
  }
  if (typeof value === "object") {
    return new ObjectSeq(value);
  }
  throw new TypeError(
    "Expected Array or collection object of values, or keyed object: " + value
  );
}
function maybeIndexedSeqFromValue(value) {
  return isArrayLike(value) ? new ArraySeq(value) : hasIterator(value) ? new CollectionSeq(value) : void 0;
}
var IS_MAP_SYMBOL = "@@__IMMUTABLE_MAP__@@";
function isMap(maybeMap) {
  return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
}
function isOrderedMap(maybeOrderedMap) {
  return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}
function isValueObject(maybeValue) {
  return Boolean(
    maybeValue && typeof maybeValue.equals === "function" && typeof maybeValue.hashCode === "function"
  );
}
function is(valueA, valueB) {
  if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
    return true;
  }
  if (!valueA || !valueB) {
    return false;
  }
  if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();
    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
  }
  return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
}
var imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul2(a, b) {
  a |= 0;
  b |= 0;
  var c = a & 65535;
  var d = b & 65535;
  return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0;
};
function smi(i32) {
  return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
var defaultValueOf = Object.prototype.valueOf;
function hash(o) {
  if (o == null) {
    return hashNullish(o);
  }
  if (typeof o.hashCode === "function") {
    return smi(o.hashCode(o));
  }
  var v = valueOf(o);
  if (v == null) {
    return hashNullish(v);
  }
  switch (typeof v) {
    case "boolean":
      return v ? 1108378657 : 1108378656;
    case "number":
      return hashNumber(v);
    case "string":
      return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
    case "object":
    case "function":
      return hashJSObj(v);
    case "symbol":
      return hashSymbol(v);
    default:
      if (typeof v.toString === "function") {
        return hashString(v.toString());
      }
      throw new Error("Value type " + typeof v + " cannot be hashed.");
  }
}
function hashNullish(nullish) {
  return nullish === null ? 1108378658 : 1108378659;
}
function hashNumber(n) {
  if (n !== n || n === Infinity) {
    return 0;
  }
  var hash2 = n | 0;
  if (hash2 !== n) {
    hash2 ^= n * 4294967295;
  }
  while (n > 4294967295) {
    n /= 4294967295;
    hash2 ^= n;
  }
  return smi(hash2);
}
function cachedHashString(string2) {
  var hashed = stringHashCache[string2];
  if (hashed === void 0) {
    hashed = hashString(string2);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string2] = hashed;
  }
  return hashed;
}
function hashString(string2) {
  var hashed = 0;
  for (var ii = 0; ii < string2.length; ii++) {
    hashed = 31 * hashed + string2.charCodeAt(ii) | 0;
  }
  return smi(hashed);
}
function hashSymbol(sym) {
  var hashed = symbolMap[sym];
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  symbolMap[sym] = hashed;
  return hashed;
}
function hashJSObj(obj) {
  var hashed;
  if (usingWeakMap) {
    hashed = weakMap.get(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = obj[UID_HASH_KEY];
  if (hashed !== void 0) {
    return hashed;
  }
  if (!canDefineProperty) {
    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
    if (hashed !== void 0) {
      return hashed;
    }
    hashed = getIENodeHash(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = nextHash();
  if (usingWeakMap) {
    weakMap.set(obj, hashed);
  } else if (isExtensible !== void 0 && isExtensible(obj) === false) {
    throw new Error("Non-extensible objects are not allowed as keys.");
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: hashed
    });
  } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
    obj.propertyIsEnumerable = function() {
      return this.constructor.prototype.propertyIsEnumerable.apply(
        this,
        arguments
      );
    };
    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
  } else if (obj.nodeType !== void 0) {
    obj[UID_HASH_KEY] = hashed;
  } else {
    throw new Error("Unable to set a non-enumerable property on object.");
  }
  return hashed;
}
var isExtensible = Object.isExtensible;
var canDefineProperty = function() {
  try {
    Object.defineProperty({}, "@", {});
    return true;
  } catch (e2) {
    return false;
  }
}();
function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1:
        return node.uniqueID;
      case 9:
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
}
function valueOf(obj) {
  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
function nextHash() {
  var nextHash2 = ++_objHashUID;
  if (_objHashUID & 1073741824) {
    _objHashUID = 0;
  }
  return nextHash2;
}
var usingWeakMap = typeof WeakMap === "function";
var weakMap;
if (usingWeakMap) {
  weakMap = /* @__PURE__ */ new WeakMap();
}
var symbolMap = /* @__PURE__ */ Object.create(null);
var _objHashUID = 0;
var UID_HASH_KEY = "__immutablehash__";
if (typeof Symbol === "function") {
  UID_HASH_KEY = Symbol(UID_HASH_KEY);
}
var STRING_HASH_CACHE_MIN_STRLEN = 16;
var STRING_HASH_CACHE_MAX_SIZE = 255;
var STRING_HASH_CACHE_SIZE = 0;
var stringHashCache = {};
var ToKeyedSequence = /* @__PURE__ */ function(KeyedSeq2) {
  function ToKeyedSequence2(indexed, useKeys) {
    this._iter = indexed;
    this._useKeys = useKeys;
    this.size = indexed.size;
  }
  if (KeyedSeq2)
    ToKeyedSequence2.__proto__ = KeyedSeq2;
  ToKeyedSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  ToKeyedSequence2.prototype.constructor = ToKeyedSequence2;
  ToKeyedSequence2.prototype.get = function get11(key, notSetValue) {
    return this._iter.get(key, notSetValue);
  };
  ToKeyedSequence2.prototype.has = function has5(key) {
    return this._iter.has(key);
  };
  ToKeyedSequence2.prototype.valueSeq = function valueSeq2() {
    return this._iter.valueSeq();
  };
  ToKeyedSequence2.prototype.reverse = function reverse3() {
    var this$1$1 = this;
    var reversedSequence = reverseFactory(this, true);
    if (!this._useKeys) {
      reversedSequence.valueSeq = function() {
        return this$1$1._iter.toSeq().reverse();
      };
    }
    return reversedSequence;
  };
  ToKeyedSequence2.prototype.map = function map3(mapper, context) {
    var this$1$1 = this;
    var mappedSequence = mapFactory(this, mapper, context);
    if (!this._useKeys) {
      mappedSequence.valueSeq = function() {
        return this$1$1._iter.toSeq().map(mapper, context);
      };
    }
    return mappedSequence;
  };
  ToKeyedSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(v, k) {
      return fn(v, k, this$1$1);
    }, reverse3);
  };
  ToKeyedSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
    return this._iter.__iterator(type, reverse3);
  };
  return ToKeyedSequence2;
}(KeyedSeq);
ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
var ToIndexedSequence = /* @__PURE__ */ function(IndexedSeq2) {
  function ToIndexedSequence2(iter) {
    this._iter = iter;
    this.size = iter.size;
  }
  if (IndexedSeq2)
    ToIndexedSequence2.__proto__ = IndexedSeq2;
  ToIndexedSequence2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  ToIndexedSequence2.prototype.constructor = ToIndexedSequence2;
  ToIndexedSequence2.prototype.includes = function includes3(value) {
    return this._iter.includes(value);
  };
  ToIndexedSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    var i2 = 0;
    reverse3 && ensureSize(this);
    return this._iter.__iterate(
      function(v) {
        return fn(v, reverse3 ? this$1$1.size - ++i2 : i2++, this$1$1);
      },
      reverse3
    );
  };
  ToIndexedSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
    var this$1$1 = this;
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    var i2 = 0;
    reverse3 && ensureSize(this);
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(
        type,
        reverse3 ? this$1$1.size - ++i2 : i2++,
        step.value,
        step
      );
    });
  };
  return ToIndexedSequence2;
}(IndexedSeq);
var ToSetSequence = /* @__PURE__ */ function(SetSeq2) {
  function ToSetSequence2(iter) {
    this._iter = iter;
    this.size = iter.size;
  }
  if (SetSeq2)
    ToSetSequence2.__proto__ = SetSeq2;
  ToSetSequence2.prototype = Object.create(SetSeq2 && SetSeq2.prototype);
  ToSetSequence2.prototype.constructor = ToSetSequence2;
  ToSetSequence2.prototype.has = function has5(key) {
    return this._iter.includes(key);
  };
  ToSetSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(v) {
      return fn(v, v, this$1$1);
    }, reverse3);
  };
  ToSetSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      return step.done ? step : iteratorValue(type, step.value, step.value, step);
    });
  };
  return ToSetSequence2;
}(SetSeq);
var FromEntriesSequence = /* @__PURE__ */ function(KeyedSeq2) {
  function FromEntriesSequence2(entries3) {
    this._iter = entries3;
    this.size = entries3.size;
  }
  if (KeyedSeq2)
    FromEntriesSequence2.__proto__ = KeyedSeq2;
  FromEntriesSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
  FromEntriesSequence2.prototype.constructor = FromEntriesSequence2;
  FromEntriesSequence2.prototype.entrySeq = function entrySeq2() {
    return this._iter.toSeq();
  };
  FromEntriesSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._iter.__iterate(function(entry) {
      if (entry) {
        validateEntry(entry);
        var indexedCollection = isCollection(entry);
        return fn(
          indexedCollection ? entry.get(1) : entry[1],
          indexedCollection ? entry.get(0) : entry[0],
          this$1$1
        );
      }
    }, reverse3);
  };
  FromEntriesSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
    var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
    return new Iterator(function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        if (entry) {
          validateEntry(entry);
          var indexedCollection = isCollection(entry);
          return iteratorValue(
            type,
            indexedCollection ? entry.get(0) : entry[0],
            indexedCollection ? entry.get(1) : entry[1],
            step
          );
        }
      }
    });
  };
  return FromEntriesSequence2;
}(KeyedSeq);
ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
function flipFactory(collection) {
  var flipSequence = makeSequence(collection);
  flipSequence._iter = collection;
  flipSequence.size = collection.size;
  flipSequence.flip = function() {
    return collection;
  };
  flipSequence.reverse = function() {
    var reversedSequence = collection.reverse.apply(this);
    reversedSequence.flip = function() {
      return collection.reverse();
    };
    return reversedSequence;
  };
  flipSequence.has = function(key) {
    return collection.includes(key);
  };
  flipSequence.includes = function(key) {
    return collection.has(key);
  };
  flipSequence.cacheResult = cacheResultThrough;
  flipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(function(v, k) {
      return fn(k, v, this$1$1) !== false;
    }, reverse3);
  };
  flipSequence.__iteratorUncached = function(type, reverse3) {
    if (type === ITERATE_ENTRIES) {
      var iterator = collection.__iterator(type, reverse3);
      return new Iterator(function() {
        var step = iterator.next();
        if (!step.done) {
          var k = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k;
        }
        return step;
      });
    }
    return collection.__iterator(
      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
      reverse3
    );
  };
  return flipSequence;
}
function mapFactory(collection, mapper, context) {
  var mappedSequence = makeSequence(collection);
  mappedSequence.size = collection.size;
  mappedSequence.has = function(key) {
    return collection.has(key);
  };
  mappedSequence.get = function(key, notSetValue) {
    var v = collection.get(key, NOT_SET);
    return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);
  };
  mappedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(
      function(v, k, c) {
        return fn(mapper.call(context, v, k, c), k, this$1$1) !== false;
      },
      reverse3
    );
  };
  mappedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var key = entry[0];
      return iteratorValue(
        type,
        key,
        mapper.call(context, entry[1], key, collection),
        step
      );
    });
  };
  return mappedSequence;
}
function reverseFactory(collection, useKeys) {
  var this$1$1 = this;
  var reversedSequence = makeSequence(collection);
  reversedSequence._iter = collection;
  reversedSequence.size = collection.size;
  reversedSequence.reverse = function() {
    return collection;
  };
  if (collection.flip) {
    reversedSequence.flip = function() {
      var flipSequence = flipFactory(collection);
      flipSequence.reverse = function() {
        return collection.flip();
      };
      return flipSequence;
    };
  }
  reversedSequence.get = function(key, notSetValue) {
    return collection.get(useKeys ? key : -1 - key, notSetValue);
  };
  reversedSequence.has = function(key) {
    return collection.has(useKeys ? key : -1 - key);
  };
  reversedSequence.includes = function(value) {
    return collection.includes(value);
  };
  reversedSequence.cacheResult = cacheResultThrough;
  reversedSequence.__iterate = function(fn, reverse3) {
    var this$1$12 = this;
    var i2 = 0;
    reverse3 && ensureSize(collection);
    return collection.__iterate(
      function(v, k) {
        return fn(v, useKeys ? k : reverse3 ? this$1$12.size - ++i2 : i2++, this$1$12);
      },
      !reverse3
    );
  };
  reversedSequence.__iterator = function(type, reverse3) {
    var i2 = 0;
    reverse3 && ensureSize(collection);
    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      return iteratorValue(
        type,
        useKeys ? entry[0] : reverse3 ? this$1$1.size - ++i2 : i2++,
        entry[1],
        step
      );
    });
  };
  return reversedSequence;
}
function filterFactory(collection, predicate, context, useKeys) {
  var filterSequence = makeSequence(collection);
  if (useKeys) {
    filterSequence.has = function(key) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && !!predicate.call(context, v, key, collection);
    };
    filterSequence.get = function(key, notSetValue) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;
    };
  }
  filterSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(function(v, k, c) {
      if (predicate.call(context, v, k, c)) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1);
      }
    }, reverse3);
    return iterations;
  };
  filterSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterations = 0;
    return new Iterator(function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        var value = entry[1];
        if (predicate.call(context, value, key, collection)) {
          return iteratorValue(type, useKeys ? key : iterations++, value, step);
        }
      }
    });
  };
  return filterSequence;
}
function countByFactory(collection, grouper, context) {
  var groups = Map$1().asMutable();
  collection.__iterate(function(v, k) {
    groups.update(grouper.call(context, v, k, collection), 0, function(a) {
      return a + 1;
    });
  });
  return groups.asImmutable();
}
function groupByFactory(collection, grouper, context) {
  var isKeyedIter = isKeyed(collection);
  var groups = (isOrdered(collection) ? OrderedMap() : Map$1()).asMutable();
  collection.__iterate(function(v, k) {
    groups.update(
      grouper.call(context, v, k, collection),
      function(a) {
        return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
      }
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr) {
    return reify(collection, coerce(arr));
  }).asImmutable();
}
function sliceFactory(collection, begin, end, useKeys) {
  var originalSize = collection.size;
  if (wholeSlice(begin, end, originalSize)) {
    return collection;
  }
  var resolvedBegin = resolveBegin(begin, originalSize);
  var resolvedEnd = resolveEnd(end, originalSize);
  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
  }
  var resolvedSize = resolvedEnd - resolvedBegin;
  var sliceSize;
  if (resolvedSize === resolvedSize) {
    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  }
  var sliceSeq = makeSequence(collection);
  sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || void 0;
  if (!useKeys && isSeq(collection) && sliceSize >= 0) {
    sliceSeq.get = function(index2, notSetValue) {
      index2 = wrapIndex(this, index2);
      return index2 >= 0 && index2 < sliceSize ? collection.get(index2 + resolvedBegin, notSetValue) : notSetValue;
    };
  }
  sliceSeq.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (sliceSize === 0) {
      return 0;
    }
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v, k) {
      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
      }
    });
    return iterations;
  };
  sliceSeq.__iteratorUncached = function(type, reverse3) {
    if (sliceSize !== 0 && reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    if (sliceSize === 0) {
      return new Iterator(iteratorDone);
    }
    var iterator = collection.__iterator(type, reverse3);
    var skipped = 0;
    var iterations = 0;
    return new Iterator(function() {
      while (skipped++ < resolvedBegin) {
        iterator.next();
      }
      if (++iterations > sliceSize) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (useKeys || type === ITERATE_VALUES || step.done) {
        return step;
      }
      if (type === ITERATE_KEYS) {
        return iteratorValue(type, iterations - 1, void 0, step);
      }
      return iteratorValue(type, iterations - 1, step.value[1], step);
    });
  };
  return sliceSeq;
}
function takeWhileFactory(collection, predicate, context) {
  var takeSequence = makeSequence(collection);
  takeSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    collection.__iterate(
      function(v, k, c) {
        return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1$1);
      }
    );
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterating = true;
    return new Iterator(function() {
      if (!iterating) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k = entry[0];
      var v = entry[1];
      if (!predicate.call(context, v, k, this$1$1)) {
        iterating = false;
        return iteratorDone();
      }
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return takeSequence;
}
function skipWhileFactory(collection, predicate, context, useKeys) {
  var skipSequence = makeSequence(collection);
  skipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v, k, c) {
      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1);
      }
    });
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var skipping = true;
    var iterations = 0;
    return new Iterator(function() {
      var step;
      var k;
      var v;
      do {
        step = iterator.next();
        if (step.done) {
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          }
          if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations++, void 0, step);
          }
          return iteratorValue(type, iterations++, step.value[1], step);
        }
        var entry = step.value;
        k = entry[0];
        v = entry[1];
        skipping && (skipping = predicate.call(context, v, k, this$1$1));
      } while (skipping);
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return skipSequence;
}
function concatFactory(collection, values2) {
  var isKeyedCollection = isKeyed(collection);
  var iters = [collection].concat(values2).map(function(v) {
    if (!isCollection(v)) {
      v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
    } else if (isKeyedCollection) {
      v = KeyedCollection(v);
    }
    return v;
  }).filter(function(v) {
    return v.size !== 0;
  });
  if (iters.length === 0) {
    return collection;
  }
  if (iters.length === 1) {
    var singleton = iters[0];
    if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
      return singleton;
    }
  }
  var concatSeq = new ArraySeq(iters);
  if (isKeyedCollection) {
    concatSeq = concatSeq.toKeyedSeq();
  } else if (!isIndexed(collection)) {
    concatSeq = concatSeq.toSetSeq();
  }
  concatSeq = concatSeq.flatten(true);
  concatSeq.size = iters.reduce(function(sum2, seq) {
    if (sum2 !== void 0) {
      var size2 = seq.size;
      if (size2 !== void 0) {
        return sum2 + size2;
      }
    }
  }, 0);
  return concatSeq;
}
function flattenFactory(collection, depth, useKeys) {
  var flatSequence = makeSequence(collection);
  flatSequence.__iterateUncached = function(fn, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    var stopped = false;
    function flatDeep(iter, currentDepth) {
      iter.__iterate(function(v, k) {
        if ((!depth || currentDepth < depth) && isCollection(v)) {
          flatDeep(v, currentDepth + 1);
        } else {
          iterations++;
          if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
            stopped = true;
          }
        }
        return !stopped;
      }, reverse3);
    }
    flatDeep(collection, 0);
    return iterations;
  };
  flatSequence.__iteratorUncached = function(type, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(type, reverse3);
    var stack2 = [];
    var iterations = 0;
    return new Iterator(function() {
      while (iterator) {
        var step = iterator.next();
        if (step.done !== false) {
          iterator = stack2.pop();
          continue;
        }
        var v = step.value;
        if (type === ITERATE_ENTRIES) {
          v = v[1];
        }
        if ((!depth || stack2.length < depth) && isCollection(v)) {
          stack2.push(iterator);
          iterator = v.__iterator(type, reverse3);
        } else {
          return useKeys ? step : iteratorValue(type, iterations++, v, step);
        }
      }
      return iteratorDone();
    });
  };
  return flatSequence;
}
function flatMapFactory(collection, mapper, context) {
  var coerce = collectionClass(collection);
  return collection.toSeq().map(function(v, k) {
    return coerce(mapper.call(context, v, k, collection));
  }).flatten(true);
}
function interposeFactory(collection, separator) {
  var interposedSequence = makeSequence(collection);
  interposedSequence.size = collection.size && collection.size * 2 - 1;
  interposedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(
      function(v) {
        return (!iterations || fn(separator, iterations++, this$1$1) !== false) && fn(v, iterations++, this$1$1) !== false;
      },
      reverse3
    );
    return iterations;
  };
  interposedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_VALUES, reverse3);
    var iterations = 0;
    var step;
    return new Iterator(function() {
      if (!step || iterations % 2) {
        step = iterator.next();
        if (step.done) {
          return step;
        }
      }
      return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
    });
  };
  return interposedSequence;
}
function sortFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  var isKeyedCollection = isKeyed(collection);
  var index2 = 0;
  var entries3 = collection.toSeq().map(function(v, k) {
    return [k, v, index2++, mapper ? mapper(v, k, collection) : v];
  }).valueSeq().toArray();
  entries3.sort(function(a, b) {
    return comparator(a[3], b[3]) || a[2] - b[2];
  }).forEach(
    isKeyedCollection ? function(v, i2) {
      entries3[i2].length = 2;
    } : function(v, i2) {
      entries3[i2] = v[1];
    }
  );
  return isKeyedCollection ? KeyedSeq(entries3) : isIndexed(collection) ? IndexedSeq(entries3) : SetSeq(entries3);
}
function maxFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  if (mapper) {
    var entry = collection.toSeq().map(function(v, k) {
      return [v, mapper(v, k, collection)];
    }).reduce(function(a, b) {
      return maxCompare(comparator, a[1], b[1]) ? b : a;
    });
    return entry && entry[0];
  }
  return collection.reduce(function(a, b) {
    return maxCompare(comparator, a, b) ? b : a;
  });
}
function maxCompare(comparator, a, b) {
  var comp = comparator(b, a);
  return comp === 0 && b !== a && (b === void 0 || b === null || b !== b) || comp > 0;
}
function zipWithFactory(keyIter, zipper, iters, zipAll2) {
  var zipSequence = makeSequence(keyIter);
  var sizes = new ArraySeq(iters).map(function(i2) {
    return i2.size;
  });
  zipSequence.size = zipAll2 ? sizes.max() : sizes.min();
  zipSequence.__iterate = function(fn, reverse3) {
    var iterator = this.__iterator(ITERATE_VALUES, reverse3);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      if (fn(step.value, iterations++, this) === false) {
        break;
      }
    }
    return iterations;
  };
  zipSequence.__iteratorUncached = function(type, reverse3) {
    var iterators = iters.map(
      function(i2) {
        return i2 = Collection(i2), getIterator(reverse3 ? i2.reverse() : i2);
      }
    );
    var iterations = 0;
    var isDone = false;
    return new Iterator(function() {
      var steps;
      if (!isDone) {
        steps = iterators.map(function(i2) {
          return i2.next();
        });
        isDone = zipAll2 ? steps.every(function(s) {
          return s.done;
        }) : steps.some(function(s) {
          return s.done;
        });
      }
      if (isDone) {
        return iteratorDone();
      }
      return iteratorValue(
        type,
        iterations++,
        zipper.apply(
          null,
          steps.map(function(s) {
            return s.value;
          })
        )
      );
    });
  };
  return zipSequence;
}
function reify(iter, seq) {
  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}
function validateEntry(entry) {
  if (entry !== Object(entry)) {
    throw new TypeError("Expected [K, V] tuple: " + entry);
  }
}
function collectionClass(collection) {
  return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
}
function makeSequence(collection) {
  return Object.create(
    (isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype
  );
}
function cacheResultThrough() {
  if (this._iter.cacheResult) {
    this._iter.cacheResult();
    this.size = this._iter.size;
    return this;
  }
  return Seq.prototype.cacheResult.call(this);
}
function defaultComparator(a, b) {
  if (a === void 0 && b === void 0) {
    return 0;
  }
  if (a === void 0) {
    return 1;
  }
  if (b === void 0) {
    return -1;
  }
  return a > b ? 1 : a < b ? -1 : 0;
}
function arrCopy(arr, offset) {
  offset = offset || 0;
  var len = Math.max(0, arr.length - offset);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset];
  }
  return newArr;
}
function invariant(condition, error) {
  if (!condition) {
    throw new Error(error);
  }
}
function assertNotInfinite(size2) {
  invariant(
    size2 !== Infinity,
    "Cannot perform this action with an infinite size."
  );
}
function coerceKeyPath(keyPath) {
  if (isArrayLike(keyPath) && typeof keyPath !== "string") {
    return keyPath;
  }
  if (isOrdered(keyPath)) {
    return keyPath.toArray();
  }
  throw new TypeError(
    "Invalid keyPath: expected Ordered Collection or Array: " + keyPath
  );
}
var toString2 = Object.prototype.toString;
function isPlainObject(value) {
  if (!value || typeof value !== "object" || toString2.call(value) !== "[object Object]") {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  var parentProto = proto;
  var nextProto = Object.getPrototypeOf(proto);
  while (nextProto !== null) {
    parentProto = nextProto;
    nextProto = Object.getPrototypeOf(parentProto);
  }
  return parentProto === proto;
}
function isDataStructure(value) {
  return typeof value === "object" && (isImmutable(value) || Array.isArray(value) || isPlainObject(value));
}
function quoteString(value) {
  try {
    return typeof value === "string" ? JSON.stringify(value) : String(value);
  } catch (_ignoreError) {
    return JSON.stringify(value);
  }
}
function has(collection, key) {
  return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty$1.call(collection, key);
}
function get(collection, key, notSetValue) {
  return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === "function" ? collection.get(key) : collection[key];
}
function shallowCopy(from) {
  if (Array.isArray(from)) {
    return arrCopy(from);
  }
  var to2 = {};
  for (var key in from) {
    if (hasOwnProperty$1.call(from, key)) {
      to2[key] = from[key];
    }
  }
  return to2;
}
function remove(collection, key) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.remove) {
      throw new TypeError(
        "Cannot update immutable value without .remove() method: " + collection
      );
    }
    return collection.remove(key);
  }
  if (!hasOwnProperty$1.call(collection, key)) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  if (Array.isArray(collectionCopy)) {
    collectionCopy.splice(key, 1);
  } else {
    delete collectionCopy[key];
  }
  return collectionCopy;
}
function set(collection, key, value) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.set) {
      throw new TypeError(
        "Cannot update immutable value without .set() method: " + collection
      );
    }
    return collection.set(key, value);
  }
  if (hasOwnProperty$1.call(collection, key) && value === collection[key]) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  collectionCopy[key] = value;
  return collectionCopy;
}
function updateIn$1(collection, keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = void 0;
  }
  var updatedValue = updateInDeeply(
    isImmutable(collection),
    collection,
    coerceKeyPath(keyPath),
    0,
    notSetValue,
    updater
  );
  return updatedValue === NOT_SET ? notSetValue : updatedValue;
}
function updateInDeeply(inImmutable, existing, keyPath, i2, notSetValue, updater) {
  var wasNotSet = existing === NOT_SET;
  if (i2 === keyPath.length) {
    var existingValue = wasNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
  }
  if (!wasNotSet && !isDataStructure(existing)) {
    throw new TypeError(
      "Cannot update within non-data-structure value in path [" + keyPath.slice(0, i2).map(quoteString) + "]: " + existing
    );
  }
  var key = keyPath[i2];
  var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
  var nextUpdated = updateInDeeply(
    nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),
    nextExisting,
    keyPath,
    i2 + 1,
    notSetValue,
    updater
  );
  return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(
    wasNotSet ? inImmutable ? emptyMap() : {} : existing,
    key,
    nextUpdated
  );
}
function setIn$1(collection, keyPath, value) {
  return updateIn$1(collection, keyPath, NOT_SET, function() {
    return value;
  });
}
function setIn(keyPath, v) {
  return setIn$1(this, keyPath, v);
}
function removeIn(collection, keyPath) {
  return updateIn$1(collection, keyPath, function() {
    return NOT_SET;
  });
}
function deleteIn(keyPath) {
  return removeIn(this, keyPath);
}
function update$1(collection, key, notSetValue, updater) {
  return updateIn$1(collection, [key], notSetValue, updater);
}
function update(key, notSetValue, updater) {
  return arguments.length === 1 ? key(this) : update$1(this, key, notSetValue, updater);
}
function updateIn(keyPath, notSetValue, updater) {
  return updateIn$1(this, keyPath, notSetValue, updater);
}
function merge$1() {
  var iters = [], len = arguments.length;
  while (len--)
    iters[len] = arguments[len];
  return mergeIntoKeyedWith(this, iters);
}
function mergeWith$1(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  if (typeof merger !== "function") {
    throw new TypeError("Invalid merger function: " + merger);
  }
  return mergeIntoKeyedWith(this, iters, merger);
}
function mergeIntoKeyedWith(collection, collections, merger) {
  var iters = [];
  for (var ii = 0; ii < collections.length; ii++) {
    var collection$1 = KeyedCollection(collections[ii]);
    if (collection$1.size !== 0) {
      iters.push(collection$1);
    }
  }
  if (iters.length === 0) {
    return collection;
  }
  if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
    return collection.constructor(iters[0]);
  }
  return collection.withMutations(function(collection2) {
    var mergeIntoCollection = merger ? function(value, key) {
      update$1(
        collection2,
        key,
        NOT_SET,
        function(oldVal) {
          return oldVal === NOT_SET ? value : merger(oldVal, value, key);
        }
      );
    } : function(value, key) {
      collection2.set(key, value);
    };
    for (var ii2 = 0; ii2 < iters.length; ii2++) {
      iters[ii2].forEach(mergeIntoCollection);
    }
  });
}
function mergeDeepWithSources(collection, sources, merger) {
  return mergeWithSources(collection, sources, deepMergerWith(merger));
}
function mergeWithSources(collection, sources, merger) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot merge into non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    return typeof merger === "function" && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
  }
  var isArray2 = Array.isArray(collection);
  var merged = collection;
  var Collection3 = isArray2 ? IndexedCollection : KeyedCollection;
  var mergeItem = isArray2 ? function(value) {
    if (merged === collection) {
      merged = shallowCopy(merged);
    }
    merged.push(value);
  } : function(value, key) {
    var hasVal = hasOwnProperty$1.call(merged, key);
    var nextVal = hasVal && merger ? merger(merged[key], value, key) : value;
    if (!hasVal || nextVal !== merged[key]) {
      if (merged === collection) {
        merged = shallowCopy(merged);
      }
      merged[key] = nextVal;
    }
  };
  for (var i2 = 0; i2 < sources.length; i2++) {
    Collection3(sources[i2]).forEach(mergeItem);
  }
  return merged;
}
function deepMergerWith(merger) {
  function deepMerger(oldValue, newValue, key) {
    return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
  }
  return deepMerger;
}
function areMergeable(oldDataStructure, newDataStructure) {
  var oldSeq = Seq(oldDataStructure);
  var newSeq = Seq(newDataStructure);
  return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);
}
function mergeDeep() {
  var iters = [], len = arguments.length;
  while (len--)
    iters[len] = arguments[len];
  return mergeDeepWithSources(this, iters);
}
function mergeDeepWith(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return mergeDeepWithSources(this, iters, merger);
}
function mergeIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return updateIn$1(this, keyPath, emptyMap(), function(m) {
    return mergeWithSources(m, iters);
  });
}
function mergeDeepIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return updateIn$1(
    this,
    keyPath,
    emptyMap(),
    function(m) {
      return mergeDeepWithSources(m, iters);
    }
  );
}
function withMutations(fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}
function asMutable() {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}
function asImmutable() {
  return this.__ensureOwner();
}
function wasAltered() {
  return this.__altered;
}
var Map$1 = /* @__PURE__ */ function(KeyedCollection2) {
  function Map2(value) {
    return value === void 0 || value === null ? emptyMap() : isMap(value) && !isOrdered(value) ? value : emptyMap().withMutations(function(map3) {
      var iter = KeyedCollection2(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v, k) {
        return map3.set(k, v);
      });
    });
  }
  if (KeyedCollection2)
    Map2.__proto__ = KeyedCollection2;
  Map2.prototype = Object.create(KeyedCollection2 && KeyedCollection2.prototype);
  Map2.prototype.constructor = Map2;
  Map2.of = function of() {
    var keyValues = [], len = arguments.length;
    while (len--)
      keyValues[len] = arguments[len];
    return emptyMap().withMutations(function(map3) {
      for (var i2 = 0; i2 < keyValues.length; i2 += 2) {
        if (i2 + 1 >= keyValues.length) {
          throw new Error("Missing value for key: " + keyValues[i2]);
        }
        map3.set(keyValues[i2], keyValues[i2 + 1]);
      }
    });
  };
  Map2.prototype.toString = function toString5() {
    return this.__toString("Map {", "}");
  };
  Map2.prototype.get = function get11(k, notSetValue) {
    return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
  };
  Map2.prototype.set = function set3(k, v) {
    return updateMap(this, k, v);
  };
  Map2.prototype.remove = function remove3(k) {
    return updateMap(this, k, NOT_SET);
  };
  Map2.prototype.deleteAll = function deleteAll(keys2) {
    var collection = Collection(keys2);
    if (collection.size === 0) {
      return this;
    }
    return this.withMutations(function(map3) {
      collection.forEach(function(key) {
        return map3.remove(key);
      });
    });
  };
  Map2.prototype.clear = function clear3() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._root = null;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyMap();
  };
  Map2.prototype.sort = function sort3(comparator) {
    return OrderedMap(sortFactory(this, comparator));
  };
  Map2.prototype.sortBy = function sortBy2(mapper, comparator) {
    return OrderedMap(sortFactory(this, comparator, mapper));
  };
  Map2.prototype.map = function map3(mapper, context) {
    var this$1$1 = this;
    return this.withMutations(function(map4) {
      map4.forEach(function(value, key) {
        map4.set(key, mapper.call(context, value, key, this$1$1));
      });
    });
  };
  Map2.prototype.__iterator = function __iterator2(type, reverse3) {
    return new MapIterator(this, type, reverse3);
  };
  Map2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    this._root && this._root.iterate(function(entry) {
      iterations++;
      return fn(entry[1], entry[0], this$1$1);
    }, reverse3);
    return iterations;
  };
  Map2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeMap(this.size, this._root, ownerID, this.__hash);
  };
  return Map2;
}(KeyedCollection);
Map$1.isMap = isMap;
var MapPrototype = Map$1.prototype;
MapPrototype[IS_MAP_SYMBOL] = true;
MapPrototype[DELETE] = MapPrototype.remove;
MapPrototype.removeAll = MapPrototype.deleteAll;
MapPrototype.setIn = setIn;
MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
MapPrototype.update = update;
MapPrototype.updateIn = updateIn;
MapPrototype.merge = MapPrototype.concat = merge$1;
MapPrototype.mergeWith = mergeWith$1;
MapPrototype.mergeDeep = mergeDeep;
MapPrototype.mergeDeepWith = mergeDeepWith;
MapPrototype.mergeIn = mergeIn;
MapPrototype.mergeDeepIn = mergeDeepIn;
MapPrototype.withMutations = withMutations;
MapPrototype.wasAltered = wasAltered;
MapPrototype.asImmutable = asImmutable;
MapPrototype["@@transducer/init"] = MapPrototype.asMutable = asMutable;
MapPrototype["@@transducer/step"] = function(result, arr) {
  return result.set(arr[0], arr[1]);
};
MapPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
var ArrayMapNode = function ArrayMapNode2(ownerID, entries3) {
  this.ownerID = ownerID;
  this.entries = entries3;
};
ArrayMapNode.prototype.get = function get2(shift, keyHash, key, notSetValue) {
  var entries3 = this.entries;
  for (var ii = 0, len = entries3.length; ii < len; ii++) {
    if (is(key, entries3[ii][0])) {
      return entries3[ii][1];
    }
  }
  return notSetValue;
};
ArrayMapNode.prototype.update = function update2(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var entries3 = this.entries;
  var idx = 0;
  var len = entries3.length;
  for (; idx < len; idx++) {
    if (is(key, entries3[idx][0])) {
      break;
    }
  }
  var exists = idx < len;
  if (exists ? entries3[idx][1] === value : removed) {
    return this;
  }
  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);
  if (removed && entries3.length === 1) {
    return;
  }
  if (!exists && !removed && entries3.length >= MAX_ARRAY_MAP_SIZE) {
    return createNodes(ownerID, entries3, key, value);
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries3 : arrCopy(entries3);
  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }
  if (isEditable) {
    this.entries = newEntries;
    return this;
  }
  return new ArrayMapNode(ownerID, newEntries);
};
var BitmapIndexedNode = function BitmapIndexedNode2(ownerID, bitmap, nodes2) {
  this.ownerID = ownerID;
  this.bitmap = bitmap;
  this.nodes = nodes2;
};
BitmapIndexedNode.prototype.get = function get3(shift, keyHash, key, notSetValue) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
  var bitmap = this.bitmap;
  return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(
    shift + SHIFT,
    keyHash,
    key,
    notSetValue
  );
};
BitmapIndexedNode.prototype.update = function update3(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var bit = 1 << keyHashFrag;
  var bitmap = this.bitmap;
  var exists = (bitmap & bit) !== 0;
  if (!exists && value === NOT_SET) {
    return this;
  }
  var idx = popCount(bitmap & bit - 1);
  var nodes2 = this.nodes;
  var node = exists ? nodes2[idx] : void 0;
  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
  if (newNode === node) {
    return this;
  }
  if (!exists && newNode && nodes2.length >= MAX_BITMAP_INDEXED_SIZE) {
    return expandNodes(ownerID, nodes2, bitmap, keyHashFrag, newNode);
  }
  if (exists && !newNode && nodes2.length === 2 && isLeafNode(nodes2[idx ^ 1])) {
    return nodes2[idx ^ 1];
  }
  if (exists && newNode && nodes2.length === 1 && isLeafNode(newNode)) {
    return newNode;
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
  var newNodes = exists ? newNode ? setAt(nodes2, idx, newNode, isEditable) : spliceOut(nodes2, idx, isEditable) : spliceIn(nodes2, idx, newNode, isEditable);
  if (isEditable) {
    this.bitmap = newBitmap;
    this.nodes = newNodes;
    return this;
  }
  return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
};
var HashArrayMapNode = function HashArrayMapNode2(ownerID, count3, nodes2) {
  this.ownerID = ownerID;
  this.count = count3;
  this.nodes = nodes2;
};
HashArrayMapNode.prototype.get = function get4(shift, keyHash, key, notSetValue) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var node = this.nodes[idx];
  return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
};
HashArrayMapNode.prototype.update = function update4(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var removed = value === NOT_SET;
  var nodes2 = this.nodes;
  var node = nodes2[idx];
  if (removed && !node) {
    return this;
  }
  var newNode = updateNode(
    node,
    ownerID,
    shift + SHIFT,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
  if (newNode === node) {
    return this;
  }
  var newCount = this.count;
  if (!node) {
    newCount++;
  } else if (!newNode) {
    newCount--;
    if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
      return packNodes(ownerID, nodes2, newCount, idx);
    }
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newNodes = setAt(nodes2, idx, newNode, isEditable);
  if (isEditable) {
    this.count = newCount;
    this.nodes = newNodes;
    return this;
  }
  return new HashArrayMapNode(ownerID, newCount, newNodes);
};
var HashCollisionNode = function HashCollisionNode2(ownerID, keyHash, entries3) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entries = entries3;
};
HashCollisionNode.prototype.get = function get5(shift, keyHash, key, notSetValue) {
  var entries3 = this.entries;
  for (var ii = 0, len = entries3.length; ii < len; ii++) {
    if (is(key, entries3[ii][0])) {
      return entries3[ii][1];
    }
  }
  return notSetValue;
};
HashCollisionNode.prototype.update = function update5(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (keyHash === void 0) {
    keyHash = hash(key);
  }
  var removed = value === NOT_SET;
  if (keyHash !== this.keyHash) {
    if (removed) {
      return this;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
  }
  var entries3 = this.entries;
  var idx = 0;
  var len = entries3.length;
  for (; idx < len; idx++) {
    if (is(key, entries3[idx][0])) {
      break;
    }
  }
  var exists = idx < len;
  if (exists ? entries3[idx][1] === value : removed) {
    return this;
  }
  SetRef(didAlter);
  (removed || !exists) && SetRef(didChangeSize);
  if (removed && len === 2) {
    return new ValueNode(ownerID, this.keyHash, entries3[idx ^ 1]);
  }
  var isEditable = ownerID && ownerID === this.ownerID;
  var newEntries = isEditable ? entries3 : arrCopy(entries3);
  if (exists) {
    if (removed) {
      idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
    } else {
      newEntries[idx] = [key, value];
    }
  } else {
    newEntries.push([key, value]);
  }
  if (isEditable) {
    this.entries = newEntries;
    return this;
  }
  return new HashCollisionNode(ownerID, this.keyHash, newEntries);
};
var ValueNode = function ValueNode2(ownerID, keyHash, entry) {
  this.ownerID = ownerID;
  this.keyHash = keyHash;
  this.entry = entry;
};
ValueNode.prototype.get = function get6(shift, keyHash, key, notSetValue) {
  return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
};
ValueNode.prototype.update = function update6(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  var removed = value === NOT_SET;
  var keyMatch = is(key, this.entry[0]);
  if (keyMatch ? value === this.entry[1] : removed) {
    return this;
  }
  SetRef(didAlter);
  if (removed) {
    SetRef(didChangeSize);
    return;
  }
  if (keyMatch) {
    if (ownerID && ownerID === this.ownerID) {
      this.entry[1] = value;
      return this;
    }
    return new ValueNode(ownerID, this.keyHash, [key, value]);
  }
  SetRef(didChangeSize);
  return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
};
ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse3) {
  var entries3 = this.entries;
  for (var ii = 0, maxIndex = entries3.length - 1; ii <= maxIndex; ii++) {
    if (fn(entries3[reverse3 ? maxIndex - ii : ii]) === false) {
      return false;
    }
  }
};
BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse3) {
  var nodes2 = this.nodes;
  for (var ii = 0, maxIndex = nodes2.length - 1; ii <= maxIndex; ii++) {
    var node = nodes2[reverse3 ? maxIndex - ii : ii];
    if (node && node.iterate(fn, reverse3) === false) {
      return false;
    }
  }
};
ValueNode.prototype.iterate = function(fn, reverse3) {
  return fn(this.entry);
};
var MapIterator = /* @__PURE__ */ function(Iterator3) {
  function MapIterator2(map3, type, reverse3) {
    this._type = type;
    this._reverse = reverse3;
    this._stack = map3._root && mapIteratorFrame(map3._root);
  }
  if (Iterator3)
    MapIterator2.__proto__ = Iterator3;
  MapIterator2.prototype = Object.create(Iterator3 && Iterator3.prototype);
  MapIterator2.prototype.constructor = MapIterator2;
  MapIterator2.prototype.next = function next() {
    var type = this._type;
    var stack2 = this._stack;
    while (stack2) {
      var node = stack2.node;
      var index2 = stack2.index++;
      var maxIndex = void 0;
      if (node.entry) {
        if (index2 === 0) {
          return mapIteratorValue(type, node.entry);
        }
      } else if (node.entries) {
        maxIndex = node.entries.length - 1;
        if (index2 <= maxIndex) {
          return mapIteratorValue(
            type,
            node.entries[this._reverse ? maxIndex - index2 : index2]
          );
        }
      } else {
        maxIndex = node.nodes.length - 1;
        if (index2 <= maxIndex) {
          var subNode = node.nodes[this._reverse ? maxIndex - index2 : index2];
          if (subNode) {
            if (subNode.entry) {
              return mapIteratorValue(type, subNode.entry);
            }
            stack2 = this._stack = mapIteratorFrame(subNode, stack2);
          }
          continue;
        }
      }
      stack2 = this._stack = this._stack.__prev;
    }
    return iteratorDone();
  };
  return MapIterator2;
}(Iterator);
function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
  return {
    node,
    index: 0,
    __prev: prev
  };
}
function makeMap(size2, root, ownerID, hash2) {
  var map3 = Object.create(MapPrototype);
  map3.size = size2;
  map3._root = root;
  map3.__ownerID = ownerID;
  map3.__hash = hash2;
  map3.__altered = false;
  return map3;
}
var EMPTY_MAP;
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map3, k, v) {
  var newRoot;
  var newSize;
  if (!map3._root) {
    if (v === NOT_SET) {
      return map3;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map3.__ownerID, [[k, v]]);
  } else {
    var didChangeSize = MakeRef();
    var didAlter = MakeRef();
    newRoot = updateNode(
      map3._root,
      map3.__ownerID,
      0,
      void 0,
      k,
      v,
      didChangeSize,
      didAlter
    );
    if (!didAlter.value) {
      return map3;
    }
    newSize = map3.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
  }
  if (map3.__ownerID) {
    map3.size = newSize;
    map3._root = newRoot;
    map3.__hash = void 0;
    map3.__altered = true;
    return map3;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
  if (!node) {
    if (value === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value]);
  }
  return node.update(
    ownerID,
    shift,
    keyHash,
    key,
    value,
    didChangeSize,
    didAlter
  );
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }
  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var newNode;
  var nodes2 = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes2);
}
function createNodes(ownerID, entries3, key, value) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  var node = new ValueNode(ownerID, hash(key), [key, value]);
  for (var ii = 0; ii < entries3.length; ii++) {
    var entry = entries3[ii];
    node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
  }
  return node;
}
function packNodes(ownerID, nodes2, count3, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count3);
  for (var ii = 0, bit = 1, len = nodes2.length; ii < len; ii++, bit <<= 1) {
    var node = nodes2[ii];
    if (node !== void 0 && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes2, bitmap, including, node) {
  var count3 = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes2[count3++] : void 0;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count3 + 1, expandedNodes);
}
function popCount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function setAt(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}
var MAX_ARRAY_MAP_SIZE = SIZE / 4;
var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
var IS_LIST_SYMBOL = "@@__IMMUTABLE_LIST__@@";
function isList(maybeList) {
  return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
}
var List = /* @__PURE__ */ function(IndexedCollection2) {
  function List2(value) {
    var empty = emptyList();
    if (value === void 0 || value === null) {
      return empty;
    }
    if (isList(value)) {
      return value;
    }
    var iter = IndexedCollection2(value);
    var size2 = iter.size;
    if (size2 === 0) {
      return empty;
    }
    assertNotInfinite(size2);
    if (size2 > 0 && size2 < SIZE) {
      return makeList(0, size2, SHIFT, null, new VNode(iter.toArray()));
    }
    return empty.withMutations(function(list) {
      list.setSize(size2);
      iter.forEach(function(v, i2) {
        return list.set(i2, v);
      });
    });
  }
  if (IndexedCollection2)
    List2.__proto__ = IndexedCollection2;
  List2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
  List2.prototype.constructor = List2;
  List2.of = function of() {
    return this(arguments);
  };
  List2.prototype.toString = function toString5() {
    return this.__toString("List [", "]");
  };
  List2.prototype.get = function get11(index2, notSetValue) {
    index2 = wrapIndex(this, index2);
    if (index2 >= 0 && index2 < this.size) {
      index2 += this._origin;
      var node = listNodeFor(this, index2);
      return node && node.array[index2 & MASK];
    }
    return notSetValue;
  };
  List2.prototype.set = function set3(index2, value) {
    return updateList(this, index2, value);
  };
  List2.prototype.remove = function remove3(index2) {
    return !this.has(index2) ? this : index2 === 0 ? this.shift() : index2 === this.size - 1 ? this.pop() : this.splice(index2, 1);
  };
  List2.prototype.insert = function insert(index2, value) {
    return this.splice(index2, 0, value);
  };
  List2.prototype.clear = function clear3() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = this._origin = this._capacity = 0;
      this._level = SHIFT;
      this._root = this._tail = this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyList();
  };
  List2.prototype.push = function push() {
    var values2 = arguments;
    var oldSize = this.size;
    return this.withMutations(function(list) {
      setListBounds(list, 0, oldSize + values2.length);
      for (var ii = 0; ii < values2.length; ii++) {
        list.set(oldSize + ii, values2[ii]);
      }
    });
  };
  List2.prototype.pop = function pop() {
    return setListBounds(this, 0, -1);
  };
  List2.prototype.unshift = function unshift() {
    var values2 = arguments;
    return this.withMutations(function(list) {
      setListBounds(list, -values2.length);
      for (var ii = 0; ii < values2.length; ii++) {
        list.set(ii, values2[ii]);
      }
    });
  };
  List2.prototype.shift = function shift() {
    return setListBounds(this, 1);
  };
  List2.prototype.concat = function concat3() {
    var arguments$1 = arguments;
    var seqs = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      var argument = arguments$1[i2];
      var seq = IndexedCollection2(
        typeof argument !== "string" && hasIterator(argument) ? argument : [argument]
      );
      if (seq.size !== 0) {
        seqs.push(seq);
      }
    }
    if (seqs.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
      return this.constructor(seqs[0]);
    }
    return this.withMutations(function(list) {
      seqs.forEach(function(seq2) {
        return seq2.forEach(function(value) {
          return list.push(value);
        });
      });
    });
  };
  List2.prototype.setSize = function setSize2(size2) {
    return setListBounds(this, 0, size2);
  };
  List2.prototype.map = function map3(mapper, context) {
    var this$1$1 = this;
    return this.withMutations(function(list) {
      for (var i2 = 0; i2 < this$1$1.size; i2++) {
        list.set(i2, mapper.call(context, list.get(i2), i2, this$1$1));
      }
    });
  };
  List2.prototype.slice = function slice3(begin, end) {
    var size2 = this.size;
    if (wholeSlice(begin, end, size2)) {
      return this;
    }
    return setListBounds(
      this,
      resolveBegin(begin, size2),
      resolveEnd(end, size2)
    );
  };
  List2.prototype.__iterator = function __iterator2(type, reverse3) {
    var index2 = reverse3 ? this.size : 0;
    var values2 = iterateList(this, reverse3);
    return new Iterator(function() {
      var value = values2();
      return value === DONE ? iteratorDone() : iteratorValue(type, reverse3 ? --index2 : index2++, value);
    });
  };
  List2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var index2 = reverse3 ? this.size : 0;
    var values2 = iterateList(this, reverse3);
    var value;
    while ((value = values2()) !== DONE) {
      if (fn(value, reverse3 ? --index2 : index2++, this) === false) {
        break;
      }
    }
    return index2;
  };
  List2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyList();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeList(
      this._origin,
      this._capacity,
      this._level,
      this._root,
      this._tail,
      ownerID,
      this.__hash
    );
  };
  return List2;
}(IndexedCollection);
List.isList = isList;
var ListPrototype = List.prototype;
ListPrototype[IS_LIST_SYMBOL] = true;
ListPrototype[DELETE] = ListPrototype.remove;
ListPrototype.merge = ListPrototype.concat;
ListPrototype.setIn = setIn;
ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
ListPrototype.update = update;
ListPrototype.updateIn = updateIn;
ListPrototype.mergeIn = mergeIn;
ListPrototype.mergeDeepIn = mergeDeepIn;
ListPrototype.withMutations = withMutations;
ListPrototype.wasAltered = wasAltered;
ListPrototype.asImmutable = asImmutable;
ListPrototype["@@transducer/init"] = ListPrototype.asMutable = asMutable;
ListPrototype["@@transducer/step"] = function(result, arr) {
  return result.push(arr);
};
ListPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
var VNode = function VNode2(array, ownerID) {
  this.array = array;
  this.ownerID = ownerID;
};
VNode.prototype.removeBefore = function removeBefore(ownerID, level, index2) {
  if (index2 === level ? 1 << level : this.array.length === 0) {
    return this;
  }
  var originIndex = index2 >>> level & MASK;
  if (originIndex >= this.array.length) {
    return new VNode([], ownerID);
  }
  var removingFirst = originIndex === 0;
  var newChild;
  if (level > 0) {
    var oldChild = this.array[originIndex];
    newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index2);
    if (newChild === oldChild && removingFirst) {
      return this;
    }
  }
  if (removingFirst && !newChild) {
    return this;
  }
  var editable = editableVNode(this, ownerID);
  if (!removingFirst) {
    for (var ii = 0; ii < originIndex; ii++) {
      editable.array[ii] = void 0;
    }
  }
  if (newChild) {
    editable.array[originIndex] = newChild;
  }
  return editable;
};
VNode.prototype.removeAfter = function removeAfter(ownerID, level, index2) {
  if (index2 === (level ? 1 << level : 0) || this.array.length === 0) {
    return this;
  }
  var sizeIndex = index2 - 1 >>> level & MASK;
  if (sizeIndex >= this.array.length) {
    return this;
  }
  var newChild;
  if (level > 0) {
    var oldChild = this.array[sizeIndex];
    newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index2);
    if (newChild === oldChild && sizeIndex === this.array.length - 1) {
      return this;
    }
  }
  var editable = editableVNode(this, ownerID);
  editable.array.splice(sizeIndex + 1);
  if (newChild) {
    editable.array[sizeIndex] = newChild;
  }
  return editable;
};
var DONE = {};
function iterateList(list, reverse3) {
  var left = list._origin;
  var right = list._capacity;
  var tailPos = getTailOffset(right);
  var tail = list._tail;
  return iterateNodeOrLeaf(list._root, list._level, 0);
  function iterateNodeOrLeaf(node, level, offset) {
    return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
  }
  function iterateLeaf(node, offset) {
    var array = offset === tailPos ? tail && tail.array : node && node.array;
    var from = offset > left ? 0 : left - offset;
    var to2 = right - offset;
    if (to2 > SIZE) {
      to2 = SIZE;
    }
    return function() {
      if (from === to2) {
        return DONE;
      }
      var idx = reverse3 ? --to2 : from++;
      return array && array[idx];
    };
  }
  function iterateNode(node, level, offset) {
    var values2;
    var array = node && node.array;
    var from = offset > left ? 0 : left - offset >> level;
    var to2 = (right - offset >> level) + 1;
    if (to2 > SIZE) {
      to2 = SIZE;
    }
    return function() {
      while (true) {
        if (values2) {
          var value = values2();
          if (value !== DONE) {
            return value;
          }
          values2 = null;
        }
        if (from === to2) {
          return DONE;
        }
        var idx = reverse3 ? --to2 : from++;
        values2 = iterateNodeOrLeaf(
          array && array[idx],
          level - SHIFT,
          offset + (idx << level)
        );
      }
    };
  }
}
function makeList(origin, capacity, level, root, tail, ownerID, hash2) {
  var list = Object.create(ListPrototype);
  list.size = capacity - origin;
  list._origin = origin;
  list._capacity = capacity;
  list._level = level;
  list._root = root;
  list._tail = tail;
  list.__ownerID = ownerID;
  list.__hash = hash2;
  list.__altered = false;
  return list;
}
var EMPTY_LIST;
function emptyList() {
  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
}
function updateList(list, index2, value) {
  index2 = wrapIndex(list, index2);
  if (index2 !== index2) {
    return list;
  }
  if (index2 >= list.size || index2 < 0) {
    return list.withMutations(function(list2) {
      index2 < 0 ? setListBounds(list2, index2).set(0, value) : setListBounds(list2, 0, index2 + 1).set(index2, value);
    });
  }
  index2 += list._origin;
  var newTail = list._tail;
  var newRoot = list._root;
  var didAlter = MakeRef();
  if (index2 >= getTailOffset(list._capacity)) {
    newTail = updateVNode(newTail, list.__ownerID, 0, index2, value, didAlter);
  } else {
    newRoot = updateVNode(
      newRoot,
      list.__ownerID,
      list._level,
      index2,
      value,
      didAlter
    );
  }
  if (!didAlter.value) {
    return list;
  }
  if (list.__ownerID) {
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}
function updateVNode(node, ownerID, level, index2, value, didAlter) {
  var idx = index2 >>> level & MASK;
  var nodeHas = node && idx < node.array.length;
  if (!nodeHas && value === void 0) {
    return node;
  }
  var newNode;
  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(
      lowerNode,
      ownerID,
      level - SHIFT,
      index2,
      value,
      didAlter
    );
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }
  if (nodeHas && node.array[idx] === value) {
    return node;
  }
  if (didAlter) {
    SetRef(didAlter);
  }
  newNode = editableVNode(node, ownerID);
  if (value === void 0 && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = value;
  }
  return newNode;
}
function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}
function listNodeFor(list, rawIndex) {
  if (rawIndex >= getTailOffset(list._capacity)) {
    return list._tail;
  }
  if (rawIndex < 1 << list._level + SHIFT) {
    var node = list._root;
    var level = list._level;
    while (node && level > 0) {
      node = node.array[rawIndex >>> level & MASK];
      level -= SHIFT;
    }
    return node;
  }
}
function setListBounds(list, begin, end) {
  if (begin !== void 0) {
    begin |= 0;
  }
  if (end !== void 0) {
    end |= 0;
  }
  var owner = list.__ownerID || new OwnerID();
  var oldOrigin = list._origin;
  var oldCapacity = list._capacity;
  var newOrigin = oldOrigin + begin;
  var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
    return list;
  }
  if (newOrigin >= newCapacity) {
    return list.clear();
  }
  var newLevel = list._level;
  var newRoot = list._root;
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [void 0, newRoot] : [],
      owner
    );
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newCapacity += offsetShift;
    oldCapacity += offsetShift;
  }
  var oldTailOffset = getTailOffset(oldCapacity);
  var newTailOffset = getTailOffset(newCapacity);
  while (newTailOffset >= 1 << newLevel + SHIFT) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [newRoot] : [],
      owner
    );
    newLevel += SHIFT;
  }
  var oldTail = list._tail;
  var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
  if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = oldTailOffset >>> level & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }
    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
  }
  if (newCapacity < oldCapacity) {
    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  }
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newCapacity -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0;
    while (newRoot) {
      var beginIndex = newOrigin >>> newLevel & MASK;
      if (beginIndex !== newTailOffset >>> newLevel & MASK) {
        break;
      }
      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }
      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    }
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(
        owner,
        newLevel,
        newTailOffset - offsetShift
      );
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newCapacity -= offsetShift;
    }
  }
  if (list.__ownerID) {
    list.size = newCapacity - newOrigin;
    list._origin = newOrigin;
    list._capacity = newCapacity;
    list._level = newLevel;
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}
function getTailOffset(size2) {
  return size2 < SIZE ? 0 : size2 - 1 >>> SHIFT << SHIFT;
}
var OrderedMap = /* @__PURE__ */ function(Map2) {
  function OrderedMap2(value) {
    return value === void 0 || value === null ? emptyOrderedMap() : isOrderedMap(value) ? value : emptyOrderedMap().withMutations(function(map3) {
      var iter = KeyedCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v, k) {
        return map3.set(k, v);
      });
    });
  }
  if (Map2)
    OrderedMap2.__proto__ = Map2;
  OrderedMap2.prototype = Object.create(Map2 && Map2.prototype);
  OrderedMap2.prototype.constructor = OrderedMap2;
  OrderedMap2.of = function of() {
    return this(arguments);
  };
  OrderedMap2.prototype.toString = function toString5() {
    return this.__toString("OrderedMap {", "}");
  };
  OrderedMap2.prototype.get = function get11(k, notSetValue) {
    var index2 = this._map.get(k);
    return index2 !== void 0 ? this._list.get(index2)[1] : notSetValue;
  };
  OrderedMap2.prototype.clear = function clear3() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._map.clear();
      this._list.clear();
      this.__altered = true;
      return this;
    }
    return emptyOrderedMap();
  };
  OrderedMap2.prototype.set = function set3(k, v) {
    return updateOrderedMap(this, k, v);
  };
  OrderedMap2.prototype.remove = function remove3(k) {
    return updateOrderedMap(this, k, NOT_SET);
  };
  OrderedMap2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._list.__iterate(
      function(entry) {
        return entry && fn(entry[1], entry[0], this$1$1);
      },
      reverse3
    );
  };
  OrderedMap2.prototype.__iterator = function __iterator2(type, reverse3) {
    return this._list.fromEntrySeq().__iterator(type, reverse3);
  };
  OrderedMap2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    var newList = this._list.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return emptyOrderedMap();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      this._map = newMap;
      this._list = newList;
      return this;
    }
    return makeOrderedMap(newMap, newList, ownerID, this.__hash);
  };
  return OrderedMap2;
}(Map$1);
OrderedMap.isOrderedMap = isOrderedMap;
OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
function makeOrderedMap(map3, list, ownerID, hash2) {
  var omap = Object.create(OrderedMap.prototype);
  omap.size = map3 ? map3.size : 0;
  omap._map = map3;
  omap._list = list;
  omap.__ownerID = ownerID;
  omap.__hash = hash2;
  omap.__altered = false;
  return omap;
}
var EMPTY_ORDERED_MAP;
function emptyOrderedMap() {
  return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
}
function updateOrderedMap(omap, k, v) {
  var map3 = omap._map;
  var list = omap._list;
  var i2 = map3.get(k);
  var has5 = i2 !== void 0;
  var newMap;
  var newList;
  if (v === NOT_SET) {
    if (!has5) {
      return omap;
    }
    if (list.size >= SIZE && list.size >= map3.size * 2) {
      newList = list.filter(function(entry, idx) {
        return entry !== void 0 && i2 !== idx;
      });
      newMap = newList.toKeyedSeq().map(function(entry) {
        return entry[0];
      }).flip().toMap();
      if (omap.__ownerID) {
        newMap.__ownerID = newList.__ownerID = omap.__ownerID;
      }
    } else {
      newMap = map3.remove(k);
      newList = i2 === list.size - 1 ? list.pop() : list.set(i2, void 0);
    }
  } else if (has5) {
    if (v === list.get(i2)[1]) {
      return omap;
    }
    newMap = map3;
    newList = list.set(i2, [k, v]);
  } else {
    newMap = map3.set(k, list.size);
    newList = list.set(list.size, [k, v]);
  }
  if (omap.__ownerID) {
    omap.size = newMap.size;
    omap._map = newMap;
    omap._list = newList;
    omap.__hash = void 0;
    omap.__altered = true;
    return omap;
  }
  return makeOrderedMap(newMap, newList);
}
var IS_STACK_SYMBOL = "@@__IMMUTABLE_STACK__@@";
function isStack(maybeStack) {
  return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
}
var Stack = /* @__PURE__ */ function(IndexedCollection2) {
  function Stack2(value) {
    return value === void 0 || value === null ? emptyStack() : isStack(value) ? value : emptyStack().pushAll(value);
  }
  if (IndexedCollection2)
    Stack2.__proto__ = IndexedCollection2;
  Stack2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
  Stack2.prototype.constructor = Stack2;
  Stack2.of = function of() {
    return this(arguments);
  };
  Stack2.prototype.toString = function toString5() {
    return this.__toString("Stack [", "]");
  };
  Stack2.prototype.get = function get11(index2, notSetValue) {
    var head = this._head;
    index2 = wrapIndex(this, index2);
    while (head && index2--) {
      head = head.next;
    }
    return head ? head.value : notSetValue;
  };
  Stack2.prototype.peek = function peek() {
    return this._head && this._head.value;
  };
  Stack2.prototype.push = function push() {
    var arguments$1 = arguments;
    if (arguments.length === 0) {
      return this;
    }
    var newSize = this.size + arguments.length;
    var head = this._head;
    for (var ii = arguments.length - 1; ii >= 0; ii--) {
      head = {
        value: arguments$1[ii],
        next: head
      };
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.pushAll = function pushAll(iter) {
    iter = IndexedCollection2(iter);
    if (iter.size === 0) {
      return this;
    }
    if (this.size === 0 && isStack(iter)) {
      return iter;
    }
    assertNotInfinite(iter.size);
    var newSize = this.size;
    var head = this._head;
    iter.__iterate(function(value) {
      newSize++;
      head = {
        value,
        next: head
      };
    }, true);
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.pop = function pop() {
    return this.slice(1);
  };
  Stack2.prototype.clear = function clear3() {
    if (this.size === 0) {
      return this;
    }
    if (this.__ownerID) {
      this.size = 0;
      this._head = void 0;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return emptyStack();
  };
  Stack2.prototype.slice = function slice3(begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    var resolvedBegin = resolveBegin(begin, this.size);
    var resolvedEnd = resolveEnd(end, this.size);
    if (resolvedEnd !== this.size) {
      return IndexedCollection2.prototype.slice.call(this, begin, end);
    }
    var newSize = this.size - resolvedBegin;
    var head = this._head;
    while (resolvedBegin--) {
      head = head.next;
    }
    if (this.__ownerID) {
      this.size = newSize;
      this._head = head;
      this.__hash = void 0;
      this.__altered = true;
      return this;
    }
    return makeStack(newSize, head);
  };
  Stack2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    if (!ownerID) {
      if (this.size === 0) {
        return emptyStack();
      }
      this.__ownerID = ownerID;
      this.__altered = false;
      return this;
    }
    return makeStack(this.size, this._head, ownerID, this.__hash);
  };
  Stack2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return new ArraySeq(this.toArray()).__iterate(
        function(v, k) {
          return fn(v, k, this$1$1);
        },
        reverse3
      );
    }
    var iterations = 0;
    var node = this._head;
    while (node) {
      if (fn(node.value, iterations++, this) === false) {
        break;
      }
      node = node.next;
    }
    return iterations;
  };
  Stack2.prototype.__iterator = function __iterator2(type, reverse3) {
    if (reverse3) {
      return new ArraySeq(this.toArray()).__iterator(type, reverse3);
    }
    var iterations = 0;
    var node = this._head;
    return new Iterator(function() {
      if (node) {
        var value = node.value;
        node = node.next;
        return iteratorValue(type, iterations++, value);
      }
      return iteratorDone();
    });
  };
  return Stack2;
}(IndexedCollection);
Stack.isStack = isStack;
var StackPrototype = Stack.prototype;
StackPrototype[IS_STACK_SYMBOL] = true;
StackPrototype.shift = StackPrototype.pop;
StackPrototype.unshift = StackPrototype.push;
StackPrototype.unshiftAll = StackPrototype.pushAll;
StackPrototype.withMutations = withMutations;
StackPrototype.wasAltered = wasAltered;
StackPrototype.asImmutable = asImmutable;
StackPrototype["@@transducer/init"] = StackPrototype.asMutable = asMutable;
StackPrototype["@@transducer/step"] = function(result, arr) {
  return result.unshift(arr);
};
StackPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
function makeStack(size2, head, ownerID, hash2) {
  var map3 = Object.create(StackPrototype);
  map3.size = size2;
  map3._head = head;
  map3.__ownerID = ownerID;
  map3.__hash = hash2;
  map3.__altered = false;
  return map3;
}
var EMPTY_STACK;
function emptyStack() {
  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}
var IS_SET_SYMBOL = "@@__IMMUTABLE_SET__@@";
function isSet(maybeSet) {
  return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
}
function isOrderedSet(maybeOrderedSet) {
  return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (!isCollection(b) || a.size !== void 0 && b.size !== void 0 && a.size !== b.size || a.__hash !== void 0 && b.__hash !== void 0 && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
    return false;
  }
  if (a.size === 0 && b.size === 0) {
    return true;
  }
  var notAssociative = !isAssociative(a);
  if (isOrdered(a)) {
    var entries3 = a.entries();
    return b.every(function(v, k) {
      var entry = entries3.next().value;
      return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
    }) && entries3.next().done;
  }
  var flipped = false;
  if (a.size === void 0) {
    if (b.size === void 0) {
      if (typeof a.cacheResult === "function") {
        a.cacheResult();
      }
    } else {
      flipped = true;
      var _ = a;
      a = b;
      b = _;
    }
  }
  var allEqual = true;
  var bSize = b.__iterate(function(v, k) {
    if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
      allEqual = false;
      return false;
    }
  });
  return allEqual && a.size === bSize;
}
function mixin(ctor, methods) {
  var keyCopier = function(key) {
    ctor.prototype[key] = methods[key];
  };
  Object.keys(methods).forEach(keyCopier);
  Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
  return ctor;
}
function toJS(value) {
  if (!value || typeof value !== "object") {
    return value;
  }
  if (!isCollection(value)) {
    if (!isDataStructure(value)) {
      return value;
    }
    value = Seq(value);
  }
  if (isKeyed(value)) {
    var result$1 = {};
    value.__iterate(function(v, k) {
      result$1[k] = toJS(v);
    });
    return result$1;
  }
  var result = [];
  value.__iterate(function(v) {
    result.push(toJS(v));
  });
  return result;
}
var Set$1 = /* @__PURE__ */ function(SetCollection2) {
  function Set2(value) {
    return value === void 0 || value === null ? emptySet() : isSet(value) && !isOrdered(value) ? value : emptySet().withMutations(function(set3) {
      var iter = SetCollection2(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v) {
        return set3.add(v);
      });
    });
  }
  if (SetCollection2)
    Set2.__proto__ = SetCollection2;
  Set2.prototype = Object.create(SetCollection2 && SetCollection2.prototype);
  Set2.prototype.constructor = Set2;
  Set2.of = function of() {
    return this(arguments);
  };
  Set2.fromKeys = function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  };
  Set2.intersect = function intersect2(sets) {
    sets = Collection(sets).toArray();
    return sets.length ? SetPrototype.intersect.apply(Set2(sets.pop()), sets) : emptySet();
  };
  Set2.union = function union(sets) {
    sets = Collection(sets).toArray();
    return sets.length ? SetPrototype.union.apply(Set2(sets.pop()), sets) : emptySet();
  };
  Set2.prototype.toString = function toString5() {
    return this.__toString("Set {", "}");
  };
  Set2.prototype.has = function has5(value) {
    return this._map.has(value);
  };
  Set2.prototype.add = function add2(value) {
    return updateSet(this, this._map.set(value, value));
  };
  Set2.prototype.remove = function remove3(value) {
    return updateSet(this, this._map.remove(value));
  };
  Set2.prototype.clear = function clear3() {
    return updateSet(this, this._map.clear());
  };
  Set2.prototype.map = function map3(mapper, context) {
    var this$1$1 = this;
    var didChanges = false;
    var newMap = updateSet(
      this,
      this._map.mapEntries(function(ref2) {
        var v = ref2[1];
        var mapped = mapper.call(context, v, v, this$1$1);
        if (mapped !== v) {
          didChanges = true;
        }
        return [mapped, mapped];
      }, context)
    );
    return didChanges ? newMap : this;
  };
  Set2.prototype.union = function union() {
    var iters = [], len = arguments.length;
    while (len--)
      iters[len] = arguments[len];
    iters = iters.filter(function(x) {
      return x.size !== 0;
    });
    if (iters.length === 0) {
      return this;
    }
    if (this.size === 0 && !this.__ownerID && iters.length === 1) {
      return this.constructor(iters[0]);
    }
    return this.withMutations(function(set3) {
      for (var ii = 0; ii < iters.length; ii++) {
        SetCollection2(iters[ii]).forEach(function(value) {
          return set3.add(value);
        });
      }
    });
  };
  Set2.prototype.intersect = function intersect2() {
    var iters = [], len = arguments.length;
    while (len--)
      iters[len] = arguments[len];
    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function(iter) {
      return SetCollection2(iter);
    });
    var toRemove = [];
    this.forEach(function(value) {
      if (!iters.every(function(iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function(set3) {
      toRemove.forEach(function(value) {
        set3.remove(value);
      });
    });
  };
  Set2.prototype.subtract = function subtract2() {
    var iters = [], len = arguments.length;
    while (len--)
      iters[len] = arguments[len];
    if (iters.length === 0) {
      return this;
    }
    iters = iters.map(function(iter) {
      return SetCollection2(iter);
    });
    var toRemove = [];
    this.forEach(function(value) {
      if (iters.some(function(iter) {
        return iter.includes(value);
      })) {
        toRemove.push(value);
      }
    });
    return this.withMutations(function(set3) {
      toRemove.forEach(function(value) {
        set3.remove(value);
      });
    });
  };
  Set2.prototype.sort = function sort3(comparator) {
    return OrderedSet(sortFactory(this, comparator));
  };
  Set2.prototype.sortBy = function sortBy2(mapper, comparator) {
    return OrderedSet(sortFactory(this, comparator, mapper));
  };
  Set2.prototype.wasAltered = function wasAltered3() {
    return this._map.wasAltered();
  };
  Set2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var this$1$1 = this;
    return this._map.__iterate(function(k) {
      return fn(k, k, this$1$1);
    }, reverse3);
  };
  Set2.prototype.__iterator = function __iterator2(type, reverse3) {
    return this._map.__iterator(type, reverse3);
  };
  Set2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
    if (ownerID === this.__ownerID) {
      return this;
    }
    var newMap = this._map.__ensureOwner(ownerID);
    if (!ownerID) {
      if (this.size === 0) {
        return this.__empty();
      }
      this.__ownerID = ownerID;
      this._map = newMap;
      return this;
    }
    return this.__make(newMap, ownerID);
  };
  return Set2;
}(SetCollection);
Set$1.isSet = isSet;
var SetPrototype = Set$1.prototype;
SetPrototype[IS_SET_SYMBOL] = true;
SetPrototype[DELETE] = SetPrototype.remove;
SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
SetPrototype.withMutations = withMutations;
SetPrototype.asImmutable = asImmutable;
SetPrototype["@@transducer/init"] = SetPrototype.asMutable = asMutable;
SetPrototype["@@transducer/step"] = function(result, arr) {
  return result.add(arr);
};
SetPrototype["@@transducer/result"] = function(obj) {
  return obj.asImmutable();
};
SetPrototype.__empty = emptySet;
SetPrototype.__make = makeSet;
function updateSet(set3, newMap) {
  if (set3.__ownerID) {
    set3.size = newMap.size;
    set3._map = newMap;
    return set3;
  }
  return newMap === set3._map ? set3 : newMap.size === 0 ? set3.__empty() : set3.__make(newMap);
}
function makeSet(map3, ownerID) {
  var set3 = Object.create(SetPrototype);
  set3.size = map3 ? map3.size : 0;
  set3._map = map3;
  set3.__ownerID = ownerID;
  return set3;
}
var EMPTY_SET;
function emptySet() {
  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}
var Range = /* @__PURE__ */ function(IndexedSeq2) {
  function Range2(start2, end, step) {
    if (!(this instanceof Range2)) {
      return new Range2(start2, end, step);
    }
    invariant(step !== 0, "Cannot step a Range by 0");
    start2 = start2 || 0;
    if (end === void 0) {
      end = Infinity;
    }
    step = step === void 0 ? 1 : Math.abs(step);
    if (end < start2) {
      step = -step;
    }
    this._start = start2;
    this._end = end;
    this._step = step;
    this.size = Math.max(0, Math.ceil((end - start2) / step - 1) + 1);
    if (this.size === 0) {
      if (EMPTY_RANGE) {
        return EMPTY_RANGE;
      }
      EMPTY_RANGE = this;
    }
  }
  if (IndexedSeq2)
    Range2.__proto__ = IndexedSeq2;
  Range2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
  Range2.prototype.constructor = Range2;
  Range2.prototype.toString = function toString5() {
    if (this.size === 0) {
      return "Range []";
    }
    return "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
  };
  Range2.prototype.get = function get11(index2, notSetValue) {
    return this.has(index2) ? this._start + wrapIndex(this, index2) * this._step : notSetValue;
  };
  Range2.prototype.includes = function includes3(searchValue) {
    var possibleIndex = (searchValue - this._start) / this._step;
    return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
  };
  Range2.prototype.slice = function slice3(begin, end) {
    if (wholeSlice(begin, end, this.size)) {
      return this;
    }
    begin = resolveBegin(begin, this.size);
    end = resolveEnd(end, this.size);
    if (end <= begin) {
      return new Range2(0, 0);
    }
    return new Range2(
      this.get(begin, this._end),
      this.get(end, this._end),
      this._step
    );
  };
  Range2.prototype.indexOf = function indexOf2(searchValue) {
    var offsetValue = searchValue - this._start;
    if (offsetValue % this._step === 0) {
      var index2 = offsetValue / this._step;
      if (index2 >= 0 && index2 < this.size) {
        return index2;
      }
    }
    return -1;
  };
  Range2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
    return this.indexOf(searchValue);
  };
  Range2.prototype.__iterate = function __iterate2(fn, reverse3) {
    var size2 = this.size;
    var step = this._step;
    var value = reverse3 ? this._start + (size2 - 1) * step : this._start;
    var i2 = 0;
    while (i2 !== size2) {
      if (fn(value, reverse3 ? size2 - ++i2 : i2++, this) === false) {
        break;
      }
      value += reverse3 ? -step : step;
    }
    return i2;
  };
  Range2.prototype.__iterator = function __iterator2(type, reverse3) {
    var size2 = this.size;
    var step = this._step;
    var value = reverse3 ? this._start + (size2 - 1) * step : this._start;
    var i2 = 0;
    return new Iterator(function() {
      if (i2 === size2) {
        return iteratorDone();
      }
      var v = value;
      value += reverse3 ? -step : step;
      return iteratorValue(type, reverse3 ? size2 - ++i2 : i2++, v);
    });
  };
  Range2.prototype.equals = function equals3(other) {
    return other instanceof Range2 ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
  };
  return Range2;
}(IndexedSeq);
var EMPTY_RANGE;
function getIn$1(collection, searchKeyPath, notSetValue) {
  var keyPath = coerceKeyPath(searchKeyPath);
  var i2 = 0;
  while (i2 !== keyPath.length) {
    collection = get(collection, keyPath[i2++], NOT_SET);
    if (collection === NOT_SET) {
      return notSetValue;
    }
  }
  return collection;
}
function getIn(searchKeyPath, notSetValue) {
  return getIn$1(this, searchKeyPath, notSetValue);
}
function hasIn$1(collection, keyPath) {
  return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
}
function hasIn(searchKeyPath) {
  return hasIn$1(this, searchKeyPath);
}
function toObject() {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function(v, k) {
    object[k] = v;
  });
  return object;
}
Collection.isIterable = isCollection;
Collection.isKeyed = isKeyed;
Collection.isIndexed = isIndexed;
Collection.isAssociative = isAssociative;
Collection.isOrdered = isOrdered;
Collection.Iterator = Iterator;
mixin(Collection, {
  toArray: function toArray() {
    assertNotInfinite(this.size);
    var array = new Array(this.size || 0);
    var useTuples = isKeyed(this);
    var i2 = 0;
    this.__iterate(function(v, k) {
      array[i2++] = useTuples ? [k, v] : v;
    });
    return array;
  },
  toIndexedSeq: function toIndexedSeq() {
    return new ToIndexedSequence(this);
  },
  toJS: function toJS$1() {
    return toJS(this);
  },
  toKeyedSeq: function toKeyedSeq() {
    return new ToKeyedSequence(this, true);
  },
  toMap: function toMap() {
    return Map$1(this.toKeyedSeq());
  },
  toObject,
  toOrderedMap: function toOrderedMap() {
    return OrderedMap(this.toKeyedSeq());
  },
  toOrderedSet: function toOrderedSet() {
    return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
  },
  toSet: function toSet() {
    return Set$1(isKeyed(this) ? this.valueSeq() : this);
  },
  toSetSeq: function toSetSeq() {
    return new ToSetSequence(this);
  },
  toSeq: function toSeq() {
    return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
  },
  toStack: function toStack() {
    return Stack(isKeyed(this) ? this.valueSeq() : this);
  },
  toList: function toList() {
    return List(isKeyed(this) ? this.valueSeq() : this);
  },
  toString: function toString3() {
    return "[Collection]";
  },
  __toString: function __toString(head, tail) {
    if (this.size === 0) {
      return head + tail;
    }
    return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
  },
  concat: function concat2() {
    var values2 = [], len = arguments.length;
    while (len--)
      values2[len] = arguments[len];
    return reify(this, concatFactory(this, values2));
  },
  includes: function includes(searchValue) {
    return this.some(function(value) {
      return is(value, searchValue);
    });
  },
  entries: function entries() {
    return this.__iterator(ITERATE_ENTRIES);
  },
  every: function every(predicate, context) {
    assertNotInfinite(this.size);
    var returnValue = true;
    this.__iterate(function(v, k, c) {
      if (!predicate.call(context, v, k, c)) {
        returnValue = false;
        return false;
      }
    });
    return returnValue;
  },
  filter: function filter2(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, true));
  },
  find: function find(predicate, context, notSetValue) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[1] : notSetValue;
  },
  forEach: function forEach2(sideEffect, context) {
    assertNotInfinite(this.size);
    return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
  },
  join: function join2(separator) {
    assertNotInfinite(this.size);
    separator = separator !== void 0 ? "" + separator : ",";
    var joined = "";
    var isFirst = true;
    this.__iterate(function(v) {
      isFirst ? isFirst = false : joined += separator;
      joined += v !== null && v !== void 0 ? v.toString() : "";
    });
    return joined;
  },
  keys: function keys() {
    return this.__iterator(ITERATE_KEYS);
  },
  map: function map2(mapper, context) {
    return reify(this, mapFactory(this, mapper, context));
  },
  reduce: function reduce$12(reducer, initialReduction, context) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context,
      arguments.length < 2,
      false
    );
  },
  reduceRight: function reduceRight(reducer, initialReduction, context) {
    return reduce(
      this,
      reducer,
      initialReduction,
      context,
      arguments.length < 2,
      true
    );
  },
  reverse: function reverse() {
    return reify(this, reverseFactory(this, true));
  },
  slice: function slice(begin, end) {
    return reify(this, sliceFactory(this, begin, end, true));
  },
  some: function some(predicate, context) {
    return !this.every(not(predicate), context);
  },
  sort: function sort2(comparator) {
    return reify(this, sortFactory(this, comparator));
  },
  values: function values() {
    return this.__iterator(ITERATE_VALUES);
  },
  butLast: function butLast() {
    return this.slice(0, -1);
  },
  isEmpty: function isEmpty() {
    return this.size !== void 0 ? this.size === 0 : !this.some(function() {
      return true;
    });
  },
  count: function count2(predicate, context) {
    return ensureSize(
      predicate ? this.toSeq().filter(predicate, context) : this
    );
  },
  countBy: function countBy(grouper, context) {
    return countByFactory(this, grouper, context);
  },
  equals: function equals(other) {
    return deepEqual(this, other);
  },
  entrySeq: function entrySeq() {
    var collection = this;
    if (collection._cache) {
      return new ArraySeq(collection._cache);
    }
    var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
    entriesSequence.fromEntrySeq = function() {
      return collection.toSeq();
    };
    return entriesSequence;
  },
  filterNot: function filterNot(predicate, context) {
    return this.filter(not(predicate), context);
  },
  findEntry: function findEntry(predicate, context, notSetValue) {
    var found = notSetValue;
    this.__iterate(function(v, k, c) {
      if (predicate.call(context, v, k, c)) {
        found = [k, v];
        return false;
      }
    });
    return found;
  },
  findKey: function findKey(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry && entry[0];
  },
  findLast: function findLast(predicate, context, notSetValue) {
    return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
  },
  findLastEntry: function findLastEntry(predicate, context, notSetValue) {
    return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
  },
  findLastKey: function findLastKey(predicate, context) {
    return this.toKeyedSeq().reverse().findKey(predicate, context);
  },
  first: function first(notSetValue) {
    return this.find(returnTrue, null, notSetValue);
  },
  flatMap: function flatMap(mapper, context) {
    return reify(this, flatMapFactory(this, mapper, context));
  },
  flatten: function flatten2(depth) {
    return reify(this, flattenFactory(this, depth, true));
  },
  fromEntrySeq: function fromEntrySeq() {
    return new FromEntriesSequence(this);
  },
  get: function get7(searchKey, notSetValue) {
    return this.find(function(_, key) {
      return is(key, searchKey);
    }, void 0, notSetValue);
  },
  getIn,
  groupBy: function groupBy(grouper, context) {
    return groupByFactory(this, grouper, context);
  },
  has: function has2(searchKey) {
    return this.get(searchKey, NOT_SET) !== NOT_SET;
  },
  hasIn,
  isSubset: function isSubset(iter) {
    iter = typeof iter.includes === "function" ? iter : Collection(iter);
    return this.every(function(value) {
      return iter.includes(value);
    });
  },
  isSuperset: function isSuperset(iter) {
    iter = typeof iter.isSubset === "function" ? iter : Collection(iter);
    return iter.isSubset(this);
  },
  keyOf: function keyOf(searchValue) {
    return this.findKey(function(value) {
      return is(value, searchValue);
    });
  },
  keySeq: function keySeq() {
    return this.toSeq().map(keyMapper).toIndexedSeq();
  },
  last: function last(notSetValue) {
    return this.toSeq().reverse().first(notSetValue);
  },
  lastKeyOf: function lastKeyOf(searchValue) {
    return this.toKeyedSeq().reverse().keyOf(searchValue);
  },
  max: function max2(comparator) {
    return maxFactory(this, comparator);
  },
  maxBy: function maxBy(mapper, comparator) {
    return maxFactory(this, comparator, mapper);
  },
  min: function min2(comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator
    );
  },
  minBy: function minBy(mapper, comparator) {
    return maxFactory(
      this,
      comparator ? neg(comparator) : defaultNegComparator,
      mapper
    );
  },
  rest: function rest() {
    return this.slice(1);
  },
  skip: function skip(amount) {
    return amount === 0 ? this : this.slice(Math.max(0, amount));
  },
  skipLast: function skipLast(amount) {
    return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
  },
  skipWhile: function skipWhile(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, true));
  },
  skipUntil: function skipUntil(predicate, context) {
    return this.skipWhile(not(predicate), context);
  },
  sortBy: function sortBy(mapper, comparator) {
    return reify(this, sortFactory(this, comparator, mapper));
  },
  take: function take(amount) {
    return this.slice(0, Math.max(0, amount));
  },
  takeLast: function takeLast(amount) {
    return this.slice(-Math.max(0, amount));
  },
  takeWhile: function takeWhile(predicate, context) {
    return reify(this, takeWhileFactory(this, predicate, context));
  },
  takeUntil: function takeUntil(predicate, context) {
    return this.takeWhile(not(predicate), context);
  },
  update: function update7(fn) {
    return fn(this);
  },
  valueSeq: function valueSeq() {
    return this.toIndexedSeq();
  },
  hashCode: function hashCode() {
    return this.__hash || (this.__hash = hashCollection(this));
  }
});
var CollectionPrototype = Collection.prototype;
CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
CollectionPrototype.toJSON = CollectionPrototype.toArray;
CollectionPrototype.__toStringMapper = quoteString;
CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
  return this.toString();
};
CollectionPrototype.chain = CollectionPrototype.flatMap;
CollectionPrototype.contains = CollectionPrototype.includes;
mixin(KeyedCollection, {
  flip: function flip() {
    return reify(this, flipFactory(this));
  },
  mapEntries: function mapEntries(mapper, context) {
    var this$1$1 = this;
    var iterations = 0;
    return reify(
      this,
      this.toSeq().map(function(v, k) {
        return mapper.call(context, [k, v], iterations++, this$1$1);
      }).fromEntrySeq()
    );
  },
  mapKeys: function mapKeys(mapper, context) {
    var this$1$1 = this;
    return reify(
      this,
      this.toSeq().flip().map(function(k, v) {
        return mapper.call(context, k, v, this$1$1);
      }).flip()
    );
  }
});
var KeyedCollectionPrototype = KeyedCollection.prototype;
KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
KeyedCollectionPrototype.toJSON = toObject;
KeyedCollectionPrototype.__toStringMapper = function(v, k) {
  return quoteString(k) + ": " + quoteString(v);
};
mixin(IndexedCollection, {
  toKeyedSeq: function toKeyedSeq2() {
    return new ToKeyedSequence(this, false);
  },
  filter: function filter3(predicate, context) {
    return reify(this, filterFactory(this, predicate, context, false));
  },
  findIndex: function findIndex(predicate, context) {
    var entry = this.findEntry(predicate, context);
    return entry ? entry[0] : -1;
  },
  indexOf: function indexOf(searchValue) {
    var key = this.keyOf(searchValue);
    return key === void 0 ? -1 : key;
  },
  lastIndexOf: function lastIndexOf(searchValue) {
    var key = this.lastKeyOf(searchValue);
    return key === void 0 ? -1 : key;
  },
  reverse: function reverse2() {
    return reify(this, reverseFactory(this, false));
  },
  slice: function slice2(begin, end) {
    return reify(this, sliceFactory(this, begin, end, false));
  },
  splice: function splice(index2, removeNum) {
    var numArgs = arguments.length;
    removeNum = Math.max(removeNum || 0, 0);
    if (numArgs === 0 || numArgs === 2 && !removeNum) {
      return this;
    }
    index2 = resolveBegin(index2, index2 < 0 ? this.count() : this.size);
    var spliced = this.slice(0, index2);
    return reify(
      this,
      numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index2 + removeNum))
    );
  },
  findLastIndex: function findLastIndex(predicate, context) {
    var entry = this.findLastEntry(predicate, context);
    return entry ? entry[0] : -1;
  },
  first: function first2(notSetValue) {
    return this.get(0, notSetValue);
  },
  flatten: function flatten3(depth) {
    return reify(this, flattenFactory(this, depth, false));
  },
  get: function get8(index2, notSetValue) {
    index2 = wrapIndex(this, index2);
    return index2 < 0 || this.size === Infinity || this.size !== void 0 && index2 > this.size ? notSetValue : this.find(function(_, key) {
      return key === index2;
    }, void 0, notSetValue);
  },
  has: function has3(index2) {
    index2 = wrapIndex(this, index2);
    return index2 >= 0 && (this.size !== void 0 ? this.size === Infinity || index2 < this.size : this.indexOf(index2) !== -1);
  },
  interpose: function interpose(separator) {
    return reify(this, interposeFactory(this, separator));
  },
  interleave: function interleave() {
    var collections = [this].concat(arrCopy(arguments));
    var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
    var interleaved = zipped.flatten(true);
    if (zipped.size) {
      interleaved.size = zipped.size * collections.length;
    }
    return reify(this, interleaved);
  },
  keySeq: function keySeq2() {
    return Range(0, this.size);
  },
  last: function last2(notSetValue) {
    return this.get(-1, notSetValue);
  },
  skipWhile: function skipWhile2(predicate, context) {
    return reify(this, skipWhileFactory(this, predicate, context, false));
  },
  zip: function zip() {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections));
  },
  zipAll: function zipAll() {
    var collections = [this].concat(arrCopy(arguments));
    return reify(this, zipWithFactory(this, defaultZipper, collections, true));
  },
  zipWith: function zipWith(zipper) {
    var collections = arrCopy(arguments);
    collections[0] = this;
    return reify(this, zipWithFactory(this, zipper, collections));
  }
});
var IndexedCollectionPrototype = IndexedCollection.prototype;
IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
mixin(SetCollection, {
  get: function get9(value, notSetValue) {
    return this.has(value) ? value : notSetValue;
  },
  includes: function includes2(value) {
    return this.has(value);
  },
  keySeq: function keySeq3() {
    return this.valueSeq();
  }
});
var SetCollectionPrototype = SetCollection.prototype;
SetCollectionPrototype.has = CollectionPrototype.includes;
SetCollectionPrototype.contains = SetCollectionPrototype.includes;
SetCollectionPrototype.keys = SetCollectionPrototype.values;
mixin(KeyedSeq, KeyedCollectionPrototype);
mixin(IndexedSeq, IndexedCollectionPrototype);
mixin(SetSeq, SetCollectionPrototype);
function reduce(collection, reducer, reduction, context, useFirst, reverse3) {
  assertNotInfinite(collection.size);
  collection.__iterate(function(v, k, c) {
    if (useFirst) {
      useFirst = false;
      reduction = v;
    } else {
      reduction = reducer.call(context, reduction, v, k, c);
    }
  }, reverse3);
  return reduction;
}
function keyMapper(v, k) {
  return k;
}
function entryMapper(v, k) {
  return [k, v];
}
function not(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
function neg(predicate) {
  return function() {
    return -predicate.apply(this, arguments);
  };
}
function defaultZipper() {
  return arrCopy(arguments);
}
function defaultNegComparator(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}
function hashCollection(collection) {
  if (collection.size === Infinity) {
    return 0;
  }
  var ordered = isOrdered(collection);
  var keyed = isKeyed(collection);
  var h2 = ordered ? 1 : 0;
  var size2 = collection.__iterate(
    keyed ? ordered ? function(v, k) {
      h2 = 31 * h2 + hashMerge(hash(v), hash(k)) | 0;
    } : function(v, k) {
      h2 = h2 + hashMerge(hash(v), hash(k)) | 0;
    } : ordered ? function(v) {
      h2 = 31 * h2 + hash(v) | 0;
    } : function(v) {
      h2 = h2 + hash(v) | 0;
    }
  );
  return murmurHashOfSize(size2, h2);
}
function murmurHashOfSize(size2, h2) {
  h2 = imul(h2, 3432918353);
  h2 = imul(h2 << 15 | h2 >>> -15, 461845907);
  h2 = imul(h2 << 13 | h2 >>> -13, 5);
  h2 = (h2 + 3864292196 | 0) ^ size2;
  h2 = imul(h2 ^ h2 >>> 16, 2246822507);
  h2 = imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = smi(h2 ^ h2 >>> 16);
  return h2;
}
function hashMerge(a, b) {
  return a ^ b + 2654435769 + (a << 6) + (a >> 2) | 0;
}
var OrderedSet = /* @__PURE__ */ function(Set2) {
  function OrderedSet2(value) {
    return value === void 0 || value === null ? emptyOrderedSet() : isOrderedSet(value) ? value : emptyOrderedSet().withMutations(function(set3) {
      var iter = SetCollection(value);
      assertNotInfinite(iter.size);
      iter.forEach(function(v) {
        return set3.add(v);
      });
    });
  }
  if (Set2)
    OrderedSet2.__proto__ = Set2;
  OrderedSet2.prototype = Object.create(Set2 && Set2.prototype);
  OrderedSet2.prototype.constructor = OrderedSet2;
  OrderedSet2.of = function of() {
    return this(arguments);
  };
  OrderedSet2.fromKeys = function fromKeys(value) {
    return this(KeyedCollection(value).keySeq());
  };
  OrderedSet2.prototype.toString = function toString5() {
    return this.__toString("OrderedSet {", "}");
  };
  return OrderedSet2;
}(Set$1);
OrderedSet.isOrderedSet = isOrderedSet;
var OrderedSetPrototype = OrderedSet.prototype;
OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;
OrderedSetPrototype.__empty = emptyOrderedSet;
OrderedSetPrototype.__make = makeOrderedSet;
function makeOrderedSet(map3, ownerID) {
  var set3 = Object.create(OrderedSetPrototype);
  set3.size = map3 ? map3.size : 0;
  set3._map = map3;
  set3.__ownerID = ownerID;
  return set3;
}
var EMPTY_ORDERED_SET;
function emptyOrderedSet() {
  return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}
function throwOnInvalidDefaultValues(defaultValues) {
  if (isRecord(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead."
    );
  }
  if (isImmutable(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead."
    );
  }
  if (defaultValues === null || typeof defaultValues !== "object") {
    throw new Error(
      "Can not call `Record` with a non-object as default values. Use a plain javascript object instead."
    );
  }
}
var Record = function Record2(defaultValues, name2) {
  var hasInitialized;
  throwOnInvalidDefaultValues(defaultValues);
  var RecordType = function Record3(values2) {
    var this$1$1 = this;
    if (values2 instanceof RecordType) {
      return values2;
    }
    if (!(this instanceof RecordType)) {
      return new RecordType(values2);
    }
    if (!hasInitialized) {
      hasInitialized = true;
      var keys2 = Object.keys(defaultValues);
      var indices = RecordTypePrototype._indices = {};
      RecordTypePrototype._name = name2;
      RecordTypePrototype._keys = keys2;
      RecordTypePrototype._defaultValues = defaultValues;
      for (var i2 = 0; i2 < keys2.length; i2++) {
        var propName = keys2[i2];
        indices[propName] = i2;
        if (RecordTypePrototype[propName]) {
          typeof console === "object" && console.warn && console.warn(
            "Cannot define " + recordName(this) + ' with property "' + propName + '" since that property name is part of the Record API.'
          );
        } else {
          setProp(RecordTypePrototype, propName);
        }
      }
    }
    this.__ownerID = void 0;
    this._values = List().withMutations(function(l) {
      l.setSize(this$1$1._keys.length);
      KeyedCollection(values2).forEach(function(v, k) {
        l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? void 0 : v);
      });
    });
    return this;
  };
  var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
  RecordTypePrototype.constructor = RecordType;
  if (name2) {
    RecordType.displayName = name2;
  }
  return RecordType;
};
Record.prototype.toString = function toString4() {
  var str = recordName(this) + " { ";
  var keys2 = this._keys;
  var k;
  for (var i2 = 0, l = keys2.length; i2 !== l; i2++) {
    k = keys2[i2];
    str += (i2 ? ", " : "") + k + ": " + quoteString(this.get(k));
  }
  return str + " }";
};
Record.prototype.equals = function equals2(other) {
  return this === other || isRecord(other) && recordSeq(this).equals(recordSeq(other));
};
Record.prototype.hashCode = function hashCode2() {
  return recordSeq(this).hashCode();
};
Record.prototype.has = function has4(k) {
  return this._indices.hasOwnProperty(k);
};
Record.prototype.get = function get10(k, notSetValue) {
  if (!this.has(k)) {
    return notSetValue;
  }
  var index2 = this._indices[k];
  var value = this._values.get(index2);
  return value === void 0 ? this._defaultValues[k] : value;
};
Record.prototype.set = function set2(k, v) {
  if (this.has(k)) {
    var newValues = this._values.set(
      this._indices[k],
      v === this._defaultValues[k] ? void 0 : v
    );
    if (newValues !== this._values && !this.__ownerID) {
      return makeRecord(this, newValues);
    }
  }
  return this;
};
Record.prototype.remove = function remove2(k) {
  return this.set(k);
};
Record.prototype.clear = function clear2() {
  var newValues = this._values.clear().setSize(this._keys.length);
  return this.__ownerID ? this : makeRecord(this, newValues);
};
Record.prototype.wasAltered = function wasAltered2() {
  return this._values.wasAltered();
};
Record.prototype.toSeq = function toSeq2() {
  return recordSeq(this);
};
Record.prototype.toJS = function toJS$12() {
  return toJS(this);
};
Record.prototype.entries = function entries2() {
  return this.__iterator(ITERATE_ENTRIES);
};
Record.prototype.__iterator = function __iterator(type, reverse3) {
  return recordSeq(this).__iterator(type, reverse3);
};
Record.prototype.__iterate = function __iterate(fn, reverse3) {
  return recordSeq(this).__iterate(fn, reverse3);
};
Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
  if (ownerID === this.__ownerID) {
    return this;
  }
  var newValues = this._values.__ensureOwner(ownerID);
  if (!ownerID) {
    this.__ownerID = ownerID;
    this._values = newValues;
    return this;
  }
  return makeRecord(this, newValues, ownerID);
};
Record.isRecord = isRecord;
Record.getDescriptiveName = recordName;
var RecordPrototype = Record.prototype;
RecordPrototype[IS_RECORD_SYMBOL] = true;
RecordPrototype[DELETE] = RecordPrototype.remove;
RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
RecordPrototype.getIn = getIn;
RecordPrototype.hasIn = CollectionPrototype.hasIn;
RecordPrototype.merge = merge$1;
RecordPrototype.mergeWith = mergeWith$1;
RecordPrototype.mergeIn = mergeIn;
RecordPrototype.mergeDeep = mergeDeep;
RecordPrototype.mergeDeepWith = mergeDeepWith;
RecordPrototype.mergeDeepIn = mergeDeepIn;
RecordPrototype.setIn = setIn;
RecordPrototype.update = update;
RecordPrototype.updateIn = updateIn;
RecordPrototype.withMutations = withMutations;
RecordPrototype.asMutable = asMutable;
RecordPrototype.asImmutable = asImmutable;
RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
RecordPrototype.inspect = RecordPrototype.toSource = function() {
  return this.toString();
};
function makeRecord(likeRecord, values2, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._values = values2;
  record.__ownerID = ownerID;
  return record;
}
function recordName(record) {
  return record.constructor.displayName || record.constructor.name || "Record";
}
function recordSeq(record) {
  return keyedSeqFromValue(record._keys.map(function(k) {
    return [k, record.get(k)];
  }));
}
function setProp(prototype, name2) {
  try {
    Object.defineProperty(prototype, name2, {
      get: function() {
        return this.get(name2);
      },
      set: function(value) {
        invariant(this.__ownerID, "Cannot set on an immutable record.");
        this.set(name2, value);
      }
    });
  } catch (error) {
  }
}
function splitToSet(s) {
  return Set$1(s.split(/\s+/).filter((x) => !!x));
}
const builtinConstants = Map$1([
  ["e", Math.E],
  ["pi", Math.PI]
]);
`
log
log1p
`.split("\n").filter((x) => !!x);
const builtinFunctions = Map$1([
  [
    "other",
    splitToSet(`
abs ceil fix floor gcd hypot invmod lcm log mod round sign
bitAnd bitNot bitOr bitXor leftShift rightArithShift rightLogShift
bellNumbers catalan composition stirlingS2
combinations combinationsWithRep factorial gamma kldivergence
lgamma multinomial permutations erf
`)
  ],
  [
    "trig",
    splitToSet(`
sin asin sinh asinh
cos acos cosh acosh
cot acot coth acoth
csc acsc csch acsch
sec sech
tan atan atan2 tanh atanh
`)
  ]
]);
function parseToEntry(s) {
  const node = parse$2(s);
  if (!isFunctionAssignmentNode(node)) {
    throw new Error("invalid function for shadowed builtin:" + s);
  }
  return [node.name, node];
}
Map$1(
  splitToSet(`
sec(x)=1/cos(x)
csc(x)=1/sin(x)
`).map(parseToEntry)
);
Map$1(
  splitToSet(`
add(x,y)=x+y
cbrt(x)=x^(1/3)
cube(x)=x^3
divide(x,y)=x/y
exp(x)=e^x
expm1(x)=e^x-1
log10(x)=log(x)/log(10)
log1p(x)=log(x+1)
log2(x)=log(x)/log(2)
multiply(a,b)=a*b
nthRoot(b,p)=b^(1/p)
pow(b,p)=b^p
sqrt(x)=x^.5
square(x)=x^2
subtract(a,b)=a-b
unaryMinus(x)=-x
unaryPlus(x)=x
`).map(parseToEntry)
);
splitToSet(`
arg conj im re
`);
splitToSet(`
dotDived dotMultiply dotPow norm nthRoots xgcd
and not or xor apply column concat count cross
ctranspose det diag diff dot eitgs expm filter
flatten forEach getMatrixDataType identity inv
kron map matrixfromColumns matrixFromFunction
matrixFromRows ones partitionSelect pinv
range reshape resize rotate rotationMatrix row
size sort sqrtm squeeze transpose zeros pickRandom
random randomInt compare compareNatural compareText
equal equalText larger largerEq smaller smallerEq unequal
setCartesian setDifference setDistinct setIntersect setIsSubset
setMultiplicity setPowerset setSize setSymDifference setUnion
cumsum mad max mean median min mode prod quantileSeq std
sum variance bin format hex oct print to clone hasNumericValue
isInteger isNaN isNegative isNumberic isPositive isPrime isZero
numeric typeOf
`);
const knownSymbols = builtinFunctions.valueSeq().reduce((r, v) => v.union(r), Set$1(builtinConstants.keySeq()));
const rules = [...simplify$1.rules, "sin(n1)/cos(n1) -> tan(n1)"];
function simplify(expr, exactFractions = true) {
  const node = isString$1(expr) ? parse$2(expr) : expr;
  const body = isAssignmentNode(node) ? getAssignmentBody(node) : node;
  const result = errorable(() => simplify$1(body, rules, {}, { exactFractions }));
  const simple = Either.on(result, {
    Left: () => node,
    Right: (value) => value
  });
  if (isAssignmentNode(node)) {
    return new AssignmentNode(new SymbolNode(node.name), simple);
  }
  return simple;
}
const Tree = (t, fn = () => []) => {
  return [t, fn(t).map((u) => Tree(u, fn))];
};
Tree.toObject = (tree, mapper, idx = 0, parent) => {
  const [t, children] = tree;
  return {
    ...mapper(t, idx, parent),
    children: children.map((u, uidx) => Tree.toObject(u, mapper, uidx, t))
  };
};
function parse$1(s) {
  return errorable(() => {
    const parsed = parse$2(s);
    if (isAssignmentNode(parsed)) {
      return parsed;
    } else if (isFunctionAssignmentNode(parsed)) {
      return parsed;
    }
    return simplify(parsed);
  });
}
function getDerivative(node, by, args = {}) {
  const expanded = inline(node, args);
  const derived = derivative(expanded, by);
  return derived;
}
function fixFunctionCalls(n, env) {
  return n.transform((node) => {
    if (isFunctionNode(node)) {
      const name2 = node.fn.name;
      if (node.args.length > 1) {
        return node;
      }
      const to2 = env[name2];
      if (!defined(to2) || isFunctionAssignmentNode(to2)) {
        return node;
      }
      return op("*", node.fn, node.args[0]);
    }
    if (isOperatorNode(node) && node.op === "*") {
      const [left, right] = node.args;
      if (isSymbolNode(left)) {
        const to2 = env[left.name];
        if (defined(to2) && isFunctionAssignmentNode(to2)) {
          return new FunctionNode(to2.name, [right]);
        }
      }
    }
    return node;
  });
}
function inline(node, env, depth = 0, maxDepth = 100) {
  if (depth > maxDepth) {
    return node;
  }
  if (isAssignmentNode(node)) {
    return node.value;
  }
  if (isFunctionNode(node)) {
    const name2 = node.fn.name;
    const to2 = env[name2];
    if (isFunctionAssignmentNode(to2)) {
      const subbed = subs(to2, node);
      return inline(subbed, env, depth + 1);
    }
  }
  return node.transform((n) => {
    if (isFunctionNode(n)) {
      const name2 = n.fn.name;
      const to2 = env[name2];
      if (isFunctionAssignmentNode(to2)) {
        const subbed = subs(to2, n);
        return inline(subbed, env, depth + 1);
      }
    }
    if (isSymbolNode(n)) {
      const name2 = n.name;
      const value = env[name2];
      const to2 = defined(value) && typeof value === "number" ? new ConstantNode(value) : value;
      if (defined(to2)) {
        const subbed = n.transform(
          (s) => isSymbolNode(s) && s.name === name2 ? to2 : s
        );
        return inline(subbed, env, depth + 1);
      }
    }
    return n;
  });
}
function getDependencies$1(expr, args = {}) {
  const node = typeof expr === "string" ? parse$2(expr) : expr;
  const expanded = inline(node, args);
  const body = isAssignmentNode(expanded) ? expanded.value : expanded;
  const params = isFunctionAssignmentNode(expanded) ? expanded.params : [];
  const filtered = body.filter(
    (node2) => isSymbolNode(node2) && !knownSymbols.has(node2.name) && !params.includes(node2.name)
  );
  const dependencies2 = unique(filtered.map((x) => {
    var _a;
    return (_a = x.name) != null ? _a : "";
  }));
  return dependencies2;
}
function subs(def2, call) {
  const ret = call.transform((n) => {
    if (isFunctionNode(n)) {
      if (n.fn.name === def2.name || def2.name === "#dummy#") {
        const env = Object.fromEntries(
          def2.params.map((p2, i2) => {
            var _a;
            return [p2, (_a = n.args[i2]) != null ? _a : new ConstantNode(0)];
          })
        );
        const ret2 = def2.expr.transform(
          (s) => isSymbolNode(s) && s.name in env ? env[s.name] : s
        );
        return ret2;
      }
      return n;
    } else {
      return n;
    }
  });
  return ret;
}
[0, 1, 2].map((x) => new ConstantNode(x));
const opMap = {
  "+": "add",
  "-": "subtract",
  "*": "multiply",
  "/": "divide",
  "^": "pow"
};
function op(op2, ...[left, right]) {
  const name2 = opMap[op2];
  return new OperatorNode(op2, name2, [left, right]);
}
function getChildren(n) {
  const children = [];
  n.forEach((c) => children.push(c));
  return children;
}
function nodeToTree(n) {
  return Tree(n, getChildren);
}
let nodeObjectCnt = 0;
function nodeToObject(n, childIdx, parent) {
  return {
    mathNode: n,
    id: (nodeObjectCnt++).toString(),
    type: n.type,
    label: nodeToLabel(n),
    parent,
    childIdx
  };
}
function nodeToObjectTree(n) {
  nodeObjectCnt = 0;
  return Tree.toObject(nodeToTree(n), nodeToObject);
}
function lx(is2, to2) {
  return tuple$1(is2, to2);
}
const labelExtractors = [
  lx(isArrayNode, () => "array"),
  lx(isAssignmentNode, (n) => n.name),
  lx(isSymbolNode, (n) => n.name),
  lx(isFunctionNode, () => "function call"),
  lx(isOperatorNode, (n) => n.op),
  lx(isConstantNode, (n) => n.value),
  lx(isParenthesisNode, () => "parenthesis")
];
function nodeToLabel(n) {
  for (const [is2, to2] of labelExtractors) {
    if (is2(n)) {
      return to2(n);
    }
  }
  return "Unknown type: " + n.type;
}
function getBody(n) {
  if (isAssignmentNode(n)) {
    return n.value;
  }
  if (isFunctionAssignmentNode(n)) {
    return n.expr;
  }
  return n;
}
function unJS(expr) {
  return expr.replace(/\*\*/g, "^").replace(/Math\.PI/g, "pi").replace(/Math\.E/g, "e").replace(/Math\./g, "").replace(
    /const ([^=]+)=(.+)=>(.+)/,
    (match, name2, args, body) => name2 + args + "=" + body
  ).replace(/const ([^=]+)=(.+)/, (match, name2, body) => name2 + "=" + body);
}
function parseNode(s, env) {
  return Errorable.map(parse$1(unJS(s)), (node) => fixFunctionCalls(node, env));
}
function getAssignmentBody(node) {
  return isAssignmentNode(node) ? node.value : node;
}
const getNodeName = (node) => isAssignmentNode(node) || isFunctionAssignmentNode(node) ? node.name : "anon: " + node.toString();
function defaultCall(fn, names) {
  const name2 = fn.name;
  const args = fn.params.map((x) => names.has(x) ? x : "__unused");
  const call = `${name2}(${args.join(",")})`;
  return parse$2(call);
}
function EnvType({
  onChange,
  tag: tag2,
  data,
  mathEnv,
  getMathValue,
  items,
  getDatum: getDatum2,
  getDependencies: getDependencies2,
  toTex,
  onDependencyChange
}) {
  const envType = {
    tag: tag2,
    onDependencyChange,
    getDatum: getDatum2,
    getDependencies: getDependencies2,
    has: (key) => data.has(key),
    get: (key) => data.get(key),
    set: (key, value, props = {}) => {
      const oldValue = data.get(key);
      data.set(key, value);
      mathEnv[key] = getMathValue(value);
      if (!items.has(key)) {
        items.set(key, {
          name: key,
          color: "#FFFF00",
          hidden: false,
          showGraph: false,
          showValue: false,
          description: void 0,
          typeTag: tag2,
          ...props
        });
      }
      const item = items.get(key);
      assert.defined(item);
      items.set(key, { ...item, ...props });
      envType.showGraph(key, item.showGraph);
      if (key != "time") {
        onChange(key, "update", value, oldValue);
      }
      return value;
    },
    delete: (key) => {
      const oldValue = data.get(key);
      data.delete(key);
      delete mathEnv[key];
      if (key != "time") {
        onChange(key, "delete", void 0, oldValue);
      }
    },
    toRecord: () => Object.fromEntries(data.entries()),
    showGraph: (key, showGraph) => {
      const item = items.get(key);
      assert.defined(item);
      item.showGraph = showGraph;
      if (key != "time") {
        onChange(key, "update");
      }
    },
    colorGraph: (key, color) => {
      const item = items.get(key);
      assert.defined(item);
      if (color === item.color) {
        return;
      }
      item.color = color;
      if (key != "time") {
        onChange(key, "update");
      }
    },
    getState: (key) => {
      const item = items.get(key);
      assert.defined(item);
      const value = data.get(key);
      const state2 = reactive({ ...item, value });
      watch(
        () => state2.value,
        (value2) => {
          envType.set(key, value2);
        }
      );
      watch(
        () => state2.showGraph,
        (show) => envType.showGraph(key, show)
      );
      watch(
        () => state2.color,
        (color) => envType.colorGraph(key, color)
      );
      return state2;
    },
    toTex: (key, v) => {
      const tex = toTex(v);
      const fullTex = tex.includes("=") ? tex : "\\mathrm{" + key + "}:=" + tex;
      return fullTex;
    }
  };
  return envType;
}
function Animation(fnName, from, to2, period) {
  return { fnName, from, to: to2, period };
}
Animation.toExprString = ({ fnName, from, to: to2, period }) => `${fnName}(time, ${from}, ${to2 - from}, ${period})`;
Animation.toMathNode = (animation) => parse$2(Animation.toExprString(animation));
Animation.toTex = (animation) => Animation.toMathNode(animation).toTex();
let nodes = reactive({});
function node2html(node) {
  return tex2html(node == null ? void 0 : node.toTex());
}
function tex2html(tex) {
  return tex2svg(tex).outerHTML;
}
function tex2svg(tex) {
  return MathJax.tex2svg(tex, {
    display: true,
    scale: 1,
    lineWidth: 5
  });
}
function addTexElement(elementId, tex) {
  nodes[elementId] = tex2svg(tex);
}
function isEnvExpr(x) {
  return defined(x) && hasPropIs(x, "expr", isString$1) && hasPropIs(x, "name", isString$1) && hasProp(x, "error") && hasProp(x, "node") && hasProp(x, "simpleNode") && hasPropIs(x, "isSimplified", isBoolean$1);
}
function EnvExpr(expr, env) {
  const parsed = parseNode(expr, (env == null ? void 0 : env.getMathEnv()) || {});
  const { node, error } = Errorable.on(parsed, {
    Left: (err) => ({ error: err.message }),
    Right: (node2) => ({ node: node2 })
  });
  if (defined(node)) {
    const name2 = getNodeName(node);
    const simpleNode = simplify(node, true);
    const isSimplified = node.toString() === simpleNode.toString();
    const vars = getDependencies$1(node);
    const tex = node.toTex();
    addTexElement("tex_" + name2, tex);
    return { expr, error, node, vars, name: name2, simpleNode, isSimplified };
  } else {
    const name2 = defined(node) ? getNodeName(node) : `ERROR: ${expr}`;
    return {
      expr,
      error,
      node,
      vars: [],
      name: name2,
      simpleNode: void 0,
      isSimplified: true
    };
  }
}
EnvExpr.toEvalFn = (name2, expr, exprEnv) => {
  if (defined(expr.node)) {
    const vars = flattenDependencyTree(exprEnv.getDependencies(name2));
    const free = vars.filter((x) => !x);
    const first3 = free.keySeq().first();
    return nodeToEvalFn(expr.node, exprEnv, first3 != null ? first3 : "__unused");
  }
  return () => 0;
};
{
  const formatError = (expr) => {
    var _a;
    return ((_a = expr.error) != null ? _a : "Error") + expr.expr;
  };
  EnvExpr.toExprString = (expr) => {
    var _a, _b;
    return defined(expr.error) ? formatError(expr) : (_b = (_a = expr.node) == null ? void 0 : _a.toString()) != null ? _b : expr.expr;
  };
}
{
  EnvExpr.toTex = (expr) => {
    var _a, _b;
    return (_b = (_a = expr.node) == null ? void 0 : _a.toTex()) != null ? _b : expr.expr;
  };
}
EnvExpr.getDependencies = (expr) => {
  if (defined(expr.node)) {
    return Set$1(getDependencies$1(expr.node));
  }
  return Set$1();
};
const emptyEnv = void 0;
const periodic = {
  name: "periodic",
  description: "periodic functions, useful for animationing variables",
  expression: {
    sinal: [
      EnvExpr(
        "sinal(x, min, height, width) = min + height/2 * (1 + sin(2 pi x / width) )",
        emptyEnv
      ),
      "sin wave"
    ],
    zigZag: [
      EnvExpr(
        "zigZag(x, min, height, width) = min + height * (acos(0.999 sin(2 pi x / width)) / pi)",
        emptyEnv
      ),
      "linear"
    ]
  },
  constant: {
    min: [1, ""],
    height: [5, ""],
    width: [5, ""]
  },
  animated: {}
};
function libraryToSaveRep(library) {
  let idx = 0;
  const constant = Map$1(library.constant).map(
    ([value, description], name2) => ({
      animated: void 0,
      expression: void 0,
      constant: value,
      ...defaultEnvItem("constant", name2, description),
      order: idx++
    })
  );
  const animated = Map$1(library.animated).map(
    ([value, description], name2) => ({
      constant: void 0,
      expression: void 0,
      animated: value,
      ...defaultEnvItem("animated", name2, description),
      order: idx++
    })
  );
  const expression = Map$1(library.expression).map(
    ([value, description], name2) => ({
      constant: void 0,
      animated: void 0,
      expression: value.expr,
      ...defaultEnvItem("expression", name2, description),
      order: idx++
    })
  );
  return expression.merge(animated, constant);
}
const libraryArr = [periodic];
const libraries = Map$1(
  libraryArr.map((library) => [library.name, library])
);
const libraryDescriptions = Map$1(
  libraryArr.map((library) => [library.name, library.description])
);
const librarySaveReps = Map$1(
  libraries.map((library) => libraryToSaveRep(library))
);
function Parametric(fnName, xName, yName) {
  return { fnName, xName, yName };
}
Parametric.toExprString = ({ fnName, xName, yName }) => `${fnName}(t) = [ ${xName}(t), ${yName}(t) ]`;
Parametric.toMathNode = (parametric) => parse$2(Parametric.toExprString(parametric));
Parametric.toTex = (parametric) => Parametric.toMathNode(parametric).toTex();
const zero = () => 0;
const magnitude = (x) => Array.isArray(x) ? Math.sqrt(x[0] ** 2 + x[1] ** 2) : x;
Parametric.toEvalFn = (_name, expr, exprEnv) => {
  var _a, _b, _c, _d;
  const fnX = (_b = (_a = exprEnv.getDatum(expr.xName)) == null ? void 0 : _a.evalFn) != null ? _b : zero;
  const fnY = (_d = (_c = exprEnv.getDatum(expr.yName)) == null ? void 0 : _c.evalFn) != null ? _d : zero;
  return (x) => [magnitude(fnX(x)), magnitude(fnY(x))];
};
function defaultEnvItem(typeTag, name2, description = "") {
  return {
    name: name2,
    color: `#00FFFF`,
    hidden: false,
    showGraph: false,
    showValue: false,
    description,
    typeTag
  };
}
const datumGetter = (item, evalFn, options = { nSamples: 100 }) => ({
  evalFn,
  show: item.showGraph,
  color: item.color,
  nSamples: options.nSamples
});
const mkExprEnv = () => {
  const items = reactive(/* @__PURE__ */ new Map());
  const mathEnv = {};
  const constants = /* @__PURE__ */ new Map();
  const animations = /* @__PURE__ */ new Map();
  const expressions = /* @__PURE__ */ new Map();
  const parametrics = /* @__PURE__ */ new Map();
  const order = reactive([]);
  let active = false;
  function onChange(name2, changeType = "update", newValue, oldValue) {
    if (!active) {
      return;
    }
    exprEnv.dirty = true;
    exprEnv.order.forEach((valueName) => {
      const type = exprEnv.getType(valueName);
      const value = exprEnv[type].get(valueName);
      if (defined(value)) {
        exprEnv[type].onDependencyChange(
          value,
          name2,
          newValue,
          oldValue
        );
      }
    });
    if (changeType === "delete") {
      const idx = order.indexOf(name2);
      if (idx >= 0) {
        order.splice(idx, 1);
      }
    } else {
      if (!order.includes(name2)) {
        order.push(name2);
      }
    }
  }
  const exprEnv = reactive({
    dirty: false,
    constant: EnvType({
      onChange,
      tag: "constant",
      data: constants,
      mathEnv,
      getMathValue: (x) => x,
      items,
      getDatum: (v, item) => datumGetter(item, () => v, { nSamples: 2 }),
      getDependencies: () => Set$1(),
      toTex: (v) => v.toString(),
      onDependencyChange: () => {
      }
    }),
    animated: EnvType({
      onChange,
      tag: "animated",
      data: animations,
      mathEnv,
      getMathValue: (x) => Animation.toMathNode(x),
      items,
      getDatum: (v, item) => {
        var _a;
        if (!defined(exprEnv.expression.get(v.fnName))) {
          const fn = (_a = libraries.get("periodic")) == null ? void 0 : _a.expression[v.fnName][0];
          assert(defined(fn), "missing periodic function: " + v.fnName);
          exprEnv.expression.set(v.fnName, fn, { hidden: true });
        }
        return datumGetter(
          item,
          nodeToEvalFn(Animation.toMathNode(v), exprEnv)
        );
      },
      getDependencies: () => Set$1(["time"]),
      toTex: Animation.toTex,
      onDependencyChange: () => {
      }
    }),
    expression: EnvType({
      onChange,
      tag: "expression",
      data: expressions,
      mathEnv,
      getMathValue: (v) => {
        var _a;
        return (_a = v.node) != null ? _a : 0;
      },
      items,
      getDatum: (v, item) => datumGetter(item, EnvExpr.toEvalFn(item.name, v, exprEnv)),
      getDependencies: EnvExpr.getDependencies,
      toTex: EnvExpr.toTex,
      onDependencyChange: (expr, dependencyName, newDependencyValue, oldDependencyValue) => {
        var _a, _b;
        if (expr.vars.includes(dependencyName)) {
          const showGraph = (_b = (_a = exprEnv.items.get(expr.name)) == null ? void 0 : _a.showGraph) != null ? _b : false;
          exprEnv.expression.showGraph(expr.name, showGraph);
          if (isEnvExpr(newDependencyValue) && isEnvExpr(oldDependencyValue) && (isAssignmentNode(newDependencyValue.node) && isFunctionAssignmentNode(oldDependencyValue.node) || isAssignmentNode(oldDependencyValue.node) && isFunctionAssignmentNode(newDependencyValue.node))) {
            exprEnv.expression.set(expr.name, EnvExpr(expr.expr, exprEnv));
          }
        }
      }
    }),
    parametric: EnvType({
      onChange,
      tag: "parametric",
      data: parametrics,
      mathEnv,
      getMathValue: (_v) => 0,
      items,
      getDatum: (v, item) => datumGetter(item, Parametric.toEvalFn(item.name, v, exprEnv)),
      getDependencies: (v) => Set$1(
        exprEnv.getDependencies(v.xName).merge(exprEnv.getDependencies(v.yName)).keySeq()
      ),
      toTex: Parametric.toTex,
      onDependencyChange: (_expr, _dependencyName, _newDependencyValue, _oldDependencyValue) => {
      }
    }),
    items,
    getMathEnv: (includeConstants = false) => includeConstants ? { ...mathEnv, ...builtinConstants.toObject() } : mathEnv,
    getDependencies: (key) => getDependencies(key, exprEnv, items),
    getDatum: (key) => getDatum(key, exprEnv, items),
    order,
    getType: (key) => {
      var _a, _b;
      return (_b = (_a = items.get(key)) == null ? void 0 : _a.typeTag) != null ? _b : "constant";
    },
    activate: () => {
      active = true;
    }
  });
  return exprEnv;
};
function getDatum(key, env, items) {
  if (!items.has(key)) {
    return void 0;
  }
  const item = items.get(key);
  const value = env[item.typeTag].get(key);
  const Ivalue = value;
  const datum = env[item.typeTag].getDatum(Ivalue, item);
  return datum;
}
function getDependencies(key, env, items) {
  if (!items.has(key)) {
    return Map$1();
  }
  const item = items.get(key);
  const value = env[item.typeTag].get(key);
  const Ivalue = value;
  const local = env[item.typeTag].getDependencies(Ivalue);
  const deps = local.toMap().map((name2) => ({
    bound: items.has(name2),
    transitive: items.has(name2) ? getDependencies(name2, env, items) : Map$1()
  }));
  return deps;
}
const tuple = (a, b) => [a, b];
function flattenDependencyTree(tree) {
  function go(tree2, acc) {
    const x = tree2.toArray().map(([name2, obj]) => tuple(name2, obj.bound));
    acc.push(...x);
    tree2.forEach(({ transitive }) => go(transitive, acc));
    return acc;
  }
  return Map$1(go(tree, []));
}
const nodeToEvalFn = (node, env, freeVar = "__unused") => {
  const body = isFunctionAssignmentNode(node) ? defaultCall(node, new Set(env.order)) : getAssignmentBody(node);
  const mathEnv = { ...env.getMathEnv() };
  delete mathEnv["time"];
  const inlined = inline(body, mathEnv);
  const fn = inlined.compile().evaluate;
  const ret = (x) => {
    try {
      const result = fn({ [freeVar]: x, ...env.getMathEnv() });
      if (!isNumber(result)) {
        return 0;
      } else {
        return result;
      }
    } catch (e2) {
      return 0;
    }
  };
  return ret;
};
const SaveRep = {
  savable: {
    toSave: (rep) => JSON.stringify(rep.toJSON()),
    fromSave: (rep) => errorable(() => parse(rep)),
    saveKey: "ExprEnv"
  }
};
function toSaveRep(env) {
  const saveRep = Map$1(env.items).map((item, name2) => {
    var _a;
    return {
      ...item,
      constant: env.constant.get(name2),
      animated: env.animated.get(name2),
      expression: (_a = env.expression.get(name2)) == null ? void 0 : _a.expr,
      order: env.order.indexOf(name2),
      parametric: (() => {
        const p2 = env.parametric.get(name2);
        return defined(p2) ? [p2.xName, p2.yName] : void 0;
      })()
    };
  });
  return saveRep;
}
function fromSaveRep(saveRep) {
  const env = reactive(mkExprEnv());
  const orderMap = /* @__PURE__ */ new Map();
  saveRep.forEach((item, name2) => {
    if (defined(item.constant)) {
      env.constant.set(name2, item.constant);
      env.constant.colorGraph(name2, item.color);
      env.constant.showGraph(name2, item.showGraph);
    }
    if (defined(item.animated)) {
      env.animated.set(name2, item.animated);
      env.animated.colorGraph(name2, item.color);
      env.animated.showGraph(name2, item.showGraph);
    }
    if (defined(item.parametric)) {
      env.parametric.set(
        name2,
        Parametric(name2, item.parametric[0], item.parametric[1])
      );
      env.parametric.colorGraph(name2, item.color);
      env.parametric.showGraph(name2, item.showGraph);
    }
    if (defined(item.expression)) {
      env.expression.set(name2, EnvExpr(item.expression, env));
      env.expression.colorGraph(name2, item.color);
      env.expression.showGraph(name2, item.showGraph);
    }
    const order = defined(item.order) && isNumber$1(item.order) ? item.order : 0;
    orderMap.set(name2, order);
  });
  env.order.splice(0, env.order.length);
  Map$1(orderMap).sort().forEach((_, name2) => env.order.push(name2));
  env.activate();
  return env;
}
function isParametricRep(x) {
  return defined(x) && Array.isArray(x) && x.length === 2 && isString$1(x[0]) && isString$1(x[1]);
}
function parse(s) {
  const obj = JSON.parse(s);
  assert.is(obj, isObject$2);
  const unknownMap = Map$1(obj);
  const map3 = unknownMap.map((value) => {
    assert.propMayBe(value, "constant", isNumber$1);
    assert.propMayBe(value, "animated", isAnimation);
    assert.propMayBe(value, "parametric", isParametricRep);
    assert.propMayBe(value, "expression", isString$1);
    assert.propMayBe(value, "order", isNumber$1);
    assert.is(value, isEnvItem);
    return value;
  });
  return map3;
}
const isAnimation = (x) => {
  if (defined(x) && isObject$2(x) && hasPropIs(x, "from", isNumber$1) && hasPropIs(x, "to", isNumber$1) && hasPropIs(x, "period", isNumber$1) && hasPropIs(x, "fnName", isString$1)) {
    return true;
  }
  return false;
};
const isEnvItem = (x) => {
  assert.is(x, isObject$2);
  x["description"] || (x["description"] = "");
  if (hasPropIs(x, "name", isString$1) && hasPropIs(x, "color", isColor) && hasPropIs(x, "hidden", isBoolean$1) && hasPropIs(x, "showGraph", isBoolean$1) && hasPropIs(x, "showValue", isBoolean$1) && hasPropIs(x, "description", isString$1) && hasPropIs(x, "typeTag", isEnvTypeTag)) {
    return true;
  }
  return false;
};
const isColor = (x) => isString$1(x) && x.startsWith("#");
const isEnvTypeTag = (x) => isString$1(x) && (x === "constant" || x === "animated" || x === "expression" || x === "parametric");
let StorageKey = "ig-calc-saves";
function setStorageKey(key) {
  StorageKey = `ig-calc-saves[${key}]`;
  return Errorable.handle(
    readSaveMetadata(),
    (error) => {
      throw error;
    },
    emptySaveMetaData()
  );
}
const saveTypes = ["local", "shared", "library"];
const SaveId = (type, name2) => ({
  type,
  name: name2
});
SaveId.eq = (a, b) => a.name === b.name && a.type === b.type;
SaveId.toKey = (a) => a.type + "" + a.name;
SaveId.toString = (a) => a.type + "." + a.name;
SaveId.fromKey = (key) => SaveId(...key.split(""));
const DefaultSaveId = SaveId("local", "Default");
const EmptySaveId = SaveId("local", "Empty");
const defaultSaveMetadata = {
  local: {
    Empty: "A fresh start",
    Default: "Loaded on page refresh"
  },
  shared: {},
  library: {}
};
function isSaveType(x) {
  return isString$1(x) && ["local", "shared", "library"].includes(x);
}
function getSaveEntry(save2, saveable) {
  if (!defined(save2)) {
    return Left(new Error("corrupt save for entry " + saveable.saveKey));
  }
  return saveable.fromSave(save2[saveable.saveKey]);
}
function hasSaveEntry(save2, savable) {
  if (!hasPropIs(save2, savable.saveKey, isString$1)) {
    return void 0;
  }
  return save2;
}
function parseSaveMetaData(s) {
  return errorable(() => {
    const obj = JSON.parse(s);
    assert.propIs(
      obj,
      "local",
      (x) => typeof x === "object"
    );
    assert.propIs(
      obj,
      "shared",
      (x) => typeof x === "object"
    );
    assert.propIs(
      obj,
      "library",
      (x) => typeof x === "object"
    );
    for (const type of saveTypes) {
      const t = obj[type];
      assert.is(t, isObject$2);
      for (const name2 in t) {
        assert.is(t[name2], isString$1);
      }
    }
    return obj;
  });
}
const emptySaveMetaData = () => ({
  local: {},
  library: {},
  shared: {}
});
function readSaveMetadata() {
  return errorable(() => {
    const str = window.localStorage.getItem(StorageKey);
    if (!str) {
      writeSaveMetadata(defaultSaveMetadata);
      return defaultSaveMetadata;
    }
    return Errorable.raise(parseSaveMetaData(str)).value;
  });
}
function writeSaveMetadata(metadata) {
  window.localStorage.setItem(StorageKey, JSON.stringify(metadata));
}
function writeSave(meta, id, description, saveStr) {
  meta[id.type][id.name] = description;
  writeSaveMetadata(meta);
  window.localStorage.setItem(
    StorageKey + "/" + id.type + "/" + id.name,
    saveStr
  );
}
function readSave(id) {
  return errorable(() => {
    if (id.name === "Empty") {
      return '{"saveName":"Default","saveDescription":"Loaded on page refresh","ExprEnv":"{}","ExpressionUiState":"{}"}';
    }
    const saveStr = window.localStorage.getItem(
      StorageKey + "/" + id.type + "/" + id.name
    );
    if (!defined(saveStr)) {
      if (id.name === "Default") {
        return '{"saveName":"Default","saveDescription":"Loaded on page refresh","ExprEnv":"{}","ExpressionUiState":"{}"}';
      }
      throw new Error("Save " + id.name + " not found");
    }
    return saveStr;
  });
}
function MMap(fn, un) {
  return {
    of: (kv) => {
      const map3 = reactive(/* @__PURE__ */ new Map());
      const mmap = {
        has: (k) => map3.has(fn(k)),
        get: (k) => map3.get(fn(k)),
        set: (k, v) => {
          map3.set(fn(k), v);
          return v;
        },
        mappedKeys: () => mapIter(map3.keys(), un),
        values: () => map3.values()
      };
      if (defined(kv)) {
        mmap.set(kv[0], kv[1]);
      }
      return mmap;
    }
  };
}
const cursorState = reactive({
  show: false,
  top: 500,
  left: 500,
  oldTop: 500,
  oldLeft: 500,
  animate: false
});
function scrollToElement(selected) {
  if (!defined(selected)) {
    return;
  }
  const [el] = selected;
  el.scrollIntoView({ block: "nearest", behavior: "smooth" });
}
function goToElement(selected) {
  if (!defined(selected)) {
    return;
  }
  const [el, rect] = selected;
  let bounds = rect;
  if (window.innerHeight - bounds.top < 80) {
    window.scrollBy(0, 160);
    bounds = el.getBoundingClientRect();
  }
  moveTo((bounds.top + bounds.bottom) / 2, (bounds.left + bounds.right) / 2);
  bounds = el.getBoundingClientRect();
  if (window.innerHeight - bounds.top < 80) {
    window.scrollBy(0, 160);
    cursorState.top += 160;
    cursorState.oldTop += 160;
    bounds = el.getBoundingClientRect();
    moveTo((bounds.top + bounds.bottom) / 2, (bounds.left + bounds.right) / 2);
  }
}
function moveTo(top, left) {
  cursorState.oldLeft = cursorState.left;
  cursorState.oldTop = cursorState.top;
  cursorState.left = left;
  cursorState.top = top;
  cursorState.animate = false;
  cursorState.show = false;
  void nextTick(() => {
    cursorState.show = true;
    cursorState.animate = true;
  });
}
const actionNames = [
  "wait",
  "alert",
  "showCursor",
  "select",
  "goto",
  "scrollTo",
  "gotoNoScroll",
  "click",
  "set",
  "append",
  "type"
];
function isAction(x) {
  return Array.isArray(x) && x.length === 2 && actionNames.includes(x[0]) && hasProp(x[1], "delay") && hasProp(x[1], "args");
}
let selectedElement = void 0;
const actionHandlers = {
  wait: () => {
  },
  alert,
  showCursor: () => {
    cursorState.show = true;
  },
  select: ({ elementId }) => {
    var _a;
    if (defined(elementId)) {
      selectedElement = (_a = getVisibleElement(elementId)) != null ? _a : void 0;
    }
  },
  scrollTo: ({ elementId }) => {
    actionHandlers.select({ elementId });
    scrollToElement(selectedElement);
  },
  gotoNoScroll: ({ elementId }) => {
    actionHandlers.select({ elementId });
    goToElement(selectedElement);
  },
  goto: ({ elementId }) => {
    prependAction("gotoNoScroll", { delay: 0.3, args: { elementId } });
    prependAction("scrollTo", { delay: 0, args: { elementId } });
  },
  click: ({ elementId }) => {
    actionHandlers.select({ elementId });
    if (!defined(selectedElement)) {
      return;
    }
    const [el] = selectedElement;
    el.classList.add("fakeActive");
    setTimeout(() => el.classList.remove("fakeActive"), 500);
    el.click();
  },
  set: ({ value, elementId }) => {
    actionHandlers.select({ elementId });
    if (selectedElement instanceof HTMLInputElement) {
      selectedElement.value = value != null ? value : "";
      selectedElement.dispatchEvent(new Event("input", { bubbles: true }));
      selectedElement.dispatchEvent(new Event("change", { bubbles: true }));
    }
  },
  append: ({ value, elementId }) => {
    actionHandlers.select({ elementId });
    if (defined(selectedElement) && selectedElement[0] instanceof HTMLInputElement) {
      const el = selectedElement[0];
      el.value += value;
      el.dispatchEvent(new Event("input", { bubbles: true }));
    }
  },
  type: ({ value, elementId }) => {
    actionHandlers.select({ elementId });
    if (defined(selectedElement) && selectedElement[0] instanceof HTMLInputElement) {
      actions == null ? void 0 : actions.unshift(
        ...(value != null ? value : "").split("").map(
          (char) => mkAction("append", { delay: 0.2, args: { value: char, elementId } })
        )
      );
    }
  }
};
function mkAction(name2, { delay, args }) {
  return [name2, { delay, args }];
}
function addAction(name2, { delay, args }) {
  actions == null ? void 0 : actions.push([name2, { delay, args }]);
}
function sendActions(channel, actions2) {
  channel.postMessage(actions2);
}
function sendAction(channel, name2, { delay, args }) {
  channel.postMessage({ action: [name2, { delay, args }] });
}
function prependAction(name2, { delay, args }) {
  actions == null ? void 0 : actions.unshift([name2, { delay, args }]);
}
function runAction([name2, { args }]) {
  if (name2 in actionHandlers) {
    const fn = actionHandlers[name2];
    fn(args);
  } else {
    alert(`unknown action ${name2}`);
  }
}
const actions = [];
const bodyEl = document.getElementsByTagName("body")[0];
let previousElapsedTime = 0;
let nextTime = 0.01;
let holdPointerEvents = void 0;
function tick(elapsedTime) {
  const deltaSeconds = (elapsedTime - previousElapsedTime) / 1e3;
  if (deltaSeconds < nextTime) {
    return;
  }
  previousElapsedTime = elapsedTime;
  if (defined(actions) && actions.length > 0) {
    if (!defined(holdPointerEvents)) {
      holdPointerEvents = bodyEl.style.pointerEvents;
      bodyEl.style.pointerEvents = "none";
      bodyEl.style.overflow = "hidden";
    }
    if (actions.length > 0 && actions[0][1].delay > 0) {
      nextTime = actions[0][1].delay;
      actions[0][1].delay = 0;
      return;
    } else {
      nextTime = 0.5;
    }
    const action = actions.shift();
    runAction(action);
  } else if (defined(holdPointerEvents)) {
    bodyEl.style.pointerEvents = holdPointerEvents;
    holdPointerEvents = void 0;
    bodyEl.style.overflow = "";
  }
}
function getVisibleElement(id) {
  return Array.from(document.querySelectorAll("#" + id.replaceAll(":", "\\:"))).map((x) => tuple$1(x, x.getBoundingClientRect())).filter(
    ([el, rect]) => el instanceof HTMLElement && rect.top != rect.bottom && rect.left != rect.right
  )[0];
}
function createDocChannel() {
  return new BroadcastChannel("docChannel");
}
function initReceiver({
  setTopic
}) {
  const docChannel = createDocChannel();
  docChannel.onmessage = (event) => {
    const data = event.data;
    handleMessage(data, setTopic);
  };
}
function handleMessage(data, setTopic) {
  if (Array.isArray(data)) {
    data.forEach((x) => handleMessage(x, setTopic));
  } else {
    if (hasPropIs(data, "topic", isString$1)) {
      setTopic(data.topic);
      addAction("goto", { delay: 1, args: { elementId: "docTopic" } });
    }
    if (hasPropIs(data, "action", isAction)) {
      actions.push(data.action);
    }
  }
}
function Interval(...args) {
  return { lo: args[0], hi: args[1] };
}
Interval.span = (i2) => i2.hi - i2.lo;
Interval.offset = (i2, by) => ({
  lo: i2.lo + by,
  hi: i2.hi + by
});
Interval.update = (i2, vals) => {
  [i2.lo, i2.hi] = vals;
  return i2;
};
Interval.clampNumber = (i2, n) => Math.max(i2.lo, Math.min(n, i2.hi));
Interval.midpoint = (i2) => i2.lo + (i2.hi - i2.lo) / 2;
Interval.scale = (i2, by) => {
  const mid = Interval.midpoint(i2);
  const r = by * Interval.span(i2) / 2;
  return Interval(mid - r, mid + r);
};
Interval.at = (i2, pct) => i2.lo + Interval.span(i2) * pct;
Interval.pct = (i2, at) => (at - i2.lo) / Interval.span(i2);
Interval.scaleBetween = (a, b) => Interval.span(a) / Interval.span(b);
function Rect(...args) {
  return { x: Interval(args[0], args[1]), y: Interval(args[2], args[3]) };
}
Rect.map = (r, fx, fy) => [
  fx(r.x),
  fy(r.y)
];
function overI(method) {
  const f = Interval[method];
  return (r) => Rect.map(r, f, f);
}
function appI(method) {
  const f = Interval[method];
  return (r, xArg, yArg) => ({
    x: f(r.x, xArg),
    y: f(r.y, yArg)
  });
}
Rect.span = overI("span");
Rect.update = (r, vals) => {
  [r.x.lo, r.x.hi, r.y.lo, r.y.hi] = vals;
  return r;
};
Rect.midpoint = overI("midpoint");
Rect.toTuple = (r) => [
  r.x.lo,
  r.x.hi,
  r.y.lo,
  r.y.hi
];
Rect.offset = appI("offset");
Rect.scale = appI("scale");
Rect.at = overI("at");
Rect.pct = overI("pct");
Rect.scaleBetween = (a, b) => [
  Interval.scaleBetween(a.x, b.x),
  Interval.scaleBetween(a.y, b.y)
];
function panGraph(graph, deltaX, deltaY) {
  graph.x = Interval.offset(
    graph.x,
    -1 * (deltaX * Interval.span(graph.x)) / graph.width
  );
  graph.y = Interval.offset(
    graph.y,
    deltaY * Interval.span(graph.y) / graph.height
  );
}
const Renderer = (viewCanvas, graph) => {
  const rect = Rect(0, 1e3, 0, 1e3);
  const srcCanvas = new OffscreenCanvas(rect.x.hi, rect.y.hi);
  const srcCtx = srcCanvas.getContext("2d", { alpha: false });
  const imageData = srcCtx.getImageData(
    0,
    0,
    srcCanvas.width,
    srcCanvas.height
  );
  const data = new DataView(imageData.data.buffer);
  const renderer2 = {
    viewCanvas,
    rect,
    srcCanvas,
    srcCtx,
    imageData,
    data,
    graph,
    dx: 0,
    dy: 0,
    scale: Rect.scaleBetween(graph, rect),
    viewScale: Rect.scaleBetween(
      rect,
      Rect(0, viewCanvas.width, 0, viewCanvas.height)
    ),
    resize: (newGraph = renderer2.graph) => {
      renderer2.graph = newGraph;
      renderer2.scale = Rect.scaleBetween(renderer2.graph, renderer2.rect);
      renderer2.viewScale = Rect.scaleBetween(
        rect,
        Rect(0, viewCanvas.width, 0, viewCanvas.height)
      );
      renderer2.fullRender();
    },
    onTick: () => {
      if (!defined(renderer2.srcCanvas)) {
        return;
      }
      const px = Math.floor(renderer2.dx * renderer2.viewScale[0]);
      const py = Math.floor(renderer2.dy * renderer2.viewScale[1]);
      if (px !== 0 || py !== 0) {
        const width = rect.x.hi * 4;
        const offset = px * -4;
        for (let y = 0; y <= rect.y.hi; y++) {
          const start2 = y * width;
          const end = start2 + width - 1;
          if (offset >= 0) {
            renderer2.imageData.data.copyWithin(
              start2,
              Math.max(start2 + offset, start2),
              Math.min(end, end - offset)
            );
          } else {
            renderer2.imageData.data.copyWithin(
              Math.max(start2 - offset, start2),
              start2,
              Math.min(end, end + offset)
            );
          }
        }
        srcCtx.putImageData(renderer2.imageData, 0, 0);
        const usedX = px / renderer2.viewScale[0];
        const usedY = py / renderer2.viewScale[1];
        renderer2.dx -= usedX;
        renderer2.dy -= usedY;
        panGraph(renderer2.graph, usedX, usedY);
        renderer2.renderCanvas(px * 2, 0);
        renderer2.drawCanvas();
      }
    },
    drawCanvas: () => {
      const ctx = renderer2.viewCanvas.getContext("2d", { alpha: false });
      ctx.drawImage(
        srcCanvas,
        0,
        0,
        viewCanvas.width,
        viewCanvas.height
      );
    },
    fullRender: () => renderer2.renderCanvas(0, srcCanvas.height),
    renderCanvas: (px = 0, py = 0) => {
      return;
    }
  };
  renderer2.resize();
  renderer2.fullRender();
  renderer2.drawCanvas();
  return renderer2;
};
let renderer = void 0;
function setRenderer(r) {
  renderer = r;
  return r;
}
const state = reactive({
  currentSave: DefaultSaveId,
  currentEnv: mkExprEnv(),
  copying: void 0,
  newName: void 0,
  newDescr: void 0,
  deletedSaves: emptySaveMetaData(),
  shareString: "",
  showDescriptions: false,
  showDeletedSaves: false,
  hasDeletedSaves: false,
  error: "",
  saveMetaData: Errorable.handle(
    readSaveMetadata(),
    (error) => state.error = error.message,
    emptySaveMetaData()
  ),
  tickTime: 0.1,
  runTimer: true
});
const rickRoll = reactive({ show: false, word: "" });
const environments = MMap(SaveId.toKey, SaveId.fromKey).of([
  EmptySaveId,
  mkExprEnv()
]);
function purgeDeletedSave(id) {
  delete state.deletedSaves[id.type][id.name];
  checkForDeletedSaves();
}
function baseUrl() {
  return window.location.protocol + "//" + window.location.host + window.location.pathname;
}
function share(id) {
  var _a;
  const description = (_a = state.saveMetaData[id.type][id.name]) != null ? _a : "No Description";
  const save2 = Errorable.raise(readSave(id)).value;
  const shareStr = JSON.stringify({ name: id.name, description, save: save2 });
  const compressed = lzString.exports.compressToEncodedURIComponent(shareStr);
  state.shareString = baseUrl() + "?shared=" + compressed;
  void navigator.clipboard.writeText(state.shareString);
  return compressed;
}
function getSerializedSave(env) {
  const saveRep = toSaveRep(env);
  const serialized = SaveRep.savable.toSave(saveRep);
  const saveObj = { [SaveRep.savable.saveKey]: serialized };
  return JSON.stringify(saveObj);
}
function save(id, description) {
  writeSave(
    state.saveMetaData,
    id,
    description != null ? description : "",
    getSerializedSave(environments.get(id))
  );
  environments.get(id).dirty = false;
}
function load(id) {
  if (!environments.has(id)) {
    const loaded = loadSave(id);
    assert.defined(loaded);
    environments.set(id, loaded);
    loaded.dirty = false;
  }
  return environments.get(id);
}
function open(id) {
  state.currentSave = EmptySaveId;
  state.currentEnv = environments.get(EmptySaveId);
  nextTick(() => {
    const env = load(id);
    env.constant.set("time", 0);
    assert.defined(env);
    state.currentEnv = env;
    state.currentSave = id;
  });
}
function loadSave(id) {
  if (id.type === "library") {
    const saveRep = librarySaveReps.get(id.name);
    assert(defined(saveRep), "Missing SaveRep for library: " + id.name);
    const env = fromSaveRep(saveRep);
    environments.set(id, env);
    return env;
  } else {
    return Either.on(readSave(id), {
      Left: (x) => {
        state.error = x.message;
        return void 0;
      },
      Right: (x) => {
        const obj = JSON.parse(x);
        const saveRep = getSaveEntry(
          hasSaveEntry(obj, SaveRep.savable),
          SaveRep.savable
        );
        if (isLeft(saveRep)) {
          throw saveRep.value;
        }
        const env = fromSaveRep(saveRep.value);
        environments.set(id, env);
        return env;
      }
    });
  }
}
function saveList(type) {
  if (type === "library") {
    return libraryDescriptions.mapEntries(([name2, description]) => [
      SaveId("library", name2),
      {
        description,
        deleted: false
      }
    ]);
  }
  const saveMap = Map$1(state.saveMetaData[type]).map(
    (v) => [v, false]
  );
  const map3 = state.showDeletedSaves ? Map$1(state.deletedSaves[type]).map((v) => [v, true]).concat(saveMap) : saveMap;
  const ret = map3.sortBy((_, k) => {
    var _a;
    return (_a = { Empty: "", Default: " " }[k]) != null ? _a : k;
  }).mapEntries(([k, [description, deleted]]) => [
    SaveId(type, k),
    {
      description,
      deleted
    }
  ]);
  return ret;
}
function copy(id) {
  var _a;
  state.copying = id;
  if (id.name === "Empty" || id.name === "Default") {
    state.newName = "name";
    state.newDescr = "";
  } else {
    state.newName = "Copy of " + id.name;
    state.newDescr = (_a = state.saveMetaData[id.type][id.name]) != null ? _a : "";
  }
}
function create() {
  var _a;
  if (!defined(state.newName)) {
    throw new Error("save name is empty");
  }
  if (state.newName in state.saveMetaData["local"]) {
    throw new Error("save already exists: " + state.newName);
  }
  const descr = (_a = state.newDescr) != null ? _a : "No Description";
  const id = SaveId("local", state.newName);
  if (defined(state.copying)) {
    const fromSave = Errorable.raise(readSave(state.copying)).value;
    writeSave(state.saveMetaData, id, descr, fromSave);
    state.saveMetaData["local"][state.newName] = descr;
    selectSave(id);
  } else {
    save(id, descr);
  }
  cancel();
}
function purgeAllDeletedSaves() {
  state.deletedSaves = emptySaveMetaData();
  state.hasDeletedSaves = false;
}
function cancel() {
  state.copying = void 0;
  state.newName = void 0;
  state.newDescr = void 0;
}
function deleteSave(id) {
  var _a;
  state.deletedSaves[id.type][id.name] = (_a = state.saveMetaData[id.type][id.name]) != null ? _a : "";
  delete state.saveMetaData[id.type][id.name];
  writeSaveMetadata(state.saveMetaData);
  state.hasDeletedSaves = true;
}
function restoreAllDeletedSaves() {
  for (const type in state.deletedSaves) {
    for (const name2 in state.deletedSaves[type]) {
      restoreDeletedSave(SaveId(type, name2));
    }
  }
  state.hasDeletedSaves = false;
}
function checkForDeletedSaves() {
  state.hasDeletedSaves = Map$1(state.deletedSaves).map((x) => Map$1(x).size).some((x) => x > 0);
}
function restoreDeletedSave(id) {
  state.saveMetaData[id.type][id.name] = state.deletedSaves[id.type][id.name];
  writeSaveMetadata(state.saveMetaData);
  delete state.deletedSaves[id.type][id.name];
  checkForDeletedSaves();
}
function selectSave(id) {
  open(id);
}
function unselectSave() {
}
function initSaveWidget() {
  var _a, _b, _c;
  const search = window.location.search;
  const params = new URLSearchParams(search);
  const storageKey = (_a = params.get("StorageKey")) != null ? _a : "";
  if (params.has("docDriven") && params.get("docDriven") === "true") {
    initReceiver({
      setTopic: (topic) => {
        state.docTopic = topic;
      }
    });
  }
  if (params.has("StorageKey")) {
    state.saveMetaData = setStorageKey(storageKey);
  }
  if (params.has("saveType") && params.has("saveName")) {
    const saveType = params.get("saveType");
    const saveName = params.get("saveName");
    if (isSaveType(saveType) && notBlank(saveName)) {
      const saveId = SaveId(saveType, saveName);
      open(saveId);
      return;
    }
  }
  if (params.has("shared")) {
    const shareStr = (_b = params.get("shared")) != null ? _b : "";
    if (shareStr === "") {
      open(DefaultSaveId);
      return;
    }
    const uncompressed = (_c = lzString.exports.decompressFromEncodedURIComponent(shareStr)) != null ? _c : "";
    const saveObj = JSON.parse(uncompressed);
    const newSaveId = SaveId("shared", saveObj.name);
    writeSave(state.saveMetaData, newSaveId, saveObj.description, saveObj.save);
    open(newSaveId);
    selectSave(newSaveId);
    const keyParam = storageKey === "" ? "" : `&StorageKey=${storageKey}`;
    window.location.href = baseUrl() + `?saveType=shared&saveName=${saveObj.name}${keyParam}`;
  } else {
    open(DefaultSaveId);
  }
}
const onTicks = {};
let time = 0;
function gameLoop(elapsedTime) {
  renderer == null ? void 0 : renderer.onTick();
  tick(elapsedTime);
  const t = elapsedTime / 1e3;
  const delta = t - time;
  if (delta >= state.tickTime) {
    time = t;
    if (state.runTimer) {
      state.currentEnv.constant.set("time", time, { hidden: true });
      Object.values(onTicks).forEach((x) => x(delta));
    }
  }
  window.requestAnimationFrame(gameLoop);
}
let gameLoopRunning = false;
function initUI() {
  if (!gameLoopRunning) {
    gameLoopRunning = true;
    window.requestAnimationFrame(gameLoop);
  }
}
const currentSaveIsLibrary = computed(
  () => state.currentSave.type === "library"
);
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    onBeforeMount(() => {
      initSaveWidget();
      initUI();
    });
    return (_ctx, _cache) => {
      const _component_router_view = resolveComponent("router-view");
      return openBlock(), createBlock(_component_router_view, { id: "app" });
    };
  }
});
function route(callback) {
  return callback;
}
/*!
  * vue-router v4.1.2
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module";
}
const assign = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = isArray(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
const noop = () => {
};
const isArray = Array.isArray;
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash2 = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash2 = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash2,
    path,
    query,
    hash: hash2
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base2) {
  if (!base2 || !pathname.toLowerCase().startsWith(base2.toLowerCase()))
    return pathname;
  return pathname.slice(base2.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a, b) {
  const aLastIndex = a.matched.length - 1;
  const bLastIndex = b.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length)
    return false;
  for (const key in a) {
    if (!isSameRouteLocationParamsValue(a[key], b[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a, b) {
  return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;
}
function isEquivalentArray(a, b) {
  return isArray(b) ? a.length === b.length && a.every((value, i2) => value === b[i2]) : a.length === 1 && a[0] === b;
}
function resolveRelativePath(to2, from) {
  if (to2.startsWith("/"))
    return to2;
  if (!to2)
    return from;
  const fromSegments = from.split("/");
  const toSegments = to2.split("/");
  let position2 = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position2 > 1)
        position2--;
    } else
      break;
  }
  return fromSegments.slice(0, position2).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base2) {
  if (!base2) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base2 = baseEl && baseEl.getAttribute("href") || "/";
      base2 = base2.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base2 = "/";
    }
  }
  if (base2[0] !== "/" && base2[0] !== "#")
    base2 = "/" + base2;
  return removeTrailingSlash(base2);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base2, location2) {
  return base2.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position2) {
  let scrollToOptions;
  if ("el" in position2) {
    const positionEl = position2.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position2);
  } else {
    scrollToOptions = position2;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path, delta) {
  const position2 = history.state ? history.state.position - delta : -1;
  return position2 + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base2, location2) {
  const { pathname, search, hash: hash2 } = location2;
  const hashPos = base2.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash2.includes(base2.slice(hashPos)) ? base2.slice(hashPos).length : 1;
    let pathFromHash = hash2.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base2);
  return path + search + hash2;
}
function useHistoryListeners(base2, historyState, currentLocation, replace) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state: state2 }) => {
    const to2 = createCurrentLocation(base2, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state2) {
      currentLocation.value = to2;
      historyState.value = state2;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta = fromState ? state2.position - fromState.position : 0;
    } else {
      replace(to2);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index2 = listeners.indexOf(callback);
      if (index2 > -1)
        listeners.splice(index2, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener);
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base2) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base2, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      position: history2.length - 1,
      replaced: true,
      scroll: null
    }, true);
  }
  function changeLocation(to2, state2, replace2) {
    const hashIndex = base2.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base2 : base2.slice(hashIndex)) + to2 : createBaseLocation() + base2 + to2;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state2, "", url);
      historyState.value = state2;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url);
    }
  }
  function replace(to2, data) {
    const state2 = assign({}, history2.state, buildState(
      historyState.value.back,
      to2,
      historyState.value.forward,
      true
    ), data, { position: historyState.value.position });
    changeLocation(to2, state2, true);
    currentLocation.value = to2;
  }
  function push(to2, data) {
    const currentState = assign(
      {},
      historyState.value,
      history2.state,
      {
        forward: to2,
        scroll: computeScrollPosition()
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state2 = assign({}, buildState(currentLocation.value, to2, null), { position: currentState.position + 1 }, data);
    changeLocation(to2, state2, false);
    currentLocation.value = to2;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace
  };
}
function createWebHistory(base2) {
  base2 = normalizeBase(base2);
  const historyNavigation = useHistoryStateNavigation(base2);
  const historyListeners = useHistoryListeners(base2, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign({
    location: "",
    base: base2,
    go,
    createHref: createHref.bind(null, base2)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function createWebHashHistory(base2) {
  base2 = location.host ? base2 || location.pathname + location.search : "";
  if (!base2.includes("#"))
    base2 += "#";
  return createWebHistory(base2);
}
function isRouteLocation(route2) {
  return typeof route2 === "string" || route2 && typeof route2 === "object";
}
function isRouteName(name2) {
  return typeof name2 === "string" || typeof name2 === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type, params) {
  {
    return assign(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys2 = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [90];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value, repeatable, optional, regexp } = token;
        keys2.push({
          name: value,
          repeatable,
          optional
        });
        const re3 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re3 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re3})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re3}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re3})(?:/(?:${re3}))*)` : `(${re3})`;
        if (!tokenIndex)
          subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re3 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i2 = score.length - 1;
    score[i2][score[i2].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re2 = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse2(path) {
    const match = path.match(re2);
    const params = {};
    if (!match)
      return null;
    for (let i2 = 1; i2 < match.length; i2++) {
      const value = match[i2] || "";
      const key = keys2[i2 - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify2(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path += token.value;
        } else if (token.type === 1) {
          const { value, repeatable, optional } = token;
          const param = value in params ? params[value] : "";
          if (isArray(param) && !repeatable) {
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text = isArray(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2 && segments.length > 1) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path += text;
        }
      }
    }
    return path;
  }
  return {
    re: re2,
    score,
    keys: keys2,
    parse: parse2,
    stringify: stringify2
  };
}
function compareScoreArray(a, b) {
  let i2 = 0;
  while (i2 < a.length && i2 < b.length) {
    const diff2 = b[i2] - a[i2];
    if (diff2)
      return diff2;
    i2++;
  }
  if (a.length < b.length) {
    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
  } else if (a.length > b.length) {
    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a, b) {
  let i2 = 0;
  const aScore = a.score;
  const bScore = b.score;
  while (i2 < aScore.length && i2 < bScore.length) {
    const comp = compareScoreArray(aScore[i2], bScore[i2]);
    if (comp)
      return comp;
    i2++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last3 = score[score.length - 1];
  return score.length > 0 && last3[last3.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state2})/"${buffer2}": ${message}`);
  }
  let state2 = 0;
  let previousState = state2;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i2 = 0;
  let char;
  let buffer2 = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer2)
      return;
    if (state2 === 0) {
      segment.push({
        type: 0,
        value: buffer2
      });
    } else if (state2 === 1 || state2 === 2 || state2 === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer2}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer2,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer2 = "";
  }
  function addCharToBuffer() {
    buffer2 += char;
  }
  while (i2 < path.length) {
    char = path[i2++];
    if (char === "\\" && state2 !== 2) {
      previousState = state2;
      state2 = 4;
      continue;
    }
    switch (state2) {
      case 0:
        if (char === "/") {
          if (buffer2) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state2 = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state2 = previousState;
        break;
      case 1:
        if (char === "(") {
          state2 = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state2 = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i2--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state2 = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state2 = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i2--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state2 === 2)
    crash(`Unfinished custom RegExp for param "${buffer2}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser2 = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign(parser2, {
    record,
    parent,
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes2, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name2) {
    return matcherMap.get(name2);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(assign({}, mainNormalizedRecord, {
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
        }
      }
      originalRecord = originalRecord || matcher;
      insertMatcher(matcher);
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index2 = matchers.indexOf(matcherRef);
      if (index2 > -1) {
        matchers.splice(index2, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i2 = 0;
    while (i2 < matchers.length && comparePathParserScore(matcher, matchers[i2]) >= 0 && (matcher.record.path !== matchers[i2].record.path || !isRecordChildOf(matcher, matchers[i2])))
      i2++;
    matchers.splice(i2, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve2(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name2;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name2 = matcher.record.name;
      params = assign(
        paramsFromLocation(
          currentLocation.params,
          matcher.keys.filter((k) => !k.optional).map((k) => k.name)
        ),
        location2.params
      );
      path = matcher.stringify(params);
    } else if ("path" in location2) {
      path = location2.path;
      matcher = matchers.find((m) => m.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name2 = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name2 = matcher.record.name;
      params = assign({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name: name2,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes2.forEach((route2) => addRoute(route2));
  return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys2) {
  const newParams = {};
  for (const key of keys2) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name2 in record.components)
      propsObject[name2] = typeof props === "boolean" ? props : props[name2];
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
  const options = {};
  for (const key in defaults) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
  }
  return options;
}
function isRecordChildOf(record, parent) {
  return parent.children.some((child) => child === record || isRecordChildOf(record, child));
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i2 = 0; i2 < searchParams.length; ++i2) {
    const searchParam = searchParams[i2].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values2 = isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
    values2.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value2 != null)
          search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) {
      normalizedQuery[key] = isArray(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
const matchedRouteKey = Symbol("");
const viewDepthKey = Symbol("");
const routerKey = Symbol("");
const routeLocationKey = Symbol("");
const routerViewLocationKey = Symbol("");
function useCallbacks() {
  let handlers = [];
  function add2(handler) {
    handlers.push(handler);
    return () => {
      const i2 = handlers.indexOf(handler);
      if (i2 > -1)
        handlers.splice(i2, 1);
    };
  }
  function reset2() {
    handlers = [];
  }
  return {
    add: add2,
    list: () => handlers,
    reset: reset2
  };
}
function guardToPromiseFn(guard, to2, from, record, name2) {
  const enterCallbackArray = record && (record.enterCallbacks[name2] = record.enterCallbacks[name2] || []);
  return () => new Promise((resolve2, reject) => {
    const next = (valid) => {
      if (valid === false)
        reject(createRouterError(4, {
          from,
          to: to2
        }));
      else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to2,
          to: valid
        }));
      } else {
        if (enterCallbackArray && record.enterCallbacks[name2] === enterCallbackArray && typeof valid === "function")
          enterCallbackArray.push(valid);
        resolve2();
      }
    };
    const guardReturn = guard.call(record && record.instances[name2], to2, from, next);
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to2, from) {
  const guards = [];
  for (const record of matched) {
    for (const name2 in record.components) {
      let rawComponent = record.components[name2];
      if (guardType !== "beforeRouteEnter" && !record.instances[name2])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to2, from, record, name2));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name2}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name2] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to2, from, record, name2)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink(props) {
  const router = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route2 = computed(() => router.resolve(unref(props.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route2.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index2 = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index2 > -1)
      return index2;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index2;
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route2.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route2.value.params));
  function navigate(e2 = {}) {
    if (guardEvent(e2)) {
      return router[unref(props.replace) ? "replace" : "push"](
        unref(props.to)
      ).catch(noop);
    }
    return Promise.resolve();
  }
  return {
    route: route2,
    href: computed(() => route2.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props.custom ? children : h("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e2) {
  if (e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey)
    return;
  if (e2.defaultPrevented)
    return;
  if (e2.button !== void 0 && e2.button !== 0)
    return;
  if (e2.currentTarget && e2.currentTarget.getAttribute) {
    const target = e2.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e2.preventDefault)
    e2.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i2) => value !== outerValue[i2]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  compatConfig: { MODE: 3 },
  setup(props, { attrs, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to2, name2], [oldInstance, from, oldName]) => {
      if (to2) {
        to2.instances[name2] = instance;
        if (from && from !== to2 && instance && instance === oldInstance) {
          if (!to2.leaveGuards.size) {
            to2.leaveGuards = from.leaveGuards;
          }
          if (!to2.updateGuards.size) {
            to2.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance && to2 && (!from || !isSameRouteRecord(to2, from) || !oldInstance)) {
        (to2.enterCallbacks[name2] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route2 = routeToDisplay.value;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[props.name];
      const currentName = props.name;
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route: route2 });
      }
      const routePropsOption = matchedRoute.props[props.name];
      const routeProps = routePropsOption ? routePropsOption === true ? route2.params : typeof routePropsOption === "function" ? routePropsOption(route2) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h(ViewComponent, assign({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return normalizeSlot(slots.default, { Component: component, route: route2 }) || component;
    };
  }
});
function normalizeSlot(slot, data) {
  if (!slot)
    return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter$1(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = applyToParams.bind(null, decode);
  function addRoute(parentOrRoute, route2) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route2;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name2) {
    const recordMatcher = matcher.getRecordMatcher(name2);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name2) {
    return !!matcher.getRecordMatcher(name2);
  }
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      matcherLocation = assign({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign({}, rawLocation, {
        params: encodeParams(rawLocation.params)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash2 = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
      hash: encodeHash(hash2),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign({
      fullPath,
      hash: hash2,
      query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to2) {
    return typeof to2 === "string" ? parseURL(parseQuery$1, to2, currentRoute.value.path) : assign({}, to2);
  }
  function checkCanceledNavigation(to2, from) {
    if (pendingLocation !== to2) {
      return createRouterError(8, {
        from,
        to: to2
      });
    }
  }
  function push(to2) {
    return pushWithRedirect(to2);
  }
  function replace(to2) {
    return push(assign(locationAsObject(to2), { replace: true }));
  }
  function handleRedirectRecord(to2) {
    const lastMatched = to2.matched[to2.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to2) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
        newTargetLocation.params = {};
      }
      return assign({
        query: to2.query,
        hash: to2.hash,
        params: "path" in newTargetLocation ? {} : to2.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to2, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to2);
    const from = currentRoute.value;
    const data = to2.state;
    const force = to2.force;
    const replace2 = to2.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign(locationAsObject(shouldRedirect), {
          state: data,
          force,
          replace: replace2
        }),
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(
        from,
        from,
        true,
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, 2) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(failure2, 2)) {
          return pushWithRedirect(
            assign(locationAsObject(failure2.to), {
              state: data,
              force,
              replace: replace2
            }),
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
      }
      triggerAfterEach(toLocation, from, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to2, from) {
    const error = checkCanceledNavigation(to2, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function navigate(to2, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to2, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to2, from);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to2, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to2, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to2, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to2, from);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to2, from));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of to2.matched) {
        if (record.beforeEnter && !from.matched.includes(record)) {
          if (isArray(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to2, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to2, from));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to2.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to2, from);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to2, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to2, from, failure) {
    for (const guard of afterGuards.list())
      guard(to2, from, failure);
  }
  function finalizeNavigation(toLocation, from, isPush, replace2, data) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error)
      return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state2 = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign({
          scroll: isFirstNavigation && state2 && state2.scroll
        }, data));
      else
        routerHistory.push(toLocation.fullPath, data);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to2, _from, info) => {
      if (!router.listening)
        return;
      const toLocation = resolve2(to2);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from).catch((error) => {
        if (isNavigationFailure(error, 4 | 8)) {
          return error;
        }
        if (isNavigationFailure(error, 2)) {
          pushWithRedirect(
            error.to,
            toLocation
          ).then((failure) => {
            if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop);
          return Promise.reject();
        }
        if (info.delta)
          routerHistory.go(-info.delta, false);
        return triggerError(error, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          toLocation,
          from,
          false
        );
        if (failure) {
          if (info.delta) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop);
    });
  }
  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  function triggerError(error, to2, from) {
    markAsReady(error);
    const list = errorHandlers.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to2, from));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve3, reject) => {
      readyHandlers.add([resolve3, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to2, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to2.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to2, from, scrollPosition)).then((position2) => position2 && scrollToPosition(position2)).catch((err) => triggerError(err, to2, from));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options,
    push,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,
    install(app2) {
      const router2 = this;
      app2.component("RouterLink", RouterLink);
      app2.component("RouterView", RouterView);
      app2.config.globalProperties.$router = router2;
      Object.defineProperty(app2.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        reactiveRoute[key] = computed(() => currentRoute.value[key]);
      }
      app2.provide(routerKey, router2);
      app2.provide(routeLocationKey, reactive(reactiveRoute));
      app2.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app2.unmount;
      installedApps.add(app2);
      app2.unmount = function() {
        installedApps.delete(app2);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  return router;
}
function runGuardQueue(guards) {
  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
}
function extractChangingRecords(to2, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to2.matched.length);
  for (let i2 = 0; i2 < len; i2++) {
    const recordFrom = from.matched[i2];
    if (recordFrom) {
      if (to2.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to2.matched[i2];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
const scriptRel = function detectScriptRel() {
  const relList = document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}();
const seen = {};
const base = "/ig-calc-testing/";
const __vitePreload = function preload(baseModule, deps) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  return Promise.all(deps.map((dep) => {
    dep = `${base}${dep}`;
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
const routes = [
  {
    path: "/",
    component: () => __vitePreload(() => import("./MainLayout.a65f97d5.js"), true ? ["assets/MainLayout.a65f97d5.js","assets/MainLayout.025cabff.css","assets/QBtn.f303d055.js","assets/QLayout.4d2c4661.js","assets/QSelect.08a7fb2c.js","assets/plugin-vue_export-helper.21dcd24c.js"] : void 0),
    children: [{ path: "", component: () => __vitePreload(() => import("./ErrorNotFound.1fdfb524.js"), true ? ["assets/ErrorNotFound.1fdfb524.js","assets/QBtn.f303d055.js","assets/plugin-vue_export-helper.21dcd24c.js"] : void 0) }]
  },
  {
    path: "/docs/:topic?",
    component: () => __vitePreload(() => import("./DocLayout.66eefcbd.js"), true ? ["assets/DocLayout.66eefcbd.js","assets/QBtn.f303d055.js","assets/QLayout.4d2c4661.js"] : void 0),
    children: [{ path: "", component: () => __vitePreload(() => import("./ErrorNotFound.1fdfb524.js"), true ? ["assets/ErrorNotFound.1fdfb524.js","assets/QBtn.f303d055.js","assets/plugin-vue_export-helper.21dcd24c.js"] : void 0) }]
  },
  {
    path: "/testActions/",
    component: () => __vitePreload(() => import("./TestActionsLayout.648c86ef.js"), true ? ["assets/TestActionsLayout.648c86ef.js","assets/QBtn.f303d055.js","assets/QLayout.4d2c4661.js","assets/QSelect.08a7fb2c.js"] : void 0),
    children: [{ path: "", component: () => __vitePreload(() => import("./ErrorNotFound.1fdfb524.js"), true ? ["assets/ErrorNotFound.1fdfb524.js","assets/QBtn.f303d055.js","assets/plugin-vue_export-helper.21dcd24c.js"] : void 0) }]
  },
  {
    path: "/:catchAll(.*)*",
    component: () => __vitePreload(() => import("./ErrorNotFound.1fdfb524.js"), true ? ["assets/ErrorNotFound.1fdfb524.js","assets/QBtn.f303d055.js","assets/plugin-vue_export-helper.21dcd24c.js"] : void 0)
  }
];
var createRouter = route(function() {
  const createHistory = createWebHashHistory;
  const Router = createRouter$1({
    scrollBehavior: () => ({ left: 0, top: 0 }),
    routes,
    history: createHistory("/ig-calc-testing/")
  });
  return Router;
});
async function createQuasarApp(createAppFn, quasarUserOptions2) {
  const app2 = createAppFn(_sfc_main);
  app2.use(Quasar, quasarUserOptions2);
  const router = markRaw(
    typeof createRouter === "function" ? await createRouter({}) : createRouter
  );
  return {
    app: app2,
    router
  };
}
var quasarUserOptions = { config: { "dark": true } };
async function start({
  app: app2,
  router
}) {
  app2.use(router);
  app2.mount("#q-app");
}
createQuasarApp(createApp, quasarUserOptions).then(start);
export { createSlots as $, normalizeClass as A, normalizeProps as B, normalizeStyle as C, toDisplayString as D, EffectScope as E, toHandlerKey as F, BaseTransition as G, Comment as H, Fragment as I, Suspense as J, KeepAlive as K, Text as L, callWithAsyncErrorHandling as M, callWithErrorHandling as N, cloneVNode as O, compatUtils as P, computed as Q, ReactiveEffect as R, Static as S, Teleport as T, createBlock as U, createCommentVNode as V, createElementBlock as W, createBaseVNode as X, createHydrationRenderer as Y, createPropsRestProxy as Z, createRenderer as _, effectScope as a, watchSyncEffect as a$, createStaticVNode as a0, createTextVNode as a1, createVNode as a2, defineAsyncComponent as a3, defineComponent as a4, defineEmits as a5, defineExpose as a6, defineProps as a7, devtools as a8, getCurrentInstance as a9, provide as aA, pushScopeId as aB, queuePostFlushCb as aC, registerRuntimeCompiler as aD, renderList as aE, renderSlot as aF, resolveComponent as aG, resolveDirective as aH, resolveDynamicComponent as aI, resolveFilter as aJ, resolveTransitionHooks as aK, setBlockTracking as aL, setDevtoolsHook as aM, setTransitionHooks as aN, ssrContextKey as aO, ssrUtils as aP, toHandlers as aQ, transformVNodeArgs as aR, useAttrs as aS, useSSRContext as aT, useSlots as aU, useTransitionState as aV, version$2 as aW, warn as aX, watch as aY, watchEffect as aZ, watchPostEffect as a_, getTransitionRawChildren as aa, guardReactiveProps as ab, h as ac, handleError as ad, initCustomFormatter as ae, inject as af, isMemoSame as ag, isRuntimeOnly as ah, isVNode as ai, mergeDefaults as aj, mergeProps as ak, nextTick as al, onActivated as am, onBeforeMount as an, onBeforeUnmount as ao, onBeforeUpdate as ap, onDeactivated as aq, onErrorCaptured as ar, onMounted as as, onRenderTracked as at, onRenderTriggered as au, onServerPrefetch as av, onUnmounted as aw, onUpdated as ax, openBlock as ay, popScopeId as az, isReactive as b, getDerivative as b$, withAsyncContext as b0, withCtx as b1, withDefaults as b2, withDirectives as b3, withMemo as b4, withScopeId as b5, Transition as b6, TransitionGroup as b7, VueElement as b8, createApp as b9, cleanEvt as bA, Interval as bB, setRenderer as bC, Renderer as bD, state as bE, defined as bF, renderer as bG, isValidNumber as bH, listenOpts as bI, History as bJ, isNumber$2 as bK, isDate$1 as bL, isObject$1 as bM, injectMultipleProps as bN, injectProp as bO, debounce as bP, Map$1 as bQ, isString$1 as bR, Errorable as bS, errorable as bT, stop as bU, currentSaveIsLibrary as bV, Parametric as bW, isNumber$1 as bX, node2html as bY, opMap as bZ, tex2html as b_, createSSRApp as ba, defineCustomElement as bb, defineSSRCustomElement as bc, hydrate as bd, initDirectivesForSSR as be, render as bf, useCssModule as bg, useCssVars as bh, vModelCheckbox as bi, vModelDynamic as bj, vModelRadio as bk, vModelSelect as bl, vModelText as bm, vShow as bn, withKeys as bo, withModifiers as bp, tabsKey as bq, isKeyCode as br, shouldIgnoreKey as bs, stopAndPrevent as bt, noop$1 as bu, client as bv, leftClick as bw, addEvt as bx, preventDraggable as by, position as bz, customRef as c, getBody as c0, nodeToObjectTree as c1, EnvExpr as c2, ConstantNode as c3, saveTypes as c4, saveList as c5, load as c6, Animation as c7, rickRoll as c8, getAugmentedNamespace as c9, createDocChannel as cA, mkAction as cB, sendActions as cC, unique as cD, sendAction as cE, commonjsGlobal as ca, getDefaultExportFromCjs as cb, environments as cc, save as cd, selectSave as ce, restoreDeletedSave as cf, purgeDeletedSave as cg, unselectSave as ch, copy as ci, share as cj, deleteSave as ck, SaveId as cl, restoreAllDeletedSaves as cm, purgeAllDeletedSaves as cn, create as co, cancel as cp, cursorState as cq, prevent as cr, isRuntimeSsrPreHydration as cs, layoutKey as ct, getEventPath as cu, Platform as cv, pageContainerKey as cw, formKey as cx, globalConfig as cy, isDeepEqual as cz, isReadonly as d, effect as e, isRef as f, getCurrentScope as g, isShallow as h, isProxy as i, readonly as j, ref as k, shallowReadonly as l, markRaw as m, shallowRef as n, onScopeDispose as o, proxyRefs as p, stop$1 as q, reactive as r, shallowReactive as s, toRaw as t, toRef as u, toRefs as v, triggerRef as w, unref as x, camelize as y, capitalize as z };
